[{"title":"è¿‘ç«¯ç­–ç•¥ä¼˜åŒ–â€”PPO","path":"/2025/02/23/MudSynth/RL/è¿‘ç«¯ç­–ç•¥ä¼˜åŒ–â€”PPO/","content":"å¼ºåŒ–å­¦ä¹ åŸºç¡€ Action Space Reward Trajectory Return(å›æŠ¥) E(x)xâˆ¼p(x)=âˆ‘xxâ‹…p(x)â‰ˆ1nâˆ‘i=1nxxâˆ¼p(x)E(x)_{x \\sim p(x)} = \\sum_{x} x \\cdot p(x) \\approx \\frac{1}{n} \\sum_{i=1}^{n} x \\quad x \\sim p(x) E(x)xâˆ¼p(x)â€‹=xâˆ‘â€‹xâ‹…p(x)â‰ˆn1â€‹i=1âˆ‘nâ€‹xxâˆ¼p(x) ç›®çš„ï¼šè®­ç»ƒä¸€ä¸ªPolicyç½‘ç»œÏ€\\piÏ€ï¼Œåœ¨æ‰€æœ‰çŠ¶æ€Sä¸‹ï¼Œç»™å‡ºç›¸åº”çš„Actionï¼Œå¾—åˆ°Returnçš„æœŸæœ›æœ€å¤§ ç›®çš„ï¼šè®­ç»ƒä¸€ä¸ªPolicyç½‘ç»œÏ€\\piÏ€ï¼Œåœ¨æ‰€æœ‰çš„Trajectoryä¸­ï¼Œç»™å‡ºç›¸åº”çš„Actionï¼Œå¾—åˆ°Returnçš„æœŸæœ›æœ€å¤§ã€‚ ä¹Ÿå°±æ˜¯æœ€å¤§åŒ–ï¼šE(R(Ï„))Ï„âˆ¼PÎ¸(Ï„)=âˆ‘Ï„R(Ï„)PÎ¸(Ï„)E(R(\\tau))_{\\tau \\sim P_\\theta(\\tau)} = \\sum_{\\tau} R(\\tau) P_\\theta(\\tau)E(R(Ï„))Ï„âˆ¼PÎ¸â€‹(Ï„)â€‹=âˆ‘Ï„â€‹R(Ï„)PÎ¸â€‹(Ï„), å¯ä»¥ä½¿ç”¨æ¢¯åº¦ä¸Šå‡æ³•ã€‚ åœ¨å¼ºåŒ–å­¦ä¹ ä¸­ï¼Œæˆ‘ä»¬è®¤ä¸ºä¸‹ä¸€ä¸ªçŠ¶æ€çš„æ¦‚ç‡ä»…ç”±å½“å‰çŠ¶æ€å’Œè¦åšçš„åŠ¨ä½œå†³å®šï¼Œæ‰€ä»¥PÎ¸(Ï„n)P_\\theta(\\tau^n)PÎ¸â€‹(Ï„n)å¯ä»¥è¢«è¡¨ç¤ºä¸ºï¼š PÎ¸(Ï„n)=âˆt=1Tnp(snâˆ£snâˆ’1,anâˆ’1)PÎ¸(antâˆ£snt)P_\\theta(\\tau^n) = \\prod_{t=1}^{T_n}p(s_n|s_{n-1},a_{n-1})P_\\theta(a_n^t|s_n^t) PÎ¸â€‹(Ï„n)=t=1âˆTnâ€‹â€‹p(snâ€‹âˆ£snâˆ’1â€‹,anâˆ’1â€‹)PÎ¸â€‹(antâ€‹âˆ£sntâ€‹) ç”±äºpppä¸€èˆ¬ä¸ºå¸¸æ•°ï¼Œå¯ä»¥è¢«å¿½ç•¥ï¼Œç»§ç»­åŒ–ç®€ä¸Šå¼å¯å¾— è¯¥å¯¼æ•°çš„ç›´è§‚æ„ä¹‰æ˜¯ï¼Œå¦‚æœ R(Ï„n)R(\\tau^n)R(Ï„n) æ˜¯å¤§äº0çš„ï¼Œåˆ™å¢å¤§æ‰€æœ‰æ‰§è¡Œå½“å‰trajectoryåŠ¨ä½œçš„æ¦‚ç‡ï¼ˆPÎ¸(antâˆ£snt)P_\\theta(a_n^t|s_n^t)PÎ¸â€‹(antâ€‹âˆ£sntâ€‹)ï¼‰ï¼Œåä¹‹å‡å°‘ã€‚è¯¥ç®—æ³•è¢«ç§°ä¸º Policy gradient ç®—æ³•ã€‚ Policy Gradientæ˜¯ä¸€ä¸ªon policyçš„ç®—æ³•ï¼Œæ¯æ¬¡è®©agentå®Œnè½®æ¸¸æˆï¼Œç„¶åç”¨nè½®çš„trajectoryæ›´æ–°ç­–ç•¥ã€‚ ç¼ºç‚¹ï¼šæ”¶é›†çš„æ•°æ®åªè¢«ç”¨äºæ›´æ–°ä¸€å›ï¼Œå¤§é‡æ•°æ®æ”¶é›†ï¼Œå¯¼è‡´æ—¶é—´æ•ˆç‡ä½ã€‚ å¯ä»¥ä¼˜åŒ–çš„åœ°æ–¹ ç»™R(Ï„n)R(\\tau^n)R(Ï„n)æ·»åŠ ä¸€ä¸ªæŠ˜æ‰£å› å­ã€‚ï¼ˆä¸€ä¸ªåŠ¨ä½œåªèƒ½å½±å“åé¢çš„rewardï¼Œä¸”åé¢çš„rewardæˆ‘ä»¬åº”è¯¥å°½å¿«æ‹¿åˆ°æ›´å¥½ï¼Œæ‰€ä»¥æ·»åŠ äº†ä¸€ä¸ªæŠ˜æ‰£å› å­ï¼‰ åœ¨å¥½çš„å±€åŠ¿ä¸‹ï¼Œæ‰€æœ‰åŠ¨ä½œçš„æ¦‚ç‡éƒ½ä¼šè¢«æå‡ï¼Œåçš„å±€åŠ¿ä¸‹æ‰€æœ‰åŠ¨ä½œçš„æ¦‚ç‡éƒ½ä¼šè¢«å‡å°‘ã€‚æ·»åŠ ä¸€ä¸ªbaselineï¼ˆç›¸å‡ï¼‰å¯ä»¥è®©éƒ¨åˆ†åŠ¨ä½œæ¦‚ç‡æå‡ï¼Œéƒ¨åˆ†åŠ¨ä½œæ¦‚ç‡å‡å°‘ï¼Œä½¿å­¦ä¹ æ”¶æ•›æ›´è¿…é€Ÿã€‚ å…·ä½“ä¼˜åŒ–è§ä¸‹å›¾ï¼š æ¥ä¸‹æ¥å›é¡¾ä¸‰ä¸ªå¸¸è§çš„å¼ºåŒ–å­¦ä¹ æ–°æ¦‚å¿µï¼š ç„¶åå¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œå¯ä»¥ä½¿ç”¨Advantage Functionæ›¿æ¢æ‰åŸå¼å­ä¸­çš„ Rtnâˆ’B(Snt)R_t^n-B(S_n^t)Rtnâ€‹âˆ’B(Sntâ€‹),ä½†æ˜¯æˆ‘ä»¬æ­¤æ—¶åœ¨å®ç°çš„è¿‡ç¨‹ä¸­è¿˜æ˜¯éœ€è¦è®­ç»ƒä¸¤ä¸ªç¥ç»ç½‘ç»œåˆ†åˆ«æ‹ŸåˆAction-Value Functionä»¥åŠState-Value Functionã€‚æœ‰æ²¡æœ‰åŠæ³•åªè®­ç»ƒä¸€ä¸ªç½‘ç»œå‘¢ï¼Ÿ è§‚å¯Ÿçº¢æ¡†ä¸éš¾å‘ç°ï¼Œæ­¤æ—¶Advantage Functionä¸­åªå«æœ‰State-Value Functionæˆ‘ä»¬åªéœ€è¦è®­ç»ƒä¸€ä¸ªç½‘ç»œå³å¯ã€‚ ä¸ºäº†ä½¿å³ä¾§å¼å­è¡¨ç¤ºçš„æ›´ä¸ºç®€æ´ï¼Œå®šä¹‰ Î´\\deltaÎ´ å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä»ä¸Šå›¾ä¸éš¾ç†è§£ï¼Œéšç€ä¼˜åŠ¿å‡½æ•°é˜¶æ•°çš„å¢åŠ ï¼Œä¼°è®¡çš„åå·®è¶Šå°ï¼Œæ–¹å·®è¶Šå¤§ã€‚ä¸ºäº†æ›´å¥½çš„ä¼°è®¡çœŸå®çš„ä¼˜åŠ¿å‡½æ•°ï¼ˆå¹³è¡¡æ–¹å·®å’Œåå·®ï¼‰ï¼Œæˆ‘ä»¬ä¸‹é¢å¼•å…¥GAEç®—æ³•ï¼ˆå¦‚ä¸‹å›¾æ‰€ç¤ºï¼‰ã€‚ æœ€åæ€»ç»“ä¸‹ä¸Šé¢æ¨åˆ°å‡ºæ¥æœ€ä¸ºé‡è¦çš„å‡ ä¸ªå…¬å¼ï¼ˆè§ä¸‹å›¾ï¼‰ï¼š Î´\\deltaÎ´ GAEä¼°è®¡çš„ä¼˜åŠ¿å‡½æ•° ä¼˜åŒ–åçš„ç­–ç•¥ç›®æ ‡ å…¶ä¸­ï¼ŒçŠ¶æ€ä»·å€¼å‡½æ•°ä½¿ç”¨ç¥ç»ç½‘ç»œè¿›è¡Œæ‹Ÿåˆï¼Œå’Œç­–ç•¥å‡½æ•°å…±ç”¨å‚æ•°ã€‚ï¼ˆçº¢è‰²labelä»£è¡¨çš„æ˜¯æ‹Ÿåˆä¼°è®¡çš„Vå’ŒçœŸå®çš„æŠ˜æ‰£å›æŠ¥å€¼ï¼‰ PPO ä¹‹å‰On Policyæ‰€å­˜åœ¨çš„é—®é¢˜å·²ç»ç®€å•ä»‹ç»è¿‡äº†ï¼Œä¸»è¦æ˜¯é‡‡é›†çš„æ•°æ®åªèƒ½å¤Ÿç”¨äºè®­ç»ƒä¸€æ¬¡ç¥ç»ç½‘ç»œï¼Œæœ‰ç‚¹æµªè´¹ï¼Œæ—¶é—´æ•ˆç‡ä½ã€‚ PPOå¯¹è¿™ä¸ªOn Policyè¿›è¡Œäº†ä¼˜åŒ–ï¼Œè®©æ¯æ¬¡é‡‡æ ·çš„æ•°æ®å¯ä»¥è¢«ç”¨äºè®­ç»ƒå¤šæ¬¡æ¥ä¼˜åŒ–ç½‘ç»œå‚æ•°ã€‚ é‡è¦æ€§é‡‡æ ·ï¼šå¦‚ä½•è®©AIã€Œåƒè€æœ¬ã€è¿˜ä¸ç¿»è½¦ï¼Ÿ é‡è¦æ€§é‡‡æ ·åœ¨PPOä¸­çš„ä½œç”¨ï¼Œå¯ä»¥ç†è§£ä¸ºâ€œç”¨æ—§ç»éªŒå­¦æ–°æ‹›ï¼Œä½†é¿å…ç¿»è½¦â€ã€‚æ¯”å¦‚ä½ å­¦éª‘è‡ªè¡Œè½¦æ—¶ï¼Œç”¨ä¹‹å‰æ‘”è·¤çš„ç»éªŒè°ƒæ•´åŠ¨ä½œï¼Œä½†åˆä¸è®©æ–°åŠ¨ä½œå’Œæ—§åŠ¨ä½œå·®åˆ«å¤ªå¤§ã€‚PPOé€šè¿‡ç»™æ—§ç­–ç•¥çš„æ•°æ®åŠ ä¸Šâ€œè°ƒæ•´ç³»æ•°â€ï¼ˆé‡è¦æ€§æƒé‡ï¼‰ï¼Œè®©æ–°ç­–ç•¥èƒ½å¤ç”¨è¿™äº›æ•°æ®æ›´æ–°è‡ªå·±ï¼ŒåŒæ—¶é™åˆ¶è°ƒæ•´å¹…åº¦ï¼ˆæ¯”å¦‚ç”¨clipå‡½æ•°â€œå‰ªæ‰â€è¿‡å¤§çš„æ”¹åŠ¨ï¼‰ï¼Œé˜²æ­¢æ­¥å­è¿ˆå¤ªå¤§å¯¼è‡´ç­–ç•¥å´©åã€‚è¿™æ ·æ—¢èƒ½é«˜æ•ˆåˆ©ç”¨æ•°æ®ï¼Œåˆèƒ½ç¨³å®šè®­ç»ƒã€‚ 1. ä»On-Policyçš„ç—›ç‚¹è¯´èµ· æƒ³è±¡ä½ æ­£åœ¨å­¦éª‘è‡ªè¡Œè½¦ï¼ˆè®­ç»ƒç­–ç•¥Î¸ï¼‰ï¼Œä¼ ç»ŸOn-Policyç®—æ³•å°±åƒä¸€ä½ä¸¥æ ¼çš„æ•™ç»ƒï¼š è§„åˆ™ï¼šæ¯æ¬¡è°ƒæ•´åŠ¨ä½œï¼ˆæ›´æ–°Î¸ï¼‰åï¼Œå¿…é¡»é‡æ–°ä¸Šè·¯éª‘è¡Œï¼ˆé‡‡æ ·æ–°è½¨è¿¹Ï„âˆ¼pÎ¸ï¼‰ï¼Œè®°å½•æ‘”å€’çš„å§¿åŠ¿ã€‚ é—®é¢˜ï¼šå“ªæ€•åªæ˜¯å¾®è°ƒäº†è½¦æŠŠè§’åº¦ï¼Œä¹‹å‰æ‰€æœ‰æ‘”å€’çš„æ•°æ®å…¨éƒ¨ä½œåºŸã€‚æ•ˆç‡æä½ï¼Œä¸”95%çš„æ—¶é—´æµªè´¹åœ¨é‡å¤é‡‡æ ·ä¸Šï¼ æ­¤æ—¶ï¼Œä¸€ä¸ªçµé­‚æ‹·é—®è¯ç”Ÿäº†ï¼šèƒ½å¦ç”¨å†å²æ‘”å€’æ•°æ®ï¼ˆæ—§ç­–ç•¥ï¼‰æŒ‡å¯¼æ–°åŠ¨ä½œï¼ˆæ–°ç­–ç•¥ï¼‰ï¼Ÿ ç­”æ¡ˆå°±æ˜¯é‡è¦æ€§é‡‡æ ·ï¼ˆImportance Samplingï¼‰ã€‚ 2. é‡è¦æ€§é‡‡æ ·çš„ç›´è§‚æ„ä¹‰ 2.1 äºŒæ‰‹ä¹¦å®šä»·çš„ç»Ÿè®¡å“²å­¦ å‡è®¾ä½ æƒ³è®¡ç®—æŸç»ç‰ˆä¹¦åœ¨ä¹¦åº—çš„å‡ä»·ï¼ˆåˆ†å¸ƒp(x)ï¼‰ï¼Œä½†åªèƒ½ä»äºŒæ‰‹å¸‚åœºï¼ˆåˆ†å¸ƒq(x)ï¼‰æ”¶é›†æ•°æ®ã€‚ç›´æ¥è®¡ç®—äºŒæ‰‹å¸‚åœºçš„å‡ä»·ä¼šåé«˜ï¼Œå› ä¸ºç»ç‰ˆä¹¦è¢«ç‚’é«˜ä»·ã€‚ è§£å†³æ–¹æ³•ï¼šä¸ºæ¯æœ¬ä¹¦çš„ä»·æ ¼ä¹˜ä¸Šä¸€ä¸ªä¿®æ­£ç³»æ•°ï¼ˆ= ä¹¦åº—å®šä»·/äºŒæ‰‹å¸‚åœºå®šä»·ï¼‰ã€‚ä¾‹å¦‚ï¼š æŸä¹¦åœ¨ä¹¦åº—åŸä»·50å…ƒï¼ŒäºŒæ‰‹å¸‚åœºå–100å…ƒï¼Œåˆ™ä¿®æ­£ç³»æ•°=0.5 æœ€ç»ˆç»Ÿè®¡æ—¶ï¼Œè¿™æœ¬ä¹¦çš„è´¡çŒ®æ˜¯ï¼š100å…ƒ Ã— 0.5 = 50å…ƒï¼ˆè¿˜åŸçœŸå®ä»·å€¼ï¼‰ è¿™é‡Œçš„ä¿®æ­£ç³»æ•°å°±æ˜¯é‡è¦æ€§æƒé‡ p(x)q(x)\\frac{p(x)}{q(x)}q(x)p(x)â€‹ï¼Œå®ƒæŠµæ¶ˆäº†åˆ†å¸ƒå·®å¼‚å¸¦æ¥çš„åå·®ã€‚ 2.2 å›åˆ°è‡ªè¡Œè½¦ï¼šå¦‚ä½•ç”¨æ—§åŠ¨ä½œå­¦æ–°æ‹›ï¼Ÿ å‡è®¾æ—§ç­–ç•¥Î¸_oldçš„æ‘”å€’æ•°æ®ä¸­æœ‰ä¸€ä¸ªåŠ¨ä½œï¼šâ€œè…¿æŠ¬é«˜10cmæ—¶æ‘”å€’â€ã€‚ç°åœ¨æ–°ç­–ç•¥Î¸æƒ³å°è¯•â€œè…¿æŠ¬8cmâ€ã€‚ç›´æ¥å¤ç”¨æ—§æ•°æ®ä¼šæœ‰ä¸¤ä¸ªé—®é¢˜ï¼š åå·®ï¼šæ—§æ•°æ®ä¸­â€œæŠ¬10cmâ€çš„é¢‘ç‡å¯èƒ½å’Œæ–°ç­–ç•¥â€œæŠ¬8cmâ€çš„å®é™…æ¦‚ç‡ä¸åŒã€‚ é£é™©ï¼šå¦‚æœç›²ç›®å‚è€ƒæ—§åŠ¨ä½œï¼Œå¯èƒ½å­¦å¾—æ¯”åŸæ¥æ›´å·®ï¼ˆæ¢¯åº¦çˆ†ç‚¸ï¼‰ã€‚ é‡è¦æ€§é‡‡æ ·çš„ä½œç”¨ï¼š ç»™æ¯ä¸ªæ—§åŠ¨ä½œåŠ ä¸Šä¸€ä¸ªå¯ä¿¡åº¦æ ‡ç­¾ï¼ˆé‡è¦æ€§æƒé‡=æ–°ç­–ç•¥äº§ç”Ÿè¯¥åŠ¨ä½œçš„æ¦‚ç‡ / æ—§ç­–ç•¥çš„æ¦‚ç‡ï¼‰ã€‚ å¦‚æœæ–°ç­–ç•¥Î¸è®¤ä¸ºâ€œæŠ¬10cmâ€çš„æ¦‚ç‡æ˜¯æ—§ç­–ç•¥çš„80%ï¼Œåˆ™è¿™ä¸ªåŠ¨ä½œçš„æ¢¯åº¦æ›´æ–°æƒé‡å°±æ˜¯0.8ã€‚ æ•ˆæœï¼šç›¸å½“äºæ•™ç»ƒè¯´ï¼šâ€œä½ è¿‡å»æŠ¬10cmæ‘”äº†ï¼Œä½†ç°åœ¨ä½ åªæ‰“ç®—æŠ¬8cmï¼Œæ‰€ä»¥è¿™ä¸ªæ—§åŠ¨ä½œçš„å‚è€ƒä»·å€¼æ‰“8æŠ˜ã€‚â€ 3. æ•°å­¦è§†è§’ï¼šæœŸæœ›ä¿®æ­£ä¸æ¦‚ç‡æ¯” 3.1 åŸå§‹On-Policyæ¢¯åº¦ âˆ‡RË‰Î¸=EÏ„âˆ¼pÎ¸(Ï„)[R(Ï„)âˆ‡logâ¡pÎ¸(Ï„)] abla \\bar{R}_\\theta = \\mathbb{E}_{\\tau \\sim p_\\theta(\\tau)} \\left[ R(\\tau) abla \\log p_\\theta(\\tau) \\right] âˆ‡RË‰Î¸â€‹=EÏ„âˆ¼pÎ¸â€‹(Ï„)â€‹[R(Ï„)âˆ‡logpÎ¸â€‹(Ï„)] ç—›ç‚¹ï¼šæ¯æ¬¡æ›´æ–°Î¸åï¼Œå¿…é¡»é‡æ–°é‡‡æ ·Ï„âˆ¼pÎ¸(Ï„)ï¼Œæˆæœ¬é«˜æ˜‚ã€‚ 3.2 é‡è¦æ€§é‡‡æ ·æ”¹é€ åçš„æ¢¯åº¦ âˆ‡RË‰Î¸=EÏ„âˆ¼q(Ï„)[pÎ¸(Ï„)q(Ï„)R(Ï„)âˆ‡logâ¡pÎ¸(Ï„)] abla \\bar{R}_\\theta = \\mathbb{E}_{\\tau \\sim q(\\tau)} \\left[ \\frac{p_\\theta(\\tau)}{q(\\tau)} R(\\tau) abla \\log p_\\theta(\\tau) \\right] âˆ‡RË‰Î¸â€‹=EÏ„âˆ¼q(Ï„)â€‹[q(Ï„)pÎ¸â€‹(Ï„)â€‹R(Ï„)âˆ‡logpÎ¸â€‹(Ï„)] é­”æ³•ï¼šé‡‡æ ·åˆ†å¸ƒä»æ–°ç­–ç•¥pÎ¸åˆ‡æ¢åˆ°æ—§ç­–ç•¥qï¼Œä½†é€šè¿‡ä¹˜ä¸Šæ¦‚ç‡æ¯” pÎ¸(Ï„)q(Ï„)\\frac{p_\\theta(\\tau)}{q(\\tau)}q(Ï„)pÎ¸â€‹(Ï„)â€‹ ä¿®æ­£åå·®ã€‚ ç‰©ç†æ„ä¹‰ï¼š è‹¥æ–°ç­–ç•¥pÎ¸æ¯”æ—§ç­–ç•¥qæ›´å€¾å‘äºæŸä¸ªÏ„ï¼ˆå³pÎ¸q&gt;1\\frac{p_\\theta}{q} &gt;1qpÎ¸â€‹â€‹&gt;1ï¼‰ï¼Œåˆ™æ”¾å¤§è¯¥Ï„çš„æ¢¯åº¦è´¡çŒ®ã€‚ åä¹‹åˆ™ç¼©å°ï¼Œç”šè‡³å¿½ç•¥ï¼ˆå¦‚PPOçš„Clipæ“ä½œï¼‰ã€‚ 4. é‡è¦æ€§é‡‡æ ·çš„éšæ‚£ï¼šæ–¹å·®çˆ†ç‚¸ 4.1 ä¸ºä»€ä¹ˆä¸èƒ½æ— è„‘å¤ç”¨æ—§æ•°æ®ï¼Ÿ å›åˆ°äºŒæ‰‹ä¹¦ä¾‹å­ï¼šå¦‚æœæŸä¹¦åœ¨ä¹¦åº—åŸä»·50å…ƒï¼Œä½†äºŒæ‰‹å¸‚åœºæ ‡ä»·10,000å…ƒï¼ˆæ¦‚ç‡æ¯”=0.005ï¼‰ï¼Œåˆ™ä¿®æ­£åçš„ä»·æ ¼ä¸º10,000Ã—0.005=50å…ƒã€‚çœ‹ä¼¼åˆç†ï¼Œä½†é—®é¢˜åœ¨äºï¼š è‹¥è¿™æœ¬ä¹¦åœ¨äºŒæ‰‹å¸‚åœºè¢«é¢‘ç¹äº¤æ˜“ï¼ˆé‡‡æ ·å¤šï¼‰ï¼Œåˆ™å®ƒä¼šä¸»å¯¼æ•´ä½“å‡ä»·çš„è®¡ç®—ï¼Œå¯¼è‡´ç»Ÿè®¡ç»“æœæ³¢åŠ¨æå¤§ã€‚ å¯¹åº”åˆ°RLä¸­ï¼šè‹¥æ–°æ—§ç­–ç•¥åœ¨æŸä¸ªè½¨è¿¹Ï„ä¸Šçš„æ¦‚ç‡å·®å¼‚æå¤§ï¼ˆä¾‹å¦‚pÎ¸q=100\\frac{p_\\theta}{q} =100qpÎ¸â€‹â€‹=100ï¼‰ï¼Œåˆ™å°‘é‡Ï„çš„æ ·æœ¬ä¼šä¸»å¯¼æ¢¯åº¦æ›´æ–°ï¼Œä½¿å¾—è®­ç»ƒä¸ç¨³å®šã€‚ 4.2 PPOçš„æ™ºæ…§ï¼šç»™ã€Œåƒè€æœ¬ã€åŠ ä¸Šå®‰å…¨ç»³ PPOçš„è§£å†³æ–¹æ¡ˆç®€å•ç²—æš´â€”â€”é™åˆ¶é‡è¦æ€§æƒé‡çš„å¹…åº¦ï¼š è®¡ç®—åŸå§‹æƒé‡ï¼šr(Î¸)=pÎ¸(Ï„)q(Ï„)r(\\theta) = \\frac{p_\\theta(\\tau)}{q(\\tau)}r(Î¸)=q(Ï„)pÎ¸â€‹(Ï„)â€‹ ç”¨Clipå‡½æ•°è£å‰ªï¼šrclip=clip(r(Î¸),1âˆ’Ïµ,1+Ïµ)r_{\\text{clip}} = \\text{clip}(r(\\theta), 1-\\epsilon, 1+\\epsilon)rclipâ€‹=clip(r(Î¸),1âˆ’Ïµ,1+Ïµ) ç›´è§‚è§£é‡Šï¼š æ•™ç»ƒè¯´ï¼šâ€œæ—§åŠ¨ä½œå’Œæ–°åŠ¨ä½œå·®å¼‚è¶…è¿‡Â±10%çš„éƒ¨åˆ†æˆ‘ä¸è®¤ï¼Œé¿å…ä½ ä¹±æ”¹åŠ¨ä½œæ‘”å¾—æ›´æƒ¨ã€‚â€ æ•°å­¦ä¸Šï¼Œè¿™é™åˆ¶äº†æ¢¯åº¦æ›´æ–°çš„æœ€å¤§æ­¥é•¿ï¼Œé¿å…å•ä¸€æ ·æœ¬ä¸»å¯¼å­¦ä¹ è¿‡ç¨‹ã€‚ 5. æ€»ç»“ï¼šé‡è¦æ€§é‡‡æ ·çš„åŒé‡ä»·å€¼ é«˜æ•ˆæ€§ï¼šæ‰“ç ´On-Policyçš„é‡‡æ ·æ·é”ï¼Œè®©AIèƒ½å¤ç”¨å†å²æ•°æ®ï¼Œå¤§å¹…æå‡è®­ç»ƒæ•ˆç‡ã€‚ å®‰å…¨æ€§ï¼šé€šè¿‡æ¦‚ç‡æ¯”å’ŒClipæœºåˆ¶ï¼Œåœ¨ã€Œå¤§èƒ†åˆ›æ–°ã€å’Œã€Œè°¨æ…è¿­ä»£ã€ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ï¼Œé¿å…ç­–ç•¥å´©æºƒã€‚ å¦‚åŒå­¦éª‘è‡ªè¡Œè½¦ï¼š çœ‹è‡ªå·±è¿‡å»çš„æ‘”å€’å½•åƒï¼ˆé‡è¦æ€§é‡‡æ ·ï¼‰æ¯”æ¯æ¬¡éƒ½çœŸæ‘”ï¼ˆOn-Policyï¼‰æ›´é«˜æ•ˆã€‚ ä½†æ¨¡ä»¿æ—¶éœ€æ³¨æ„ï¼šâ€œä¸Šæ¬¡æŠ¬è…¿10cmæ‘”äº†ï¼Œè¿™æ¬¡è¯•è¯•8cmï¼Œä½†ç»ä¸çªç„¶æŠ¬è…¿20cmï¼ˆClipé™åˆ¶ï¼‰â€ã€‚ ç›®æ ‡å‡½æ•°æ›´æ–° ç†è§£äº†é‡è¦æ€§é‡‡æ ·ï¼Œæˆ‘ä»¬ä¾¿å¯ç”¨å…¶æ¥æ›´æ–°æˆ‘ä»¬çš„ç›®æ ‡å‡½æ•°ï¼Œå°†åŸæ¥On-Policyçš„å­¦ä¹ è½¬ä¸ºOff-Policyã€‚ å…¶ä¸­ç¬¬ä¸€æ­¥æ˜¯åŸå§‹çš„On-PolicyæŸå¤±å‡½æ•°ï¼Œç¬¬äºŒæ­¥å˜ä¸ºäº†Off-PolicyæŸå¤±å‡½æ•°ï¼ˆÎ¸â€²\\theta&#x27;Î¸â€²ä¸ºå‚è€ƒç­–ç•¥ï¼Œå‚è€ƒç­–ç•¥ç”¨äºé‡‡æ ·ï¼Œå¹¶å¯ä»¥ç”¨äºå¤šæ¬¡è®­ç»ƒä¼˜åŒ–Î¸\\thetaÎ¸ï¼‰ã€‚æœ€åçš„Losså°±æ˜¯PPOç®—æ³•çš„æŸå¤±å‡½æ•°ã€‚ ä½†æ˜¯å¯¹äºå‚è€ƒç­–ç•¥å’Œç°æœ‰çš„ç­–ç•¥è¿˜æ˜¯æœ‰ä¸€äº›é™åˆ¶ï¼Œå°±æ˜¯å‚è€ƒç­–ç•¥å’Œç°æœ‰çš„ç­–ç•¥ä¸èƒ½ç›¸å·®å¤ªå¤§ã€‚ä¸ç„¶è®­ç»ƒæ•ˆæœä¼šéå¸¸ä¸å¥½ã€‚ å¯ä»¥é€šè¿‡ä¸‹é¢çš„æ–¹å¼è¿›è¡Œçº¦æŸï¼š å¢åŠ KLæ•£åº¦æ­£åˆ™åŒ–é¡¹è¿›è¡Œçº¦æŸ ä½¿ç”¨CLIPå‡½æ•°ï¼Œé˜²æ­¢è®­ç»ƒçš„ç­–ç•¥å’Œå‚è€ƒçš„ç­–ç•¥åå·®è¿‡å¤§","tags":["LLM","RL","PPO"],"categories":["LLM","RL"]},{"title":"ä»é›¶å¼€å§‹äº†è§£LLaMAï¼šå¼€æºå¤§è¯­è¨€æ¨¡å‹çš„æ¶æ„è§£æ","path":"/2025/02/02/MudSynth/LLM/ä»é›¶å¼€å§‹äº†è§£LLaMAï¼šå¼€æºå¤§è¯­è¨€æ¨¡å‹çš„æ¶æ„è§£æ/","content":"æ•´ç†è‡ªBç«™æ•™ç¨‹ï¼šå›¾è§£llamaæ¶æ„ è§£è¯»æºç å®ç°_å“”å“©å“”å“©_bilibili 0. å¼•è¨€ è¿‘å¹´æ¥ï¼Œå¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰åœ¨è‡ªç„¶è¯­è¨€å¤„ç†é¢†åŸŸå–å¾—äº†çªç ´æ€§è¿›å±•ï¼Œè€ŒLLaMAï¼ˆLarge Language Model Meta AIï¼‰ä½œä¸ºMeta AIå¼€æºçš„ä¸€ç³»åˆ—LLMï¼Œä»¥å…¶ä¼˜å¼‚çš„æ€§èƒ½å’Œå¼€æ”¾çš„å§¿æ€ï¼Œè¿…é€Ÿæˆä¸ºç ”ç©¶è€…å’Œå¼€å‘è€…å…³æ³¨çš„ç„¦ç‚¹ã€‚ ä½ æ˜¯å¦å¥½å¥‡LLaMAæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿå®ƒä¸å…¶ä»–LLMç›¸æ¯”æœ‰ä½•ä¼˜åŠ¿ï¼Ÿåœ¨è¿™ç¯‡åšå®¢ä¸­ï¼Œæˆ‘ä»¬å°†ç»“åˆä»£ç æ·±å…¥æµ…å‡ºåœ°è§£æLLaMAçš„æ•´ä½“æ¶æ„ï¼Œå¸¦ä½ ä»é›¶å¼€å§‹äº†è§£è¿™ä¸€å¼ºå¤§çš„è¯­è¨€æ¨¡å‹ã€‚æˆ‘ä»¬å°†æ¢è®¨LLaMAçš„æ¨¡å‹ç»“æ„ï¼Œå¸®åŠ©ä½ å…¨é¢ç†è§£LLaMAçš„è¿ä½œæœºåˆ¶ï¼Œå¹¶ä¸ºä½ å¼€å¯æ¢ç´¢LLMä¸–ç•Œçš„å¤§é—¨ã€‚ ä¸ºäº†èƒ½å¤Ÿæ›´å¥½çš„é…åˆåŸä»£ç è¿›è¡Œé˜…è¯»ï¼Œé¦–å…ˆéœ€è¦å®‰è£…transformersåº“ï¼š 1pip install transformers ä½¿ç”¨pip show transformerså®šä½åˆ°å®‰è£…åŒ…çš„ä½ç½®åï¼Œä½¿ç”¨ä»£ç ç¼–è¾‘å™¨æ‰“å¼€åº“æ‰€åœ¨æ–‡ä»¶å¤¹ï¼Œæˆ‘ä»¬éœ€è¦é˜…è¯»çš„ä»£ç åœ¨models/llamaæ–‡ä»¶å¤¹ä¸­ã€‚ 1. åˆ†è¯å™¨éƒ¨åˆ† åœ¨LLaMAçš„æ•´ä½“æ¶æ„ä¸­ï¼Œåˆ†è¯å™¨ï¼ˆTokenizerï¼‰éƒ¨åˆ†è´Ÿè´£å°†åŸå§‹æ–‡æœ¬è½¬æ¢ä¸ºæ¨¡å‹èƒ½å¤Ÿç†è§£çš„è¾“å…¥æ ¼å¼ã€‚è¿™ä¸ªè¿‡ç¨‹æ˜¯æ·±åº¦å­¦ä¹ æ¨¡å‹å¤„ç†æ–‡æœ¬æ•°æ®çš„å…³é”®æ­¥éª¤ï¼Œä¸»è¦é€šè¿‡å°†æ–‡æœ¬è½¬æ¢ä¸ºä¸€ç³»åˆ—æ•°å­—åŒ–çš„IDï¼ˆå³token IDsï¼‰æ¥å®ç°ã€‚ ä»¥ä¸€ä¸ªç®€å•çš„ä¾‹å­ä¸ºè¯´æ˜ï¼šå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªæ–‡æœ¬è¾“å…¥ â€œI love machine learning.â€ã€‚åˆ†è¯å™¨é¦–å…ˆä¼šå°†æ–‡æœ¬åˆ†å‰²æˆä»¥ä¸‹å‡ ä¸ªå•å…ƒï¼š â€œIâ€ â€œloveâ€ â€œmachineâ€ â€œlearningâ€ â€.â€ æ¥ç€ï¼Œåˆ†è¯å™¨å°†è¿™äº›è¯æ±‡æ˜ å°„ä¸ºå¯¹åº”çš„æ•°å­—IDï¼ˆtoken IDsï¼‰ã€‚ä¾‹å¦‚ï¼Œå‡è®¾è¯æ±‡è¡¨ä¸­çš„æ˜ å°„ä¸ºï¼š â€œIâ€ -&gt; 101 â€œloveâ€ -&gt; 2057 â€œmachineâ€ -&gt; 12345 â€œlearningâ€ -&gt; 67890 â€œ.â€ -&gt; 999 æœ€ç»ˆï¼Œåˆ†è¯å™¨è¾“å‡ºçš„token IDsåºåˆ—ä¸ºï¼š[101, 2057, 12345, 67890, 999]ã€‚è¿™äº›IDä½œä¸ºLLaMAæ¨¡å‹çš„è¾“å…¥ï¼Œä¾›æ¨¡å‹è¿›è¡Œè¿›ä¸€æ­¥çš„è®¡ç®—å’Œå¤„ç†ã€‚ é€šè¿‡è¿™ç§æ–¹å¼ï¼ŒLLaMAèƒ½å¤Ÿé«˜æ•ˆåœ°ç†è§£å’Œå¤„ç†æ–‡æœ¬æ•°æ®ï¼Œä¸ºåç»­çš„æ¨¡å‹è®¡ç®—å¥ å®šåŸºç¡€ã€‚åˆ†è¯å™¨åœ¨è¿™ä¸€è¿‡ç¨‹ä¸­çš„ä½œç”¨ä¸ä»…ä»…æ˜¯å°†æ–‡å­—è½¬ä¸ºæ•°å­—ï¼Œå®ƒè¿˜è¦ç¡®ä¿åˆ†å‰²çš„å•ä½èƒ½å¤Ÿåæ˜ å‡ºæ–‡æœ¬çš„è¯­æ³•å’Œè¯­ä¹‰ç»“æ„ï¼Œä»è€Œæé«˜æ¨¡å‹çš„ç†è§£èƒ½åŠ›å’Œç”Ÿæˆæ•ˆæœã€‚ 2. LLaMAä¸»å¹²éƒ¨åˆ† LLaMAçš„ä¸»å¹²éƒ¨åˆ†ä¸»è¦è´Ÿè´£å¯¹è¾“å…¥æ–‡æœ¬è¿›è¡Œæ·±å…¥çš„ç‰¹å¾æå–å’Œç†è§£ã€‚è¿™ä¸€éƒ¨åˆ†ä»åˆ†è¯å™¨è¾“å‡ºçš„token IDså¼€å§‹ï¼Œç»è¿‡åµŒå…¥å±‚ï¼ˆEmbeddingï¼‰ï¼Œå¹¶é€šè¿‡å¤šä¸ªéšè—çŠ¶æ€ï¼ˆhidden statesï¼‰å±‚å±‚ä¼ é€’ï¼Œæœ€ç»ˆè¾“å‡ºæ¨¡å‹çš„é«˜çº§ç‰¹å¾è¡¨ç¤ºã€‚ 2.1 åµŒå…¥å±‚ï¼ˆEmbeddingï¼‰ åœ¨LLaMAæ¨¡å‹çš„ä¸»å¹²éƒ¨åˆ†ï¼Œé¦–å…ˆæ˜¯åµŒå…¥å±‚ï¼ˆEmbeddingï¼‰ã€‚åµŒå…¥å±‚å°†æ¯ä¸ªtoken IDè½¬åŒ–ä¸ºé«˜ç»´å‘é‡ï¼Œä½¿å¾—æ¨¡å‹å¯ä»¥åœ¨æ›´é«˜å±‚æ¬¡ä¸Šç†è§£å’Œå¤„ç†è¾“å…¥æ•°æ®ã€‚åµŒå…¥å‘é‡åŒ…å«äº†æ¯ä¸ªtokençš„è¯­ä¹‰ä¿¡æ¯ï¼Œä½¿å¾—æ¨¡å‹èƒ½å¤ŸåŸºäºè¿™äº›ä¿¡æ¯è¿›è¡Œåç»­çš„è®¡ç®—ã€‚ 2.2 éšè—çŠ¶æ€ï¼ˆhidden statesï¼‰ ä»åµŒå…¥å±‚è¾“å‡ºçš„å‘é‡ä¼šè¿›å…¥ä¸€ç³»åˆ—çš„éšè—çŠ¶æ€ï¼ˆhidden statesï¼‰ã€‚è¿™äº›éšè—çŠ¶æ€æ˜¯ç¥ç»ç½‘ç»œä¸­æ¯ä¸€å±‚çš„è¾“å‡ºï¼ŒåŒ…å«äº†è¾“å…¥æ•°æ®åœ¨ç½‘ç»œä¸­çš„é€æ­¥è½¬æ¢è¿‡ç¨‹ã€‚LLaMAä½¿ç”¨äº†å¤šä¸ªéšè—çŠ¶æ€å±‚ï¼Œè¿™äº›å±‚å…±åŒä½œç”¨ï¼Œæ•æ‰äº†æ–‡æœ¬ä¸­æ›´å¤æ‚çš„è¯­æ³•å’Œè¯­ä¹‰ç‰¹å¾ã€‚æ¯ä¸€å±‚çš„è¾“å‡ºéƒ½ä¼šæä¾›å…³äºè¾“å…¥æ–‡æœ¬çš„ä¸åŒæ–¹é¢çš„ç†è§£ï¼Œå¸®åŠ©æ¨¡å‹æ„å»ºæ›´ç²¾ç¡®çš„ä¸Šä¸‹æ–‡å…³ç³»ã€‚ 2.3 å¤šå±‚å¤„ç†ï¼ˆLayersï¼‰ LLaMAæ¨¡å‹çš„æ ¸å¿ƒéƒ¨åˆ†ç”±å¤šä¸ªå±‚ï¼ˆLayersï¼‰ ç»„æˆï¼Œæ¯ä¸€å±‚éƒ½åœ¨ä¸æ–­æ”¹è¿›æ¨¡å‹å¯¹è¾“å…¥æ–‡æœ¬çš„ç†è§£ã€‚è¿™äº›å±‚é€šè¿‡å¤šä¸ªç¥ç»ç½‘ç»œæ¨¡å—ï¼Œå¦‚è‡ªæ³¨æ„åŠ›æœºåˆ¶ï¼ˆSelf-attentionï¼‰ï¼Œå¸®åŠ©æ¨¡å‹æ•æ‰é•¿è·ç¦»ä¾èµ–å…³ç³»å’Œå¤æ‚çš„è¯­ä¹‰ä¿¡æ¯ã€‚æ¯ä¸€å±‚éƒ½ä»å‰ä¸€å±‚çš„è¾“å‡ºï¼ˆå³éšè—çŠ¶æ€ï¼‰ä¸­æå–æ›´é«˜å±‚æ¬¡çš„ç‰¹å¾è¡¨ç¤ºï¼Œé€æ­¥å¢å¼ºå¯¹æ–‡æœ¬çš„ç†è§£ã€‚åœ¨åé¢æˆ‘ä»¬ä¼šç»“åˆä»£ç è¿›è¡Œå…·ä½“è®²è§£ã€‚ æœ€ç»ˆï¼ŒLLaMAé€šè¿‡è¿™äº›å¤šå±‚çš„å¤„ç†æœºåˆ¶ï¼Œèƒ½å¤Ÿè·å¾—æ›´ä¸ºä¸°å¯Œçš„è¯­ä¹‰è¡¨ç¤ºï¼Œè¿›è€Œå®Œæˆå„ç§è¯­è¨€ç†è§£å’Œç”Ÿæˆä»»åŠ¡ã€‚ é€šè¿‡è¿™ç§ç»“æ„ï¼ŒLLaMAèƒ½å¤Ÿæœ‰æ•ˆåœ°è¿›è¡Œæ–‡æœ¬çš„æ·±åº¦å¤„ç†ï¼Œæœ€å¤§åŒ–å…¶å¯¹è¾“å…¥çš„ç†è§£èƒ½åŠ›ã€‚æ¯ä¸ªå±‚çº§çš„è¾“å‡ºï¼ˆéšè—çŠ¶æ€ï¼‰éƒ½ä¼šä¼ é€’è‡³ä¸‹ä¸€å±‚ï¼Œä»¥ç¡®ä¿æ¨¡å‹åœ¨æ¯ä¸€é˜¶æ®µéƒ½èƒ½æ„å»ºå‡ºæ›´å…·è¯­å¢ƒæ„ŸçŸ¥çš„ç‰¹å¾è¡¨ç¤ºã€‚ 2.4 ä»£ç å®ç° è¿™ä¸€éƒ¨åˆ†çš„ä»£ç å¯¹åº”çš„å°±æ˜¯models/llama/modeling_llama.pyä¸­çš„LlamaModelç±» 123456789101112131415161718192021222324class LlamaModel(LlamaPreTrainedModel): &quot;&quot;&quot; Transformer decoder consisting of *config.num_hidden_layers* layers. Each layer is a [`LlamaDecoderLayer`] Args: config: LlamaConfig &quot;&quot;&quot; def __init__(self, config: LlamaConfig): super().__init__(config) self.padding_idx = config.pad_token_id self.vocab_size = config.vocab_size self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx) self.layers = nn.ModuleList( [LlamaDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)] ) self.norm = LlamaRMSNorm(config.hidden_size, eps=config.rms_norm_eps) self.rotary_emb = LlamaRotaryEmbedding(config=config) self.gradient_checkpointing = False # Initialize weights and apply final processing self.post_init() ç„¶åæ ¸å¿ƒçš„æ‰§è¡Œé¡ºåºå¦‚ä¸‹ï¼ˆforwardå‡½æ•°ç²¾ç®€ç‰ˆï¼‰ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061if inputs_embeds is None:\tinputs_embeds = self.embed_tokens(input_ids)causal_mask = self._update_causal_mask( attention_mask, inputs_embeds, cache_position, past_key_values, output_attentions)hidden_states = inputs_embeds# create position embeddings to be shared across the decoder layersposition_embeddings = self.rotary_emb(hidden_states, position_ids)# hidden states forward(decoder layers)for decoder_layer in self.layers[: self.config.num_hidden_layers]:\tif output_hidden_states: all_hidden_states += (hidden_states,)\tif self.gradient_checkpointing and self.training: layer_outputs = self._gradient_checkpointing_func( decoder_layer.__call__, hidden_states, causal_mask, position_ids, past_key_values, output_attentions, use_cache, cache_position, position_embeddings, )\telse: layer_outputs = decoder_layer( hidden_states, attention_mask=causal_mask, position_ids=position_ids, past_key_value=past_key_values, output_attentions=output_attentions, use_cache=use_cache, cache_position=cache_position, position_embeddings=position_embeddings, **flash_attn_kwargs, )\thidden_states = layer_outputs[0]\tif output_attentions: all_self_attns += (layer_outputs[1],)hidden_states = self.norm(hidden_states)# add hidden states from the last decoder layerif output_hidden_states:\tall_hidden_states += (hidden_states,)output = BaseModelOutputWithPast(\tlast_hidden_state=hidden_states,\tpast_key_values=past_key_values if use_cache else None,\thidden_states=all_hidden_states,\tattentions=all_self_attns,)return output if return_dict else output.to_tuple() 3. LLaMAçš„CLMä»»åŠ¡ åœ¨LLaMAæ¨¡å‹ä¸­ï¼ŒCLMä»»åŠ¡ï¼ˆCausal Language Modelingï¼‰æ˜¯ç”¨äºè®­ç»ƒæ¨¡å‹ç†è§£æ–‡æœ¬ç”Ÿæˆçš„å…³é”®ä»»åŠ¡ä¹‹ä¸€ã€‚å…¶ä¸»è¦ç›®æ ‡æ˜¯é€šè¿‡é¢„æµ‹ä¸‹ä¸€ä¸ªtokençš„æ–¹å¼ï¼Œè®­ç»ƒæ¨¡å‹æŒæ¡è¯­è¨€çš„ç”Ÿæˆèƒ½åŠ›ã€‚ 3.1 è‡ªå›å½’Lossï¼ˆCausal Lossï¼‰ LLaMAåœ¨CLMä»»åŠ¡ä¸­ä½¿ç”¨äº†è‡ªå›å½’æŸå¤±ï¼ˆCausal Lossï¼‰ã€‚åœ¨è¯¥ä»»åŠ¡ä¸­ï¼Œæ¨¡å‹åŸºäºè¾“å…¥çš„æ–‡æœ¬ï¼ˆæˆ–tokenåºåˆ—ï¼‰é€æ­¥é¢„æµ‹æ¯ä¸ªtokenï¼Œå°è¯•ç”Ÿæˆä¸‹ä¸€ä¸ªtokenã€‚è¿™ä¸€è¿‡ç¨‹é€šè¿‡è®¡ç®—é¢„æµ‹å€¼ä¸å®é™…å€¼ä¹‹é—´çš„å·®è·æ¥ä¼˜åŒ–æ¨¡å‹ï¼Œä»è€Œä½¿æ¨¡å‹èƒ½å¤Ÿæ›´å‡†ç¡®åœ°é¢„æµ‹æœªæ¥çš„tokenã€‚æŸå¤±å‡½æ•°åˆ™æ ¹æ®è¿™ä¸ªå·®è·æ¥åå‘ä¼ æ’­è¯¯å·®ï¼Œæ›´æ–°æ¨¡å‹å‚æ•°ã€‚ 3.2 CLMè¾“å‡º CLMä»»åŠ¡çš„æœ€ç»ˆè¾“å‡ºæ˜¯CLM outputï¼Œå³é€šè¿‡è®­ç»ƒå¾—åˆ°çš„tokené¢„æµ‹ç»“æœã€‚è¿™ä¸ªè¾“å‡ºåŒ…å«äº†æ¯ä¸ªæ—¶é—´æ­¥çš„é¢„æµ‹tokenï¼Œä»¥åŠå…¶å¯¹åº”çš„ç”Ÿæˆæ¦‚ç‡åˆ†å¸ƒï¼Œæœ€ç»ˆæ„æˆäº†æ¨¡å‹çš„è¯­è¨€ç”Ÿæˆèƒ½åŠ›ã€‚ 3.3 ä»£ç å®ç° è¿™ä¸€éƒ¨åˆ†çš„ä»£ç å¯¹åº”çš„å°±æ˜¯models/llama/modeling_llama.pyä¸­çš„LlamaForCausalLMç±» 123456789101112class LlamaForCausalLM(LlamaPreTrainedModel, GenerationMixin): _tied_weights_keys = [&quot;lm_head.weight&quot;] _tp_plan = &#123;&quot;lm_head&quot;: &quot;colwise_rep&quot;&#125; def __init__(self, config): super().__init__(config) self.model = LlamaModel(config) self.vocab_size = config.vocab_size self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False) # Initialize weights and apply final processing self.post_init() å¯ä»¥çœ‹åˆ°ï¼Œä»–ä¸Šæ¥å°±å®šä¹‰äº†ä¸€ä¸ªLlamaModelï¼Œåˆ©ç”¨è¾“å‡ºçš„hidden_statesåšè‡ªå›å½’ä»»åŠ¡ï¼ˆnext token predictionï¼‰ã€‚ ç„¶åæˆ‘ä»¬çœ‹forwardéƒ¨åˆ†ï¼ˆç²¾ç®€ç‰ˆï¼‰ï¼Œè¾“å…¥input_idsï¼Œå…ˆè¿‡ä¸Šé¢æˆ‘ä»¬è¯´çš„modelã€‚ç„¶åè¿‡linearå±‚ï¼Œæœ€åè®¡ç®—ä¸€ä¸ªlossï¼Œloss functionçš„å®šä¹‰è§åç»­ä»£ç ã€‚ forwardéƒ¨åˆ†ç²¾ç®€ç‰ˆå¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334# decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)outputs = self.model(\tinput_ids=input_ids,\tattention_mask=attention_mask,\tposition_ids=position_ids,\tpast_key_values=past_key_values,\tinputs_embeds=inputs_embeds,\tuse_cache=use_cache,\toutput_attentions=output_attentions,\toutput_hidden_states=output_hidden_states,\treturn_dict=return_dict,\tcache_position=cache_position,\t**kwargs,)hidden_states = outputs[0]# Only compute necessary logits, and do not upcast them to float if we are not computing the losslogits = self.lm_head(hidden_states[:, -num_logits_to_keep:, :])loss = Noneif labels is not None:\tloss = self.loss_function(logits=logits, labels=labels, vocab_size=self.config.vocab_size, **kwargs)if not return_dict:\toutput = (logits,) + outputs[1:]\treturn (loss,) + output if loss is not None else outputreturn CausalLMOutputWithPast(\tloss=loss,\tlogits=logits,\tpast_key_values=outputs.past_key_values,\thidden_states=outputs.hidden_states,\tattentions=outputs.attentions,) losséƒ¨åˆ†ä»£ç å¦‚ä¸‹(é»˜è®¤æ˜¯ForCausalLM)ï¼š 1234567891011@propertydef loss_function(self):\tloss_type = getattr(self, &quot;loss_type&quot;, None)\tif loss_type is None or loss_type not in LOSS_MAPPING: logger.warning_once( f&quot;`loss_type=&#123;loss_type&#125;` was set in the config but it is unrecognised.&quot; f&quot;Using the default loss: `ForCausalLMLoss`.&quot; ) loss_type = &quot;ForCausalLM&quot;\treturn LOSS_MAPPING[loss_type] ForCausalLMLoss å‡½æ•°ï¼šå› æœè¯­è¨€æ¨¡å‹æŸå¤±è®¡ç®— è¿™ä¸€éƒ¨åˆ†ä½¿ç”¨çš„å°±æ˜¯ï¼š 123456def fixed_cross_entropy(source, target, num_items_in_batch: int = None, ignore_index: int = -100, **kwargs): reduction = &quot;sum&quot; if num_items_in_batch is not None else &quot;mean&quot; loss = nn.functional.cross_entropy(source, target, ignore_index=ignore_index, reduction=reduction) if reduction == &quot;sum&quot;: loss = loss / num_items_in_batch return loss 1234567891011121314151617def ForCausalLMLoss( logits, labels, vocab_size: int, num_items_in_batch: int = None, ignore_index: int = -100, **kwargs): # Upcast to float if we need to compute the loss to avoid potential precision issues logits = logits.float() labels = labels.to(logits.device) # Shift so that tokens &lt; n predict n shift_logits = logits[..., :-1, :].contiguous() shift_labels = labels[..., 1:].contiguous() # Flatten the tokens shift_logits = shift_logits.view(-1, vocab_size) shift_labels = shift_labels.view(-1) # Enable model parallelism shift_labels = shift_labels.to(shift_logits.device) loss = fixed_cross_entropy(shift_logits, shift_labels, num_items_in_batch, ignore_index, **kwargs) return loss 1. è¾“å…¥å‚æ•° logits: æ¨¡å‹è¾“å‡ºï¼Œå½¢çŠ¶ (batch_size, sequence_length, vocab_size)ã€‚ labels: çœŸå®æ ‡ç­¾ï¼Œå½¢çŠ¶ (batch_size, sequence_length)ã€‚ vocab_size: è¯æ±‡è¡¨å¤§å°ã€‚ ignore_index: å¿½ç•¥çš„æ ‡ç­¾ç´¢å¼•ï¼ˆå¦‚å¡«å……ç¬¦ï¼‰ã€‚ 2. æ ¸å¿ƒæ­¥éª¤ 2.1 ç§»ä½æ“ä½œ 12shift_logits = logits[..., :-1, :] # é¢„æµ‹ï¼šå»æ‰æœ€åä¸€ä¸ªè¯shift_labels = labels[..., 1:] # æ ‡ç­¾ï¼šå»æ‰ç¬¬ä¸€ä¸ªè¯ ç›®çš„: ä½¿æ¨¡å‹åªèƒ½åŸºäºå‰ ( n-1 ) ä¸ªè¯é¢„æµ‹ç¬¬ ( n ) ä¸ªè¯ã€‚ 2.2 å±•å¹³ 12shift_logits = shift_logits.view(-1, vocab_size) # å±•å¹³ä¸º (N, vocab_size)shift_labels = shift_labels.view(-1) # å±•å¹³ä¸º (N,) ç›®çš„: å°†æ‰€æœ‰é¢„æµ‹å’Œæ ‡ç­¾æ”¾åœ¨ç»Ÿä¸€ç»´åº¦ï¼Œæ–¹ä¾¿è®¡ç®—æŸå¤±ã€‚ 2.3 è®¡ç®—äº¤å‰ç†µæŸå¤± 1loss = fixed_cross_entropy(shift_logits, shift_labels, ...) å…¬å¼:loss=âˆ’1Nâˆ‘i=1Nâˆ‘j=1Vyijlogâ¡(pij)\\text{loss} = -\\frac{1}{N} \\sum_{i=1}^{N} \\sum_{j=1}^{V} y_{ij} \\log(p_{ij}) loss=âˆ’N1â€‹i=1âˆ‘Nâ€‹j=1âˆ‘Vâ€‹yijâ€‹log(pijâ€‹) å…¶ä¸­ï¼š pij=softmax(shift_logitsij)p_{ij} = \\text{softmax}(\\text{shift\\_logits}_{ij})pijâ€‹=softmax(shift_logitsijâ€‹)ã€‚ yijy_{ij}yijâ€‹ æ˜¯çœŸå®æ ‡ç­¾çš„ one-hot ç¼–ç ã€‚ 3. æ€»ç»“ åŠŸèƒ½: è®¡ç®—å› æœè¯­è¨€æ¨¡å‹çš„æŸå¤±ã€‚ æ ¸å¿ƒ: é€šè¿‡ç§»ä½æ“ä½œå®ç°å› æœæ€§ï¼Œä½¿ç”¨äº¤å‰ç†µè¡¡é‡é¢„æµ‹ä¸çœŸå®æ ‡ç­¾çš„å·®å¼‚ã€‚ è¾“å‡º: æŸå¤±å€¼ï¼ˆæ ‡é‡ï¼‰ã€‚ ç¤ºä¾‹ è¾“å…¥ï¼š logits: (2, 3, 5)ï¼ˆæ‰¹æ¬¡ 2ï¼Œåºåˆ— 3ï¼Œè¯æ±‡è¡¨ 5ï¼‰ã€‚ labels: (2, 3)ã€‚ è¾“å‡ºï¼š shift_logits: (2, 2, 5)ã€‚ shift_labels: (2, 2)ã€‚ æœ€ç»ˆæŸå¤±ï¼šæ ‡é‡å€¼ã€‚ 4. LLaMAçš„æ–‡æœ¬åˆ†ç±»ä»»åŠ¡ é™¤äº†ç”Ÿæˆä»»åŠ¡ï¼ŒLLaMAè¿˜æ”¯æŒæ–‡æœ¬åˆ†ç±»ä»»åŠ¡ï¼Œè¿™æ˜¯è®¸å¤šè‡ªç„¶è¯­è¨€å¤„ç†ä»»åŠ¡çš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œç‰¹åˆ«æ˜¯åœ¨æƒ…æ„Ÿåˆ†æã€ä¸»é¢˜åˆ†ç±»ç­‰ä»»åŠ¡ä¸­å…·æœ‰å¹¿æ³›åº”ç”¨ã€‚ 4.1 åˆ†ç±»å±‚ï¼ˆClassifier Layerï¼‰ åœ¨æ–‡æœ¬åˆ†ç±»ä»»åŠ¡ä¸­ï¼ŒLLaMAé€šè¿‡ä¸€ä¸ªnn.Linearå±‚å°†éšè—çŠ¶æ€ï¼ˆhidden statesï¼‰è½¬æ¢ä¸ºé€‚åˆåˆ†ç±»ä»»åŠ¡çš„è¾“å‡ºã€‚è¯¥å±‚æ ¹æ®è¾“å…¥æ–‡æœ¬çš„ç‰¹å¾ï¼Œè®¡ç®—å‡ºæ¯ä¸ªç±»åˆ«çš„æ¦‚ç‡ã€‚ 4.2 åˆ†ç±»æŸå¤±ï¼ˆClassification Lossï¼‰ LLaMAä½¿ç”¨åˆ†ç±»æŸå¤±ï¼ˆClassification Lossï¼‰ æ¥ä¼˜åŒ–æ–‡æœ¬åˆ†ç±»ä»»åŠ¡ã€‚ä¸CLMä»»åŠ¡ä¸åŒï¼Œåˆ†ç±»ä»»åŠ¡çš„ç›®æ ‡æ˜¯å°†æ–‡æœ¬åˆ†é…åˆ°ç‰¹å®šçš„ç±»åˆ«ä¸­ï¼ŒæŸå¤±å‡½æ•°è®¡ç®—é¢„æµ‹ç±»åˆ«ä¸å®é™…ç±»åˆ«ä¹‹é—´çš„å·®è·ï¼Œå¹¶é€šè¿‡åå‘ä¼ æ’­è°ƒæ•´æ¨¡å‹å‚æ•°ã€‚ 4.3 åˆ†ç±»è¾“å‡ºï¼ˆClassifier outputï¼‰ åˆ†ç±»ä»»åŠ¡çš„è¾“å‡ºæ˜¯Classifier outputï¼Œå³æ¨¡å‹å¯¹è¾“å…¥æ–‡æœ¬æ‰€é¢„æµ‹çš„åˆ†ç±»ç»“æœã€‚è¿™ä¸ªè¾“å‡ºè¡¨ç¤ºæ¨¡å‹å¯¹æ¯ä¸ªç±»åˆ«çš„é¢„æµ‹æ¦‚ç‡ï¼Œå¹¶é€šè¿‡é€‰æ‹©æ¦‚ç‡æœ€å¤§çš„ç±»åˆ«ä½œä¸ºæœ€ç»ˆåˆ†ç±»ç»“æœã€‚ æ€»ç»“æ¥è¯´ï¼ŒLLaMAä¸ä»…åœ¨è¯­è¨€ç”Ÿæˆä»»åŠ¡ï¼ˆCLMä»»åŠ¡ï¼‰ä¸­è¡¨ç°å‡ºè‰²ï¼Œè¿˜åœ¨æ–‡æœ¬åˆ†ç±»ä»»åŠ¡ä¸­å…·å¤‡å¼ºå¤§çš„èƒ½åŠ›ã€‚é€šè¿‡ä½¿ç”¨è‡ªå›å½’æŸå¤±å’Œåˆ†ç±»æŸå¤±ï¼ŒLLaMAèƒ½å¤Ÿåœ¨è¿™ä¸¤ç±»ä»»åŠ¡ä¸­è¿›è¡Œé«˜æ•ˆçš„å­¦ä¹ ä¸ä¼˜åŒ–ï¼Œä»è€Œå®ç°å¹¿æ³›çš„è‡ªç„¶è¯­è¨€å¤„ç†åº”ç”¨ã€‚ 4.4 ä»£ç å®ç° è¿™ä¸€éƒ¨åˆ†çš„ä»£ç å¯¹åº”çš„å°±æ˜¯models/llama/modeling_llama.pyä¸­çš„LlamaForSequenceClassificationç±» 123456789class LlamaForSequenceClassification(LlamaPreTrainedModel): def __init__(self, config): super().__init__(config) self.num_labels = config.num_labels self.model = LlamaModel(config) self.score = nn.Linear(config.hidden_size, self.num_labels, bias=False) # Initialize weights and apply final processing self.post_init() ç„¶åæˆ‘ä»¬çœ‹forwardéƒ¨åˆ†ï¼ˆç²¾ç®€ç‰ˆï¼‰ï¼Œè¾“å…¥input_idsï¼Œå…ˆè¿‡ä¸Šé¢æˆ‘ä»¬è¯´çš„modelã€‚ç„¶åè¿‡linearå±‚ï¼Œæœ€åè®¡ç®—ä¸€ä¸ªlossï¼Œloss functionçš„å®šä¹‰è§åç»­ä»£ç ã€‚ forwardéƒ¨åˆ†ç²¾ç®€ç‰ˆå¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031transformer_outputs = self.model(\tinput_ids,\tattention_mask=attention_mask,\tposition_ids=position_ids,\tpast_key_values=past_key_values,\tinputs_embeds=inputs_embeds,\tuse_cache=use_cache,\toutput_attentions=output_attentions,\toutput_hidden_states=output_hidden_states,\treturn_dict=return_dict,)hidden_states = transformer_outputs[0]logits = self.score(hidden_states)pooled_logits = logits[torch.arange(batch_size, device=logits.device), sequence_lengths]loss = Noneif labels is not None:\tloss = self.loss_function(logits=logits, labels=labels, pooled_logits=pooled_logits, config=self.config)if not return_dict:\toutput = (pooled_logits,) + transformer_outputs[1:]\treturn ((loss,) + output) if loss is not None else outputreturn SequenceClassifierOutputWithPast(\tloss=loss,\tlogits=pooled_logits,\tpast_key_values=transformer_outputs.past_key_values,\thidden_states=transformer_outputs.hidden_states,\tattentions=transformer_outputs.attentions,) lossè¿˜æ˜¯ä½¿ç”¨çš„æ˜¯äº¤å‰ç†µæŸå¤±å‡½æ•°ï¼Œè¿™é‡Œä¸å†èµ˜è¿° ç„¶åå…¶å®è¿˜æœ‰ä¸¤ä¸ªå‡½æ•°: 4.5 LlamaForQuestionAnswering ä»»åŠ¡ï¼šé—®ç­”ä»»åŠ¡ æŸå¤±å‡½æ•°ï¼šäº¤å‰ç†µæŸå¤±ï¼ˆCross-Entropy Lossï¼‰ åœ¨é—®ç­”ä»»åŠ¡ä¸­ï¼Œç‰¹åˆ«æ˜¯æŠ½å–å¼é—®ç­”ä»»åŠ¡ä¸­ï¼ŒLLaMAé€šå¸¸ä¼šé€šè¿‡äº¤å‰ç†µæŸå¤±æ¥è®¡ç®—é¢„æµ‹çš„ç­”æ¡ˆä½ç½®ä¸å®é™…ç­”æ¡ˆä¹‹é—´çš„å·®è·ã€‚æ¨¡å‹ä¼šè¾“å‡ºæ¯ä¸ªtokenä½œä¸ºç­”æ¡ˆçš„æ¦‚ç‡åˆ†å¸ƒï¼Œäº¤å‰ç†µæŸå¤±ç”¨äºæ¯”è¾ƒé¢„æµ‹çš„ç­”æ¡ˆè·¨åº¦ä¸çœŸå®ç­”æ¡ˆçš„è·¨åº¦ä¹‹é—´çš„å·®è·ã€‚ è¿™é‡Œçš„æŸå¤±å‡½æ•°é€šå¸¸æ˜¯torch.nn.CrossEntropyLossï¼Œç”¨æ¥å¯¹ç­”æ¡ˆspanè¿›è¡Œè¯„ä¼°ã€‚ 4.6 LlamaForTokenClassification ä»»åŠ¡ï¼šæ ‡è®°åˆ†ç±»ä»»åŠ¡ æŸå¤±å‡½æ•°ï¼šäº¤å‰ç†µæŸå¤±ï¼ˆCross-Entropy Lossï¼‰ åœ¨æ ‡è®°åˆ†ç±»ä»»åŠ¡ä¸­ï¼ˆå¦‚å‘½åå®ä½“è¯†åˆ«ã€è¯æ€§æ ‡æ³¨ç­‰ï¼‰ï¼Œæ¨¡å‹ä¼šä¸ºè¾“å…¥çš„æ¯ä¸ªtokenåˆ†é…ä¸€ä¸ªæ ‡ç­¾ã€‚æ¯ä¸ªtokençš„logitså°†ä¸çœŸå®æ ‡ç­¾è¿›è¡Œæ¯”è¾ƒï¼Œé€šå¸¸ä½¿ç”¨äº¤å‰ç†µæŸå¤±æ¥è®¡ç®—æŸå¤±ã€‚ åŒæ ·ï¼Œäº¤å‰ç†µæŸå¤±é€šè¿‡ torch.nn.CrossEntropyLoss æ¥å®ç°ã€‚ 5. LLaMAçš„Layerå±‚ LLaMAçš„Layerå±‚æ˜¯æ¨¡å‹çš„æ ¸å¿ƒç»“æ„ä¹‹ä¸€ï¼Œæ¯ä¸€å±‚éƒ½ç”±å¤šä¸ªé‡è¦ç»„æˆéƒ¨åˆ†æ„æˆï¼Œè¿™äº›ç»„ä»¶å…±åŒä½œç”¨ï¼Œå¸®åŠ©æ¨¡å‹å¤„ç†è¾“å…¥æ•°æ®å¹¶æå–æ›´æ·±å±‚æ¬¡çš„ç‰¹å¾è¡¨ç¤ºã€‚æ¯ä¸€å±‚çš„å¤„ç†æ­¥éª¤é€šå¸¸åŒ…æ‹¬è‡ªæ³¨æ„åŠ›æœºåˆ¶ï¼ˆAttentionï¼‰ã€å½’ä¸€åŒ–ï¼ˆNormï¼‰å’Œå¤šå±‚æ„ŸçŸ¥æœºï¼ˆMLPï¼‰ç­‰æ¨¡å—ã€‚ 5.1 å½’ä¸€åŒ–ï¼ˆNormï¼‰ æ¯ä¸€å±‚çš„è¾“å…¥ï¼ˆå³éšè—çŠ¶æ€hidden statesï¼‰é¦–å…ˆä¼šç»è¿‡å½’ä¸€åŒ–ï¼ˆNormï¼‰ æ“ä½œã€‚å½’ä¸€åŒ–çš„ç›®çš„æ˜¯è°ƒæ•´è¾“å…¥çš„åˆ†å¸ƒï¼Œä½¿å¾—æ¨¡å‹è®­ç»ƒæ›´åŠ ç¨³å®šï¼Œå¹¶åŠ é€Ÿæ”¶æ•›è¿‡ç¨‹ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼ŒLLaMAèƒ½å¤Ÿç¡®ä¿æ¯ä¸€å±‚çš„è¾“å…¥éƒ½å¤„äºä¸€ä¸ªåˆç†çš„æ•°å€¼èŒƒå›´å†…ã€‚ 5.2 è‡ªæ³¨æ„åŠ›æœºåˆ¶ï¼ˆAttentionï¼‰ æ¥ä¸‹æ¥ï¼Œè‡ªæ³¨æ„åŠ›æœºåˆ¶ï¼ˆAttentionï¼‰ ä¼šè¢«åº”ç”¨äºæ¯ä¸€å±‚çš„éšè—çŠ¶æ€ã€‚è‡ªæ³¨æ„åŠ›æœºåˆ¶æ˜¯LLaMAå¤„ç†åºåˆ—æ•°æ®çš„å…³é”®ï¼Œå®ƒå¸®åŠ©æ¨¡å‹æ ¹æ®è¾“å…¥æ•°æ®çš„å„ä¸ªéƒ¨åˆ†ä¹‹é—´çš„å…³ç³»æ¥è°ƒæ•´æ¯ä¸ªtokençš„è¡¨ç¤ºã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæ¨¡å‹èƒ½å¤Ÿæ•æ‰åˆ°åºåˆ—ä¸­è¿œç¨‹ä¾èµ–çš„å…³ç³»ï¼Œä»è€Œæå‡å¯¹æ–‡æœ¬è¯­ä¹‰çš„ç†è§£èƒ½åŠ›ã€‚æ³¨æ„åŠ›æœºåˆ¶ä¸­çš„ç»†èŠ‚ä¼šåœ¨åé¢è¿›è¡Œè¯¦ç»†è§£é‡Šã€‚ åœ¨æ­¤æ­¥éª¤ä¸­ï¼Œæ¨¡å‹ä¼šè®¡ç®—æ¯ä¸ªtokenä¸å…¶ä»–tokençš„ç›¸å…³æ€§ï¼Œå¹¶åŸºäºè¿™äº›ä¿¡æ¯æ¥æ›´æ–°éšè—çŠ¶æ€ï¼Œä½¿å¾—æ¯ä¸ªtokençš„è¡¨ç¤ºæ›´åŠ è´´åˆä¸Šä¸‹æ–‡ã€‚ 5.3 æ®‹å·®è¿æ¥ï¼ˆResidualï¼‰ åœ¨è‡ªæ³¨æ„åŠ›æ¨¡å—ä¹‹åï¼Œæ®‹å·®è¿æ¥ï¼ˆResidualï¼‰ è¢«ç”¨äºå°†è¾“å…¥éšè—çŠ¶æ€ä¸ç»è¿‡è‡ªæ³¨æ„åŠ›æœºåˆ¶æ›´æ–°åçš„éšè—çŠ¶æ€ç›¸åŠ ï¼Œä»è€Œå½¢æˆæ›´æ–°åçš„éšè—çŠ¶æ€ã€‚è¿™ç§æ®‹å·®è¿æ¥æœ‰åŠ©äºé˜²æ­¢æ¢¯åº¦æ¶ˆå¤±é—®é¢˜ï¼Œä½¿å¾—æ·±å±‚æ¨¡å‹èƒ½å¤Ÿæ›´å¥½åœ°è®­ç»ƒã€‚ 5.4 å¤šå±‚æ„ŸçŸ¥æœºï¼ˆMLPï¼‰ æ¯ä¸€å±‚çš„ååŠéƒ¨åˆ†æ˜¯å¤šå±‚æ„ŸçŸ¥æœºï¼ˆMLPï¼‰ æ¨¡å—ï¼Œå®ƒé€šå¸¸ç”±è‹¥å¹²ä¸ªå…¨è¿æ¥å±‚ï¼ˆfully connected layersï¼‰æ„æˆã€‚MLPå±‚çš„ä½œç”¨æ˜¯è¿›ä¸€æ­¥å¤„ç†æ›´æ–°åçš„éšè—çŠ¶æ€ï¼Œé€šè¿‡éçº¿æ€§å˜æ¢æ¥å¢åŠ æ¨¡å‹çš„è¡¨è¾¾èƒ½åŠ›ã€‚MLPå±‚å¸®åŠ©æ¨¡å‹åœ¨å¤„ç†ä¿¡æ¯æ—¶æ›´å¥½åœ°æ•æ‰å¤æ‚çš„æ¨¡å¼ã€‚ 5.5 æ®‹å·®è¿æ¥ï¼ˆResidualï¼‰ ä¸è‡ªæ³¨æ„åŠ›æœºåˆ¶ç±»ä¼¼ï¼ŒMLPæ¨¡å—åçš„è¾“å‡ºä¹Ÿä¼šé€šè¿‡ä¸€ä¸ªæ®‹å·®è¿æ¥ä¸è¾“å…¥è¿›è¡Œç›¸åŠ ã€‚è¿™æ ·å¯ä»¥ç¡®ä¿æ¯ä¸€å±‚çš„ç‰¹å¾è¡¨ç¤ºä¸ä»…ä»…ä¾èµ–äºå½“å‰å±‚çš„è¾“å‡ºï¼Œè¿˜ç»“åˆäº†è¾“å…¥çš„ä¿¡æ¯ï¼Œä½¿å¾—æ¢¯åº¦èƒ½å¤Ÿé¡ºåˆ©ä¼ æ’­ï¼Œä»è€Œæé«˜è®­ç»ƒæ•ˆæœã€‚ 5.6 æœ€ç»ˆè¾“å‡ºï¼ˆhidden statesï¼‰ ç»è¿‡ä¸Šè¿°æ­¥éª¤ï¼Œæ¯ä¸€å±‚çš„æœ€ç»ˆè¾“å‡ºæ˜¯æ›´æ–°åçš„éšè—çŠ¶æ€ï¼ˆhidden statesï¼‰ï¼Œå®ƒåŒ…å«äº†æ¨¡å‹åœ¨è¯¥å±‚æå–åˆ°çš„æ‰€æœ‰è¯­ä¹‰ä¿¡æ¯ã€‚è¿™äº›éšè—çŠ¶æ€å°†è¢«ä¼ é€’åˆ°ä¸‹ä¸€å±‚ï¼Œç»§ç»­è¿›è¡Œè¿›ä¸€æ­¥çš„å¤„ç†ï¼Œç›´åˆ°æ•´ä¸ªç½‘ç»œå®Œæˆè®­ç»ƒã€‚ æ€»ç»“æ¥è¯´ï¼ŒLLaMAçš„æ¯ä¸€å±‚é€šè¿‡è‡ªæ³¨æ„åŠ›ã€å½’ä¸€åŒ–ã€MLPå’Œæ®‹å·®è¿æ¥ç­‰æ¨¡å—çš„åä½œï¼Œèƒ½å¤Ÿä»è¾“å…¥æ•°æ®ä¸­æå–è¶Šæ¥è¶Šä¸°å¯Œçš„ç‰¹å¾ã€‚è¿™äº›å±‚çº§çš„ç»„åˆæ„å»ºäº†ä¸€ä¸ªæ·±åº¦ç¥ç»ç½‘ç»œï¼Œä½¿å¾—LLaMAèƒ½å¤Ÿåœ¨å¤šä¸ªè‡ªç„¶è¯­è¨€å¤„ç†ä»»åŠ¡ä¸­å–å¾—è‰¯å¥½çš„æ•ˆæœã€‚ 5.7 ä»£ç å®ç° è¿™ä¸€éƒ¨åˆ†çš„ä»£ç å¯¹åº”çš„å°±æ˜¯models/llama/modeling_llama.pyä¸­çš„LlamaDecoderLayerç±» 12345678910class LlamaDecoderLayer(nn.Module): def __init__(self, config: LlamaConfig, layer_idx: int): super().__init__() self.hidden_size = config.hidden_size self.self_attn = LlamaAttention(config=config, layer_idx=layer_idx) self.mlp = LlamaMLP(config) self.input_layernorm = LlamaRMSNorm(config.hidden_size, eps=config.rms_norm_eps) self.post_attention_layernorm = LlamaRMSNorm(config.hidden_size, eps=config.rms_norm_eps) å¯ä»¥çœ‹åˆ°ç¡®å®å¦‚æˆ‘ä»¬ä¹‹å‰æ‰€ä»‹ç»é‚£æ ·ï¼ŒåŒ…å«äº†3ä¸ªéƒ¨åˆ†ï¼š Attentionéƒ¨åˆ† MLPéƒ¨åˆ† æ ‡å‡†åŒ–éƒ¨åˆ† forwardå‡½æ•°å®ç°å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829residual = hidden_stateshidden_states = self.input_layernorm(hidden_states)# Self Attentionhidden_states, self_attn_weights = self.self_attn(\thidden_states=hidden_states,\tattention_mask=attention_mask,\tposition_ids=position_ids,\tpast_key_value=past_key_value,\toutput_attentions=output_attentions,\tuse_cache=use_cache,\tcache_position=cache_position,\tposition_embeddings=position_embeddings,\t**kwargs,)hidden_states = residual + hidden_states# Fully Connectedresidual = hidden_stateshidden_states = self.post_attention_layernorm(hidden_states)hidden_states = self.mlp(hidden_states)hidden_states = residual + hidden_statesoutputs = (hidden_states,)if output_attentions:\toutputs += (self_attn_weights,)return outputs å¯ä»¥çœ‹åˆ°å°±æ˜¯å¦‚ä¸Šå›¾æ‰€ç¤ºçš„ä¸€ä¸ªæµç¨‹ã€‚ 6. Attentionéƒ¨åˆ† åœ¨LLaMAæ¨¡å‹ä¸­ï¼ŒAttentionæœºåˆ¶æ˜¯ä¸€ä¸ªå…³é”®çš„æ¨¡å—ï¼Œå¸®åŠ©æ¨¡å‹åœ¨å¤„ç†æ–‡æœ¬æ—¶æ•æ‰ä¸åŒä½ç½®ä¹‹é—´çš„ä¾èµ–å…³ç³»ã€‚é€šè¿‡è¿™ç§æœºåˆ¶ï¼Œæ¨¡å‹èƒ½å¤ŸåŠ¨æ€åœ°å…³æ³¨è¾“å…¥åºåˆ—ä¸­ä¸å½“å‰tokenç›¸å…³çš„éƒ¨åˆ†ï¼Œä»è€Œæ”¹å–„å¯¹ä¸Šä¸‹æ–‡çš„ç†è§£ã€‚ 6.1 è¾“å…¥å¤„ç† é¦–å…ˆï¼Œæ¨¡å‹ä¼šå°†éšè—çŠ¶æ€ï¼ˆhidden statesï¼‰é€šè¿‡çº¿æ€§å±‚ï¼ˆnn.Linearï¼‰è½¬æ¢ä¸ºæŸ¥è¯¢ï¼ˆqueryï¼‰ ã€é”®ï¼ˆkeyï¼‰å’Œå€¼ï¼ˆvalueï¼‰ã€‚è¿™äº›è¡¨ç¤ºå°†ä½œä¸ºè‡ªæ³¨æ„åŠ›è®¡ç®—çš„æ ¸å¿ƒè¾“å…¥ã€‚ 6.2 æ—‹è½¬ä½ç½®ç¼–ç ï¼ˆapply_rotary_pos_embï¼‰ æ¥ç€ï¼Œé€šè¿‡æ—‹è½¬ä½ç½®ç¼–ç ï¼ˆapply_rotary_pos_embï¼‰ å¯¹æŸ¥è¯¢å’Œé”®è¿›è¡Œä½ç½®ç¼–ç ã€‚è¿™ä¸€æ­¥ç¡®ä¿æ¨¡å‹èƒ½å¤Ÿæ•æ‰åˆ°è¾“å…¥ä¸­å„tokençš„ä½ç½®ä¿¡æ¯ï¼Œä»è€Œæ­£ç¡®ç†è§£å…¶åœ¨ä¸Šä¸‹æ–‡ä¸­çš„è§’è‰²ã€‚ 6.3 è®¡ç®—æ³¨æ„åŠ›æƒé‡ ç„¶åï¼ŒæŸ¥è¯¢å’Œé”®å°†è¿›è¡Œç‚¹ç§¯è®¡ç®—ï¼Œå¹¶é€šè¿‡softmaxå‡½æ•°å¾—åˆ°æ³¨æ„åŠ›æƒé‡ï¼ˆattn_weightsï¼‰ã€‚è¿™äº›æƒé‡è¡¨ç¤ºæ¯ä¸ªtokenåœ¨å½“å‰ä¸Šä¸‹æ–‡ä¸­å¯¹å…¶ä»–tokençš„â€œå…³æ³¨ç¨‹åº¦â€ã€‚ 6.4 è®¡ç®—è¾“å‡º æœ€åï¼Œæ³¨æ„åŠ›æƒé‡ä¼šä¸å€¼ï¼ˆvalueï¼‰è¿›è¡ŒçŸ©é˜µä¹˜æ³•ï¼ˆMatMulï¼‰ï¼Œä»è€Œå¾—åˆ°æœ€ç»ˆçš„Attentionè¾“å‡ºï¼ˆattn_outputï¼‰ã€‚è¿™ä¸ªè¾“å‡ºè¡¨ç¤ºäº†æ¨¡å‹åŸºäºè¾“å…¥æ–‡æœ¬ä¸­å„éƒ¨åˆ†å…³ç³»æ‰€åšçš„åŠ æƒæ±‡æ€»ã€‚ 6.5 ä»£ç å®ç° è¿™ä¸€éƒ¨åˆ†çš„ä»£ç å¯¹åº”çš„å°±æ˜¯models/llama/modeling_llama.pyä¸­çš„LlamaAttentionç±» 12345678910111213141516171819202122232425class LlamaAttention(nn.Module): &quot;&quot;&quot;Multi-headed attention from &#x27;Attention Is All You Need&#x27; paper&quot;&quot;&quot; def __init__(self, config: LlamaConfig, layer_idx: int): super().__init__() self.config = config self.layer_idx = layer_idx self.head_dim = getattr(config, &quot;head_dim&quot;, config.hidden_size // config.num_attention_heads) self.num_key_value_groups = config.num_attention_heads // config.num_key_value_heads self.scaling = self.head_dim**-0.5 self.attention_dropout = config.attention_dropout self.is_causal = True self.q_proj = nn.Linear( config.hidden_size, config.num_attention_heads * self.head_dim, bias=config.attention_bias ) self.k_proj = nn.Linear( config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias ) self.v_proj = nn.Linear( config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias ) self.o_proj = nn.Linear( config.num_attention_heads * self.head_dim, config.hidden_size, bias=config.attention_bias ) forwardå‡½æ•°å®ç°å¦‚ä¸‹ï¼ˆç²¾ç®€ç‰ˆï¼‰ï¼š 12345678910111213141516171819202122232425262728input_shape = hidden_states.shape[:-1]hidden_shape = (*input_shape, -1, self.head_dim)query_states = self.q_proj(hidden_states).view(hidden_shape).transpose(1, 2)key_states = self.k_proj(hidden_states).view(hidden_shape).transpose(1, 2)value_states = self.v_proj(hidden_states).view(hidden_shape).transpose(1, 2)cos, sin = position_embeddingsquery_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)if past_key_value is not None:\t# sin and cos are specific to RoPE models; cache_position needed for the static cache\tcache_kwargs = &#123;&quot;sin&quot;: sin, &quot;cos&quot;: cos, &quot;cache_position&quot;: cache_position&#125;\tkey_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)attn_output, attn_weights = attention_interface(\tself,\tquery_states,\tkey_states,\tvalue_states,\tattention_mask,\tdropout=0.0 if not self.training else self.attention_dropout,\tscaling=self.scaling,\t**kwargs,)attn_output = attn_output.reshape(*input_shape, -1).contiguous()attn_output = self.o_proj(attn_output)return attn_output, attn_weights å¯¹äºAttentionä¸­çš„ä¸€äº›é‡è¦æŠ€æœ¯å¦‚RoPEä»¥åŠPaged Attentionç­‰åç»­ä¼šå•å¼€æ ç›®è¿›è¡Œä»‹ç»ã€‚ 7. MLPéƒ¨åˆ† 7.1 ç®€ä»‹ MLPè¿™ä¸€éƒ¨åˆ†çš„è®¾è®¡åˆ™æ›´ä¸ºç®€å•ï¼Œè¯¦ç»†è®¾è®¡åç»­ä¼šç»“åˆä»£ç è¿›è¡Œè¿›ä¸€æ­¥çš„è®²è§£ï¼Œç®€å•ä»‹ç»ä¸‹ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼š é—¨æ§ä¸æŠ•å½±çš„ç»“åˆï¼šé€šè¿‡å°†gate_proj_outputå’Œup_proj_outputç›¸ä¹˜ï¼Œæ¨¡å‹èƒ½å¤Ÿåœ¨æ¯ä¸€å±‚ä¸­çµæ´»åœ°è°ƒæ•´ä¿¡æ¯æµåŠ¨ã€‚è¿™ç§è®¾è®¡é€šè¿‡åŠ æƒå’Œé—¨æ§çš„æ–¹å¼ï¼Œç¡®ä¿æ¨¡å‹èƒ½å¤Ÿæœ‰é€‰æ‹©æ€§åœ°ä¿ç•™æˆ–æŠ‘åˆ¶ä¸åŒçš„è¾“å…¥ç‰¹å¾ï¼Œä»è€Œæé«˜å¤„ç†èƒ½åŠ›ã€‚ï¼ˆupæ˜¯å‡é‡‡æ ·çš„æµç¨‹ï¼Œdownæ˜¯é™é‡‡æ ·çš„è¿‡ç¨‹ï¼‰ éçº¿æ€§æ¿€æ´»ï¼šæ¿€æ´»å‡½æ•°çš„å¼•å…¥ç¡®ä¿äº†æ¨¡å‹èƒ½å¤Ÿæ•æ‰å¤æ‚çš„éçº¿æ€§æ¨¡å¼ï¼Œä½¿å¾—LLaMAå¯ä»¥æ›´å¥½åœ°æ‹Ÿåˆæ•°æ®ä¸­çš„å¤æ‚å…³ç³»ï¼Œæå‡æ¨¡å‹çš„å‡†ç¡®æ€§å’Œæ³›åŒ–èƒ½åŠ›ã€‚ 7.2 ä»£ç å®ç° è¿™ä¸€éƒ¨åˆ†çš„ä»£ç å¯¹åº”çš„å°±æ˜¯models/llama/modeling_llama.pyä¸­çš„LlamaMLPç±» ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314class LlamaMLP(nn.Module): def __init__(self, config): super().__init__() self.config = config self.hidden_size = config.hidden_size self.intermediate_size = config.intermediate_size self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=config.mlp_bias) self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=config.mlp_bias) self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=config.mlp_bias) self.act_fn = ACT2FN[config.hidden_act] def forward(self, x): down_proj = self.down_proj(self.act_fn(self.gate_proj(x)) * self.up_proj(x)) return down_proj å…¶ä¸­self.act_fnæŒ‡çš„æ˜¯æ¿€æ´»å‡½æ•°ï¼Œç¬¦åˆä¸Šå›¾æ‰€ç¤ºçš„è¿ç®—æ­¥éª¤ 8. å½’ä¸€åŒ–éƒ¨åˆ†ï¼ˆRMSNormï¼‰ 8.1 ç®€ä»‹ åœ¨LLaMAæ¨¡å‹ä¸­ï¼ŒRMSNormï¼ˆå‡æ–¹æ ¹å½’ä¸€åŒ–ï¼‰æ˜¯ä¸€ç§ç”¨äºå½’ä¸€åŒ–çš„æŠ€æœ¯ï¼Œç±»ä¼¼äºä¼ ç»Ÿçš„Layer Normalizationï¼Œä½†é‡‡ç”¨äº†ä¸åŒçš„å½’ä¸€åŒ–æ–¹å¼ã€‚ä¸LayerNormåŸºäºå‡å€¼å’Œæ–¹å·®çš„æ ‡å‡†åŒ–ä¸åŒï¼ŒRMSNormåªä½¿ç”¨è¾“å…¥çš„æ–¹å·®ï¼ˆè€Œéå‡å€¼ï¼‰ï¼Œé€šè¿‡è®¡ç®—å‡æ–¹æ ¹ï¼ˆRMSï¼‰æ¥è°ƒæ•´æ¯ä¸ªtokençš„ç‰¹å¾ã€‚è¿™ç§æ–¹æ³•çš„ä¼˜åŠ¿åœ¨äºæ•°å€¼è®¡ç®—çš„ç®€åŒ–ä¸ç¨³å®šæ€§ï¼Œå°¤å…¶æ˜¯åœ¨å¤„ç†å¤§è§„æ¨¡é¢„è®­ç»ƒæ¨¡å‹æ—¶ã€‚RMSNormèƒ½å¤Ÿé¿å…è®­ç»ƒè¿‡ç¨‹ä¸­å‡ºç°çš„æ¢¯åº¦æ¶ˆå¤±æˆ–çˆ†ç‚¸é—®é¢˜ï¼Œå¹¶åœ¨è®¸å¤šä»»åŠ¡ä¸­å±•ç°äº†å‡ºè‰²çš„æ€§èƒ½ã€‚ ä¸æ ‡å‡†åŒ–æ–¹æ³•ï¼ˆå¦‚LayerNormï¼‰ä¸åŒï¼ŒRMSNormä¸éœ€è¦ä¸­å¿ƒåŒ–è¾“å…¥æ•°æ®ï¼Œè€Œæ˜¯ç›´æ¥å¯¹æ¯ä¸ªtokençš„ç‰¹å¾è¿›è¡Œå½’ä¸€åŒ–ï¼Œä¿ç•™äº†è¾“å…¥æ•°æ®çš„åŸå§‹åˆ†å¸ƒã€‚è¿™ä½¿å¾—å®ƒåœ¨å¤§è§„æ¨¡ç¥ç»ç½‘ç»œè®­ç»ƒä¸­å…·æœ‰æ›´é«˜çš„æ•ˆç‡ä¸ç¨³å®šæ€§ï¼Œå°¤å…¶é€‚ç”¨äºåƒLLaMAè¿™æ ·çš„å¤§å‹æ¨¡å‹ã€‚ æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨Â LlamaRMSNormÂ å±‚çš„å®ç°å’Œå·¥ä½œåŸç†ã€‚ 8.2 ä»£ç å®ç° è¿™ä¸€éƒ¨åˆ†çš„ä»£ç å¯¹åº”çš„å°±æ˜¯models/llama/modeling_llama.pyä¸­çš„LlamaMLPç±» 123456789101112131415161718class LlamaRMSNorm(nn.Module): def __init__(self, hidden_size, eps=1e-6): &quot;&quot;&quot; LlamaRMSNorm is equivalent to T5LayerNorm &quot;&quot;&quot; super().__init__() self.weight = nn.Parameter(torch.ones(hidden_size)) self.variance_epsilon = eps def forward(self, hidden_states): input_dtype = hidden_states.dtype hidden_states = hidden_states.to(torch.float32) variance = hidden_states.pow(2).mean(-1, keepdim=True) hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon) return self.weight * hidden_states.to(input_dtype) def extra_repr(self): return f&quot;&#123;tuple(self.weight.shape)&#125;, eps=&#123;self.variance_epsilon&#125;&quot; LlamaRMSNorm æ˜¯ä¸€ç§å½’ä¸€åŒ–æ–¹æ³•ï¼Œç±»ä¼¼äº T5 æ¨¡å‹ä¸­çš„ T5LayerNormï¼Œä½†å®ƒä½¿ç”¨ å‡æ–¹æ ¹ï¼ˆRMSï¼‰å½’ä¸€åŒ–ï¼Œè€Œä¸æ˜¯å¸¸è§„çš„æ ‡å‡†åŒ–æ–¹æ³•ï¼ˆå¦‚ LayerNormï¼‰ã€‚è¿™ç§æ–¹æ³•é€šè¿‡å¯¹è¾“å…¥çš„æ–¹å·®è¿›è¡Œå½’ä¸€åŒ–ï¼Œä½¿å¾—æ¨¡å‹åœ¨è®­ç»ƒæ—¶æ›´åŠ ç¨³å®šã€‚ æ•°å­¦å…¬å¼ å‡æ–¹æ ¹å½’ä¸€åŒ–çš„æ ¸å¿ƒå…¬å¼å¦‚ä¸‹ï¼š x^i=xi1Nâˆ‘i=1Nxi2+Ïµ\\hat{x}_i = \\frac{x_i}{\\sqrt{\\frac{1}{N} \\sum_{i=1}^N x_i^2 + \\epsilon}} x^iâ€‹=N1â€‹âˆ‘i=1Nâ€‹xi2â€‹+Ïµâ€‹xiâ€‹â€‹ å…¶ä¸­ï¼š xix_ixiâ€‹ æ˜¯è¾“å…¥çš„ç¬¬ iii ä¸ªå…ƒç´ ï¼ˆä¾‹å¦‚æŸä¸ªtokençš„ç‰¹å¾å€¼ï¼‰ã€‚ NNN æ˜¯ç‰¹å¾ç»´åº¦çš„å¤§å°ã€‚ Ïµ\\epsilonÏµ æ˜¯é˜²æ­¢é™¤é›¶é”™è¯¯çš„å°å¸¸æ•°ï¼ˆä¾‹å¦‚ 1eâˆ’61e-61eâˆ’6ï¼‰ã€‚ x^i\\hat{x}_ix^iâ€‹ æ˜¯å½’ä¸€åŒ–åçš„è¾“å‡ºã€‚ 1. åˆå§‹åŒ– 12self.weight = nn.Parameter(torch.ones(hidden_size))self.variance_epsilon = eps self.weightï¼šä¸€ä¸ªå¯å­¦ä¹ çš„å‚æ•°ï¼Œç”¨äºå¯¹å½’ä¸€åŒ–åçš„éšè—çŠ¶æ€è¿›è¡Œç¼©æ”¾ï¼Œåˆå§‹å€¼ä¸º 1ã€‚ self.variance_epsilonï¼šå°å¸¸æ•° epsï¼Œç”¨äºé˜²æ­¢é™¤é›¶é”™è¯¯ã€‚ 2. å‰å‘ä¼ æ’­ 1234hidden_states = hidden_states.to(torch.float32)variance = hidden_states.pow(2).mean(-1, keepdim=True)hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)return self.weight * hidden_states.to(input_dtype) è®¡ç®—æ–¹å·®ï¼šé¦–å…ˆå°†è¾“å…¥ hidden_states è½¬æ¢ä¸º float32ï¼Œç„¶åæ²¿ç‰¹å¾ç»´åº¦è®¡ç®—æ–¹å·®ã€‚ å‡æ–¹æ ¹å½’ä¸€åŒ–ï¼šä½¿ç”¨ torch.rsqrt() å¯¹æ–¹å·®åŠ ä¸Šå°å¸¸æ•° eps åå–å¹³æ–¹æ ¹çš„å€’æ•°ï¼Œè¿›è¡Œå½’ä¸€åŒ–å¤„ç†ã€‚ ç¼©æ”¾å’Œæ¢å¤æ•°æ®ç±»å‹ï¼šå½’ä¸€åŒ–åçš„ç»“æœä¹˜ä»¥å¯å­¦ä¹ çš„ weight å‚æ•°ï¼Œå¹¶æ¢å¤åˆ°è¾“å…¥çš„åŸå§‹æ•°æ®ç±»å‹ã€‚ 3. é¢å¤–æ˜¾ç¤ºä¿¡æ¯ 12def extra_repr(self): return f&quot;&#123;tuple(self.weight.shape)&#125;, eps=&#123;self.variance_epsilon&#125;&quot; extra_repr() ç”¨äºè¿”å›è¯¥å±‚çš„é¢å¤–ä¿¡æ¯ï¼Œä¾¿äºè°ƒè¯•ã€‚ æ€»ç»“ LlamaRMSNorm æ˜¯ä¸€ç§ä¼˜åŒ–çš„å½’ä¸€åŒ–æ–¹æ³•ï¼Œå¸¸ç”¨äº LLaMA æ¨¡å‹ã€‚å®ƒé€šè¿‡è®¡ç®—è¾“å…¥çš„æ–¹å·®å¹¶å¯¹å…¶è¿›è¡Œå‡æ–¹æ ¹å½’ä¸€åŒ–ï¼Œä½¿ç”¨å¯å­¦ä¹ çš„å‚æ•°è¿›è¡Œç¼©æ”¾ï¼Œå¸®åŠ©æ¨¡å‹åœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ä¿æŒç¨³å®šæ€§ã€‚ä¸ä¼ ç»Ÿçš„æ ‡å‡†åŒ–æ–¹æ³•ç›¸æ¯”ï¼ŒRMSNorm åœ¨ä¸€äº›ä»»åŠ¡ä¸­è¡¨ç°å‡ºæ›´å¥½çš„æ•ˆæœï¼Œå°¤å…¶æ˜¯åœ¨å¤„ç†å¤§è§„æ¨¡æ¨¡å‹æ—¶ã€‚ 9. ä»£ç è°ƒè¯•æ·±å…¥ç†è§£ ä¸ºäº†èƒ½å¤Ÿæ›´æ·±å…¥çš„ç†è§£Llamaï¼Œå¯ä»¥å¯¹ä¸‹é¢çš„ä»£ç è¿›è¡Œè°ƒè¯•ï¼Œä¸€æ­¥ä¸€æ­¥è°ƒè¯•è¿›å»å°±å¯ä»¥å¯¹Llama3æ¨¡å‹çš„æ¶æ„æŒæ¡çš„æ›´åŠ æ¸…æ™°ï¼š 123456789101112131415161718192021from transformers.models.llama import LlamaModel, LlamaConfigimport torchdef run_llama(): # 1. æ¨¡å‹åˆå§‹åŒ– llamaconfig = LlamaConfig(vocab_size=32000, hidden_size=4096//2, intermediate_size=11000//2, num_hidden_layers=32//2, num_attention_heads=32//2, max_position_embeddings=2048//2) llamamodel = LlamaModel(config=llamaconfig) # 2. å®šä¹‰è¾“å…¥ batchsize=4 inputs_ids = torch.randint( low=0, high=llamaconfig.vocab_size, size=(4, 30)) # 3. è¿›è¡Œæ¨ç†forward res = llamamodel(inputs_ids) print(res) if __name__ == &#x27;__main__&#x27;: run_llama() åœ¨è¿™æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ Hugging Face çš„Â transformersÂ åº“æ¥åˆå§‹åŒ–å’Œè¿è¡Œä¸€ä¸ªç®€åŒ–ç‰ˆçš„ LLaMA æ¨¡å‹ã€‚LLaMA æ˜¯ä¸€ç§åŸºäº Transformer æ¶æ„çš„å¤§è¯­è¨€æ¨¡å‹ï¼Œå¹¿æ³›åº”ç”¨äºè‡ªç„¶è¯­è¨€å¤„ç†ä»»åŠ¡ã€‚ä»£ç é¦–å…ˆé€šè¿‡Â LlamaConfigÂ å®šä¹‰äº†æ¨¡å‹çš„é…ç½®å‚æ•°ï¼Œå¦‚è¯æ±‡è¡¨å¤§å°ã€éšè—å±‚ç»´åº¦ã€æ³¨æ„åŠ›å¤´æ•°ç­‰ï¼Œå¹¶å°†åŸå§‹æ¨¡å‹çš„å‚æ•°å‡åŠä»¥é™ä½è®¡ç®—æˆæœ¬ã€‚æ¥ç€ï¼Œæˆ‘ä»¬ç”Ÿæˆäº†ä¸€ä¸ªéšæœºçš„è¾“å…¥å¼ é‡ï¼Œå½¢çŠ¶ä¸ºÂ (4, 30)ï¼Œè¡¨ç¤º 4 ä¸ªæ ·æœ¬ï¼Œæ¯ä¸ªæ ·æœ¬é•¿åº¦ä¸º 30ã€‚æœ€åï¼Œå°†è¾“å…¥ä¼ é€’ç»™æ¨¡å‹è¿›è¡Œæ¨ç†ï¼Œå¹¶è¾“å‡ºç»“æœã€‚è¿™æ®µä»£ç å±•ç¤ºäº†å¦‚ä½•å¿«é€Ÿæ­å»ºå’Œè¿è¡Œä¸€ä¸ªç®€åŒ–ç‰ˆçš„ LLaMA æ¨¡å‹ï¼Œé€‚åˆåˆå­¦è€…äº†è§£æ¨¡å‹çš„åŸºæœ¬ä½¿ç”¨æµç¨‹ã€‚ æ ¹æ®ä»£ç è°ƒè¯•ï¼Œä¸éš¾çŸ¥é“ï¼Œé’ˆå¯¹ä¸Šé¢è¿™ä¸ªä»£ç ï¼Œhidden_statesçš„å¤§å°ä¸º[4, 30, 2048]å› ä¸ºä¸­é—´æ˜¯transformerç»“æ„ï¼Œæ‰€ä»¥hidden_statesçš„å¤§å°ä¸ä¼šå‘ç”Ÿå˜åŒ–ï¼ˆå¤šå¤´æ³¨æ„åŠ›çš„æ—¶å€™æ˜¯å…ˆprojå†åˆ†å¤šå¤´ï¼‰ æ›´å®Œæ•´çš„ä¸€ä¸ªæ¨ç†è¿‡ç¨‹è°ƒè¯•å¯ä»¥é‡‡ç”¨ä¸‹é¢è¿™ä¸ªä»£ç ï¼š 1234567891011121314151617181920212223242526272829from transformers import AutoTokenizer, LlamaForCausalLMimport torch# æŒ‡å®šæ¨¡å‹è·¯å¾„model_path = &quot;/home/vegetabot/Filesys/CodeField_win/LLaMA-Factory/Meta-Llama-3-8B-Instruct&quot;# âœ… ä½¿ç”¨ AutoTokenizerï¼Œè®©å®ƒè‡ªåŠ¨åŒ¹é… Llama 3 çš„ tokenizertokenizer = AutoTokenizer.from_pretrained(model_path, legacy=False)# âœ… ç›´æ¥ä½¿ç”¨ LlamaForCausalLMmodel = LlamaForCausalLM.from_pretrained(model_path, torch_dtype=torch.bfloat16).to(&quot;cuda&quot;)# é¢„ç¼–è¯‘æ¨¡å‹ï¼ŒåŠ é€Ÿæ¨ç†model = torch.compile(model)print(&quot;âœ… Model Compilation Complete!&quot;)# è¾“å…¥æ–‡æœ¬# input_text = &quot;ä½ å¥½ï¼Œè¯·é—® Llama 3 æœ‰å“ªäº›æ–°ç‰¹æ€§ï¼Ÿè¯·ä½¿ç”¨ä¸­æ–‡å›ç­”&quot;input_text = &quot;ä½ å¥½ï¼Œè¯·é—®Llama 3 æœ‰å“ªäº›æ–°ç‰¹æ€§ï¼Ÿè¯·ä½¿ç”¨ä¸­æ–‡å›ç­”&quot;# ç¼–ç è¾“å…¥æ–‡æœ¬inputs = tokenizer(input_text, return_tensors=&quot;pt&quot;).to(&quot;cuda&quot;)# ç”Ÿæˆæ–‡æœ¬ï¼ˆä½¿ç”¨ KV Cache åŠ é€Ÿï¼‰outputs = model.generate(**inputs, max_new_tokens=1000, use_cache=True)# è§£ç è¾“å‡ºgenerated_text = tokenizer.decode(outputs[0], skip_special_tokens=True)print(&quot;ğŸ¤– Llama 3 ç”Ÿæˆçš„å›ç­”ï¼š &quot;, generated_text) åœ¨è¿™æ®µä¼˜åŒ–åçš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ Hugging Face çš„Â transformersÂ åº“å¿«é€Ÿè°ƒç”¨Â Meta-Llama-3-8B-InstructÂ æ¨¡å‹è¿›è¡Œä¸­æ–‡å¯¹è¯ç”Ÿæˆã€‚é¦–å…ˆé€šè¿‡Â AutoTokenizerÂ å’ŒÂ AutoModelForCausalLMÂ åŠ è½½æœ¬åœ°é¢„è®­ç»ƒçš„åˆ†è¯å™¨å’Œæ¨¡å‹ï¼ˆéœ€æå‰ä¸‹è½½æ¨¡å‹æƒé‡ï¼‰ï¼Œå¹¶ä»¥Â bfloat16Â ç²¾åº¦é‡åŒ–æ¨¡å‹ä»¥é™ä½æ˜¾å­˜å ç”¨ã€‚æ¥ç€åˆ©ç”¨Â torch.compileÂ å¯¹æ¨¡å‹è¿›è¡Œç¼–è¯‘ä¼˜åŒ–ï¼ŒåŠ é€Ÿæ¨ç†æ•ˆç‡ã€‚è¾“å…¥é—®é¢˜ â€œä½ å¥½ï¼Œè¯·é—® Llama 3 æœ‰å“ªäº›æ–°ç‰¹æ€§ï¼Ÿâ€ è¢«ç¼–ç ä¸º GPU å¼ é‡åï¼Œæ¨¡å‹é€šè¿‡Â generateÂ æ–¹æ³•ç”Ÿæˆæœ€å¤š 1000 ä¸ªæ–° token çš„å›ç­”ï¼Œæœ€ç»ˆè§£ç è¾“å‡ºè‡ªç„¶æµç•…çš„ä¸­æ–‡æ–‡æœ¬ã€‚æ•´ä¸ªè¿‡ç¨‹å±•ç¤ºäº†å¦‚ä½•é«˜æ•ˆéƒ¨ç½²å¤§è¯­è¨€æ¨¡å‹å¹¶è¿›è¡Œäº¤äº’å¼æ¨ç†ã€‚ ç»è¿‡è°ƒè¯•ï¼Œä¸éš¾çŸ¥é“ï¼Œè¾“å…¥çš„queryé¦–å…ˆç»è¿‡tokenizerè¢«ç¼–ç æˆäº†[1,20]å¤§å°çš„å‘é‡ã€‚ç„¶åå†è¿›æ¨¡å‹è¿›è¡Œæ¨ç†ï¼Œå…¶ä¸­hidden_statesçš„å¤§å°ä¸º[1,20,4096],ä½¿ç”¨çš„attentionæ˜¯sdp attentionï¼Œç„¶åæˆ‘ä»¬çš„RoPEä½œç”¨åœ¨Q Kä¸Šï¼Œæ³¨æ„åŠ›æœºåˆ¶çš„å¤´æ•°ä¸º32ã€‚ å¯¹äºMLPå±‚ï¼Œéšè—å±‚æ˜¯ä»4096å…ˆå˜åŒ–åˆ°14336ç„¶åå†è¢«æ˜ å°„å›æ¥ï¼Œé‡‡ç”¨çš„æ¿€æ´»å‡½æ•°æ˜¯SiLUã€‚ä¸€å…±æ˜¯æœ‰32å±‚Decoder Layer è¿‡å¯¹LLaMAæ¶æ„çš„æ·±å…¥è§£æï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå®ƒçš„è®¾è®¡å·§å¦™åœ°å¹³è¡¡äº†æ€§èƒ½ä¸æ•ˆç‡ï¼Œä¸ºè‡ªç„¶è¯­è¨€å¤„ç†é¢†åŸŸæä¾›äº†å¼ºå¤§çš„å·¥å…·ã€‚æ— è®ºæ˜¯ç ”ç©¶è€…è¿˜æ˜¯å¼€å‘è€…ï¼ŒLLaMAçš„å¼€æºéƒ½ä¸ºæˆ‘ä»¬æ¢ç´¢è¯­è¨€æ¨¡å‹çš„æ½œåŠ›æ‰“å¼€äº†æ–°çš„å¤§é—¨ã€‚å¸Œæœ›è¿™ç¯‡åšå®¢èƒ½å¸®åŠ©ä½ æ›´å¥½åœ°ç†è§£LLaMAï¼Œä¹Ÿå¸Œæœ›å®ƒèƒ½æ¿€å‘ä½ å¯¹å¤§è¯­è¨€æ¨¡å‹çš„æ›´å¤šå…´è¶£ä¸æ€è€ƒã€‚æœªæ¥å·²æ¥ï¼Œè®©æˆ‘ä»¬ä¸€èµ·æœŸå¾…æ›´å¤šåˆ›æ–°ä¸çªç ´ï¼","tags":["LLM","llama"],"categories":["LLM"]},{"title":"ã€è®ºæ–‡ç¬”è®°ã€‘AWQ","path":"/2025/01/06/MudSynth/Quant/ã€è®ºæ–‡ç¬”è®°ã€‘AWQ/","content":"æ–‡ç« åŸºæœ¬ä¿¡æ¯ æ–‡ç« åç§°ï¼šAWQ: Activation-aware Weight Quantization for LLM Compression and Acceleration å‘è¡¨ä¼šè®®/å¹´ä»½ï¼šMLSys 2024 ä½œè€…ï¼šJi Lin, Jiaming Tang, Haotian Tang, Shang Yang å•ä½ï¼šMIT, SJTU, NVIDIA, Tsinghua MIT-IBM, UMass æ‘˜è¦ å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMsï¼‰æ˜¾è‘—æå‡äº†è®¸å¤šAIåº”ç”¨çš„æ€§èƒ½ï¼Œè€Œå°†å…¶éƒ¨ç½²åˆ°è®¾å¤‡ç«¯å¯ä»¥é™ä½äº‘è®¡ç®—æˆæœ¬å¹¶ä¿æŠ¤ç”¨æˆ·éšç§ã€‚ç„¶è€Œï¼Œæ¨¡å‹è§„æ¨¡è¿‡å¤§å’Œç¡¬ä»¶èµ„æºæœ‰é™ä½¿å¾—éƒ¨ç½²é¢ä¸´æŒ‘æˆ˜ã€‚æœ¬æ–‡æå‡ºäº†Activation-aware Weight Quantization (AWQ)ï¼Œä¸€ç§é¢å‘ç¡¬ä»¶çš„ä½æ¯”ç‰¹é‡åŒ–æ–¹æ³•ï¼Œç”¨äºå‹ç¼©LLMçš„æƒé‡ã€‚AWQå‘ç°ä»…éœ€ä¿æŠ¤çº¦1%çš„é‡è¦æƒé‡å³å¯æ˜¾è‘—é™ä½é‡åŒ–è¯¯å·®ï¼Œå¹¶é€šè¿‡å‚è€ƒæ¿€æ´»åˆ†å¸ƒï¼ˆactivation distributionï¼‰è€Œéæƒé‡åˆ†å¸ƒæ¥ç¡®å®šé‡è¦æƒé‡ã€‚ä¸ºé¿å…æ··åˆç²¾åº¦é‡åŒ–å¸¦æ¥çš„ç¡¬ä»¶æ•ˆç‡ä½ä¸‹ï¼ŒAWQé€šè¿‡æ•°å­¦æ¨å¯¼ä¿æŠ¤é‡è¦æƒé‡é€šé“å¹¶åˆ©ç”¨æ¿€æ´»ç»Ÿè®¡æ•°æ®è¿›è¡Œç¼©æ”¾ã€‚è¯¥æ–¹æ³•æ— éœ€åå‘ä¼ æ’­æˆ–é‡å»ºï¼Œå› æ­¤èƒ½å¤Ÿå¾ˆå¥½åœ°æ³›åŒ–åˆ°ä¸åŒé¢†åŸŸå’Œæ¨¡æ€ï¼Œè€Œä¸ä¼šè¿‡æ‹Ÿåˆæ ¡å‡†æ•°æ®é›†ã€‚AWQåœ¨å¤šç§ä»»åŠ¡å’Œæ¨¡å‹ä¸Šä¼˜äºç°æœ‰æ–¹æ³•ï¼Œé¦–æ¬¡å®ç°äº†æŒ‡ä»¤è°ƒä¼˜æ¨¡å‹å’Œå¤šæ¨¡æ€LLMçš„ä¼˜å¼‚é‡åŒ–æ€§èƒ½ã€‚åŒæ—¶ï¼Œæœ¬æ–‡å®ç°äº†é«˜æ•ˆçµæ´»çš„æ¨ç†æ¡†æ¶TinyChatï¼Œå°†4-bit LLMéƒ¨ç½²åˆ°å¤šç§è¾¹ç¼˜å¹³å°ï¼Œåœ¨æ¡Œé¢å’Œç§»åŠ¨GPUä¸Šå®ç°äº†è¶…è¿‡3å€çš„åŠ é€Ÿã€‚ ä¹‹å‰å·¥ä½œå­˜åœ¨çš„é—®é¢˜ ä½æ¯”ç‰¹é‡åŒ–åœ¨æ¨¡å‹æ¨ç†ä¸­å¯ä»¥æ˜¾è‘—å‡å°‘å†…å­˜å ç”¨ï¼Œä½†å½“å‰çš„é‡åŒ–æ„ŸçŸ¥è®­ç»ƒï¼ˆQATï¼‰ æˆæœ¬é«˜æ˜‚ï¼Œè€Œè®­ç»ƒåé‡åŒ–ï¼ˆPTQï¼‰ åœ¨ä½æ¯”ç‰¹åœºæ™¯ä¸‹å‡†ç¡®æ€§å¤§å¹…ä¸‹é™ã€‚ GPTQæ–¹æ³•è™½ç„¶ä½¿ç”¨äºŒé˜¶ä¿¡æ¯è¿›è¡Œè¯¯å·®è¡¥å¿ï¼Œä½†å¯èƒ½åœ¨é‡å»ºè¿‡ç¨‹ä¸­è¿‡æ‹Ÿåˆæ ¡å‡†é›†ï¼Œä»è€Œå¤±å»å¯¹åˆ†å¸ƒå¤–é¢†åŸŸçš„æ³›åŒ–èƒ½åŠ›ã€‚ æ··åˆç²¾åº¦é‡åŒ–ï¼ˆå¦‚FP16å’Œä½æ¯”ç‰¹ç»“åˆï¼‰è™½ç„¶å¯ä»¥æå‡æ€§èƒ½ï¼Œä½†åœ¨ç¡¬ä»¶å®ç°ä¸­æ•ˆç‡è¾ƒä½ã€‚ ä¸»è¦è´¡çŒ®/åˆ›æ–° æå‡ºäº†åŸºäºæ¿€æ´»æ„ŸçŸ¥ï¼ˆactivation-awareï¼‰ çš„ä½æ¯”ç‰¹æƒé‡é‡åŒ–æ–¹æ³•AWQï¼Œèƒ½å¤Ÿæ˜¾è‘—é™ä½é‡åŒ–è¯¯å·®ï¼ŒåŒæ—¶é¿å…è¿‡æ‹Ÿåˆã€‚ å¼€å‘äº†ä¸€ä¸ªç¡¬ä»¶å‹å¥½çš„æƒé‡ç¼©æ”¾æ–¹æ³•ï¼Œä¿æŠ¤é‡è¦æƒé‡é€šé“ï¼Œé¿å…ç¡¬ä»¶æ•ˆç‡ä½ä¸‹çš„æ··åˆç²¾åº¦å®ç°ã€‚ å®ç°äº†æ”¯æŒ4-bitæ¨ç†çš„é«˜æ•ˆæ¡†æ¶TinyChatï¼Œé€šè¿‡æ ¸èåˆ(kernel fusion)å’Œå¹³å°æ„ŸçŸ¥çš„æƒé‡æ‰“åŒ…(weight packing)ï¼Œåœ¨å¤šç§è¾¹ç¼˜è®¾å¤‡ä¸Šå®ç°äº†æ˜¾è‘—çš„æ¨ç†åŠ é€Ÿã€‚ AWQé¦–æ¬¡åœ¨å¤šæ¨¡æ€æ¨¡å‹ï¼ˆå¦‚OpenFlamingoå’ŒLLaVAï¼‰ä¸ŠéªŒè¯äº†å…¶é‡åŒ–æ•ˆæœï¼Œå¹¶å°†Llama-2-70Béƒ¨ç½²åˆ°ç§»åŠ¨GPUä¸Šï¼Œå…·æœ‰å¹¿æ³›é€‚åº”æ€§å’Œä½èµ„æºéœ€æ±‚ã€‚ ç›¸å…³å·¥ä½œ æ¨¡å‹é‡åŒ–æ–¹æ³• æ¨¡å‹é‡åŒ–ä¸»è¦æœ‰ä¸¤ç§æ–¹æ³•ï¼Œé‡åŒ–æ„ŸçŸ¥è®­ç»ƒï¼ˆQATï¼‰å’Œè®­ç»ƒåé‡åŒ–ï¼ˆPTQï¼‰ã€‚QATéœ€è¦åå‘ä¼ æ’­æ›´æ–°æƒé‡ï¼Œè€ŒPTQé€šå¸¸æ— éœ€è®­ç»ƒã€‚ç”±äºQATéš¾ä»¥æ‰©å±•åˆ°å¤§å‹æ¨¡å‹ï¼Œå› æ­¤å¯¹å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMsï¼‰çš„é‡åŒ–é€šå¸¸é‡‡ç”¨PTQæ–¹æ³•ã€‚é‡åŒ–èƒ½å¤Ÿå‡å°‘æ¨¡å‹å°ºå¯¸å¹¶åŠ é€Ÿæ¨ç†ã€‚ LLMsçš„é‡åŒ– é’ˆå¯¹LLMsçš„é‡åŒ–ç ”ç©¶æœ‰ä¸¤ç§è®¾ç½®ï¼š W8A8é‡åŒ–ï¼Œå°†æ¿€æ´»å€¼å’Œæƒé‡å‡é‡åŒ–ä¸ºINT8æ ¼å¼ï¼ˆDettmers et al., 2022; Xiao et al., 2022; Yao et al., 2022; Wei et al., 2022a; 2023ï¼‰ã€‚ ä½ä½æƒé‡é‡åŒ–ï¼ˆLow-bit weight-only quantizationï¼‰ï¼Œä¾‹å¦‚W4A16ï¼Œä»…å¯¹æƒé‡è¿›è¡Œä½ä½æ•´æ•°çš„é‡åŒ–ï¼ˆFrantar et al., 2022; Dettmers &amp; Zettlemoyer, 2022; Sheng et al., 2023; Park et al., 2022ï¼‰ã€‚ æœ¬æ–‡çš„ç ”ç©¶èšç„¦äºç¬¬äºŒç§è®¾ç½®ï¼Œå› ä¸ºå®ƒä¸ä»…é™ä½äº†ç¡¬ä»¶é—¨æ§›ï¼ˆéœ€è¦æ›´å°çš„å†…å­˜å®¹é‡ï¼‰ï¼Œè¿˜åŠ å¿«äº†tokenç”Ÿæˆé€Ÿåº¦ï¼ˆç¼“è§£äº†å†…å­˜å—é™çš„å·¥ä½œè´Ÿè½½ï¼‰ã€‚é™¤äº†åŸºç¡€çš„â€œèˆå…¥åˆ°æœ€è¿‘å€¼â€æ–¹æ³•ï¼ˆRound-to-Nearestï¼ŒRTNï¼‰ï¼ŒGPTQï¼ˆFrantar et al., 2022ï¼‰æ˜¯ä¸æœ¬ç ”ç©¶æœ€æ¥è¿‘çš„æ–¹æ³•ã€‚ç„¶è€Œï¼ŒGPTQçš„é‡å»ºè¿‡ç¨‹ä¼šå¯¼è‡´æ ¡å‡†é›†è¿‡æ‹Ÿåˆçš„é—®é¢˜ï¼Œå¯èƒ½æ— æ³•ä¿æŒLLMsåœ¨å…¶ä»–æ¨¡æ€å’Œé¢†åŸŸä¸­çš„æ³›åŒ–èƒ½åŠ›ã€‚æ­¤å¤–ï¼Œå®ƒå¯¹æŸäº›æ¨¡å‹ï¼ˆä¾‹å¦‚LLaMA-7Bï¼ˆTouvron et al., 2023aï¼‰å’ŒOPT-66Bï¼ˆZhang et al., 2022ï¼‰ï¼‰éœ€è¦é‡æ–°æ’åºçš„æŠ€å·§æ‰èƒ½æ­£å¸¸å·¥ä½œã€‚ é™¤äº†é’ˆå¯¹é€šç”¨ç¡¬ä»¶çš„é‡åŒ–æ–¹æ³•å¤–ï¼ŒSpAttenï¼ˆWang et al., 2020ï¼‰è®¾è®¡äº†ä¸€ç§æ¸è¿›å¼çš„æ–¹æ³•ï¼Œé€šè¿‡é€æ­¥å¢åŠ softmaxè®¡ç®—ä¸­ä½¿ç”¨çš„ä½æ•°æ¥ä¼˜åŒ–æ€§èƒ½ã€‚ ä½ä½é‡åŒ–LLMsçš„ç³»ç»Ÿæ”¯æŒ ä½ä½é‡åŒ–çš„å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMsï¼‰å› å…¶èƒ½å¤Ÿé™ä½æ¨ç†æˆæœ¬è€Œæˆä¸ºä¸€ç§çƒ­é—¨è®¾ç½®ã€‚ç›®å‰å·²æœ‰ä¸€äº›ç³»ç»Ÿæ”¯æŒä»¥å®ç°å®é™…çš„åŠ é€Ÿæ•ˆæœã€‚ä¾‹å¦‚ï¼š GPTQï¼ˆFrantar et al., 2022ï¼‰ä¸ºOPTæ¨¡å‹æä¾›äº†INT3å†…æ ¸ï¼Œå¹¶é€šè¿‡Tritonï¼ˆTillet et al., 2019ï¼‰çš„æ”¯æŒï¼Œæ‰©å±•äº†å¯¹LLaMAæ¨¡å‹INT4é‡æ’åºé‡åŒ–çš„å†…æ ¸æ”¯æŒã€‚ FlexGenï¼ˆSheng et al., 2023ï¼‰ã€llama.cpp å’Œ exllama æ‰§è¡Œç»„é—´INT4é‡åŒ–ï¼Œä»¥å‡å°‘I/Oæˆæœ¬å’Œå¸è½½æ•°æ®çš„å¼€é”€ã€‚ FasterTransformer å®ç°äº†åŸºäºFP16Ã—INT4çš„GEMMï¼ˆé€šç”¨çŸ©é˜µä¹˜æ³•ï¼‰ç”¨äºæƒé‡é‡åŒ–ï¼ˆæ¯ä¸ªå¼ é‡çš„é‡åŒ–ï¼‰ï¼Œä½†ä¸æ”¯æŒç»„é—´é‡åŒ–ã€‚ LUT-GEMMï¼ˆPark et al., 2022ï¼‰å€ŸåŠ©æŸ¥æ‰¾è¡¨ï¼Œåœ¨GPUçš„CUDAæ ¸å¿ƒä¸Šæ‰§è¡ŒåŸºäºæ¯”ç‰¹çš„è®¡ç®—ã€‚ æœ¬æ–‡çš„å¹¶è¡Œå·¥ä½œMLC-LLMï¼ˆMLC-Team, 2023ï¼‰ï¼Œé€šè¿‡å¼ºå¤§çš„TVMåç«¯ï¼ˆChen et al., 2018; Feng et al., 2023ï¼‰ï¼Œåœ¨å¤šç§è¾¹ç¼˜CPUå’ŒGPUå¹³å°ä¸Šå–å¾—äº†ä¼˜å¼‚çš„ç»“æœã€‚ AWQ: ACTIVATION-AWARE WEIGHT QUANTIZATION å›¾2:æˆ‘ä»¬è§‚å¯Ÿåˆ°ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®æ¿€æ´»åˆ†å¸ƒï¼ˆä¸­ï¼‰æ‰¾åˆ° LLM ä¸­ 1% çš„æ˜¾ç€æƒé‡ã€‚å°†æ˜¾ç€æƒé‡ä¿ç•™åœ¨ FP16 ä¸­å¯ä»¥æ˜¾ç€æé«˜é‡åŒ–æ€§èƒ½ï¼ˆPPL ä» 43.2ï¼ˆå·¦ï¼‰åˆ° 13.0ï¼ˆä¸­ï¼‰ï¼‰ï¼Œä½†æ··åˆç²¾åº¦æ ¼å¼å¹¶ä¸å…·æœ‰ç¡¬ä»¶æ•ˆç‡ã€‚æˆ‘ä»¬éµå¾ªæ¿€æ´»æ„ŸçŸ¥åŸåˆ™å¹¶æå‡º AWQï¼ˆå³ï¼‰ã€‚ AWQ æ‰§è¡Œæ¯é€šé“ç¼©æ”¾ä»¥ä¿æŠ¤æ˜¾ç€æƒé‡å¹¶å‡å°‘é‡åŒ–è¯¯å·®ã€‚æˆ‘ä»¬æµ‹é‡äº† INT3-g128 é‡åŒ–ä¸‹ OPT-6.7B çš„å›°æƒ‘åº¦ã€‚ é‡åŒ–å°†æµ®ç‚¹æ•°æ˜ å°„ä¸ºä½ä½æ•´æ•°ï¼Œæ˜¯ä¸€ç§æœ‰æ•ˆçš„æ–¹æ³•ï¼Œå¯ä»¥å‡å°LLMsï¼ˆå¤§å‹è¯­è¨€æ¨¡å‹ï¼‰çš„æ¨¡å‹å°ºå¯¸å¹¶é™ä½æ¨ç†æˆæœ¬ï¼ˆDettmers et al., 2022; Frantar et al., 2022; Yao et al., 2022; Xiao et al., 2022ï¼‰ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆæå‡ºäº†ä¸€ç§ä»…å¯¹æƒé‡è¿›è¡Œé‡åŒ–çš„æ–¹æ³•ï¼Œé€šè¿‡ä¿æŠ¤æ›´å¤šâ€œé‡è¦â€çš„æƒé‡ï¼Œåœ¨æ— éœ€è®­ç»ƒæˆ–å›å½’ï¼ˆwithout training/regressionï¼‰ çš„æƒ…å†µä¸‹æé«˜å‡†ç¡®æ€§ã€‚éšåï¼Œæˆ‘ä»¬å¼€å‘äº†ä¸€ç§æ•°æ®é©±åŠ¨æ–¹æ³•ï¼Œç”¨äºæœç´¢å‡å°‘é‡åŒ–è¯¯å·®çš„æœ€ä¼˜ç¼©æ”¾æ¯”ä¾‹ï¼ˆè¯¦è§å›¾2ï¼‰ã€‚ 1. é€šè¿‡ä¿ç•™ 1% çš„æ˜¾è‘—æƒé‡æ”¹è¿› LLM é‡åŒ– æˆ‘ä»¬è§‚å¯Ÿåˆ°ï¼Œå¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMsï¼‰çš„æƒé‡å¹¶ä¸æ˜¯åŒç­‰é‡è¦çš„ï¼šå…¶ä¸­æœ‰ä¸€å°éƒ¨åˆ†æ˜¾è‘—æƒé‡ï¼ˆsalient weightsï¼‰å¯¹ LLM çš„æ€§èƒ½æ›´ä¸ºå…³é”®ã€‚è·³è¿‡è¿™äº›æ˜¾è‘—æƒé‡çš„é‡åŒ–è¿‡ç¨‹å¯ä»¥åœ¨ä¸è¿›è¡Œä»»ä½•è®­ç»ƒæˆ–å›å½’ï¼ˆå¦‚å›¾ 2(b) æ‰€ç¤ºï¼‰çš„æƒ…å†µä¸‹ï¼Œå‡å°‘é‡åŒ–æŸå¤±å¸¦æ¥çš„æ€§èƒ½ä¸‹é™ã€‚ ä¸ºéªŒè¯è¿™ä¸€è§‚ç‚¹ï¼Œæˆ‘ä»¬åœ¨è¡¨ 1 ä¸­æµ‹è¯•äº†è·³è¿‡éƒ¨åˆ†æƒé‡é€šé“çš„é‡åŒ– LLM çš„æ€§èƒ½ã€‚æˆ‘ä»¬æµ‹é‡äº† INT3 é‡åŒ–æ¨¡å‹çš„æ€§èƒ½ï¼ŒåŒæ—¶å°†éƒ¨åˆ†æƒé‡é€šé“ä¿ç•™ä¸º FP16ï¼ˆ16ä½æµ®ç‚¹æ•°ï¼‰ã€‚ä¸€ç§å¹¿æ³›ä½¿ç”¨çš„æ–¹æ³•æ˜¯é€šè¿‡æƒé‡çš„èŒƒæ•°ï¼ˆå¦‚ L2L_2L2â€‹-èŒƒæ•°ï¼‰æ¥ç¡®å®šæƒé‡çš„é‡è¦æ€§ï¼ˆHan et al., 2015; Frankle &amp; Carbin, 2018ï¼‰ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å‘ç°åŸºäºæƒé‡ L2L_2L2â€‹-èŒƒæ•°ï¼ˆå³ä»¥æƒé‡ WWW ä¸ºåŸºç¡€çš„ FP16%ï¼‰è·³è¿‡æƒé‡é€šé“å¹¶ä¸èƒ½æ˜¾è‘—æå‡é‡åŒ–æ¨¡å‹çš„æ€§èƒ½ï¼Œå…¶æ•ˆæœä¸éšæœºé€‰æ‹©çš„æå‡å¹…åº¦ç±»ä¼¼ã€‚ æœ‰è¶£çš„æ˜¯ï¼ŒåŸºäºæ¿€æ´»å¹…å€¼ï¼ˆactivation magnitudeï¼‰ é€‰æ‹©æƒé‡å¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½ï¼Œå³ä¾¿åªä¿ç•™ 0.1%-1% çš„é€šé“ä¸º FP16ã€‚æˆ‘ä»¬æ¨æµ‹ï¼Œè¾“å…¥ç‰¹å¾çš„å¹…å€¼è¾ƒå¤§æ—¶é€šå¸¸æ›´é‡è¦ï¼Œä¿ç•™è¿™äº›å¯¹åº”æƒé‡ä¸º FP16 å¯ä»¥ä¿ç•™è¿™äº›ç‰¹å¾ï¼Œä»è€Œæœ‰åŠ©äºæ¨¡å‹æ€§èƒ½çš„æå‡ã€‚ é™åˆ¶ å°½ç®¡ä»…ä¿ç•™ 0.1% çš„æƒé‡ä¸º FP16 å¯ä»¥åœ¨é‡åŒ–æ€§èƒ½ä¸Šå®ç°æ”¹è¿›ä¸”å¯¹æ¨¡å‹å¤§å°ï¼ˆä»¥æ€»æ¯”ç‰¹æ•°è¡¡é‡ï¼‰æ²¡æœ‰æ˜¾è‘—å½±å“ï¼Œä½†è¿™ç§æ··åˆç²¾åº¦æ•°æ®ç±»å‹ä¼šå¢åŠ ç³»ç»Ÿå®ç°çš„éš¾åº¦ã€‚æˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ç§æ–¹æ³•ï¼Œåœ¨ä¸å®é™…å°†æƒé‡ä¿ç•™ä¸º FP16 çš„æƒ…å†µä¸‹ä¿æŠ¤è¿™äº›é‡è¦æƒé‡ã€‚ 2. é€šè¿‡æ¿€æ´»æ„ŸçŸ¥ç¼©æ”¾ä¿æŠ¤æ˜¾è‘—æƒé‡ æˆ‘ä»¬æå‡ºäº†ä¸€ç§æ›¿ä»£æ–¹æ³•ï¼Œé€šè¿‡é€é€šé“ç¼©æ”¾ï¼ˆper-channel scalingï¼‰ æ¥å‡å°‘æ˜¾è‘—æƒé‡çš„é‡åŒ–è¯¯å·®ã€‚è¯¥æ–¹æ³•é¿å…äº†ç¡¬ä»¶ä½æ•ˆé—®é¢˜ã€‚ åˆ†æé‡åŒ–è¯¯å·® æˆ‘ä»¬é¦–å…ˆä»æƒé‡é‡åŒ–è¯¯å·®å¼€å§‹åˆ†æã€‚è®¾ä¸€ç»„æˆ–ä¸€ä¸ªåŒºå—çš„æƒé‡ä¸º wwwï¼Œçº¿æ€§æ“ä½œå¯è¡¨ç¤ºä¸º y=wxy = wxy=wxï¼Œè€Œé‡åŒ–åçš„å¯¹åº”æ“ä½œä¸º y=Q(w)xy = Q(w)xy=Q(w)xã€‚å…·ä½“æ¥è¯´ï¼Œé‡åŒ–å‡½æ•°å®šä¹‰å¦‚ä¸‹ï¼š Q(w)=Î”â‹…Round(wÎ”),Î”=maxâ¡(âˆ£wâˆ£)2Nâˆ’1Q(w) = \\Delta \\cdot \\text{Round}\\left(\\frac{w}{\\Delta}\\right), \\quad \\Delta = \\frac{\\max(|w|)}{2^{N-1}} Q(w)=Î”â‹…Round(Î”wâ€‹),Î”=2Nâˆ’1max(âˆ£wâˆ£)â€‹ å…¶ä¸­ï¼ŒNNN è¡¨ç¤ºé‡åŒ–çš„æ¯”ç‰¹æ•°ï¼ŒÎ”\\DeltaÎ” æ˜¯æ ¹æ®ç»å¯¹æœ€å¤§å€¼ç¡®å®šçš„é‡åŒ–ç¼©æ”¾å› å­ã€‚ ç°åœ¨è€ƒè™‘ www ä¸­çš„ä¸€ä¸ªæƒé‡å…ƒç´  wwwï¼Œå¦‚æœå°†å…¶ä¹˜ä»¥ s&gt;1s &gt; 1s&gt;1ï¼Œå¹¶å°†è¾“å…¥ xxx æŒ‰æ¯”ä¾‹ç¼©å°ä¸º xs\\frac{x}{s}sxâ€‹ï¼Œåˆ™æˆ‘ä»¬æœ‰ï¼š Q(ws)â‹…xs=Î”â€²â‹…Round(wsÎ”â€²)â‹…xsQ(ws) \\cdot \\frac{x}{s} = \\Delta&#x27; \\cdot \\text{Round}\\left(\\frac{ws}{\\Delta&#x27;}\\right) \\cdot \\frac{x}{s} Q(ws)â‹…sxâ€‹=Î”â€²â‹…Round(Î”â€²wsâ€‹)â‹…sxâ€‹ å…¶ä¸­ï¼ŒÎ”â€²\\Delta&#x27;Î”â€² æ˜¯åº”ç”¨ sss åçš„æ–°é‡åŒ–ç¼©æ”¾å› å­ã€‚é€šè¿‡å®éªŒï¼Œæˆ‘ä»¬å‘ç°ä»¥ä¸‹ç»“è®ºï¼š é‡åŒ–èˆå…¥è¯¯å·®ï¼ˆRoundErrï¼‰çš„æœŸæœ›å€¼ä¸å˜ï¼šå› ä¸ºèˆå…¥å‡½æ•°å°†æµ®ç‚¹æ•°æ˜ å°„åˆ°æ•´æ•°ï¼Œå…¶è¯¯å·®åœ¨ [0,0.5][0, 0.5][0,0.5] ä¹‹é—´å‡åŒ€åˆ†å¸ƒï¼Œå¹³å‡è¯¯å·®ä¸º 0.250.250.25ï¼ˆå³ RoundErrâˆ¼0.25\\text{RoundErr} \\sim 0.25RoundErrâˆ¼0.25ï¼‰ã€‚ å•ç‹¬æ”¾å¤§æƒé‡ www é€šå¸¸ä¸ä¼šæ”¹å˜æ•´ä¸ªç»„çš„æœ€å¤§å€¼ï¼Œå› æ­¤ Î”â€²â‰ˆÎ”\\Delta&#x27; \\approx \\DeltaÎ”â€²â‰ˆÎ”ã€‚ Î”\\DeltaÎ” å’Œ Î”â€²\\Delta&#x27;Î”â€² åœ¨ FP16 ä¸­è¡¨ç¤ºï¼Œä¸ä¼šå¼•å…¥é¢å¤–é‡åŒ–è¯¯å·®ã€‚ å› æ­¤ï¼Œé‡åŒ–è¯¯å·®å¯ä»¥è¡¨è¾¾ä¸ºï¼š Err(Q(w)x)=Î”â‹…RoundErr(wÎ”)â‹…x\\text{Err}(Q(w)x) = \\Delta \\cdot \\text{RoundErr}\\left(\\frac{w}{\\Delta}\\right) \\cdot x Err(Q(w)x)=Î”â‹…RoundErr(Î”wâ€‹)â‹…x Err(Q(ws)xs)=Î”â€²â‹…RoundErr(wsÎ”â€²)â‹…xs\\text{Err}\\left(Q(ws)\\frac{x}{s}\\right) = \\Delta&#x27; \\cdot \\text{RoundErr}\\left(\\frac{ws}{\\Delta&#x27;}\\right) \\cdot \\frac{x}{s} Err(Q(ws)sxâ€‹)=Î”â€²â‹…RoundErr(Î”â€²wsâ€‹)â‹…sxâ€‹ æ–°è¯¯å·®ä¸åŸå§‹è¯¯å·®çš„æ¯”å€¼ä¸ºï¼š Î”â€²Î”â‹…1s\\frac{\\Delta&#x27;}{\\Delta} \\cdot \\frac{1}{s} Î”Î”â€²â€‹â‹…s1â€‹ ç”±äº Î”â€²â‰ˆÎ”\\Delta&#x27; \\approx \\DeltaÎ”â€²â‰ˆÎ” ä¸” s&gt;1s &gt; 1s&gt;1ï¼Œæ˜¾è‘—æƒé‡ www çš„ç›¸å¯¹è¯¯å·®ä¼šå‡å°ã€‚ å®éªŒéªŒè¯ ä¸ºäº†éªŒè¯è¿™ä¸€æ€æƒ³ï¼Œæˆ‘ä»¬å¯¹ OPT-6.7B æ¨¡å‹çš„ 1% æ˜¾è‘—é€šé“è¿›è¡Œæ”¾å¤§ï¼ˆä¹˜ä»¥ s&gt;1s &gt; 1s&gt;1ï¼‰ï¼Œå¹¶æµ‹é‡æ¯ç»„çš„ Î”\\DeltaÎ” å˜åŒ–ï¼ˆè§è¡¨ 2ï¼‰ã€‚ç»“æœè¡¨æ˜ï¼Œæ”¾å¤§æ˜¾è‘—é€šé“æ•ˆæœæ˜¾è‘—ï¼šå½“ s=1s = 1s=1ï¼ˆå³ç®€å•çš„ RTN æ–¹æ³•ï¼‰æ—¶ï¼Œå›°æƒ‘åº¦ï¼ˆperplexity, PPLï¼‰ä¸º 23.54ï¼Œè€Œ s=2s = 2s=2 æ—¶ï¼ŒPPL é™è‡³ 11.92ã€‚ éšç€ sss å¢å¤§ï¼Œå˜åŒ–çš„ Î”\\DeltaÎ” æ¯”ä¾‹ä¸€èˆ¬ä¼šå˜å¤§ï¼Œä½†å¯¹äº s&lt;2s &lt; 2s&lt;2ï¼Œè¯¥æ¯”ä¾‹ä»ç„¶è¾ƒå°ï¼ˆå°äº 5%ï¼‰ã€‚åŒæ—¶ï¼Œæ˜¾è‘—é€šé“çš„ç›¸å¯¹è¯¯å·®éšç€ sss çš„å¢åŠ è€Œç»§ç»­å‡å°ã€‚ç„¶è€Œï¼Œå½“ sss éå¸¸å¤§æ—¶ï¼ŒÎ”\\DeltaÎ” çš„å¢åŠ ä¼šæ”¾å¤§éæ˜¾è‘—é€šé“çš„ç›¸å¯¹è¯¯å·®ï¼ˆæ¯”ä¾‹ä¸º Î”â€²Î”\\frac{\\Delta&#x27;}{\\Delta}Î”Î”â€²â€‹ï¼‰ï¼Œå¹¶ä¸”å½“ s=4s = 4s=4 æ—¶ï¼Œè¿™ç§æ¯”ä¾‹æ”¾å¤§å½±å“äº† 21.2% çš„éæ˜¾è‘—é€šé“ï¼Œå¯èƒ½æŸå®³æ¨¡å‹çš„æ•´ä½“å‡†ç¡®æ€§ã€‚ æœç´¢æœ€ä¼˜æ¯”ä¾‹ ä¸ºäº†åŒæ—¶è€ƒè™‘æ˜¾è‘—æƒé‡å’Œéæ˜¾è‘—æƒé‡ï¼Œæˆ‘ä»¬é€‰æ‹©è‡ªåŠ¨æœç´¢æ¯ä¸ªè¾“å…¥é€šé“çš„æœ€ä¼˜ç¼©æ”¾å› å­ï¼Œä»¥æœ€å°åŒ–é‡åŒ–ååœ¨æŸä¸€å±‚çš„è¾“å‡ºå·®å¼‚ã€‚æ­£å¼åœ°ï¼Œæˆ‘ä»¬éœ€è¦ä¼˜åŒ–ä»¥ä¸‹ç›®æ ‡å‡½æ•°ï¼š sâˆ—=argâ¡minâ¡sL(s)s^* = \\arg\\min_s \\mathcal{L}(s) sâˆ—=argsminâ€‹L(s) L(s)=âˆ¥Q(Wâ‹…diag(s))(diag(s)âˆ’1â‹…X)âˆ’WXâˆ¥\\mathcal{L}(s) = \\| Q(W \\cdot \\text{diag}(s))(\\text{diag}(s)^{-1} \\cdot X) - WX \\| L(s)=âˆ¥Q(Wâ‹…diag(s))(diag(s)âˆ’1â‹…X)âˆ’WXâˆ¥ å…¶ä¸­ï¼ŒQQQ è¡¨ç¤ºæƒé‡é‡åŒ–å‡½æ•°ï¼ˆä¾‹å¦‚ INT3/INT4 é‡åŒ–ï¼Œç»„å¤§å°ä¸º 128ï¼‰ï¼ŒWWW æ˜¯åŸå§‹çš„ FP16 æƒé‡ï¼ŒXXX æ˜¯ä»å°å‹æ ¡å‡†é›†ï¼ˆcalibration setï¼‰ä¸­ç¼“å­˜çš„è¾“å…¥ç‰¹å¾ã€‚æ ¡å‡†é›†ä»é¢„è®­ç»ƒæ•°æ®é›†ä¸­éšæœºæŠ½å–ï¼Œé¿å…é’ˆå¯¹ç‰¹å®šä»»åŠ¡è¿‡æ‹Ÿåˆã€‚sss æ˜¯æ¯ä¸ªè¾“å…¥é€šé“çš„ç¼©æ”¾å› å­ï¼›å¯¹äº sâˆ’1s^{-1}sâˆ’1 å’Œ XXXï¼Œå®ƒé€šå¸¸å¯ä»¥ä¸å‰ä¸€ä¸ªç®—å­èåˆï¼ˆå‚è€ƒ Wei et al., 2022b; Xiao et al., 2022ï¼‰ã€‚ ç”±äºé‡åŒ–å‡½æ•°ä¸å¯å¾®åˆ†ï¼Œæ— æ³•é€šè¿‡å¸¸è§„åå‘ä¼ æ’­ä¼˜åŒ–ã€‚å°½ç®¡ä¸€äº›æŠ€æœ¯ä¾èµ–äºè¿‘ä¼¼æ¢¯åº¦ï¼ˆBengio et al., 2013; Esser et al., 2019ï¼‰ï¼Œä½†æˆ‘ä»¬å‘ç°è¿™äº›æ–¹æ³•åœ¨æ”¶æ•›æ€§ä¸Šä»ç„¶ä¸å¤Ÿç¨³å®šã€‚ ä¸ºä½¿ä¼˜åŒ–è¿‡ç¨‹æ›´åŠ ç¨³å®šï¼Œæˆ‘ä»¬é€šè¿‡åˆ†æå½±å“ç¼©æ”¾å› å­é€‰æ‹©çš„å› ç´ ï¼Œå®šä¹‰äº†ä¸€ä¸ªæœç´¢ç©ºé—´ã€‚å¦‚ä¸Šä¸€èŠ‚æ‰€è¿°ï¼Œæƒé‡é€šé“çš„æ˜¾è‘—æ€§å®é™…ä¸Šç”±æ¿€æ´»å¹…å€¼ï¼ˆactivation scaleï¼‰å†³å®šï¼ˆå› æ­¤ç§°ä¸ºâ€œæ¿€æ´»æ„ŸçŸ¥â€ï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªéå¸¸ç®€å•çš„æœç´¢ç©ºé—´ï¼š s=sXÎ±,Î±âˆ—=argâ¡minâ¡Î±L(sXÎ±)s = s_X^\\alpha, \\quad \\alpha^* = \\arg\\min_\\alpha \\mathcal{L}(s_X^\\alpha) s=sXÎ±â€‹,Î±âˆ—=argÎ±minâ€‹L(sXÎ±â€‹) å…¶ä¸­ï¼ŒsXs_XsXâ€‹ æ˜¯æ¯é€šé“æ¿€æ´»å¹…å€¼çš„å¹³å‡å€¼ï¼Œæˆ‘ä»¬é€šè¿‡å•ä¸ªè¶…å‚æ•° Î±\\alphaÎ± æ¥å¹³è¡¡æ˜¾è‘—é€šé“ä¸éæ˜¾è‘—é€šé“çš„ä¿æŠ¤ã€‚é€šè¿‡å¿«é€Ÿç½‘æ ¼æœç´¢ï¼Œå¯ä»¥åœ¨åŒºé—´ [0,1][0, 1][0,1] ä¸­æ‰¾åˆ°æœ€ä½³ Î±\\alphaÎ±ï¼ˆ0 è¡¨ç¤ºä¸è¿›è¡Œç¼©æ”¾ï¼Œ1 è¡¨ç¤ºæœç´¢ç©ºé—´ä¸­çš„æœ€å¼ºç¼©æ”¾ï¼‰ã€‚æˆ‘ä»¬è¿˜é€šè¿‡åº”ç”¨æƒé‡è£å‰ªï¼ˆweight clippingï¼‰æ¥æœ€å°åŒ–é‡åŒ–çš„å‡æ–¹è¯¯å·®ï¼ˆMSEï¼‰ã€‚ åœ¨è¡¨ 5 ä¸­ï¼Œæˆ‘ä»¬å¯¹ OPT æ¨¡å‹åœ¨ INT3-g128 é‡åŒ–ä¸‹è¿›è¡Œäº†æ¶ˆèç ”ç©¶ã€‚AWQï¼ˆæ¿€æ´»æ„ŸçŸ¥é‡åŒ–ï¼‰å§‹ç»ˆä¼˜äºæœ€è¿‘èˆå…¥é‡åŒ–ï¼ˆRTNï¼‰ï¼Œå¹¶ä¸”åœ¨ç¡¬ä»¶å‹å¥½çš„æƒ…å†µä¸‹å®ç°äº†ä¸æ··åˆç²¾åº¦ï¼ˆ1% FP16ï¼‰ç›¸å½“çš„æ€§èƒ½ã€‚ ä¼˜åŠ¿ æˆ‘ä»¬çš„æ–¹æ³•ä¸ä¾èµ–ä»»ä½•å›å½’ï¼ˆFrantar et al., 2022ï¼‰æˆ–åå‘ä¼ æ’­ï¼Œè¿™æ˜¯è®¸å¤šé‡åŒ–æ„ŸçŸ¥è®­ç»ƒæ–¹æ³•æ‰€éœ€çš„ã€‚æ­¤å¤–ï¼Œè¯¥æ–¹æ³•å¯¹æ ¡å‡†é›†çš„ä¾èµ–æå°‘ï¼Œå› ä¸ºæˆ‘ä»¬ä»…æµ‹é‡æ¯ä¸ªé€šé“çš„å¹³å‡å¹…å€¼ï¼Œä»è€Œé¿å…äº†è¿‡æ‹Ÿåˆï¼ˆå¦‚å›¾ 8 æ‰€ç¤ºï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„æ–¹æ³•åœ¨é‡åŒ–è¿‡ç¨‹ä¸­éœ€è¦æ›´å°‘çš„æ•°æ®ï¼Œå¹¶ä¸”èƒ½å¤Ÿä¿ç•™ LLM çš„çŸ¥è¯†ï¼Œä½¿å…¶ä¸å—æ ¡å‡†é›†åˆ†å¸ƒçš„é™åˆ¶ã€‚æœ‰å…³æ›´å¤šç»†èŠ‚ï¼Œè¯·å‚è§ç¬¬ 5.3 èŠ‚ã€‚ TINYCHAT: MAPPING AWQ ONTO EDGE PLATFORMS AWQ å¯ä»¥æ˜¾è‘—å‡å° LLM çš„æ¨¡å‹å¤§å°ã€‚ç„¶è€Œï¼Œå°† W4A16ï¼ˆ4-bit æƒé‡ï¼Œ16-bit æ¿€æ´»ï¼‰çš„é‡åŒ–æ‰€å¸¦æ¥çš„ç†è®ºå†…å­˜èŠ‚çœè½¬åŒ–ä¸ºå®é™…çš„åŠ é€Ÿæ•ˆæœå¹¶éæ˜“äº‹ã€‚å¦ä¸€ç§æ›¿ä»£æ–¹æ³•ï¼Œä¾‹å¦‚ SmoothQuantï¼ˆXiao et al., 2022ï¼‰ï¼Œåœ¨å­˜å‚¨å’Œè®¡ç®—ä¸­ä¿æŒç›¸åŒçš„æ•°æ®ç²¾åº¦ï¼ˆW8A8 é‡åŒ–æ–¹æ³•ï¼‰ã€‚è¿™å…è®¸åé‡åŒ–è¿‡ç¨‹æ— ç¼é›†æˆåˆ°è®¡ç®—å†…æ ¸çš„ç»“å°¾é˜¶æ®µã€‚ å¦ä¸€æ–¹é¢ï¼ŒW4A16 é‡åŒ–ä¸ºå†…å­˜è®¿é—®å’Œè®¡ç®—å¼•å…¥äº†ä¸åŒçš„æ•°æ®ç±»å‹ã€‚å› æ­¤ï¼Œå…¶åé‡åŒ–è¿‡ç¨‹å¿…é¡»è¢«é›†æˆåˆ°ä¸»è®¡ç®—å¾ªç¯ä¸­ä»¥å®ç°æœ€ä½³æ€§èƒ½ï¼Œè¿™å¢åŠ äº†å®ç°çš„éš¾åº¦ã€‚ ä¸ºè§£å†³è¿™ä¸€é—®é¢˜ï¼Œæˆ‘ä»¬æå‡ºäº†Â TinyChatï¼šä¸€ä¸ªçµæ´»çš„ç³»ç»Ÿï¼Œç”¨äº AWQ æ¨¡å‹çš„æ¨ç†ã€‚å®ƒé‡‡ç”¨ PyTorch å‰ç«¯ï¼Œå¹¶ä½¿ç”¨ç‰¹å®šè®¾å¤‡æŒ‡ä»¤é›†ï¼ˆä¾‹å¦‚ CUDA/PTXã€Neonã€AVXï¼‰çš„åç«¯æ¥å¢å¼ºæ€§èƒ½ã€‚ 1. ä¸ºä»€ä¹ˆ AWQ èƒ½åŠ é€Ÿæœ¬åœ°è®¾å¤‡ä¸Šçš„ LLM å›¾3ï¼šLlama-2-7B æ¨¡å‹åœ¨ NVIDIA RTX 4090 ä¸Šçš„ç“¶é¢ˆåˆ†æã€‚ å·¦å›¾ï¼šÂ åœ¨æœ¬åœ°è®¾å¤‡ä¸Šçš„ LLM åº”ç”¨ä¸­ï¼Œç”Ÿæˆé˜¶æ®µæ¯”ä¸Šä¸‹æ–‡é˜¶æ®µæ…¢å¾—å¤šã€‚ ä¸­å›¾ï¼šÂ ç”Ÿæˆé˜¶æ®µæ˜¯å†…å­˜å—é™çš„ï¼Œä¸”å…·æœ‰è¾ƒä½çš„ç®—æœ¯å¼ºåº¦ï¼ˆarithmetic intensityï¼‰ã€‚W4A16 é‡åŒ–å¯ä»¥å°†ç®—æœ¯å¼ºåº¦æé«˜ 4 å€ã€‚ å³å›¾ï¼šÂ æƒé‡è®¿é—®é‡æ¯”æ¿€æ´»è®¿é—®é‡é«˜å‡ºè‹¥å¹²ä¸ªæ•°é‡çº§ã€‚å› æ­¤ï¼Œæƒé‡é‡åŒ–å¯¹äºæœ¬åœ°è®¾å¤‡ä¸Šçš„ LLM æ›´ä¸ºæœ‰æ•ˆã€‚ ä¸ºäº†ç†è§£é‡åŒ– LLM åœ¨è¾¹ç¼˜è®¾å¤‡ä¸Šçš„åŠ é€Ÿæ½œåŠ›ï¼Œæˆ‘ä»¬é¦–å…ˆå¯¹ LLaMA-7Bï¼ˆTouvron et al., 2023aï¼‰æ¨¡å‹åœ¨ RTX 4090 GPU ä¸Šçš„å»¶è¿Ÿç»„æˆè¿›è¡Œäº†åˆ†æã€‚æˆ‘ä»¬é‡‡ç”¨æ¨ç†æ‰¹é‡å¤§å°ä¸º 1ï¼Œä»¥é€‚åº”è¾¹ç¼˜è®¾å¤‡çš„ä½¿ç”¨åœºæ™¯ï¼Œå¹¶åœ¨ NVIDIA FasterTransformer ä¸­ä½¿ç”¨ FP16 å®ç°è¯¥æ¨¡å‹ã€‚ ä¸Šä¸‹æ–‡é˜¶æ®µ vs. ç”Ÿæˆé˜¶æ®µçš„å»¶è¿Ÿ å¦‚å›¾ 3(a) æ‰€ç¤ºï¼Œç”Ÿæˆ 20 ä¸ª token éœ€è¦ 310 æ¯«ç§’ï¼Œè€Œå¯¹åŒ…å« 200 ä¸ª token çš„æç¤ºï¼ˆpromptï¼‰è¿›è¡Œæ‘˜è¦ä»…éœ€ 10 æ¯«ç§’ã€‚å› æ­¤ï¼Œç”Ÿæˆé˜¶æ®µçš„å»¶è¿Ÿæ˜¾è‘—é«˜äºä¸Šä¸‹æ–‡é˜¶æ®µï¼Œå°¤å…¶æ˜¯åœ¨é’ˆå¯¹äº¤äº’å¼æœ¬åœ°è®¾å¤‡åº”ç”¨æ—¶ã€‚ ç”Ÿæˆé˜¶æ®µæ˜¯å†…å­˜å—é™çš„ ä¸ºäº†åŠ é€Ÿç”Ÿæˆé˜¶æ®µï¼Œæˆ‘ä»¬åœ¨å›¾ 3(b) ä¸­è¿›è¡Œäº† Roofline åˆ†æã€‚RTX 4090 GPU çš„å³°å€¼è®¡ç®—ååé‡ä¸º 165 TFLOPSï¼Œå†…å­˜å¸¦å®½ä¸º 1TB/sã€‚å› æ­¤ï¼Œä»»ä½•ç®—æœ¯å¼ºåº¦ï¼ˆå³è®¡ç®—ä¸å†…å­˜è®¿é—®çš„æ¯”ç‡ï¼‰å°äº 165 çš„å·¥ä½œè´Ÿè½½éƒ½å—åˆ°å†…å­˜é™åˆ¶ã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå½“ä»¥ FP16 æ‰§è¡Œæ—¶ï¼Œæœ¬åœ°è®¾å¤‡ LLM çš„ç”Ÿæˆé˜¶æ®µç®—æœ¯å¼ºåº¦çº¦ä¸º 1ã€‚è¿™è¡¨æ˜å·¥ä½œè´Ÿè½½çš„å†…å­˜å—é™ç‰¹æ€§ã€‚ç”±äºç»™å®šæ¨¡å‹çš„ FLOPs æ˜¯å›ºå®šçš„ï¼Œå”¯ä¸€æé«˜å³°å€¼æ€§èƒ½çš„æ–¹æ³•æ˜¯å‡å°‘å†…å­˜è®¿é—®é‡ã€‚AWQ é€šè¿‡å°†æƒé‡å†…å­˜å‡å°‘è‡³åŸæ¥çš„å››åˆ†ä¹‹ä¸€ï¼Œæ˜¾è‘—é™ä½äº†å†…å­˜æµé‡ã€‚ æƒé‡è®¿é—®å ä¸»å¯¼çš„å†…å­˜æµé‡ æˆ‘ä»¬è¿›ä¸€æ­¥å¯¹æƒé‡å’Œæ¿€æ´»çš„å†…å­˜è®¿é—®è¿›è¡Œäº†åˆ†è§£åˆ†æï¼Œå¦‚å›¾ 3Â© æ‰€ç¤ºã€‚æ˜¾ç„¶ï¼Œæƒé‡è®¿é—®å æ®äº†æœ¬åœ°è®¾å¤‡ LLM çš„å¤§éƒ¨åˆ†å†…å­˜æµé‡ã€‚å°†æ¨¡å‹æƒé‡é‡åŒ–ä¸º 4-bit æ•´æ•°ï¼Œå¯ä»¥å°†ç®—æœ¯å¼ºåº¦ä» 1 FLOPs/Byte æå‡åˆ°çº¦ 4 FLOPs/Byteï¼Œä»è€Œåœ¨å›¾ 3(b) ä¸­è¾¾åˆ° 4TFLOPS çš„å³°å€¼æ€§èƒ½ã€‚ ç”±äºæƒé‡é‡åŒ–å‡å°‘äº†æƒé‡çš„ä½å®½ï¼ˆå› æ­¤æé«˜äº†ç†è®ºæ€§èƒ½ä¸Šé™ï¼‰ï¼Œå¯¹äºæœ¬åœ°è®¾å¤‡ä¸Šçš„ LLM åº”ç”¨ï¼Œéµå¾ªè¿™ç§é‡åŒ–è®¾ç½®æ˜¯åˆç†çš„ã€‚AWQ ä¸“æ³¨äºæƒé‡é‡åŒ–ï¼Œéå¸¸é€‚åˆæ­¤ç±»åº”ç”¨åœºæ™¯ã€‚ 2. ä½¿ç”¨ TinyChat éƒ¨ç½² AWQ æˆ‘ä»¬è¯æ˜äº† 4-bit æƒé‡é‡åŒ–å¯ä»¥å¸¦æ¥ 4 å€çš„ç†è®ºå³°å€¼æ€§èƒ½æå‡ã€‚ä¸ºäº†å®ç°è¿™ç§åŠ é€Ÿæ•ˆæœï¼Œæˆ‘ä»¬è¿›ä¸€æ­¥è®¾è®¡äº†Â TinyChatÂ ç³»ç»Ÿã€‚åœ¨ GPU ä¸Šï¼Œæˆ‘ä»¬ä¸“æ³¨äºå®ç°å…³é”®ç»„ä»¶ï¼ŒåŒ…æ‹¬æ³¨æ„åŠ›æœºåˆ¶ã€å±‚å½’ä¸€åŒ–å’Œçº¿æ€§æŠ•å½±å†…æ ¸ã€‚çµæ´»çš„å‰ç«¯å…è®¸è½»æ¾å®šåˆ¶å¹¶å¿«é€Ÿæ”¯æŒæ–°æ¨¡å‹ã€‚TinyChat ä½¿ç”¨ 4-bit AWQï¼Œä¸ Huggingface çš„ FP16 å®ç°ç›¸æ¯”ï¼Œåœ¨ä¸åŒå®¶æ—çš„ LLM ä¸Šè·å¾—äº†è¶…è¿‡ 3 å€çš„åŠ é€Ÿã€‚åœ¨ CPU ä¸Šï¼Œæˆ‘ä»¬å°†æ•´ä¸ªè®¡ç®—å›¾è½¬ä¸º C++ å®ç°ï¼Œä»¥æœ€å°åŒ–å¼€é”€ã€‚ å³æ—¶æƒé‡åé‡åŒ–ï¼ˆOn-the-fly Weight Dequantizationï¼‰ å¯¹äºé‡åŒ–å±‚ï¼Œç”±äºç¡¬ä»¶é€šå¸¸ä¸æä¾› INT4 å’Œ FP16 ä¹‹é—´çš„ä¹˜æ³•æŒ‡ä»¤ï¼Œæˆ‘ä»¬éœ€è¦å°†æ•´æ•°å³æ—¶åé‡åŒ–ä¸º FP16ã€‚ SIMD æ„ŸçŸ¥æƒé‡æ‰“åŒ…ï¼ˆSIMD-aware Weight Packingï¼‰ å³æ—¶åé‡åŒ–å‡å°‘äº†å¯¹ä¸­é—´ DRAM çš„è®¿é—®ï¼Œä½†ä»ç„¶æ¯”è¾ƒæ˜‚è´µã€‚ä¾‹å¦‚ï¼Œåé‡åŒ–å•ä¸ª 4-bit æƒé‡éœ€è¦æ‰§è¡Œ 1 æ¬¡ç§»ä½ï¼ˆshiftï¼‰ã€1 æ¬¡æŒ‰ä½ä¸æ“ä½œï¼ˆbitwise ANDï¼‰å’Œ 1 æ¬¡ FMAï¼ˆä¹˜åŠ è¿ç®—ï¼‰ç¼©æ”¾æ“ä½œï¼Œè€Œåé‡åŒ–çš„æƒé‡åªè¿›è¡Œ 1 æ¬¡ FMA è®¡ç®—ã€‚ è¿™ä¸€è¿‡ç¨‹åœ¨å…·æœ‰ SIMD æ¶æ„ï¼ˆå•æŒ‡ä»¤å¤šæ•°æ®ï¼‰çš„ CPU ä¸Šå°¤å…¶æ˜‚è´µï¼Œå› ä¸ºè¿™äº›æ¶æ„åå‘äºçŸ¢é‡åŒ–æŒ‡ä»¤ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å»ºè®®æ ¹æ®è®¾å¤‡çš„ SIMD å•å…ƒä½å®½é‡èº«å®šåˆ¶æƒé‡æ‰“åŒ…æ–¹æ¡ˆã€‚ å›¾ 4 å±•ç¤ºäº†æˆ‘ä»¬é’ˆå¯¹ ARM CPUï¼ˆå…·æœ‰ 128-bit SIMD å¯„å­˜å™¨ï¼‰çš„ç­–ç•¥ï¼Œè¿™ç§ç­–ç•¥æä¾›äº†é«˜è¾¾ 1.2 å€çš„åŠ é€Ÿã€‚åœ¨è¿™ç§æ–¹æ³•ä¸­ï¼Œæ¯ä¸ªå¯„å­˜å™¨åŒ…å« 32 ä¸ª 4-bit æƒé‡ï¼ŒæŒ‰ç…§ä»¥ä¸‹é¡ºåºå­˜å‚¨ï¼šw0,w16,w1,w17,...,w15,w31w_0, w_{16}, w_1, w_{17}, ..., w_{15}, w_{31}w0â€‹,w16â€‹,w1â€‹,w17â€‹,...,w15â€‹,w31â€‹ã€‚è¯¥æ–¹æ³•åªéœ€è¦ 3 æ¡ SIMD æŒ‡ä»¤å³å¯è§£åŒ…æ‰€æœ‰ 32 ä¸ªæƒé‡ï¼Œè€Œä¼ ç»Ÿæ‰“åŒ…æ–¹å¼ä¸­ï¼Œæ¯ä¸ªæƒé‡éœ€è¦ 3 æ¡æ ‡é‡æŒ‡ä»¤æ¥è§£åŒ…ï¼ˆå¦‚ w0,w1,...,w31w_0, w_1, ..., w_{31}w0â€‹,w1â€‹,...,w31â€‹ï¼‰ã€‚ ä¸€èˆ¬è€Œè¨€ï¼Œå¯¹äº 2n2^n2n-bit çš„ SIMD å¯„å­˜å™¨ï¼Œç›¸é‚»æƒé‡çš„ç´¢å¼•åç§»é‡ä¸º 1/8Ã—2n1/8 \\times 2^n1/8Ã—2nï¼Œå› ä¸ºæ¯ä¸ªå¯„å­˜å™¨å¯ä»¥å®¹çº³ 1/8Ã—2n1/8 \\times 2^n1/8Ã—2n ä¸ª 8-bit æ•´æ•°ã€‚åœ¨ GPU ä¸Šï¼Œæˆ‘ä»¬å‘ç°å°†æ¯ 8 ä¸ªæƒé‡æ‰“åŒ…ä¸º w0,2,4,6,1,3,5,7w_{0,2,4,6,1,3,5,7}w0,2,4,6,1,3,5,7â€‹ æ›´ä¸ºé«˜æ•ˆï¼ˆå‚è€ƒ Kim et al., 2022ï¼‰ã€‚ å†…æ ¸èåˆï¼ˆKernel Fusionï¼‰ æˆ‘ä»¬è¿˜å¹¿æ³›åº”ç”¨å†…æ ¸èåˆæ¥ä¼˜åŒ–æœ¬åœ°è®¾å¤‡ä¸Šçš„ LLM æ¨ç†ã€‚å¯¹äºå±‚å½’ä¸€åŒ–ï¼ˆlayer normalizationï¼‰ï¼Œæˆ‘ä»¬å°†æ‰€æœ‰ç®—å­ï¼ˆå¦‚ä¹˜æ³•ã€é™¤æ³•å’Œå¹³æ–¹æ ¹ï¼‰èåˆåˆ°å•ä¸ªå†…æ ¸ä¸­ã€‚å¯¹äºæ³¨æ„åŠ›å±‚ï¼ˆattention layersï¼‰ï¼Œæˆ‘ä»¬å°† QKV æŠ•å½±èåˆåˆ°ä¸€ä¸ªå†…æ ¸ä¸­ï¼Œå¹¶åœ¨å…¶ä¸­å³æ—¶è®¡ç®—ä½ç½®åµŒå…¥ï¼ˆpositional embeddingï¼‰ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬åœ¨æ³¨æ„åŠ›å†…æ ¸ä¸­é¢„åˆ†é… KV ç¼“å­˜å¹¶è¿›è¡Œç¼“å­˜æ›´æ–°ã€‚ å†…æ ¸èåˆå¯¹äºå‰å‘ä¼ æ’­å®ç°æ•ˆç‡è¾ƒä½çš„æ¨¡å‹ï¼ˆå¦‚ Falcon å’Œ StarCoderï¼‰å°¤ä¸ºæœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œåœ¨ 4090 GPU ä¸Šï¼Œæ¯ä¸ª FP16 å†…æ ¸çš„è®¡ç®—æ—¶é—´çº¦ä¸º 0.01 æ¯«ç§’ï¼Œè¿™ä¸ GPU å†…æ ¸çš„å¯åŠ¨å¼€é”€ç›¸å½“ã€‚å› æ­¤ï¼Œé€šè¿‡å†…æ ¸èåˆå‡å°‘å†…æ ¸è°ƒç”¨æ•°é‡å¯ä»¥ç›´æ¥å®ç°åŠ é€Ÿæ•ˆæœã€‚ å®éªŒç»“æœ å®éªŒè®¾ç½® é‡åŒ– æœ¬ç ”ç©¶é‡ç‚¹å…³æ³¨ä»…é’ˆå¯¹æƒé‡çš„åˆ†ç»„é‡åŒ–ï¼ˆweight-only grouped quantizationï¼‰ã€‚å¦‚ä¹‹å‰çš„ç ”ç©¶ï¼ˆDettmers &amp; Zettlemoyer, 2022ï¼›Frantar et al., 2022ï¼‰æ‰€ç¤ºï¼Œåˆ†ç»„é‡åŒ–å¯¹æé«˜æ€§èƒ½å’Œæ¨¡å‹å°ºå¯¸çš„æƒè¡¡ï¼ˆperformance/model size trade-offï¼‰æ€»æ˜¯æœ‰å¸®åŠ©çš„ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œé™¤éç‰¹åˆ«è¯´æ˜ï¼Œæˆ‘ä»¬åœ¨å®éªŒä¸­ä½¿ç”¨äº†ç»„å¤§å°ä¸º128ï¼ˆgroup size = 128ï¼‰ã€‚æˆ‘ä»¬ä¸»è¦ç ”ç©¶äº† INT4/INT3 é‡åŒ–æ–¹æ³•ï¼Œå› ä¸ºè¿™äº›æ–¹æ³•å¯ä»¥å¾ˆå¥½åœ°ä¿ç•™å¤§è¯­è¨€æ¨¡å‹ï¼ˆLLMsï¼ŒLarge Language Modelsï¼‰çš„æ€§èƒ½ï¼ˆDettmers &amp; Zettlemoyer, 2022ï¼‰ã€‚å¯¹äº AWQ æ–¹æ³•ï¼Œæˆ‘ä»¬ä» Pile æ•°æ®é›†ï¼ˆGao et al., 2020ï¼‰ä¸­é€‰å–äº†ä¸€ä¸ªå°å‹æ ¡å‡†é›†ï¼Œä»¥é¿å…è¿‡æ‹Ÿåˆåˆ°æŸä¸ªç‰¹å®šçš„ä¸‹æ¸¸é¢†åŸŸã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†ç½‘æ ¼å¤§å°ä¸º20ï¼ˆgrid size = 20ï¼‰æ¥æœç´¢å…¬å¼5ä¸­æœ€ä¼˜çš„ Î±\\alphaÎ±ã€‚ æ¨¡å‹ æˆ‘ä»¬åœ¨ LLaMAï¼ˆTouvron et al., 2023aï¼‰å’Œ OPTï¼ˆZhang et al., 2022ï¼‰ç³»åˆ—æ¨¡å‹ä¸Šå¯¹æ–¹æ³•è¿›è¡Œäº†åŸºå‡†æµ‹è¯•ã€‚æ­¤å¤–ï¼Œå°½ç®¡è¿˜æœ‰å…¶ä»–å¼€æºçš„å¤§è¯­è¨€æ¨¡å‹ï¼ˆå¦‚ BLOOMï¼ˆScao et al., 2022ï¼‰ï¼‰ï¼Œä½†ç”±äºå…¶è´¨é‡é€šå¸¸è¾ƒå·®ï¼Œæˆ‘ä»¬æœªå°†å…¶çº³å…¥ç ”ç©¶ä¸­ã€‚æˆ‘ä»¬è¿˜è¿›ä¸€æ­¥åœ¨æŒ‡ä»¤è°ƒä¼˜æ¨¡å‹ Vicunaï¼ˆChiang et al., 2023ï¼‰ä»¥åŠè§†è§‰è¯­è¨€æ¨¡å‹ OpenFlamingo-9Bï¼ˆAwadalla et al., 2023ï¼‰å’Œ LLaVA-13Bï¼ˆLiu et al., 2023aï¼‰ä¸Šè¿›è¡Œäº†æµ‹è¯•ï¼Œä»¥éªŒè¯æ–¹æ³•çš„é€šç”¨æ€§ï¼ˆgenerabilityï¼‰ã€‚ è¯„ä»· æŒ‰ç…§ä¹‹å‰çš„æ–‡çŒ®ï¼ˆDettmers et al., 2022ï¼›Xiao et al., 2022ï¼›Frantar et al., 2022ï¼›Dettmers &amp; Zettlemoyer, 2022ï¼›Yao et al., 2022ï¼‰ï¼Œæˆ‘ä»¬ä¸»è¦åœ¨è¯­è¨€å»ºæ¨¡ä»»åŠ¡ä¸­è¯„ä¼°é‡åŒ–æ¨¡å‹çš„è¡¨ç°ï¼ˆä¾‹å¦‚ WikiText-2 æ•°æ®é›†ä¸Šçš„å›°æƒ‘åº¦è¯„ä¼°ï¼ˆperplexity evaluationï¼‰ï¼ŒMerity et al., 2016ï¼‰ï¼Œå› ä¸ºå›°æƒ‘åº¦èƒ½å¤Ÿç¨³å®šåœ°åæ˜ å¤§è¯­è¨€æ¨¡å‹ï¼ˆLLMsï¼‰çš„æ€§èƒ½ï¼ˆDettmers &amp; Zettlemoyer, 2022ï¼‰ã€‚ åŸºçº¿ æˆ‘ä»¬çš„ä¸»è¦åŸºçº¿æ˜¯åŸºç¡€çš„æœ€è¿‘èˆå…¥é‡åŒ–ï¼ˆvanilla round-to-nearest quantization, RTNï¼‰ã€‚å½“ä½¿ç”¨å°çš„ç»„å¤§å°ï¼ˆå¦‚128ï¼‰æ—¶ï¼ŒRTN å®é™…ä¸Šè¡¨ç°éå¸¸å¼ºï¼ˆFrantar et al., 2022ï¼›Dettmers &amp; Zettlemoyer, 2022ï¼‰ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜ä¸æœ€å…ˆè¿›çš„é‡åŒ–æ–¹æ³• GPTQï¼ˆFrantar et al., 2022ï¼‰è¿›è¡Œäº†æ¯”è¾ƒã€‚å¯¹äº GPTQï¼Œæˆ‘ä»¬è¿˜æ¯”è¾ƒäº†ä¸€ç§æ”¹è¿›ç‰ˆæœ¬ï¼Œè¯¥ç‰ˆæœ¬é‡‡ç”¨äº†â€œé‡æ’åºï¼ˆreorderï¼‰â€æŠ€å·§ï¼ˆç§°ä¸º GPTQ-Reorder æˆ– GPTQ-Rï¼‰ã€‚å…¶ä»–æ–¹æ³•ï¼Œå¦‚ ZeroQuantï¼ˆYao et al., 2022ï¼‰ã€AdaRoundï¼ˆNagel et al., 2020ï¼‰å’Œ BRECQï¼ˆLi et al., 2021ï¼‰ï¼Œä¾èµ–äºåå‘ä¼ æ’­æ¥æ›´æ–°é‡åŒ–æƒé‡ï¼Œè¿™äº›æ–¹æ³•åœ¨æ‰©å±•åˆ°å¤§æ¨¡å‹è§„æ¨¡æ—¶å¯èƒ½ä¼šé‡åˆ°å›°éš¾ï¼›åŒæ—¶ï¼Œå®ƒä»¬çš„æ€§èƒ½ä¹Ÿä¸å¦‚ GPTQï¼ˆFrantar et al., 2022ï¼‰ï¼Œå› æ­¤æœªçº³å…¥ç ”ç©¶èŒƒå›´ã€‚ è¯„ä»·ç»“æœ LLaMA æ¨¡å‹ï¼šAWQ åœ¨ LLaMA å’Œ LLaMA-2 æ¨¡å‹ä¸Šçš„è¯„ä¼°æ˜¾ç¤ºï¼Œåœ¨é‡åŒ–å‰ååŠä¸åŒæ¨¡å‹è§„æ¨¡ï¼ˆ7B-70Bï¼‰ä¸‹ï¼Œå…¶æ€§èƒ½å§‹ç»ˆä¼˜äºå…¶ä»–æ–¹æ³•ï¼ˆå¦‚ RTN å’Œ GPTQï¼‰ã€‚ Mistral/Mixtral æ¨¡å‹ï¼šAWQ åœ¨ Mistral å’Œ Mixtral æ¨¡å‹ä¸­ä¹Ÿè¡¨ç°ä¼˜å¼‚ï¼Œè¯æ˜äº†å…¶åœ¨ä¸åŒæ¨¡å‹æ¶æ„ä¸­çš„é€šç”¨æ€§å’Œæœ‰æ•ˆæ€§ã€‚ æŒ‡ä»¤è°ƒä¼˜æ¨¡å‹ï¼šAWQ æ–¹æ³•åœ¨æŒ‡ä»¤è°ƒä¼˜æ¨¡å‹ Vicuna ä¸Šè¡¨ç°ä¼˜å¼‚ï¼Œä½¿ç”¨ GPT-4 å¾—åˆ†è¯„ä¼°ï¼Œè¯æ˜äº†å…¶åœ¨é‡åŒ–é…ç½®ä¸‹å¯¹æ¨¡å‹æ€§èƒ½çš„å¢å¼ºæ•ˆæœä»¥åŠåœ¨æŒ‡ä»¤è°ƒä¼˜ä»»åŠ¡ä¸­çš„é€šç”¨æ€§ã€‚ å¤šæ¨¡æ€è¯­è¨€æ¨¡å‹ï¼šAWQ åœ¨å¤šæ¨¡æ€æ¨¡å‹ï¼ˆå¦‚ OpenFlamingo-9B å’Œ VILAï¼‰ä¸Šå®ç°äº†é«˜æ•ˆçš„ä½æ¯”ç‰¹é‡åŒ–ï¼Œå±•ç¤ºäº†å…¶åœ¨é›¶æ ·æœ¬å’Œå°æ ·æœ¬ä»»åŠ¡ä¸­çš„ä¼˜è¶Šæ€§ï¼Œå¹¶æä¾›äº†æ˜¾è‘—çš„æ¨¡å‹å‹ç¼©èƒ½åŠ›ï¼ŒåŒæ—¶æ€§èƒ½å‡ ä¹æ— æŸã€‚ è§†è§‰æ¨ç†ç»“æœï¼šåœ¨ LLaVA-13B æ¨¡å‹çš„è§†è§‰æ¨ç†ä»»åŠ¡ä¸­ï¼ŒAWQ åœ¨é‡åŒ–é…ç½®ä¸‹æ¯” RTN äº§ç”Ÿäº†æ›´åˆç†çš„å›ç­”ï¼Œä¾‹å¦‚èƒ½å¤Ÿæ­£ç¡®ç†è§£å›¾åƒå†…å®¹ã€‚ ç¼–ç¨‹ä¸æ•°å­¦ä»»åŠ¡ç»“æœï¼šAWQ åœ¨ç¼–ç¨‹ï¼ˆMBPP æ•°æ®é›†ï¼‰å’Œæ•°å­¦ï¼ˆGSM8K æ•°æ®é›†ï¼‰ä»»åŠ¡ä¸­è¡¨ç°å‡ºè‰²ï¼Œåœ¨é‡åŒ–é…ç½®ï¼ˆINT4-g128ï¼‰ä¸‹å®ç°äº†ä¸ FP16 æ¨¡å‹ç›¸å½“çš„æ€§èƒ½ï¼ŒåŒæ—¶ä¼˜äºå…¶ä»–é‡åŒ–æ–¹æ³•ã€‚ æ ¡å‡†é›†çš„æ•°æ®æ•ˆç‡å’Œæ³›åŒ–èƒ½åŠ› æ•°æ®æ•ˆç‡ï¼šAWQ æ–¹æ³•å¯¹æ ¡å‡†é›†éœ€æ±‚è¾ƒå°ï¼Œä»…éœ€ GPTQ æ‰€éœ€æ ¡å‡†é›†è§„æ¨¡çš„1/10ï¼Œå³å¯å®ç°æ›´ä¼˜çš„é‡åŒ–æ€§èƒ½ã€‚ æ³›åŒ–èƒ½åŠ›å’Œé²æ£’æ€§ï¼šAWQ åœ¨ä¸åŒæ ¡å‡†é›†åˆ†å¸ƒä¸‹è¡¨ç°å‡ºä¼˜å¼‚çš„é²æ£’æ€§ï¼Œå…¶å›°æƒ‘åº¦çš„å¢åŠ å¹…åº¦æ˜¾è‘—å°äº GPTQï¼Œè¯æ˜äº†å…¶æ–¹æ³•å¯¹æ ¡å‡†é›†åˆ†å¸ƒå˜åŒ–çš„ä½æ•æ„Ÿæ€§å’Œæ›´å¼ºçš„æ³›åŒ–èƒ½åŠ›ã€‚ åŠ é€Ÿæ€§èƒ½è¯„ä¼° åŠ é€Ÿç»“æœï¼šTinyChat å¯¹ä¸»æµ LLMï¼ˆå¦‚ LLaMA-2 å’Œ Falconï¼‰åœ¨ä¸åŒç¡¬ä»¶å¹³å°ä¸Šæä¾›äº†æ˜¾è‘—åŠ é€Ÿæ•ˆæœï¼Œå°¤å…¶åœ¨èµ„æºå—é™çš„è®¾å¤‡ä¸Šä»è¡¨ç°ä¼˜å¼‚ã€‚ ä¸å…¶ä»–ç³»ç»Ÿæ¯”è¾ƒï¼šç›¸æ¯”ç°æœ‰æ¨ç†ç³»ç»Ÿï¼ˆå¦‚ llama.cpp å’Œ exllamaï¼‰ï¼ŒTinyChat å±•ç°äº†æ›´å¹¿çš„é€‚é…æ€§å’Œæ›´é«˜çš„åŠ é€Ÿæ€§èƒ½ï¼ŒåŒæ—¶æ”¯æŒå¤šç§æ¨¡å‹å¹¶æ˜¾è‘—å¿«äº AutoGPTQã€‚ æ€»ç»“ åœ¨æœ¬ç ”ç©¶ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§åä¸ºæ¿€æ´»æ„ŸçŸ¥æƒé‡é‡åŒ–ï¼ˆActivation-aware Weight Quantization, AWQï¼‰çš„æ–¹æ³•ã€‚è¿™æ˜¯ä¸€ç§ç®€å•ä½†æœ‰æ•ˆçš„ä½æ¯”ç‰¹æƒé‡å‹ç¼©æŠ€æœ¯ï¼Œä¸“ç”¨äºå¤§è¯­è¨€æ¨¡å‹ï¼ˆLLMsï¼‰ã€‚åŸºäºæƒé‡åœ¨ LLM ä¸­çš„é‡è¦æ€§å¹¶ä¸å‡ç­‰çš„è§‚å¯Ÿï¼ŒAWQ å¯¹æ¯ä¸ªé€šé“è¿›è¡Œç¼©æ”¾ï¼ˆper-channel scalingï¼‰ï¼Œä»¥å‡å°‘æ˜¾è‘—æƒé‡çš„é‡åŒ–æŸå¤±ã€‚ AWQ ä¸ä¼šå¯¹æ ¡å‡†é›†è¿‡æ‹Ÿåˆï¼ŒåŒæ—¶ä¿ç•™äº† LLM åœ¨å„ç§é¢†åŸŸå’Œæ¨¡æ€ä¸Šçš„é€šç”¨èƒ½åŠ›ã€‚å®ƒåœ¨è¯­è¨€å»ºæ¨¡ä»»åŠ¡ä¸Šä¼˜äºç°æœ‰æ–¹æ³•ï¼Œå¹¶é€‚ç”¨äºæŒ‡ä»¤è°ƒä¼˜æ¨¡å‹ï¼ˆinstruction-tuned LMsï¼‰å’Œå¤šæ¨¡æ€æ¨¡å‹ï¼ˆmulti-modal LMsï¼‰ã€‚ æˆ‘ä»¬çš„ TinyChat ç³»ç»Ÿè¿›ä¸€æ­¥å°† AWQ å®ç°çš„ç†è®ºå†…å­˜èŠ‚çœè½¬åŒ–ä¸ºå®æµ‹çš„ 3.2-3.3 å€åŠ é€Ÿæ•ˆæœï¼ˆç›¸è¾ƒäº Huggingface çš„ FP16 å®ç°ï¼‰ï¼Œæ”¯æŒæ¡Œé¢å’Œç§»åŠ¨ GPUã€‚è¿™ä½¿å¾—è¾¹ç¼˜è®¾å¤‡ä¸Šçš„ LLM éƒ¨ç½²æˆä¸ºå¯èƒ½ï¼Œä»è€Œæ¨åŠ¨äº† LLM çš„æ™®åŠåŒ–ã€‚ æ–¹æ³•äº®ç‚¹ï¼šAWQ æå‡ºäº†ä¸€ç§é€šé“çº§ç¼©æ”¾çš„é‡åŒ–æ–¹æ³•ï¼Œå‡å°‘æ˜¾è‘—æƒé‡çš„é‡åŒ–æŸå¤±ï¼ŒåŒæ—¶é¿å…äº†å¯¹æ ¡å‡†é›†çš„è¿‡æ‹Ÿåˆã€‚ é€‚ç”¨æ€§ï¼šAWQ é€‚ç”¨äºå¤šç§ä»»åŠ¡å’Œæ¨¡å‹ç±»å‹ï¼ŒåŒ…æ‹¬è¯­è¨€å»ºæ¨¡ã€æŒ‡ä»¤è°ƒä¼˜æ¨¡å‹å’Œå¤šæ¨¡æ€æ¨¡å‹ã€‚ åŠ é€Ÿæ€§èƒ½ï¼šé€šè¿‡ TinyChat ç³»ç»Ÿï¼ŒAWQ åœ¨æ¡Œé¢å’Œç§»åŠ¨ GPU ä¸Šå®ç°äº† 3.2-3.3 å€çš„åŠ é€Ÿï¼Œæ˜¾è‘—æå‡äº†ä½èµ„æºè®¾å¤‡ä¸Š LLM éƒ¨ç½²çš„å¯è¡Œæ€§ã€‚","tags":["LLM","Quant","PTQ"],"categories":["LLM","Quant"]},{"title":"ã€è®ºæ–‡ç¬”è®°ã€‘Re-ranking","path":"/2024/09/26/MudSynth/ReID/ã€è®ºæ–‡ç¬”è®°ã€‘Re-ranking/","content":"æ–‡ç« åŸºæœ¬ä¿¡æ¯ æ–‡ç« åç§°ï¼šRe-ranking Person Re-identification with k-reciprocal Encoding å‘è¡¨ä¼šè®®/å¹´ä»½ï¼šCVPR 2017 ä½œè€…ï¼šZhun Zhong, Liang Zheng, Donglin Cao, Shaozi Li å•ä½ï¼šCognitive Science Department, Xiamen University, China / University of Technology Sydney / Fujian Key Laboratory of Brain-inspired Computing Technique and Applications, Xiamen University æ‘˜è¦ åœ¨å°†äººå‘˜é‡æ–°è¯†åˆ«ï¼ˆRe-IDï¼‰è§†ä¸ºæ£€ç´¢è¿‡ç¨‹æ—¶ï¼Œé‡æ’åæ˜¯æé«˜å…¶å‡†ç¡®æ€§çš„é‡è¦æ­¥éª¤ã€‚ç„¶è€Œï¼Œåœ¨Re-IDé¢†åŸŸï¼ŒæŠ•å…¥åˆ°é‡æ’åä¸Šçš„åŠªåŠ›æœ‰é™ï¼Œå°¤å…¶æ˜¯é‚£äº›å®Œå…¨è‡ªåŠ¨åŒ–çš„ã€æ— ç›‘ç£çš„è§£å†³æ–¹æ¡ˆã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§k-äº’æƒ ç¼–ç æ–¹æ³•æ¥é‡æ–°æ’åRe-IDçš„ç»“æœã€‚æˆ‘ä»¬çš„å‡è®¾æ˜¯ï¼Œå¦‚æœå›¾åº“å›¾åƒåœ¨k-äº’æƒ æœ€è¿‘é‚»ä¸­ä¸æ¢é’ˆå›¾åƒç›¸ä¼¼ï¼Œé‚£ä¹ˆå®ƒæ›´æœ‰å¯èƒ½æ˜¯çœŸæ­£çš„åŒ¹é…ã€‚å…·ä½“æ¥è¯´ï¼Œç»™å®šä¸€å¼ å›¾åƒï¼Œé€šè¿‡å°†å…¶k-äº’æƒ æœ€è¿‘é‚»ç¼–ç ä¸ºå•ä¸ªå‘é‡æ¥è®¡ç®—k-äº’æƒ ç‰¹å¾ï¼Œè¯¥å‘é‡ç”¨äºåŸºäºJaccardè·ç¦»çš„é‡æ–°æ’åã€‚æœ€ç»ˆè·ç¦»è®¡ç®—ä¸ºåŸå§‹è·ç¦»å’ŒJaccardè·ç¦»çš„ç»„åˆã€‚æˆ‘ä»¬çš„é‡æ’åæ–¹æ³•ä¸éœ€è¦ä»»ä½•äººå·¥å¹²é¢„æˆ–æ ‡è®°æ•°æ®ï¼Œå› æ­¤é€‚ç”¨äºå¤§è§„æ¨¡æ•°æ®é›†ã€‚åœ¨å¤§è§„æ¨¡Market-1501ã€CUHK03ã€MARSå’ŒPRWæ•°æ®é›†ä¸Šçš„å®éªŒç»“æœè¯å®äº†æˆ‘ä»¬æ–¹æ³•çš„æœ‰æ•ˆæ€§ã€‚ ä¹‹å‰å·¥ä½œå­˜åœ¨çš„é—®é¢˜ è¿‡å¾€çš„é‡æ’åæ–¹æ³•ä¾èµ–äºåˆå§‹æ’ååˆ—è¡¨çš„è´¨é‡ï¼Œé€šè¿‡åˆ©ç”¨åˆå§‹æ’ååˆ—è¡¨ä¸­é«˜æ’åå›¾åƒä¹‹é—´çš„ç›¸ä¼¼å…³ç³»è¿›è¡Œé‡æ’åã€‚ç„¶è€Œï¼Œè¿™äº›æ–¹æ³•å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š åˆå§‹æ’ååˆ—è¡¨ä¸­å¯èƒ½åŒ…å«é”™è¯¯åŒ¹é…ï¼Œè¿™äº›é”™è¯¯åŒ¹é…å¯èƒ½ä¼šè¢«è¯¯è®¤ä¸ºæ˜¯çœŸæ­£çš„åŒ¹é…ï¼Œä»è€Œå½±å“é‡æ’åçš„å‡†ç¡®æ€§ï¼› å³ä½¿çœŸæ­£çš„åŒ¹é…å­˜åœ¨ï¼Œå®ƒä»¬ä¹Ÿå¯èƒ½ä¸ä¼šå‡ºç°åœ¨åˆå§‹æ’ååˆ—è¡¨çš„å‰å‡ åï¼Œä»è€Œå¯¼è‡´é‡æ’åæ—¶çš„å™ªå£°å¢åŠ ï¼Œæœ€ç»ˆç»“æœè¢«ç ´åã€‚ æ¯”å¦‚å¦‚ä¸Šå›¾1æ‰€ç¤ºï¼Œåœ¨å›¾1ä¸­ï¼ŒP1ã€P2ã€P3å’ŒP4æ˜¯æ¢é’ˆçš„å››ä¸ªçœŸæ­£åŒ¹é…ï¼Œä½†å®ƒä»¬éƒ½ä¸åœ¨å‰å››åæ’åä¸­ã€‚æˆ‘ä»¬è§‚å¯Ÿåˆ°ä¸€äº›é”™è¯¯åŒ¹é…ï¼ˆN1-N6ï¼‰è·å¾—äº†é«˜æ’åã€‚å› æ­¤ï¼Œç›´æ¥ä½¿ç”¨å‰kåæ’åå›¾åƒå¯èƒ½ä¼šåœ¨é‡æ’åç³»ç»Ÿä¸­å¼•å…¥å™ªå£°ï¼Œå½±å“æœ€ç»ˆç»“æœã€‚ ä¸»è¦è´¡çŒ®/åˆ›æ–° æœ¬æ–‡ä»‹ç»äº†ä¸€ç§åŸºäºk-äº’æƒ è¿‘é‚»çš„é‡æ–°æ’åæ–¹æ³•ï¼Œç”¨äºæ”¹è¿›å›¾åƒé‡æ–°è¯†åˆ«ï¼ˆre-IDï¼‰ç³»ç»Ÿçš„æ€§èƒ½ã€‚é€šè¿‡å°†åŠ æƒçš„k-äº’æƒ é‚»å±…é›†ç¼–ç ä¸ºå‘é‡ï¼Œè®¡ç®—å›¾åƒä¹‹é—´çš„Jaccardè·ç¦»ï¼Œå¹¶ç»“åˆå±€éƒ¨æŸ¥è¯¢æ‰©å±•æ–¹æ³•ï¼Œæœ€ç»ˆå¾—åˆ°æ”¹è¿›çš„é‡æ–°æ’ååˆ—è¡¨ã€‚è¯¥æ–¹æ³•æ— éœ€äººå·¥äº¤äº’æˆ–æ ‡æ³¨æ•°æ®ï¼Œä¸”èƒ½è‡ªåŠ¨ä¸”æ— ç›‘ç£åœ°åº”ç”¨äºäººé‡æ–°è¯†åˆ«æ’åï¼Œæ˜¾è‘—æé«˜äº†å¤šä¸ªæ•°æ®é›†ä¸Šçš„é‡æ–°è¯†åˆ«æ€§èƒ½ã€‚ æœ¬æ–‡çš„è´¡çŒ®å¯ä»¥æ¦‚æ‹¬å¦‚ä¸‹ï¼š æˆ‘ä»¬æå‡ºäº†é€šè¿‡å°†k-äº’æƒ ç‰¹å¾ç¼–ç ä¸ºä¸€ä¸ªå‘é‡çš„k-äº’æƒ ç‰¹å¾ã€‚é‡æ–°æ’åè¿‡ç¨‹å¯ä»¥é€šè¿‡å‘é‡æ¯”è¾ƒè½»æ¾å®Œæˆã€‚ æˆ‘ä»¬çš„æ–¹æ³•ä¸éœ€è¦ä»»ä½•äººå·¥äº¤äº’æˆ–æ ‡æ³¨æ•°æ®ï¼Œå¯ä»¥è‡ªåŠ¨ä¸”æ— ç›‘ç£åœ°åº”ç”¨äºä»»ä½•äººé‡æ–°è¯†åˆ«æ’åç»“æœã€‚ æ‰€æå‡ºçš„æ–¹æ³•æœ‰æ•ˆæé«˜äº†å¤šä¸ªæ•°æ®é›†ä¸Šçš„äººé‡æ–°è¯†åˆ«æ€§èƒ½ï¼ŒåŒ…æ‹¬Market-1501ã€CUHK03ã€MARSå’ŒPRWã€‚ç‰¹åˆ«æ˜¯åœ¨Market-1501æ•°æ®é›†ä¸Šï¼Œæˆ‘ä»¬åœ¨rank-1å’ŒmAPä¸Šéƒ½è¾¾åˆ°äº†æœ€å…ˆè¿›çš„ç²¾åº¦ã€‚ æ–¹æ³• é—®é¢˜å®šä¹‰ ç»™å®šä¸€ä¸ªæ¢æµ‹è€…på’ŒåŒ…å«Nå¹…å›¾åƒçš„å›¾åº“é›†åˆG={giâˆ£i=1,2,â€¦,N}\\mathcal{G} = \\{ g_i \\mid i = 1, 2, \\ldots, N \\}G={giâ€‹âˆ£i=1,2,â€¦,N}ï¼Œä¸¤ä¸ªäººç‰©på’Œgig_igiâ€‹ä¹‹é—´çš„åŸå§‹è·ç¦»å¯ä»¥é€šè¿‡é©¬æ°è·ç¦»ï¼ˆMahalanobis distanceï¼‰æ¥æµ‹é‡ï¼š d(p,gi)=(xpâˆ’xgi)âŠ¤M(xpâˆ’xgi)d(p, g_i) = (x_p - x_{g_i})^\\top \\mathbf{M} (x_p - x_{g_i}) d(p,giâ€‹)=(xpâ€‹âˆ’xgiâ€‹â€‹)âŠ¤M(xpâ€‹âˆ’xgiâ€‹â€‹) å…¶ä¸­xpx_pxpâ€‹å’Œxgix_{g_i}xgiâ€‹â€‹åˆ†åˆ«æ˜¯äººç‰©på’Œgig_igiâ€‹çš„ç‰¹å¾å‘é‡ï¼ŒM\\mathbf{M}Mæ˜¯ä¸€ä¸ªæ­£å®šçŸ©é˜µã€‚ åˆå§‹æ’ååˆ—è¡¨ L(p,G)={g10,g20,â€¦,gN0}\\mathcal{L}(p, \\mathcal{G}) = \\{g_1^0, g_2^0, \\ldots, g_N^0\\}L(p,G)={g10â€‹,g20â€‹,â€¦,gN0â€‹} å¯ä»¥æ ¹æ®æ¢æµ‹è€… ppp å’Œå›¾åº“ gig_igiâ€‹ ä¹‹é—´çš„æˆå¯¹åŸå§‹è·ç¦»è·å¾—ï¼Œå…¶ä¸­ d(p,gi0)&lt;d(p,gi+10)d(p, g_i^0) &lt; d(p, g_{i+1}^0)d(p,gi0â€‹)&lt;d(p,gi+10â€‹)ã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯é‡æ–°æ’åº L(p,G)\\mathcal{L}(p, \\mathcal{G})L(p,G)ï¼Œä»¥ä½¿æ›´å¤šçš„æ­£æ ·æœ¬æ’åœ¨åˆ—è¡¨çš„é¡¶éƒ¨ï¼Œä»è€Œæé«˜äººç‰©é‡æ–°è¯†åˆ«ï¼ˆre-IDï¼‰çš„æ€§èƒ½ã€‚ K-reciprocal Nearest Neighbors æŒ‰ç…§(35)ï¼Œæˆ‘ä»¬å°† N(p,k)N(p, k)N(p,k) å®šä¹‰ä¸ºæ¢æµ‹è€… ppp çš„k-è¿‘é‚»ï¼ˆå³æ’ååˆ—è¡¨çš„å‰kä¸ªæ ·æœ¬ï¼‰ï¼š N(p,k)={g10,g20,â€¦,gk0},âˆ£N(p,k)âˆ£=kN(p, k) = \\{g_1^0, g_2^0, \\ldots, g_k^0\\}, \\quad |N(p, k)| = k N(p,k)={g10â€‹,g20â€‹,â€¦,gk0â€‹},âˆ£N(p,k)âˆ£=k å…¶ä¸­ âˆ£â‹…âˆ£|\\cdot|âˆ£â‹…âˆ£ è¡¨ç¤ºé›†åˆä¸­å€™é€‰é¡¹çš„æ•°é‡ã€‚k-äº’æƒ è¿‘é‚» R(p,k)\\mathcal{R}(p, k)R(p,k) å¯ä»¥å®šä¹‰ä¸ºï¼š R(p,k)={giâˆ£(giâˆˆN(p,k))âˆ§(pâˆˆN(gi,k))}\\mathcal{R}(p, k) = \\{ g_i \\mid (g_i \\in N(p, k)) \\land (p \\in N(g_i, k)) \\} R(p,k)={giâ€‹âˆ£(giâ€‹âˆˆN(p,k))âˆ§(pâˆˆN(giâ€‹,k))} æ ¹æ®ä¹‹å‰çš„æè¿°ï¼Œk-äº’æƒ è¿‘é‚»ä¸æ¢æµ‹è€… ppp çš„å…³ç³»æ¯”k-è¿‘é‚»æ›´å¯†åˆ‡ã€‚ç„¶è€Œï¼Œç”±äºå…‰ç…§ã€å§¿åŠ¿ã€è§†è§’å’Œé®æŒ¡çš„å˜åŒ–ï¼Œæ­£æ ·æœ¬å¯èƒ½è¢«æ’é™¤åœ¨k-è¿‘é‚»ä¹‹å¤–ï¼Œè¿›è€Œä¸åŒ…å«åœ¨k-äº’æƒ è¿‘é‚»ä¸­ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬é€šè¿‡é€æ­¥å°†R(p,k)\\mathcal{R}(p, k)R(p,k)ä¸­æ¯ä¸ªå€™é€‰é¡¹çš„ 12k\\frac{1}{2}k21â€‹k äº’æƒ è¿‘é‚»æ·»åŠ åˆ°ä¸€ä¸ªæ›´é²æ£’çš„é›†åˆ Râˆ—(p,k)\\mathcal{R}^*(p, k)Râˆ—(p,k) ä¸­æ¥æ”¹è¿›ï¼Œä¾æ®å¦‚ä¸‹æ¡ä»¶ï¼š Râˆ—(p,k)â†R(p,k)âˆªR(q,12k)\\mathcal{R}^*(p, k) \\leftarrow \\mathcal{R}(p, k) \\cup \\mathcal{R}(q, \\frac{1}{2}k) Râˆ—(p,k)â†R(p,k)âˆªR(q,21â€‹k) æ¡ä»¶æ˜¯ï¼š âˆ£R(p,k)âˆ©R(q,12k)âˆ£â‰¥23âˆ£R(q,12k)âˆ£,âˆ€qâˆˆR(p,k)|\\mathcal{R}(p, k) \\cap \\mathcal{R}(q, \\frac{1}{2}k)| \\geq \\frac{2}{3} |\\mathcal{R}(q, \\frac{1}{2}k)|, \\quad \\forall q \\in \\mathcal{R}(p, k) âˆ£R(p,k)âˆ©R(q,21â€‹k)âˆ£â‰¥32â€‹âˆ£R(q,21â€‹k)âˆ£,âˆ€qâˆˆR(p,k) qqqæ˜¯åŸæœ¬pçš„kè¿‘é‚» é€šè¿‡è¿™ç§æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥å°†æ›´å¤šä¸R(p,k)\\mathcal{R}(p, k)R(p,k) ä¸­å€™é€‰é¡¹æ›´ç›¸ä¼¼çš„æ­£æ ·æœ¬æ·»åŠ åˆ°Râˆ—(p,k)\\mathcal{R}^*(p, k)Râˆ—(p,k)ä¸­ï¼Œè€Œä¸æ˜¯ä¸æ¢æµ‹è€… ppp æ›´ç›¸ä¼¼çš„æ ·æœ¬ã€‚ä¸ï¼ˆ35ï¼‰ç›¸æ¯”ï¼Œè¿™åœ¨é˜²æ­¢åŒ…å«è¿‡å¤šè´Ÿæ ·æœ¬æ–¹é¢æ›´ä¸ºä¸¥æ ¼ã€‚ Jaccardè·ç¦» åœ¨æœ¬å°èŠ‚ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡æ¯”è¾ƒæ¢æµ‹è€… ppp å’Œå›¾åº“ gig_igiâ€‹ çš„k-äº’æƒ è¿‘é‚»é›†æ¥é‡æ–°è®¡ç®—å®ƒä»¬ä¹‹é—´çš„æˆå¯¹è·ç¦»ã€‚å¦‚ä¹‹å‰å·¥ä½œæ‰€è¿° (2) (46)ï¼Œæˆ‘ä»¬è®¤ä¸ºå¦‚æœä¸¤å¹…å›¾åƒç›¸ä¼¼ï¼Œå®ƒä»¬çš„k-äº’æƒ è¿‘é‚»é›†ä¼šæœ‰é‡å ï¼Œå³åœ¨é›†åˆä¸­å­˜åœ¨ä¸€äº›é‡å¤çš„æ ·æœ¬ã€‚é‡å¤æ ·æœ¬è¶Šå¤šï¼Œä¸¤å¹…å›¾åƒå°±è¶Šç›¸ä¼¼ã€‚æ¢æµ‹è€… ppp å’Œå›¾åº“ gig_igiâ€‹ ä¹‹é—´çš„æ–°è·ç¦»å¯ä»¥é€šè¿‡å®ƒä»¬çš„k-äº’æƒ é›†çš„Jaccardåº¦é‡æ¥è®¡ç®—ï¼Œå…¬å¼å¦‚ä¸‹ï¼š dJ(p.gi)=1âˆ’âˆ£Râˆ—(p,k)âˆ©Râˆ—(gi,k)âˆ£âˆ£Râˆ—(p,k)âˆªRâˆ—(gi,k)âˆ£d_J(p.g_i) = 1 - \\frac{|\\mathcal{R}^*(p,k)\\cap\\mathcal{R}^*(g_i,k)|}{|\\mathcal{R}^*(p,k)\\cup\\mathcal{R}^*(g_i,k)|} dJâ€‹(p.giâ€‹)=1âˆ’âˆ£Râˆ—(p,k)âˆªRâˆ—(giâ€‹,k)âˆ£âˆ£Râˆ—(p,k)âˆ©Râˆ—(giâ€‹,k)âˆ£â€‹ å…¶ä¸­ âˆ£â‹…âˆ£|\\cdot|âˆ£â‹…âˆ£ è¡¨ç¤ºé›†åˆä¸­å€™é€‰é¡¹çš„æ•°é‡ã€‚æˆ‘ä»¬é‡‡ç”¨Jaccardè·ç¦»æ¥å‘½åè¿™ä¸ªæ–°è·ç¦»ã€‚å°½ç®¡ä¸Šè¿°æ–¹æ³•èƒ½å¤Ÿæ•æ‰åˆ°ä¸¤å¹…å›¾åƒä¹‹é—´çš„ç›¸ä¼¼å…³ç³»ï¼Œä½†ä»å­˜åœ¨ä¸‰ä¸ªæ˜æ˜¾çš„ç¼ºç‚¹ï¼š è·å–ä¸¤ä¸ªé‚»å±…é›† Râˆ—(p,k)\\mathcal{R}^*(p, k)Râˆ—(p,k) å’Œ Râˆ—(gi,k)\\mathcal{R}^*(g_i, k)Râˆ—(giâ€‹,k) çš„äº¤é›†å’Œå¹¶é›†åœ¨å¾ˆå¤šæƒ…å†µä¸‹æ˜¯éå¸¸è€—æ—¶çš„ï¼Œå¹¶ä¸”å½“éœ€è¦è®¡ç®—æ‰€æœ‰å›¾åƒå¯¹çš„Jaccardè·ç¦»æ—¶ï¼Œè¿™å˜å¾—æ›´åŠ å…·æœ‰æŒ‘æˆ˜æ€§ã€‚ä¸€ä¸ªæ›¿ä»£æ–¹æ³•æ˜¯å°†é‚»å±…é›†ç¼–ç ä¸ºä¸€ä¸ªæ›´ç®€å•ä½†ç­‰æ•ˆçš„å‘é‡ï¼Œä»è€Œå¤§å¤§å‡å°‘è®¡ç®—å¤æ‚åº¦ï¼ŒåŒæ—¶ä¿æŒé‚»å±…é›†ä¸­çš„åŸå§‹ç»“æ„ã€‚ è¿™ç§è·ç¦»è®¡ç®—æ–¹æ³•å¯¹æ‰€æœ‰é‚»å±…èµ‹äºˆäº†ç›¸åŒçš„æƒé‡ï¼Œå¯¼è‡´é‚»å±…é›†ç®€å•ä½†ç¼ºä¹è¾¨åˆ«åŠ›ã€‚å®é™…ä¸Šï¼Œæ›´æ¥è¿‘æ¢æµ‹è€… ppp çš„é‚»å±…æ›´æœ‰å¯èƒ½æ˜¯çœŸæ­£çš„æ­£æ ·æœ¬ã€‚å› æ­¤ï¼Œé‡æ–°åŸºäºåŸå§‹è·ç¦»è®¡ç®—æƒé‡å¹¶ä¸ºæ›´è¿‘çš„æ ·æœ¬èµ‹äºˆè¾ƒå¤§çš„æƒé‡æ˜¯ä»¤äººä¿¡æœå’Œåˆç†çš„ã€‚ ä»…ä»…è€ƒè™‘ä¸Šä¸‹æ–‡ä¿¡æ¯åœ¨æµ‹é‡ä¸¤ä¸ªäººçš„ç›¸ä¼¼æ€§æ—¶ä¼šå¸¦æ¥ç›¸å½“å¤§çš„éšœç¢ï¼Œå› ä¸ºä¸å¯é¿å…çš„å˜åŒ–ä½¿å¾—éš¾ä»¥åŒºåˆ†è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚å› æ­¤ï¼Œå°†åŸå§‹è·ç¦»å’ŒJaccardè·ç¦»ç»“åˆèµ·æ¥å¯¹äºä¸€ä¸ªç¨³å¥çš„è·ç¦»æ˜¯å¾ˆé‡è¦çš„ã€‚ å—(2)çš„å¯å‘ï¼Œæå‡ºäº†k-äº’æƒ ç‰¹å¾æ¥è§£å†³å‰ä¸¤ä¸ªç¼ºç‚¹ï¼Œé€šè¿‡å°†k-äº’æƒ è¿‘é‚»é›†ç¼–ç ä¸ºå‘é‡ Vp=[Vp,g1,Vp,g2,â€¦,Vp,gN]\\mathbf{V}_p = [\\mathcal{V}_{p, g_1}, \\mathcal{V}_{p, g_2}, \\ldots, \\mathcal{V}_{p, g_N}]Vpâ€‹=[Vp,g1â€‹â€‹,Vp,g2â€‹â€‹,â€¦,Vp,gNâ€‹â€‹]ï¼Œå…¶ä¸­ Vp,gi\\mathcal{V}_{p, g_i}Vp,giâ€‹â€‹ æœ€åˆç”±ä¸€ä¸ªäºŒè¿›åˆ¶æŒ‡ç¤ºå‡½æ•°å®šä¹‰å¦‚ä¸‹ï¼š Vp,gi={1å¦‚æœÂ giâˆˆRâˆ—(p,k)0å¦åˆ™\\mathcal{V}_{p, g_i} = \\begin{cases} 1 &amp; \\text{å¦‚æœ } g_i \\in \\mathcal{R}^*(p, k) \\\\ 0 &amp; \\text{å¦åˆ™} \\end{cases} Vp,giâ€‹â€‹={10â€‹å¦‚æœÂ giâ€‹âˆˆRâˆ—(p,k)å¦åˆ™â€‹ é€šè¿‡è¿™ç§æ–¹å¼ï¼Œk-äº’æƒ é‚»å±…é›†å¯ä»¥è¡¨ç¤ºä¸ºä¸€ä¸ªNç»´å‘é‡ï¼Œå…¶ä¸­å‘é‡çš„æ¯ä¸ªé¡¹è¡¨ç¤ºå¯¹åº”çš„å›¾åƒæ˜¯å¦åŒ…å«åœ¨Râˆ—(p,k)\\mathcal{R}^*(p, k)Râˆ—(p,k)ä¸­ã€‚ç„¶è€Œï¼Œè¿™ä¸ªå‡½æ•°ä»ç„¶å°†æ¯ä¸ªé‚»å±…è§†ä¸ºç­‰åŒçš„ã€‚ç›´è§‚ä¸Šï¼Œç¦»æ¢æµ‹è€… ppp æ›´è¿‘çš„é‚»å±…åº”è¯¥ä¸æ¢æµ‹è€… ppp æ›´ç›¸ä¼¼ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æ ¹æ®æ¢æµ‹è€…ä¸å…¶é‚»å±…ä¹‹é—´çš„åŸå§‹è·ç¦»é‡æ–°åˆ†é…æƒé‡ï¼Œæˆ‘ä»¬é€šè¿‡æˆå¯¹è·ç¦»çš„é«˜æ–¯æ ¸é‡æ–°å®šä¹‰å…¬å¼å¦‚ä¸‹ï¼š Vp,gi={eâˆ’d(p,gi)å¦‚æœÂ giâˆˆRâˆ—(p,k)0å¦åˆ™\\mathcal{V}_{p, g_i} = \\begin{cases} e^{-d(p,g_i)} &amp; \\text{å¦‚æœ } g_i \\in \\mathcal{R}^*(p, k) \\\\ 0 &amp; \\text{å¦åˆ™} \\end{cases} Vp,giâ€‹â€‹={eâˆ’d(p,giâ€‹)0â€‹å¦‚æœÂ giâ€‹âˆˆRâˆ—(p,k)å¦åˆ™â€‹ é€šè¿‡è¿™ç§æ–¹å¼ï¼Œç¡¬æƒé‡ï¼ˆ0æˆ–1ï¼‰è¢«è½¬æ¢ä¸ºè½¯æƒé‡ï¼Œç¦»æ¢æµ‹è€…æ›´è¿‘çš„é‚»å±…è¢«åˆ†é…æ›´å¤§çš„æƒé‡ï¼Œè€Œæ›´è¿œçš„é‚»å±…åˆ™åˆ†é…è¾ƒå°çš„æƒé‡ã€‚åŸºäºä¸Šè¿°å®šä¹‰ï¼Œäº¤é›†å’Œå¹¶é›†ä¸­å€™é€‰é¡¹çš„æ•°é‡å¯ä»¥è®¡ç®—ä¸ºï¼š âˆ£Râˆ—(p,k)âˆ©Râˆ—(gi,k)âˆ£=âˆ¥minâ¡(Vp,Vgi)âˆ¥1 |\\mathcal{R}^*(p, k) \\cap \\mathcal{R}^*(g_i, k)| = \\|\\min(\\mathbf{V}_p, \\mathbf{V}_{g_i})\\|_1 âˆ£Râˆ—(p,k)âˆ©Râˆ—(giâ€‹,k)âˆ£=âˆ¥min(Vpâ€‹,Vgiâ€‹â€‹)âˆ¥1â€‹ âˆ£Râˆ—(p,k)âˆªRâˆ—(gi,k)âˆ£=âˆ¥maxâ¡(Vp,Vgi)âˆ¥1 |\\mathcal{R}^*(p, k) \\cup \\mathcal{R}^*(g_i, k)| = \\|\\max(\\mathbf{V}_p, \\mathbf{V}_{g_i})\\|_1 âˆ£Râˆ—(p,k)âˆªRâˆ—(giâ€‹,k)âˆ£=âˆ¥max(Vpâ€‹,Vgiâ€‹â€‹)âˆ¥1â€‹ å…¶ä¸­ï¼Œminâ¡\\minmin å’Œ maxâ¡\\maxmax æ“ä½œåŸºäºå…ƒç´ çš„æœ€å°åŒ–å’Œæœ€å¤§åŒ–ï¼Œâˆ¥â‹…âˆ¥1\\|\\cdot\\|_1âˆ¥â‹…âˆ¥1â€‹ æ˜¯ L1L_1L1â€‹ èŒƒæ•°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¬å¼5ä¸­çš„Jaccardè·ç¦»é‡æ–°å†™ä¸ºï¼š dJ(p,gi)=1âˆ’âˆ‘j=1Nminâ¡(Vp,gj,Vgi,gj)âˆ‘j=1Nmaxâ¡(Vp,gj,Vgi,gj)d_J(p, g_i) = 1 - \\frac{\\sum_{j=1}^{N} \\min(\\mathcal{V}_{p, g_j}, \\mathcal{V}_{g_i, g_j})}{\\sum_{j=1}^{N} \\max(\\mathcal{V}_{p, g_j}, \\mathcal{V}_{g_i, g_j})} dJâ€‹(p,giâ€‹)=1âˆ’âˆ‘j=1Nâ€‹max(Vp,gjâ€‹â€‹,Vgiâ€‹,gjâ€‹â€‹)âˆ‘j=1Nâ€‹min(Vp,gjâ€‹â€‹,Vgiâ€‹,gjâ€‹â€‹)â€‹ é€šè¿‡å°†å…¬å¼5è½¬æ¢ä¸ºå…¬å¼10ï¼Œæˆ‘ä»¬æˆåŠŸåœ°å°†é›†åˆæ¯”è¾ƒé—®é¢˜è½¬æ¢ä¸ºçº¯å‘é‡è®¡ç®—ï¼Œè¿™åœ¨å®é™…æ“ä½œä¸­è¦å®¹æ˜“å¾—å¤šã€‚ Local Query Expansion æ¨¡ä»¿åŒä¸€ç±»å›¾åƒå¯èƒ½å…±äº«ç›¸ä¼¼ç‰¹å¾çš„æƒ³æ³•ï¼Œæˆ‘ä»¬ä½¿ç”¨æ¢æµ‹è€… (p) çš„k-è¿‘é‚»æ¥å®ç°å±€éƒ¨æŸ¥è¯¢æ‰©å±•ã€‚å±€éƒ¨æŸ¥è¯¢æ‰©å±•å®šä¹‰ä¸ºï¼š Vp=1âˆ£N(p,k)âˆ£âˆ‘giâˆˆN(p,k)Vgi\\mathbf{V}_p = \\frac{1}{|N(p, k)|} \\sum_{g_i \\in N(p, k)} \\mathbf{V}_{g_i} Vpâ€‹=âˆ£N(p,k)âˆ£1â€‹giâ€‹âˆˆN(p,k)âˆ‘â€‹Vgiâ€‹â€‹ å› æ­¤ï¼Œk-äº’æƒ ç‰¹å¾ Vp\\mathbf{V}_pVpâ€‹ è¢«æ¢æµ‹è€… ppp çš„k-è¿‘é‚»æ‰©å±•ã€‚è¯·æ³¨æ„ï¼Œæˆ‘ä»¬åœ¨æ¢æµ‹è€… ppp å’Œå›¾åº“ gig_igiâ€‹ ä¸Šéƒ½å®ç°äº†æ­¤æŸ¥è¯¢æ‰©å±•ã€‚ç”±äºåœ¨k-è¿‘é‚»ä¸­ä¼šæœ‰å™ªå£°ï¼Œæˆ‘ä»¬å°†å±€éƒ¨æŸ¥è¯¢æ‰©å±•ä¸­ä½¿ç”¨çš„ N(p,k)N(p, k)N(p,k) çš„å¤§å°é™åˆ¶ä¸ºè¾ƒå°çš„å€¼ã€‚ä¸ºäº†åŒºåˆ†å…¬å¼7å’Œå…¬å¼11ä¸­ä½¿ç”¨çš„ Râˆ—(gi,k)\\mathcal{R}^*(g_i, k)Râˆ—(giâ€‹,k) å’Œ N(p,k)N(p, k)N(p,k) çš„å¤§å°ï¼Œæˆ‘ä»¬å°†å‰è€…è®°ä¸º k1k_1k1â€‹ï¼Œåè€…è®°ä¸º k2k_2k2â€‹ï¼Œå…¶ä¸­ k1&gt;k2k_1 &gt; k_2k1â€‹&gt;k2â€‹ã€‚ Final Distance åœ¨æœ¬å°èŠ‚ä¸­ï¼Œæˆ‘ä»¬å…³æ³¨å…¬å¼5çš„ç¬¬ä¸‰ä¸ªç¼ºç‚¹ã€‚è™½ç„¶å¤§å¤šæ•°ç°æœ‰çš„é‡æ–°æ’åæ–¹æ³•åœ¨é‡æ–°æ’åæ—¶å¿½ç•¥äº†åŸå§‹è·ç¦»çš„é‡è¦æ€§ï¼Œä½†æˆ‘ä»¬å°†åŸå§‹è·ç¦»å’ŒJaccardè·ç¦»è”åˆèµ·æ¥ï¼Œä¿®æ­£åˆå§‹æ’ååˆ—è¡¨ã€‚æœ€ç»ˆè·ç¦» dâˆ—d^*dâˆ— å®šä¹‰ä¸ºï¼š dâˆ—(p,gi)=(1âˆ’Î»)dJ(p,gi)+Î»d(p,gi)d^*(p, g_i) = (1 - \\lambda)d_J(p, g_i) + \\lambda d(p, g_i) dâˆ—(p,giâ€‹)=(1âˆ’Î»)dJâ€‹(p,giâ€‹)+Î»d(p,giâ€‹) å…¶ä¸­ Î»âˆˆ[0,1]\\lambda \\in [0, 1]Î»âˆˆ[0,1] è¡¨ç¤ºæƒ©ç½šå› å­ï¼Œå®ƒæƒ©ç½šç¦»æ¢æµ‹è€… ppp è¾ƒè¿œçš„å›¾åº“ã€‚å½“ Î»=0\\lambda = 0Î»=0 æ—¶ï¼Œåªè€ƒè™‘k-äº’æƒ è·ç¦»ã€‚ç›¸åï¼Œå½“ Î»=1\\lambda = 1Î»=1 æ—¶ï¼Œåªè€ƒè™‘åŸå§‹è·ç¦»ã€‚ç¬¬4èŠ‚è®¨è®ºäº† Î»\\lambdaÎ» çš„å½±å“ã€‚æœ€åï¼Œé€šè¿‡å¯¹æœ€ç»ˆè·ç¦»è¿›è¡Œå‡åºæ’åºï¼Œå¯ä»¥å¾—åˆ°ä¿®æ­£åçš„æ’ååˆ—è¡¨ Lâˆ—(p,G)\\mathcal{L}^*(p, \\mathcal{G})Lâˆ—(p,G)ã€‚ Complexity Analysis åœ¨æ‰€æå‡ºçš„æ–¹æ³•ä¸­ï¼Œå¤§éƒ¨åˆ†è®¡ç®—æˆæœ¬é›†ä¸­åœ¨æ‰€æœ‰å›¾åº“å¯¹çš„æˆå¯¹è·ç¦»è®¡ç®—ä¸Šã€‚å‡è®¾å›¾åº“é›†åˆçš„å¤§å°ä¸º NNNï¼Œè·ç¦»åº¦é‡å’Œæ’åè¿‡ç¨‹æ‰€éœ€çš„è®¡ç®—å¤æ‚åº¦åˆ†åˆ«æ˜¯ O(N2)O(N^2)O(N2) å’Œ O(N2logâ¡N)O(N^2 \\log N)O(N2logN)ã€‚ç„¶è€Œï¼Œåœ¨å®é™…åº”ç”¨ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç¦»çº¿é¢„å…ˆè®¡ç®—æˆå¯¹è·ç¦»å¹¶è·å–å›¾åº“çš„æ’ååˆ—è¡¨ã€‚å› æ­¤ï¼Œç»™å®šä¸€ä¸ªæ–°çš„æ¢æµ‹è€… pppï¼Œæˆ‘ä»¬åªéœ€è®¡ç®— ppp ä¸å›¾åº“ä¹‹é—´çš„æˆå¯¹è·ç¦»ï¼Œè®¡ç®—å¤æ‚åº¦ä¸º O(N)O(N)O(N)ï¼Œå¹¶å¯¹æ‰€æœ‰æœ€ç»ˆè·ç¦»è¿›è¡Œæ’åºï¼Œè®¡ç®—å¤æ‚åº¦ä¸º O(Nlogâ¡N)O(N \\log N)O(NlogN)ã€‚ å®éªŒç»“æœ ä¸»è¦å°†æ‰€ææ–¹æ³•åœ¨ä¸¤ä¸ªåŸºäºå›¾ç‰‡çš„æ•°æ®é›†ï¼Œä¸€ä¸ªåŸºäºè§†é¢‘çš„æ•°æ®é›†ä»¥åŠä¸€ä¸ªç«¯åˆ°ç«¯çš„æ•°æ®é›†ä¸Šè¿›è¡Œäº†å®éªŒï¼Œæ‰€ææ–¹æ³•ç›¸æ¯”åŸºçº¿ï¼Œæ•ˆæœå‡æœ‰æ˜æ˜¾çš„æå‡ã€‚ å‚æ•°åˆ†æ k1çš„å½±å“ éšç€k1k_1k1â€‹çš„ä¸Šå‡ï¼Œrank-1å‡†ç¡®ç‡å…ˆä¸Šå‡ï¼Œåœ¨k1=20k_1=20k1â€‹=20æ—¶è¾¾åˆ°æœ€é«˜ï¼Œç„¶åç¼“æ…¢ä¸‹é™ã€‚è¿™æ˜¯å› ä¸ºå¼€å§‹çš„æ—¶å€™kkkè¾ƒå°ï¼Œéšç€kkkè¶Šæ¥è¶Šå¤§ï¼Œk-äº’æƒ ç‰¹å¾ä¸­é”™è¯¯çš„é‚»å±…æ•°é‡é€æ¸å¢å¤šï¼Œå¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚ k2çš„å½±å“ k2k_2k2â€‹çš„å½±å“å¦‚ä¸Šå›¾æ‰€ç¤ºã€‚å½“k2k_2k2â€‹ç­‰äº1æ—¶ï¼Œä¸è€ƒè™‘æœ¬åœ°æŸ¥è¯¢æ‰©å±•ã€‚æ˜¾ç„¶ï¼Œéšç€k2k_2k2â€‹åœ¨åˆç†èŒƒå›´å†…å¢åŠ ï¼Œæ€§èƒ½ä¹Ÿä¼šæé«˜ã€‚è¯·æ³¨æ„ï¼Œä¸º k2k_2k2â€‹ åˆ†é…å¤ªå¤§çš„å€¼ä¼šé™ä½æ€§èƒ½ã€‚å› ä¸ºå®ƒå¯èƒ½ä¼šå¯¼è‡´æœ¬åœ°æŸ¥è¯¢æ‰©å±•ä¸­ä»¥æŒ‡æ•°æ–¹å¼åŒ…å«é”™è¯¯åŒ¹é…ï¼Œè¿™æ— ç–‘ä¼šæŸå®³è¯¥åŠŸèƒ½ï¼Œä»è€ŒæŸå®³æ€§èƒ½ã€‚äº‹å®ä¸Šï¼Œå½“ç»™k2k_2k2â€‹è®¾ç½®åˆé€‚çš„å€¼æ—¶ï¼Œæœ¬åœ°æŸ¥è¯¢æ‰©å±•å¯¹äºè¿›ä¸€æ­¥æå‡æ€§èƒ½æ˜¯éå¸¸æœ‰å¥½å¤„çš„ã€‚ Î»çš„å½±å“ å‚æ•° Î»\\lambdaÎ» çš„å½±å“å¦‚ä¸Šå›¾æ‰€ç¤ºã€‚æ³¨æ„ï¼Œå½“ Î»\\lambdaÎ» è®¾ç½®ä¸º 0 æ—¶ï¼Œæˆ‘ä»¬åªè€ƒè™‘ Jaccard è·ç¦»ä½œä¸ºæœ€ç»ˆè·ç¦»ï¼›ç›¸åï¼Œå½“ Î»\\lambdaÎ» ç­‰äº1æ—¶ï¼Œå¿½ç•¥äº†æ°å¡å¾·è·ç¦»ï¼Œå…¶ç»“æœæ­£æ˜¯ä½¿ç”¨çº¯åŸå§‹è·ç¦»å¾—åˆ°çš„åŸºçº¿ç»“æœã€‚å¯ä»¥çœ‹å‡ºï¼Œå½“ä»…è€ƒè™‘æ°å¡å¾·è·ç¦»æ—¶ï¼Œæˆ‘ä»¬çš„æ–¹æ³•å§‹ç»ˆä¼˜äºåŸºçº¿ã€‚è¿™è¡¨æ˜æ‰€æå‡ºçš„æ°å¡å¾·è·ç¦»å¯¹äºé‡æ–°æ’åºæ˜¯æœ‰æ•ˆçš„ã€‚æ­¤å¤–ï¼Œå½“åŒæ—¶è€ƒè™‘åŸå§‹è·ç¦»å’ŒJaccardè·ç¦»æ—¶ï¼Œå½“ Î»\\lambdaÎ» å€¼åœ¨0.3å·¦å³æ—¶ï¼Œæ€§èƒ½å¾—åˆ°è¿›ä¸€æ­¥æé«˜ï¼Œè¿™è¡¨æ˜åŸå§‹è·ç¦»å¯¹äºé‡æ–°æ’åºä¹Ÿå¾ˆé‡è¦ã€‚ æ€»ç»“ åœ¨è¿™ç¯‡è®ºæ–‡ä¸­ï¼Œæˆ‘ä»¬è§£å†³äº†è¡Œäººå†è¯†åˆ«ï¼ˆre-IDï¼‰ä¸­çš„é‡æ’åºé—®é¢˜ã€‚æˆ‘ä»¬æå‡ºäº†ä¸€ç§k-äº’æƒ ç‰¹å¾ï¼Œé€šè¿‡å°†k-äº’æƒ æœ€è¿‘é‚»å±…ç¼–ç æˆä¸€ä¸ªå•ä¸€å‘é‡ï¼Œä½¿å¾—é‡æ’åºè¿‡ç¨‹å¯ä»¥é€šè¿‡å‘é‡æ¯”è¾ƒè½»æ¾åœ°å®Œæˆã€‚ä¸ºäº†ä»ç›¸ä¼¼æ ·æœ¬ä¸­æ•æ‰ç›¸ä¼¼æ€§å…³ç³»ï¼Œæå‡ºäº†å±€éƒ¨æ‰©å±•æŸ¥è¯¢ä»¥è·å¾—æ›´ç¨³å¥çš„k-äº’æƒ ç‰¹å¾ã€‚åŸºäºåŸå§‹è·ç¦»å’ŒJaccardè·ç¦»çš„ç»„åˆè®¡ç®—çš„æœ€ç»ˆè·ç¦»åœ¨å¤šä¸ªå¤§è§„æ¨¡æ•°æ®é›†ä¸Šæœ‰æ•ˆåœ°æå‡äº†re-IDçš„æ€§èƒ½ã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼Œæˆ‘ä»¬çš„æ–¹æ³•æ˜¯å®Œå…¨è‡ªåŠ¨åŒ–ä¸”æ— ç›‘ç£çš„ï¼Œå¹¶ä¸”å¯ä»¥è½»æ¾åœ°åº”ç”¨äºä»»ä½•æ’åç»“æœã€‚","tags":["ReID","VI-ReID","CVPR","rerank","2017"],"categories":["ReID"]},{"title":"ã€è®ºæ–‡ç¬”è®°ã€‘IDKL","path":"/2024/09/26/MudSynth/ReID/ã€è®ºæ–‡ç¬”è®°ã€‘IDKL/","content":"æ–‡ç« åŸºæœ¬ä¿¡æ¯ æ–‡ç« åç§°ï¼šImplicit Discriminative Knowledge Learning for Visible-Infrared Person Re-Identification å‘è¡¨ä¼šè®®/å¹´ä»½ï¼šCVPR 2024 ä½œè€…ï¼šKaijie Ren, Lei Zhang å•ä½ï¼šSchool of Microelectronics and Communication Engineering, Chongqing University, China æ‘˜è¦ ç”±äºä¸åŒç›¸æœºä¹‹é—´çš„ç±»å†…å˜åŒ–å’Œè·¨æ¨¡æ€å·®å¼‚ï¼Œå¯è§çº¢å¤–äººå‘˜é‡æ–°è¯†åˆ« (VI-ReID) æ˜¯ä¸€é¡¹å…·æœ‰æŒ‘æˆ˜æ€§çš„ä»»åŠ¡è·¨æ¨¡æ€è¡Œäººæ£€ç´¢ä»»åŠ¡ã€‚ç°æœ‰çš„å·¥ä½œä¸»è¦é›†ä¸­åœ¨å°†ä¸åŒæ¨¡æ€çš„å›¾åƒåµŒå…¥åˆ°ä¸€ä¸ªç»Ÿä¸€çš„ç©ºé—´ä¸­ï¼ŒæŒ–æ˜æ¨¡æ€å…±äº«ç‰¹å¾ã€‚å®ƒä»¬åªåœ¨è¿™äº›å…±äº«ç‰¹å¾ä¸­å¯»æ‰¾ç‹¬ç‰¹çš„ä¿¡æ¯ï¼Œè€Œå¿½ç•¥äº†éšè—åœ¨æ¨¡æ€ç‰¹å®šç‰¹å¾ä¸­çš„èº«ä»½æ„ŸçŸ¥æœ‰ç”¨ä¿¡æ¯ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§æ–°é¢–çš„éšå¼åˆ¤åˆ«çŸ¥è¯†å­¦ä¹  (IDKL) ç½‘ç»œæ¥æ­ç¤ºå’Œåˆ©ç”¨æ¨¡æ€ç‰¹å®šä¸­åŒ…å«çš„éšå¼åˆ¤åˆ«ä¿¡æ¯ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ç§æ–°é¢–çš„åŒæµç½‘ç»œæå–ç‰¹å®šäºæ¨¡æ€å’Œæ¨¡æ€å…±äº«ç‰¹å¾ã€‚ç„¶åï¼Œç»è¿‡å‡€åŒ–ï¼Œåœ¨ä¿æŒèº«ä»½æ„ŸçŸ¥åˆ¤åˆ«çŸ¥è¯†çš„åŒæ—¶ï¼Œå‡å°‘å…¶æ¨¡æ€é£æ ¼å·®å¼‚ã€‚éšåï¼Œè¿™ç§éšæ€§çŸ¥è¯†è¢«æç‚¼æˆæ¨¡æ€å…±äº«ç‰¹å¾ä»¥å¢å¼ºå…¶ç‹¬ç‰¹æ€§ã€‚æœ€åï¼Œæå‡ºäº†ä¸€ç§å¯¹é½æŸå¤±æ¥æœ€å°åŒ–å¢å¼ºæ¨¡æ€å…±äº«ç‰¹å¾çš„æ¨¡æ€å·®å¼‚ã€‚åœ¨å¤šä¸ªå…¬å…±æ•°æ®é›†ä¸Šçš„å¹¿æ³›å®éªŒè¯æ˜äº† IDKL ç½‘ç»œä¼˜äºæœ€å…ˆè¿›çš„æ–¹æ³•ã€‚ä»£ç å¯åœ¨ https://github.com/1KK077/IDKL è·å¾—ã€‚ ä¹‹å‰å·¥ä½œå­˜åœ¨çš„é—®é¢˜ VI-ReIDä¸­çš„æ–¹æ³•å¯ä»¥è¢«åˆ†ä¸ºä¸¤ç±»ï¼š å­¦ä¹ æ¨¡æ€å…±äº«ç‰¹å¾ï¼ˆå°½ç®¡æ•ˆæœè¾ƒå¥½ï¼Œä½†æ˜¯æ— æ³•å¾ˆå¥½çš„å¼¥åˆä¸¤ä¸ªæ¨¡æ€ä¹‹é—´çš„æ¨¡æ€å·®è·ï¼‰ å¼•å…¥é¢å¤–çš„æ¨¡æ€ä¿¡æ¯æ¥å¼¥åˆæ¨¡æ€å·®è· å°½ç®¡ä»¥ä¸Šè¿™äº›æ¨¡å‹å–å¾—äº†å¾ˆå¥½çš„æ•ˆæœï¼Œä½†æ˜¯è¿™äº›æ¨¡å‹ä¸å¯é¿å…åœ°ä¸¢å¼ƒäº†ä¸€äº›ä¾èµ–äºç‰¹å®šæ¨¡æ€ç‰¹å¾çš„åˆ¤åˆ«ä¿¡æ¯ï¼Œè¿™äº›ä¿¡æ¯ä»¥å‰æ²¡æœ‰è¢«å……åˆ†åˆ©ç”¨å’Œåˆ©ç”¨ã€‚åŒæ—¶ä¼ ç»Ÿçš„VI-ReIDæ–¹æ³•æ¶‰åŠè’¸é¦ã€å¯¹é½å’Œç›¸äº’å­¦ä¹ é€šå¸¸ä¾èµ–äºlogitsã€‚ä½†æ˜¯ï¼Œåœ¨æµ‹è¯•é˜¶æ®µæ²¡æœ‰åˆ†ç±»å™¨å‚ä¸ï¼ŒåŒ¹é…ä»…åœ¨ç‰¹å¾çº§åˆ«æ‰§è¡Œã€‚å› æ­¤ï¼Œåœ¨ç‰¹å¾çº§åˆ«è¿›è¡Œåˆ¤åˆ«ä¿¡æ¯è’¸é¦ä¹Ÿæ˜¯å¿…ä¸å¯å°‘çš„ã€‚ ä¸»è¦è´¡çŒ®/åˆ›æ–° ä¸ºäº†è§£å†³ä¸Šè¿°é™åˆ¶ï¼Œåœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ä¸ªéšå¼åˆ¤åˆ«çŸ¥è¯†å­¦ä¹  (IDKL) æ¡†æ¶ï¼Œè¯¥æ¡†æ¶ä»ç‰¹å®šäºæ¨¡æ€çš„ç‰¹å¾ä¸­æ•è·éšå¼ä¸å˜ä¿¡æ¯ï¼Œå¹¶å°†å…¶æç‚¼æˆæ¨¡æ€å…±äº«ç‰¹å¾ä»¥å¢å¼ºå…¶åˆ¤åˆ«èƒ½åŠ›ã€‚æˆ‘ä»¬é¦–å…ˆåˆ†åˆ«ä½¿ç”¨æ¨¡æ€é‰´åˆ«å™¨å’Œæ¨¡æ€æ··æ·†å™¨æå–æ¨¡æ€ç‰¹å®šå’Œæ¨¡æ€å…±äº«ç‰¹å¾ã€‚æ¨¡æ€é‰´åˆ«å™¨æœ‰æ•ˆåœ°åŒºåˆ†äº†ä¸åŒçš„æ¨¡æ€ç‰¹å¾ï¼Œèµ‹äºˆå®ƒä»¬ç‰¹å®šçš„ç‰¹å¾ï¼›è€Œæ¨¡æ€æ··æ·†å™¨æ— æ³•åŒºåˆ†æ¨¡æ€ç‰¹å¾ï¼Œä»è€Œä¸ºå®ƒä»¬èµ‹äºˆå…±äº«ç‰¹å¾ã€‚ç”±äºå‰ä¸€é˜¶æ®µçš„æ¨¡æ€ç‰¹å®šç‰¹å¾åŒ…å«å¤§é‡æ¨¡æ€å·®å¼‚ï¼Œä¸é€‚åˆç›´æ¥è’¸é¦åˆ°å…±äº«ç‰¹å¾ä¸­ã€‚æˆ‘ä»¬æœ€åˆä½¿ç”¨å®ä¾‹å½’ä¸€åŒ–æ¥å‡å°‘åŸŸå·®å¼‚ã€‚ç„¶è€Œï¼Œé‡è¦çš„æ˜¯è¦æ‰¿è®¤ IN ä¸å¯é¿å…åœ°ä¼šå¯¼è‡´æŸäº›åˆ¤åˆ«ç‰¹å¾çš„æŸå¤±ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯åœ¨ä¿ç•™èº«ä»½æ„ŸçŸ¥åˆ¤åˆ«çŸ¥è¯†çš„åŒæ—¶å‡å°‘å…¶æ¨¡æ€é£æ ¼å·®å¼‚ã€‚éšåï¼Œæˆ‘ä»¬é€šè¿‡ç‰¹å¾å›¾ç»“æ„å°†è¿™ç§éšå¼çŸ¥è¯†æå–åˆ°ç‰¹å¾çº§åˆ«çš„é€šé“å…±äº«ç‰¹å¾ä¸­ï¼Œå¹¶é€šè¿‡ logit å‘é‡çš„è¯­ä¹‰çº§åˆ«ä»¥å¢å¼ºå…¶ç‹¬ç‰¹æ€§ã€‚æœ€åï¼Œæå‡ºäº†ä¸€ç§å¯¹é½æŸå¤±æ¥æœ€å°åŒ–å¢å¼ºæ¨¡æ€å…±äº«ç‰¹å¾çš„æ¨¡æ€å·®å¼‚ã€‚ ä¸»è¦è´¡çŒ®å¯ä»¥æ¦‚æ‹¬ä¸ºï¼š æˆ‘ä»¬æå‡ºäº†éšå¼åˆ¤åˆ«çŸ¥è¯†å­¦ä¹  (IDKL) ç½‘ç»œæ¥åˆ©ç”¨æ¨¡æ€ç‰¹å®šç‰¹å¾ä¸­éšå«çš„åˆ¤åˆ«çŸ¥è¯†æ¥å¢å¼ºæ¨¡æ€å…±äº«ç‰¹å¾çš„åˆ¤åˆ«èƒ½åŠ›çš„ä¸Šé™ã€‚ ä¸ºäº†å‡å°‘æ¨¡æ€é£æ ¼å·®å¼‚è€Œä¸ä¸¢å¤±æ¨¡æ€ç‰¹å®šä¿¡æ¯çš„åˆ¤åˆ«ä¿¡æ¯ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§ IN å¼•å¯¼çš„ä¿¡æ¯å‡€åŒ–å™¨ (IP)ï¼Œå®ƒç”±åˆ¤åˆ«å¢å¼ºæŸå¤±å’Œå·®å¼‚å‡å°‘æŸå¤±ç›‘ç£ã€‚ æå‡ºäº†ä¸€ç§æ–°çš„TGSAæŸå¤±ï¼Œå°†åˆ¤åˆ«æ¨¡æ€ç‰¹å®šä¿¡æ¯æç‚¼ä¸ºæ¨¡æ€å…±äº«ç‰¹å¾ï¼Œå……åˆ†ç¼“è§£æ¨¡æ€å…±äº«ç‰¹å¾çš„æ¨¡æ€é—´å·®å¼‚ã€‚å¤§é‡çš„å®éªŒç»“æœè¯æ˜äº†æˆ‘ä»¬æ–¹æ³•çš„ä¼˜è¶Šæ€§ã€‚ æ–¹æ³• æ•´ä½“æµç¨‹å›¾ ä¸Šå›¾å±•ç¤ºçš„IDKLæ•´ä½“æµç¨‹æ¡†æ¶ï¼Œç”±ResNetæ¨¡å—æ„å»ºçš„åŒä¸€æµç½‘ç»œé¦–å…ˆåœ¨æ¨¡æ€åˆ¤åˆ«å™¨å’Œæ¨¡æ€æ··æ·†å™¨çš„çº¦æŸä¸‹æå–æ¨¡æ€ç‰¹å®šç‰¹å¾ (FspF_{sp}Fspâ€‹) å’Œæ¨¡æ€å…±äº«ç‰¹å¾ (FshF_{sh}Fshâ€‹)ï¼ŒåŒæ—¶ä½¿ç”¨å¸¸è§„çš„ReIDæŸå¤±æ¥åŸºæœ¬ä¼˜åŒ–ç½‘ç»œã€‚ç„¶åï¼Œå°†æ¨¡æ€ç‰¹å®šç‰¹å¾è¾“å…¥ä¿¡æ¯å‡€åŒ–å™¨ä»¥è°ƒèŠ‚æ¨¡æ€æ ·å¼å·®å¼‚ï¼ŒåŒæ—¶ä¿ç•™éšå¼åˆ¤åˆ«ä¿¡æ¯å¹¶è·å¾—å‡€åŒ–çš„æ¨¡æ€ç‰¹å®šç‰¹å¾ (F~sp\\tilde{F}_{sp}F~spâ€‹)ã€‚éšåï¼Œè¿™äº›éšå¼çŸ¥è¯†é€šè¿‡Triplet Graph Structure Alignment(TGSAï¼Œåœ¨feature-level)å’ŒClass Semantic Alignment(CSAï¼Œåœ¨logit-level)è’¸é¦åˆ°æ¨¡æ€å…±äº«ç‰¹å¾ä¸­ã€‚æœ€åï¼Œæå‡ºäº† Lmdr\\mathcal{L}_{mdr}Lmdrâ€‹â€‹ ä»¥æœ€å°åŒ–å¢å¼ºæ¨¡æ€å…±äº«ç‰¹å¾å†…çš„æ¨¡æ€å·®å¼‚ã€‚ ç‰¹å¾æå– é¦–å…ˆå°†å¯è§å…‰å’Œçº¢å¤–å›¾ç‰‡åˆ†åˆ«è¡¨ç¤ºä¸ºï¼š V={xiV}i=1NVI={xiI}i=1NIV=\\{x_i^V\\}_{i=1}^{N_V}\\qquad I=\\{x_i^I\\}_{i=1}^{N_I} V={xiVâ€‹}i=1NVâ€‹â€‹I={xiIâ€‹}i=1NIâ€‹â€‹ å…¶ä¸­NV=NI=NN_V=N_I=NNVâ€‹=NIâ€‹=N,è¡¨ç¤ºä»ä¸€ä¸ªmini_batchä¸­é‡‡æ ·çš„çº¢å¤–å’Œå¯è§å…‰ç…§ç‰‡æ•°é‡N=PÃ—KN=P\\times KN=PÃ—Kï¼ˆPPPä»£è¡¨çš„æ˜¯äººç‰©IDæ•°é‡ï¼ŒKKKä»£è¡¨çš„æ˜¯æ¯ä¸ªIDæ‰€é€‰æ‹©çš„å›¾ç‰‡æ•°é‡ï¼‰,å› æ­¤ä¸€ä¸ªmini-batchä¸­ä¸€å…±åŒ…å«2N2N2Nå¼ ç…§ç‰‡ã€‚ ç„¶åæ‰€æœ‰çš„ç…§ç‰‡Xé¦–å…ˆä¼šé€å…¥åŒæµnetworkä¸­æ¥æå–æ¨¡æ€ç‹¬ç‰¹ç‰¹å¾FspF_{sp}Fspâ€‹ï¼ˆFsp,VF_{sp,V}Fsp,Vâ€‹å’ŒFsp,IF_{sp,I}Fsp,Iâ€‹ï¼‰å’ŒFshF_{sh}Fshâ€‹(Fsh,VF_{sh,V}Fsh,Vâ€‹å’ŒFsh,IF_{sh,I}Fsh,Iâ€‹),ä½¿ç”¨ä¸‹å¼è¡¨ç¤ºï¼š Fsp=Esp(xâˆ£Î˜,Î¨)Fsh=Esh(xâˆ£Î˜,Î¦)F_{sp} = E_{sp}(x | \\Theta, \\Psi)\\qquad F_{sh} = E_{sh}(x | \\Theta, \\Phi)\\qquad Fspâ€‹=Espâ€‹(xâˆ£Î˜,Î¨)Fshâ€‹=Eshâ€‹(xâˆ£Î˜,Î¦) æå–å™¨EEEæ˜¯ResNet50ï¼Œaverage poolingè¢«æ›¿æ¢ä¸ºGem poolingï¼ŒÎ˜\\ThetaÎ˜ä»£è¡¨çš„æ˜¯ResNet50å‰ä¸‰ä¸ªé˜¶æ®µçš„ç½‘ç»œå‚æ•°ï¼ŒÎ¨\\PsiÎ¨,Î¦\\PhiÎ¦ä»£è¡¨çš„æ˜¯ResNet50æœ€åä¸¤ä¸ªä¸ªé˜¶æ®µçš„ç½‘ç»œå‚æ•°ã€‚ æ¨¡æ€æ··æ·†å™¨å’Œé‰´åˆ«å™¨ æ¨¡æ€æ··æ·†å™¨ ä½¿ç”¨äº†ä¸€ç§åŸºäºæ¢¯åº¦åè½¬å±‚ï¼ˆGRLï¼‰çš„å¯¹æŠ—æ€§æ¨¡æ€åˆ†ç±»å™¨ä½œä¸ºâ€œæ¨¡æ€æ··æ·†å™¨â€ã€‚ LCj=âˆ’12Nâˆ‘i=12Ntiâ‹…logâ¡p(Cj(GRL(Fshi))),\\mathcal{L}_{C_j} = -\\frac{1}{2N} \\sum_{i=1}^{2N} t_i \\cdot \\log p \\left( C_j \\left( \\text{GRL} \\left( F_{sh}^i \\right) \\right) \\right), LCjâ€‹â€‹=âˆ’2N1â€‹i=1âˆ‘2Nâ€‹tiâ€‹â‹…logp(Cjâ€‹(GRL(Fshiâ€‹))), æ¨¡æ€é‰´åˆ«å™¨ ä¸ºäº†å……åˆ†å­¦ä¹ ä¸æ¨¡æ€ç›¸å…³çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬ä½¿ç”¨æ¨¡æ€åˆ†ç±»å™¨ä½œä¸ºæ¨¡æ€é‰´åˆ«å™¨ã€‚æ­¤ä¸ä½¿ç”¨ GRL çš„åˆ†ç±»å™¨åº”ç”¨äºç‰¹å®šåˆ†æ”¯ä»¥æå–ç‰¹å®šäºæ¨¡æ€çš„ç‰¹å¾ã€‚åˆ†ç±»æŸå¤±å…¬å¼å¦‚ä¸‹ï¼š LDj=âˆ’12Nâˆ‘i=12Ntiâ‹…logâ¡p(Dj(Fspi)),\\mathcal{L}_{D_j} = -\\frac{1}{2N} \\sum_{i=1}^{2N} t_i \\cdot \\log p \\left( D_j \\left( F_{sp}^i \\right) \\right), LDjâ€‹â€‹=âˆ’2N1â€‹i=1âˆ‘2Nâ€‹tiâ€‹â‹…logp(Djâ€‹(Fspiâ€‹)), ä¸¤ä¸ªæ¨¡å—çš„æ€»æŸå¤±å¯ä»¥è¡¨ç¤ºå¦‚ä¸‹ï¼š LC=âˆ‘j=1KLCj,LD=âˆ‘j=1KLDjL_C = \\sum_{j=1}^K L_{C_j},\\qquad L_D = \\sum_{j=1}^K L_{D_j} LCâ€‹=j=1âˆ‘Kâ€‹LCjâ€‹â€‹,LDâ€‹=j=1âˆ‘Kâ€‹LDjâ€‹â€‹ ä¸ºäº†æœ‰æ•ˆåœ°æå–ç‰¹å®šäºæ¨¡æ€å’Œæ¨¡æ€å…±äº«ç‰¹å¾ï¼Œæˆ‘ä»¬å°†è¿™äº›æ¨¡æ€åˆ†ç±»å™¨æŸå¤±ä¸æ ‡å‡† ReID æŸå¤± LreidL_{reid}Lreidâ€‹ ç›¸ç»“åˆï¼Œå…¶ä¸­åŒ…æ‹¬äº¤å‰ç†µå’Œç¡¬ä¸‰å…ƒç»„æŸå¤±ã€‚è¿™äº›åº”ç”¨äºç‰¹å®šäºæ¨¡æ€å’Œæ¨¡æ€å…±äº«åˆ†æ”¯ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š Lsp=Lreid(fsp)+LD,Lsh=Lreid(fsh)+LCL_{sp} = L_{reid}(f_{sp}) + L_D,\\qquad L_{sh} = L_{reid}(f_{sh}) + L_C Lspâ€‹=Lreidâ€‹(fspâ€‹)+LDâ€‹,Lshâ€‹=Lreidâ€‹(fshâ€‹)+LCâ€‹ å…¶ä¸­fâˆˆRBÃ—Cf\\in\\mathbb{R}^{B\\times C}fâˆˆRBÃ—Cä»£è¡¨çš„æ˜¯FâˆˆRBÃ—CÃ—HÃ—WF\\in\\mathbb{R}^{B\\times C\\times H\\times W}FâˆˆRBÃ—CÃ—HÃ—Wç»è¿‡poolingåçš„ç»“æœã€‚ æœ€ç»ˆæˆ‘ä»¬æ¨¡å‹çš„åŸºæœ¬æŸå¤±å¯ä»¥è¡¨ç¤ºä¸ºï¼š Lb=Lsh+LspL_b=L_{sh}+L_{sp} Lbâ€‹=Lshâ€‹+Lspâ€‹ ä¿¡æ¯å‡€åŒ–å™¨ï¼ˆInformation Purifierï¼ŒIPï¼‰ ä¿¡æ¯å‡€åŒ–å™¨ (IP) æ—¨åœ¨æœ€å°åŒ–é£æ ¼æ–¹å·®çš„å½±å“ï¼ŒåŒæ—¶ä¿ç•™ç‰¹å®šæ¨¡æ€ç‰¹å¾ä¸­çš„èº«ä»½æ„ŸçŸ¥å’Œåˆ¤åˆ«çŸ¥è¯†ã€‚IPé›†æˆäº†å®ä¾‹å½’ä¸€åŒ–(IN)ï¼Œä¼—æ‰€å‘¨çŸ¥ï¼Œå®ƒå¯ä»¥å‡å°‘åŸŸå·®å¼‚ã€‚ç„¶è€Œï¼Œé‡è¦çš„æ˜¯è¦è®¤è¯†åˆ° IN ä¸å¯é¿å…åœ°å¯¼è‡´ä¸€äº›åˆ¤åˆ«ç‰¹å¾çš„æŸå¤±ï¼Œè¿™å¯èƒ½ä¼šé˜»ç¢ ReID çš„é«˜æ€§èƒ½ã€‚ é¦–å…ˆå¯¹FspF_{sp}Fspâ€‹ä½¿ç”¨INå¾—åˆ°F^sp\\hat{F}_{sp}F^spâ€‹: F^sp=IN(Fsp)=Fspâˆ’E[Fsp]Var[Fsp]+Ïµ\\hat{F}_{sp} = IN(F_{sp}) = \\frac{F_{sp} - E[F_{sp}]}{\\sqrt{Var[F_{sp}]} + \\epsilon} F^spâ€‹=IN(Fspâ€‹)=Var[Fspâ€‹]â€‹+ÏµFspâ€‹âˆ’E[Fspâ€‹]â€‹ ç„¶ååŒSENetçš„æ–¹æ³•ä¸€æ ·ï¼Œæˆ‘ä»¬ç”Ÿæˆäº†ä¸¤ä¸ªchannel-wiseçš„masks mem_emeâ€‹å’Œmrm_rmrâ€‹: me=Ïƒ(W2Î´(W1g(Fsp))),mr=Ïƒ(W4Î´(W3g(F^sp))),\\mathbf{m}_e = \\sigma \\left( \\mathbf{W}_2 \\delta \\left( \\mathbf{W}_1 g \\left( \\mathbf{F}_{sp} \\right) \\right) \\right), \\quad \\mathbf{m}_r = \\sigma \\left( \\mathbf{W}_4 \\delta \\left( \\mathbf{W}_3 g \\left( \\hat{\\mathbf{F}}_{sp} \\right) \\right) \\right), meâ€‹=Ïƒ(W2â€‹Î´(W1â€‹g(Fspâ€‹))),mrâ€‹=Ïƒ(W4â€‹Î´(W3â€‹g(F^spâ€‹))), ä»–ä»¬çš„ä½œç”¨åˆ†åˆ«æ˜¯ï¼Œmem_emeâ€‹ä»£è¡¨çš„æ˜¯å¢å¼ºåˆ¤åˆ«ç‰¹å¾ï¼Œmrm_rmrâ€‹ä»£è¡¨çš„æ˜¯å‡å°‘attention maskçš„å·®å¼‚ï¼ˆreduction of discrepancies attention maskï¼‰ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¾—åˆ°æ›´å¼ºçš„ç‰¹æ®Šç‰¹å¾Fspd+F_{sp}^{d+}Fspd+â€‹,ä»¥åŠæ›´å°çš„æ¨¡æ€å·®å¼‚ç‰¹å¾F^spmâˆ’\\hat{F}_{sp}^{m-}F^spmâˆ’â€‹(è®¡ç®—å¦‚ä¸Šå›¾æ‰€ç¤º) éšåï¼Œæˆ‘ä»¬è®¡ç®—åˆ¤åˆ«å¢å¼ºæŸå¤±ï¼ˆdiscrimination enhancing lossï¼‰LeL_eLeâ€‹å’Œå·®å¼‚å‡å°‘æŸå¤±ï¼ˆdiscrimination enhancing lossï¼‰LrL_rLrâ€‹åˆ†åˆ«ç”¨äºç›‘ç£mem_emeâ€‹ä¸mrm_rmrâ€‹çš„ç”Ÿæˆï¼š Le=Softplus(h(Csp(fspd+))âˆ’h(Csp(fsp)))\\mathcal{L}_e = \\text{Softplus} \\left( h \\left( C_{sp} \\left( f_{sp}^{d+} \\right) \\right) - h \\left( C_{sp} \\left( f_{sp} \\right) \\right) \\right) Leâ€‹=Softplus(h(Cspâ€‹(fspd+â€‹))âˆ’h(Cspâ€‹(fspâ€‹))) Lr=Softplus(d(f^sp,Vmâˆ’,f^sp,Imâˆ’)âˆ’d(f^sp,V,f^sp,I))\\mathcal{L}_r = \\text{Softplus} \\left( d \\left( \\hat{f}_{sp,V}^{m^-}, \\hat{f}_{sp,I}^{m^-} \\right) - d \\left( \\hat{f}_{sp,V}, \\hat{f}_{sp,I} \\right) \\right) Lrâ€‹=Softplus(d(f^â€‹sp,Vmâˆ’â€‹,f^â€‹sp,Imâˆ’â€‹)âˆ’d(f^â€‹sp,Vâ€‹,f^â€‹sp,Iâ€‹)) è¿™é‡ŒLeL_eLeâ€‹å¸Œæœ›èƒ½å¤Ÿç”Ÿæˆæ¯”FspF_{sp}Fspâ€‹æ›´å…·æœ‰åŒºåˆ«æ€§ç‰¹å¾çš„Fspd+F_{sp}^{d+}Fspd+â€‹,LrL_rLrâ€‹åˆ™å¸Œæœ›ç”Ÿæˆçš„F^spmâˆ’\\hat{F}_{sp}^{m-}F^spmâˆ’â€‹ç›¸æ¯”F^sp\\hat{F}_{sp}F^spâ€‹æœ‰æ›´å°çš„æ¨¡æ€å·®å¼‚ã€‚ Softplus(â‹…)=ln(1+expâ¡(â‹…))\\text{Softplus}(\\cdot) = \\text{ln}(1+\\exp(\\cdot))Softplus(â‹…)=ln(1+exp(â‹…))ï¼Œæ—¨åœ¨æ˜¯æŸå¤±å‡½æ•°éƒ½é™åˆ¶ä¸ºæ­£æ•° æœ€åå°†ä»–ä»¬ç»“åˆèµ·æ¥å°±å¯ä»¥å¾—åˆ°purified modality-specific feature: F~sp=meâŠ™F^spmâˆ’+mrâŠ™Fspd+.\\tilde{F}_{sp} = \\mathbf{m}_e \\odot \\hat{F}_{sp}^{m^-} + \\mathbf{m}_r \\odot F_{sp}^{d^+}. F~spâ€‹=meâ€‹âŠ™F^spmâˆ’â€‹+mrâ€‹âŠ™Fspd+â€‹. æœ€åè¿™ä¸€æ¨¡å—çš„æŸå¤±å‡½æ•°å¯ä»¥è¡¨ç¤ºä¸ºå¦‚ä¸‹å½¢å¼ï¼š Lip=Le+Lr+Lreid(f~sp)L_{ip} = L_e + L_r + L_{reid}(\\tilde{f}_{sp}) Lipâ€‹=Leâ€‹+Lrâ€‹+Lreidâ€‹(f~â€‹spâ€‹) éšå¼çŸ¥è¯†è’¸é¦ï¼ˆIKDï¼‰ ä¸ºäº†ç¡®ä¿æ¨¡æ€å…±äº«ç‰¹å¾å…¨é¢å­¦ä¹ å’Œé›†æˆéšå¼ä¿¡æ¯ï¼Œæˆ‘ä»¬é€šè¿‡ TGSA ä» feature çº§åˆ«ä»¥åŠCSA ä» logit çº§åˆ«æ‰§è¡Œè’¸é¦ã€‚ Triplet Graph Structure Alignment (TGSA) ä¸ºäº†èµ‹äºˆå…±äº«ç‰¹å¾ä»¥åŒºåˆ†æ€§ä¿¡æ¯å¹¶åœ¨ç‰¹å¾å±‚é¢å‡å°‘æ¨¡æ€å·®å¼‚ï¼Œæˆ‘ä»¬å¼€å‘äº†ä¸€ç§ä¸‰å…ƒç‰¹å¾å›¾ç»“æ„å¯¹é½æŸå¤±ã€‚è¿™ç§æ–¹æ³•çš„åŠ¨æœºæºäºç‰¹å¾å›¾ç»“æ„åŒ…å«ä¸°å¯Œçš„å…³äºç‰¹å¾ä¹‹é—´å…³ç³»å’Œåˆ†å¸ƒçš„ä¿¡æ¯ï¼Œä¾‹å¦‚ç±»é—´åŒºåˆ†æ€§å’Œç±»å†…å¤šæ ·æ€§ã€‚è¿™äº›ç‰¹æ€§è¢«ç”¨æ¥æŒ–æ˜æ½œåœ¨çš„ç‰¹å¾å…³ç³»å¹¶åœ¨[17, 36]ä¸­å¢å¼ºç‰¹å¾è¡¨ç¤ºã€‚è¡¨ç¤ºç‰¹å¾ä¹‹é—´å…³ç³»çš„å›¾ç»“æ„äº²å’ŒçŸ©é˜µè®¡ç®—å¦‚ä¸‹ï¼š Î±ij=expâ¡(L([l(fi)âˆ¥l(fj)]â‹…w))âˆ‘kâˆˆNiexpâ¡(L([l(fi)âˆ¥l(fk)]â‹…w)),\\alpha_{ij} = \\frac{\\exp \\left( L \\left( \\left[ l \\left( f_i \\right) \\parallel l \\left( f_j \\right) \\right] \\cdot w \\right) \\right)}{\\sum_{k \\in \\mathcal{N}_i} \\exp \\left( L \\left( \\left[ l \\left( f_i \\right) \\parallel l \\left( f_k \\right) \\right] \\cdot w \\right) \\right)}, Î±ijâ€‹=âˆ‘kâˆˆNiâ€‹â€‹exp(L([l(fiâ€‹)âˆ¥l(fkâ€‹)]â‹…w))exp(L([l(fiâ€‹)âˆ¥l(fjâ€‹)]â‹…w))â€‹, å…¶ä¸­Lä»£è¡¨çš„æ˜¯LeakyReLUï¼Œ[â‹…âˆ£âˆ£â‹…][\\cdot||\\cdot][â‹…âˆ£âˆ£â‹…]ä»£è¡¨çš„æ˜¯æ‹¼æ¥æ“ä½œï¼ŒNi\\mathcal{N}_iNiâ€‹è¡¨ç¤ºç”¨äºä¸ºç¬¬ i ä¸ªæ ·æœ¬å½’ä¸€åŒ–çš„é‚»å±…æ ·æœ¬ã€‚l(â‹…)l(\\cdot)l(â‹…)æ˜¯ç‰¹å¾ç»´åº¦è½¬åŒ–å±‚ï¼Œwwwæ˜¯å…¨è¿æ¥å±‚ã€‚ ç”±äºæˆ‘ä»¬åˆ©ç”¨å›¾ç»“æ„æ¥å¯¹é½å’Œæå–çŸ¥è¯†ï¼Œè€Œä¸æ˜¯å¢å¼ºç‰¹å¾ï¼Œå¹¶ä¸”æ¬§æ°ç©ºé—´åˆ†å¸ƒå¯¹ç‰¹å¾æ›´å…·æ„ä¹‰ï¼Œå› æ­¤æˆ‘ä»¬ç”¨æ¬§æ°è·ç¦»ä»£æ›¿çº¿æ€§å˜æ¢æ¥è®¡ç®—æ³¨æ„åŠ›åˆ†æ•°ï¼Œå¹¶é‡æ–°å®šä¹‰ä¸¤ç»„ç‰¹å¾çš„å›¾ç»“æ„è¡¨è¾¾å¦‚ä¸‹ï¼š A(a;b)={Î±ij}i,jâˆˆN=expâ¡(D(fai,fbj))âˆ‘kâˆˆNexpâ¡(D(fai,fbk)),\\mathbf{A}_{(a;b)} = \\left\\{ \\alpha_{ij} \\right\\}_{i,j \\in \\mathcal{N}} = \\frac{\\exp \\left( D \\left( f_a^i, f_b^j \\right) \\right)}{\\sum_{k \\in \\mathcal{N}} \\exp \\left( D \\left( f_a^i, f_b^k \\right) \\right)}, A(a;b)â€‹={Î±ijâ€‹}i,jâˆˆNâ€‹=âˆ‘kâˆˆNâ€‹exp(D(faiâ€‹,fbkâ€‹))exp(D(faiâ€‹,fbjâ€‹))â€‹, å…·ä½“è€Œè¨€ï¼Œä¸‰å…ƒç»„å›¾ç»“æ„å¯¹é½æŸå¤±Ltgsa\\mathcal{L}_{\\text{tgsa}}Ltgsaâ€‹ æ˜¯ä¸“ä¸ºè·¨æ¨¡æ€é‡è¯†åˆ«ï¼ˆReIDï¼‰å¼€å‘çš„ï¼Œç”¨äºå¯¹é½ä¸¤ç§ä¸åŒçš„æ¨¡æ€ç±»å‹ï¼Œä½¿å®ƒä»¬èƒ½å¤Ÿç¬¦åˆç›¸åŒçš„å›¾ç»“æ„åˆ†å¸ƒå¹¶å‡å°‘æ¨¡æ€å·®å¼‚ã€‚è¯¥æŸå¤±åŒ…å«ä¸¤ä¸ªè‡ªæ¨¡æ€äº²å’ŒçŸ©é˜µå’Œä¸€ä¸ªè·¨æ¨¡æ€äº²å’ŒçŸ©é˜µï¼Œåè€…ç¡®ä¿äº†å›¾ç»“æ„åˆ†å¸ƒçš„æ•´ä½“ä¸€è‡´æ€§ï¼Œå¦‚å›¾3æ‰€ç¤ºã€‚é€šè¿‡ä½¿ç”¨Kullback-Leiblerï¼ˆKLï¼‰æ•£åº¦ï¼Œè¿™ä¸‰ä¸ªçŸ©é˜µæˆå¯¹å¯¹é½ã€‚å› æ­¤ï¼Œä¸¤ç§ä¸åŒæ¨¡æ€ç±»å‹çš„å¯¹é½æŸå¤± ( Ltgsa\\mathcal{L}_{\\text{tgsa}}Ltgsaâ€‹ ) å®šä¹‰ä¸ºï¼š Ltgsa(a;b)=âˆ‘p=1Pâˆ‘k=1K(KL(A(a;a)pk,A(b;b)pk)+KL(A(a;a)pk,A(a;b)pk)+KL(A(a;b)pk,A(b;b)pk)).\\mathcal{L}_{\\text{tgsa}}^{(a;b)} = \\sum_{p=1}^{P} \\sum_{k=1}^{K} \\left( \\text{KL} \\left( A_{(a;a)}^{pk}, A_{(b;b)}^{pk} \\right) + \\text{KL} \\left( A_{(a;a)}^{pk}, A_{(a;b)}^{pk} \\right) + \\text{KL} \\left( A_{(a;b)}^{pk}, A_{(b;b)}^{pk} \\right) \\right). Ltgsa(a;b)â€‹=p=1âˆ‘Pâ€‹k=1âˆ‘Kâ€‹(KL(A(a;a)pkâ€‹,A(b;b)pkâ€‹)+KL(A(a;a)pkâ€‹,A(a;b)pkâ€‹)+KL(A(a;b)pkâ€‹,A(b;b)pkâ€‹)). å…¶ä¸­ApkA^{p_k}Apkâ€‹ä»£è¡¨çš„å«ä¹‰æ˜¯ç¬¬pä¸ªäººçš„ç¬¬kä¸ªæ ·æœ¬çš„å›¾åˆ†å¸ƒã€‚ ä¸ºäº†å°†åˆ¤åˆ«éšå¼æ¨¡å¼ç‰¹å®šçŸ¥è¯†ä¼ è¾¾ä¸ºç‰¹å¾çº§å…±äº«ç‰¹å¾ï¼Œé€šè¿‡TGSAåœ¨åŒè´¨ç‰¹å¾ä¸Šçš„ä¸¤ä¸ªåˆ†æ”¯ä¸Šçš„è’¸é¦æŸå¤±å¯ä»¥è¡¨ç¤ºä¸ºï¼š Ltgsa(a;b)=âˆ‘p=1Pâˆ‘k=1K(KL(A(a;a)pk,A(b;b)pk)+KL(A(a;a)pk,A(a;b)pk)+KL(A(a;b)pk,A(b;b)pk)).\\mathcal{L}_{\\text{tgsa}}^{(a;b)} = \\sum_{p=1}^{P} \\sum_{k=1}^{K} \\left( \\text{KL} \\left( A_{(a;a)}^{pk}, A_{(b;b)}^{pk} \\right) + \\text{KL} \\left( A_{(a;a)}^{pk}, A_{(a;b)}^{pk} \\right) + \\text{KL} \\left( A_{(a;b)}^{pk}, A_{(b;b)}^{pk} \\right) \\right). Ltgsa(a;b)â€‹=p=1âˆ‘Pâ€‹k=1âˆ‘Kâ€‹(KL(A(a;a)pkâ€‹,A(b;b)pkâ€‹)+KL(A(a;a)pkâ€‹,A(a;b)pkâ€‹)+KL(A(a;b)pkâ€‹,A(b;b)pkâ€‹)). Class Semantic Alignment(CSA) CSAç”¨äºå°†éšå¼æ¨¡æ€ç‰¹å®šçŸ¥è¯†çš„è¯­ä¹‰ä¿¡æ¯æå–åˆ°æ¨¡æ€å…±äº«åˆ†æ”¯ä¸­ï¼Œä»¥å¢å¼ºå…±äº«ç‰¹å¾çš„ç‰¹å¾è¡¨ç¤ºã€‚CSA åœ¨ logit çº§åˆ«å¯¹ä¸¤ä¸ªåˆ†æ”¯ä¹‹é—´çš„åŒè´¨ç‰¹å¾è¿›è¡Œæ“ä½œã€‚åˆ†ç±»å™¨èƒŒåçš„ logit çŸ©é˜µå¯ä»¥è¡¨è¿°ä¸ºï¼š Zsp=Csp(fsp),Zsh=Csh(fsh),\\mathbf{Z}_{sp} = C_{sp} \\left( \\mathbf{f}_{sp} \\right), \\quad \\mathbf{Z}_{sh} = C_{sh} \\left( \\mathbf{f}_{sh} \\right), Zspâ€‹=Cspâ€‹(fspâ€‹),Zshâ€‹=Cshâ€‹(fshâ€‹), CSAæŸå¤±å’Œä¹‹å‰çš„TGSAæŸå¤±éå¸¸çš„ç›¸ä¼¼ï¼Œå¯ä»¥è¡¨ç¤ºä¸ºä¸‹å¼ï¼š Lcsa=âˆ‘i=1N(KL(Zsh,Vi,Zsp,Vi)+KL(Zsh,Ii,Zsp,Ii)).\\mathcal{L}_{\\text{csa}} = \\sum_{i=1}^{N} \\left( \\text{KL} \\left( \\mathbf{Z}_{sh,V}^i, \\mathbf{Z}_{sp,V}^i \\right) + \\text{KL} \\left( \\mathbf{Z}_{sh,I}^i, \\mathbf{Z}_{sp,I}^i \\right) \\right). Lcsaâ€‹=i=1âˆ‘Nâ€‹(KL(Zsh,Viâ€‹,Zsp,Viâ€‹)+KL(Zsh,Iiâ€‹,Zsp,Iiâ€‹)). æ¨¡æ€å·®å¼‚å‡å°‘æŸå¤±ï¼ˆMDRï¼‰ Modality Discrepancy Reduction (MDR)çš„ç›®æ ‡æ˜¯ä¸ºäº†ä¿è¯æ¨¡æ€å…±äº«ç‰¹å¾çš„ä¸å˜è¡¨ç¤ºï¼Œè¿›ä¸€æ­¥åˆ©ç”¨TGSAå’ŒCSAæ¥å‡å°‘æ¨¡æ€å…±äº«åˆ†æ”¯å†…çš„æ¨¡æ€å·®å¼‚ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š Lmdr=Ltgsa(sh,V;sh,I)+âˆ‘i=1NKL(Zsh,Vi,Zsh,Ii).\\mathcal{L}_{\\text{mdr}} = \\mathcal{L}_{\\text{tgsa}}^{(sh,V;sh,I)} + \\sum_{i=1}^{N} \\text{KL} \\left( \\mathbf{Z}_{sh,V}^i, \\mathbf{Z}_{sh,I}^i \\right). Lmdrâ€‹=Ltgsa(sh,V;sh,I)â€‹+i=1âˆ‘Nâ€‹KL(Zsh,Viâ€‹,Zsh,Iiâ€‹). è¿™æ ·ï¼Œæ¨¡æ€å…±äº«åˆ†æ”¯çš„å¯è§ç‰¹å¾å’Œçº¢å¤–ç‰¹å¾å¯ä»¥ä»ç‰¹å¾çº§å’Œè¯­ä¹‰çº§å®ç°ç›¸äº’å­¦ä¹ ã€‚å®ƒä½¿ä¸¤ç§æ¨¡æ€ç‰¹å¾ç›¸äº’å¯¹é½ï¼ŒåŒæ—¶å‡è½»æ¨¡æ€å·®è·å¹¶ä¿æŒæ¨¡æ€å…±äº«ç‰¹å¾çš„ä¸å˜æ€§ã€‚ ç»¼ä¸Šï¼Œä¸€å…±åˆ†åˆ«å¯¹é½äº†ï¼š çº¢å¤–æ¨¡æ€shå’Œspï¼ˆlogit+featureï¼‰ å¯è§å…‰æ¨¡æ€shå’Œspï¼ˆlogit+featureï¼‰ åŒæ¨¡æ€çš„shï¼ˆlogit+featureï¼‰ ä¼˜åŒ– æœ€ç»ˆï¼Œé€šè¿‡ä»ç‰¹å®šäºæ¨¡æ€çš„ç‰¹å¾ä¸­è¿ç»­æå–éšå¼åˆ¤åˆ«çŸ¥è¯†ï¼Œå¹¶å§‹ç»ˆå‡å°‘æ¨¡æ€å…±äº«ç‰¹å¾ä¸­çš„æ¨¡æ€å·®å¼‚ï¼Œæˆ‘ä»¬å¯ä»¥è·å¾—æ›´å…·è¾¨åˆ«åŠ›å’Œä¸å˜çš„æ¨¡æ€å…±äº«ç‰¹å¾ã€‚ IDKLçš„æœ€ç»ˆä¼˜åŒ–å‡½æ•°å¯ä»¥è¢«è¡¨ç¤ºä¸ºå¦‚ä¸‹æ‰€ç¤ºï¼š Ltotal=Lb+Î»1Lip+Î»2Ltgsa+Î»3Lcsa+Lmdr,\\mathcal{L}_{\\text{total}} = \\mathcal{L}_b + \\lambda_1 \\mathcal{L}_{ip} + \\lambda_2 \\mathcal{L}_{\\text{tgsa}} + \\lambda_3 \\mathcal{L}_{\\text{csa}} + \\mathcal{L}_{\\text{mdr}}, Ltotalâ€‹=Lbâ€‹+Î»1â€‹Lipâ€‹+Î»2â€‹Ltgsaâ€‹+Î»3â€‹Lcsaâ€‹+Lmdrâ€‹, å…¶ä¸­,Î»1,Î»2,Î»3\\lambda_1,\\lambda_2,\\lambda_3Î»1â€‹,Î»2â€‹,Î»3â€‹ä¸ºè¶…å‚æ•°ã€‚ å®éªŒç»“æœ å±•ç¤ºå‡ºæ¥ç»“æœéå¸¸ä¸é”™ï¼Œä½†æ˜¯å¦‚æœ æ€»ç»“ ideaéå¸¸ä¸é”™ï¼Œé¦–æ¬¡ä½¿ç”¨åŒåˆ†æ”¯ç½‘ç»œå¯¹å…±äº«å’Œç‰¹æœ‰ç‰¹å¾è¿›è¡Œæå–çš„æ€è·¯å¾ˆå¥½ï¼Œä½†æ˜¯æ–‡ç« æ²¡æœ‰æè‡ªå·±ä½¿ç”¨äº†rerankç­–ç•¥ä½¿å…¶æ•ˆæœå¢é•¿äº†10ä¸ªç‚¹çš„äº‹æƒ…ï¼Œä»¥åŠGRLå¹¶æ²¡æœ‰çœŸæ­£åœ¨ä»£ç ä¸­ä½¿ç”¨è¿‡ï¼Œæ„Ÿè§‰æ–‡ç« å¤§å°é—®é¢˜è¿˜æ˜¯æœ‰äº›å¤šã€‚","tags":["ReID","2024","VI-ReID","CVPR","IDKL","rerank"],"categories":["ReID","VI-ReID"]},{"title":"ã€è®ºæ–‡ç¬”è®°ã€‘DNDM","path":"/2024/09/26/MudSynth/ReID/ã€è®ºæ–‡ç¬”è®°ã€‘DNDM/","content":"æ–‡ç« åŸºæœ¬ä¿¡æ¯ æ–‡ç« åç§°ï¼šDay-Night Cross-domain Vehicle Re-identification å‘è¡¨ä¼šè®®/å¹´ä»½ï¼šCVPR 2024 ä½œè€…ï¼šHongchao Li, Jingong Chen, Aihua Zheng, Yong Wu, Yonglong Luo å•ä½ï¼šAnhui Normal University, Anhui University æ‘˜è¦ æœ¬æ–‡æå‡ºäº†ä¸€ç§æ–°é¢–çš„æ˜¼å¤œåŒåŸŸè°ƒåˆ¶ï¼ˆDNDMï¼‰è½¦è¾†å†è¯†åˆ«æ¡†æ¶ï¼Œè§£å†³äº†è·¨æ˜¼å¤œæ€§èƒ½é—®é¢˜ï¼ˆä¹‹å‰å·¥ä½œéƒ½æ˜¯åœ¨è‰¯å¥½å…‰ç…§ä¸‹ï¼‰ã€‚å®ƒåŒ…æ‹¬ä¸€ä¸ªå¤œé—´åŸŸçœ©å…‰æŠ‘åˆ¶æ¨¡å—å’Œä¸€ä¸ªåŒåŸŸç»“æ„å¢å¼ºæ¨¡å—ï¼Œä»¥å¢å¼ºä½å…‰ç¯å¢ƒä¸‹çš„è½¦è¾†ç‰¹å¾ã€‚é€šè¿‡å¼€å‘è·¨åŸŸç±»åˆ«æ„ŸçŸ¥æ¨¡å—ï¼Œæœ¬æ–‡ä¿ƒè¿›äº†ä¸¤ä¸ªåŸŸä¸­å¤–è§‚å’Œç»“æ„ç‰¹å¾çš„äº’åŠ¨ï¼Œå¹¶æä¾›äº†åŒ…å«æ˜¼å¤œå›¾åƒçš„æ–°æ•°æ®é›†DN-Wildå’Œå¹³è¡¡æ•°æ®é›†DN-348ã€‚å®éªŒç»“æœè¡¨æ˜ï¼Œè¯¥æ¡†æ¶åœ¨æ˜¼å¤œè·¨åŸŸè½¦è¾†å†è¯†åˆ«ä¸­çš„é²æ£’æ€§ã€‚ ä¹‹å‰å·¥ä½œå­˜åœ¨çš„é—®é¢˜ è·¨æ˜¼å¤œæ€§èƒ½çš„å¿½è§† çƒ­ï¼ˆè¿‘ï¼‰çº¢å¤–æ‘„åƒæœºçš„é«˜æˆæœ¬å’Œç¯å¢ƒå…‰å¹²æ‰°ï¼ˆæ— æ³•åƒè¡Œäººé‡è¯†åˆ«è½¬åŒ–ä¸ºVIReIDï¼‰ æ•°æ®é›†ä¸­çš„æ ·æœ¬ä¸å¹³è¡¡ è·¨åŸŸç‰¹å¾å·®å¼‚å¸¦æ¥çš„æŒ‘æˆ˜ ç±»åˆ«å†…å·®å¼‚å¤§å¯¼è‡´çš„æ³›åŒ–èƒ½åŠ›ä¸è¶³ ä¸»è¦è´¡çŒ®/åˆ›æ–° æˆ‘ä»¬æä¾›äº†ä¸¤ä¸ªæ ‡å‡†åŒ–åŸºå‡†æ•°æ®é›†ï¼ŒDN-Wildå’ŒDN-348ï¼Œä»¥ä¿ƒè¿›DN-ReIDçš„ç ”ç©¶ã€‚è¿™äº›åŸºå‡†æ•°æ®é›†å°†å…è´¹å‘å­¦æœ¯ç ”ç©¶å…¬ä¼—å¼€æ”¾ã€‚ æˆ‘ä»¬æå‡ºäº†æ˜¼å¤œåŒåŸŸè°ƒåˆ¶ï¼ˆDNDMï¼‰æ¡†æ¶ï¼Œé›†æˆäº†çœ©å…‰æŠ‘åˆ¶ã€ç»“æ„å¢å¼ºå’Œç±»åˆ«æ„ŸçŸ¥çš„è®­ç»ƒï¼Œä»¥åŠ¨æ€è°ƒåˆ¶æ˜¼å¤œè·¨åŸŸè½¦è¾†ç‰¹å¾ã€‚ åœ¨å…·æœ‰æŒ‘æˆ˜æ€§çš„åŸºå‡†æ•°æ®é›†DN-348å’ŒDN-Wildä¸Šè¿›è¡Œçš„è¯¦å°½å®éªŒéªŒè¯äº†æˆ‘ä»¬çš„DNDMåœ¨æ˜¼å¤œè·¨åŸŸè½¦è¾†ReIDé—®é¢˜ä¸Šçš„ä¼˜è¶Šæ€§èƒ½å’Œæ½œåŠ›ã€‚ æ–¹æ³• 3.1 Model Architecture æå‡ºçš„DNDMæ¡†æ¶åˆ©ç”¨ResNet-50ä½œä¸ºéª¨å¹²ç½‘ç»œï¼Œä»æ˜¼å¤œå›¾åƒä¸­æå–ç‰¹å¾ã€‚ä¸ºäº†è§£å†³å¤œé—´çœ©å…‰é—®é¢˜ï¼Œæ¡†æ¶å¼•å…¥äº†å¤œé—´åŸŸçœ©å…‰æŠ‘åˆ¶ï¼ˆNight-domain Glare Suppression, NGSï¼‰æ¨¡å—ã€‚åŒåŸŸç»“æ„å¢å¼ºï¼ˆDual-domain Structure Enhancement, DSEï¼‰æ¨¡å—èšåˆå±€éƒ¨çª—å£çš„æ¢¯åº¦ï¼Œæ•æ‰å¤šæ ·çš„ç»“æ„è¡¨ç¤ºã€‚è·¨åŸŸç±»åˆ«æ„ŸçŸ¥ï¼ˆCross-domain Class Awareness, CCAï¼‰æ¨¡å—ä¿ƒè¿›æ˜¼å¤œè·¨åŸŸç‰¹å¾çš„ç›¸äº’ä½œç”¨ï¼Œå¢å¼ºå¤–è§‚å’Œç»“æ„è¡¨ç¤ºåœ¨éª¨å¹²ç½‘ç»œå„ä¸ªé˜¶æ®µçš„æœ‰æ•ˆåˆ©ç”¨ã€‚ 3.2 Baseline æ˜¼å¤œè·¨åŸŸè½¦è¾†å†è¯†åˆ«ï¼ˆDN-ReIDï¼‰æ—¨åœ¨æ£€ç´¢æ˜¼å¤œç¯å¢ƒä¸­æ„Ÿå…´è¶£çš„è½¦è¾†ã€‚ç»™å®šä¸€å¯¹è½¦è¾†å›¾åƒ I={(IDay,INight),y}I = \\{(I^{Day}, I^{Night}), y\\}I={(IDay,INight),y}ï¼Œå…¶ä¸­ IDayI^{Day}IDay å’Œ INightI^{Night}INight åˆ†åˆ«æ˜¯è¾“å…¥çš„ç™½å¤©å’Œå¤œé—´è½¦è¾†å›¾åƒï¼Œ yyy æ˜¯ç›¸å…³çš„è½¦è¾†èº«ä»½æ ‡ç­¾ã€‚ç”±éª¨å¹²ç½‘ç»œç¼–ç çš„ç›¸åº”å¤šé˜¶æ®µç‰¹å¾å¼ é‡è¡¨ç¤ºä¸º TsmT_s^mTsmâ€‹ï¼Œå…¶ä¸­ sâˆˆ{0,1,2,3,4}s \\in \\{0, 1, 2, 3, 4\\}sâˆˆ{0,1,2,3,4}ï¼Œ mâˆˆ{Day,Night}m \\in \\{Day, Night\\}mâˆˆ{Day,Night}ã€‚å¦‚å›¾3(a)æ‰€ç¤ºï¼Œéµå¾ªResNet-50éª¨å¹²ç½‘ç»œï¼Œæˆ‘ä»¬ä½¿ç”¨å…¨å±€å¹³å‡æ± åŒ–ï¼ˆGAPï¼‰å±‚æ¥è·å¾—ç›¸åº”çš„ç‰¹å¾å‘é‡ fm=GAP(T4m)f^m = GAP(T_4^m)fm=GAP(T4mâ€‹)ã€‚ç½‘ç»œéšåé’ˆå¯¹äº¤å‰ç†µæŸå¤± LceL_{ce}Lceâ€‹ å’Œä¸‰å…ƒç»„æŸå¤± LtriL_{tri}Ltriâ€‹ è¿›è¡Œä¼˜åŒ–ã€‚äº¤å‰ç†µæŸå¤±å…¬å¼å¦‚ä¸‹ï¼š Lce=âˆ’ylogâ¡(Softmax(FCclass(fm))),L_{ce} = -y \\log(\\text{Softmax}(FC_{class}(f^m))), Lceâ€‹=âˆ’ylog(Softmax(FCclassâ€‹(fm))), å…¶ä¸­ FCclassFC_{class}FCclassâ€‹ è¡¨ç¤ºé¢„æµ‹åˆ†ç±»ç»“æœçš„å…¨è¿æ¥å±‚ï¼ŒSoftmax æ˜¯è·å–å½’ä¸€åŒ–æ¦‚ç‡çš„å‡½æ•°ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒfDayf^{Day}fDay å’Œ fNightf^{Night}fNight å…±äº«ç›¸åŒçš„ FCclassFC_{class}FCclassâ€‹ å±‚ã€‚ä¸‰å…ƒç»„æŸå¤±å…¬å¼å¦‚ä¸‹ï¼š Ltri=maxâ¡(0,dijp+marginâˆ’dikn),L_{tri} = \\max(0, d_{ij}^p + \\text{margin} - d_{ik}^n), Ltriâ€‹=max(0,dijpâ€‹+marginâˆ’diknâ€‹), å…¶ä¸­ (i,j,k)(i, j, k)(i,j,k) è¡¨ç¤ºæ¯ä¸ªè®­ç»ƒæ‰¹æ¬¡å†…çš„ä¸€ä¸ªå›°éš¾ä¸‰å…ƒç»„ã€‚å¯¹äºç™½å¤©é”šå®šæ ·æœ¬ iiiï¼Œjjj æ¥è‡ªç›¸åº”çš„å¤œé—´æ­£æ ·æœ¬é›†ï¼Œkkk æ¥è‡ªç™½å¤©è´Ÿæ ·æœ¬é›†ã€‚å¯¹äºå¤œé—´é”šå®šæ ·æœ¬ iiiï¼Œjjj æ¥è‡ªç›¸åº”çš„ç™½å¤©æ­£æ ·æœ¬é›†ï¼Œkkk æ¥è‡ªå¤œé—´è´Ÿæ ·æœ¬é›†ã€‚dijp/diknd_{ij}^p / d_{ik}^ndijpâ€‹/diknâ€‹ è¡¨ç¤ºæ­£/è´Ÿæ ·æœ¬å¯¹çš„æˆå¯¹è·ç¦»ï¼Œmargin = 0.3 è¡¨ç¤ºä¸‰å…ƒç»„è·ç¦»è¾¹ç•Œã€‚ å°½ç®¡ä¸Šè¿°éª¨å¹²ç½‘ç»œå¯ä»¥æå–è½¦è¾†ç‰¹å¾ï¼Œä½†å®ƒå¹¶ä¸èƒ½æœ‰æ•ˆè§£å†³è½¦ç¯çœ©å…‰ã€ä½å…‰ç¯å¢ƒå’ŒåŸŸå·®å¼‚å¸¦æ¥çš„æŒ‘æˆ˜ã€‚ä¸ºäº†è§£å†³DN-ReIDä¸­çš„æŒ‘æˆ˜ï¼Œæˆ‘ä»¬å¼•å…¥äº†å¤œé—´åŸŸçœ©å…‰æŠ‘åˆ¶ï¼ˆNGSï¼‰æ¨¡å—ã€åŒåŸŸç»“æ„å¢å¼ºï¼ˆDSEï¼‰æ¨¡å—å’Œè·¨åŸŸç±»åˆ«æ„ŸçŸ¥ï¼ˆCCAï¼‰æ¨¡å—ã€‚ æ€»ç»“ æ˜¼å¤œè·¨åŸŸè½¦è¾†å†è¯†åˆ«ï¼ˆDN-ReIDï¼‰æå‡ºäº†åˆ©ç”¨éª¨å¹²ç½‘ç»œæå–æ˜¼å¤œç¯å¢ƒä¸­çš„è½¦è¾†ç‰¹å¾ï¼Œä¼˜åŒ–äº¤å‰ç†µæŸå¤±å’Œä¸‰å…ƒç»„æŸå¤±ã€‚ç„¶è€Œï¼Œä¼ ç»Ÿæ–¹æ³•æ— æ³•æœ‰æ•ˆè§£å†³è½¦ç¯çœ©å…‰ã€ä½å…‰ç¯å¢ƒå’ŒåŸŸå·®å¼‚çš„é—®é¢˜ã€‚ä¸ºæ­¤ï¼Œæœ¬æ–‡å¼•å…¥äº†å¤œé—´åŸŸçœ©å…‰æŠ‘åˆ¶ï¼ˆNGSï¼‰æ¨¡å—ã€åŒåŸŸç»“æ„å¢å¼ºï¼ˆDSEï¼‰æ¨¡å—å’Œè·¨åŸŸç±»åˆ«æ„ŸçŸ¥ï¼ˆCCAï¼‰æ¨¡å—ï¼Œä»¥åº”å¯¹è¿™äº›æŒ‘æˆ˜ã€‚ 3.3 NGS å€Ÿé‰´ç ”ç©¶[2, 19]ä¸­å¼ºè°ƒçš„è§†è§‰æç¤ºæ¦‚å¿µï¼Œè§†è§‰æç¤ºçš„æ•´åˆåœ¨è¯†åˆ«ä»»åŠ¡çš„ç¡®åˆ‡ç»†èŠ‚æ—¶è‡³å…³é‡è¦ã€‚æˆ‘ä»¬æå‡ºäº†ä¸€ä¸ªå¤œé—´åŸŸçœ©å…‰æŠ‘åˆ¶ï¼ˆNight-domain Glare Suppression, NGSï¼‰æ¨¡å—ï¼Œè¯¥æ¨¡å—åˆ©ç”¨çœ©å…‰æç¤ºå¼•å¯¼æ³¨æ„åŠ›åˆ°æ— çœ©å…‰åŒºåŸŸï¼Œå¹¶å‡å°‘è½¦ç¯çœ©å…‰çš„å½±å“ã€‚ç»™å®šä¸€ä¸ªå¤œé—´è½¦è¾†å›¾åƒ INightI^{Night}INightï¼Œæˆ‘ä»¬é¦–å…ˆé€šè¿‡å·ç§¯å—æå–ç‰¹å¾å¼ é‡ T0NightT_0^{Night}T0Nightâ€‹: T0Night=Mxp2Ã—2(ReLU(BN(conv7Ã—7(INight)))),T_0^{Night} = M_{xp2\\times2}(\\text{ReLU}(\\text{BN}(\\text{conv}_{7\\times7}(I^{Night})))), T0Nightâ€‹=Mxp2Ã—2â€‹(ReLU(BN(conv7Ã—7â€‹(INight)))), å…¶ä¸­ conv7Ã—7\\text{conv}_{7\\times7}conv7Ã—7â€‹ è¡¨ç¤ºä¸€ä¸ª7Ã—7å·ç§¯æ“ä½œï¼ŒBNè¡¨ç¤ºæ‰¹å½’ä¸€åŒ–æ“ä½œï¼ŒReLUè¡¨ç¤ºä¿®æ­£çº¿æ€§å•å…ƒï¼ŒMxp2Ã—2M_{xp2\\times2}Mxp2Ã—2â€‹ è¡¨ç¤º2Ã—2æœ€å¤§æ± åŒ–æ“ä½œã€‚ åŒæ—¶ï¼Œæˆ‘ä»¬å°†å¤œé—´è½¦è¾†å›¾åƒ INightI^{Night}INight è½¬æ¢ä¸ºç°åº¦å›¾åƒ IG=rgb2gray(INight)I^G = \\text{rgb2gray}(I^{Night})IG=rgb2gray(INight)ã€‚ç„¶åï¼Œæˆ‘ä»¬åº”ç”¨äº®åº¦é˜ˆå€¼220æ¥è¯†åˆ«å¤œé—´å›¾åƒä¸­çš„é«˜äº®åŒºåŸŸã€‚åœ¨è¯†åˆ«é«˜äº®åŒºåŸŸåï¼Œæˆ‘ä»¬å°†ç›¸é‚»åƒç´ ç»„åˆæˆåŒºåŸŸï¼ŒåŒæ—¶ä¸¢å¼ƒåƒç´ è¾ƒå°‘çš„åŒºåŸŸã€‚æœ€åï¼Œæˆ‘ä»¬ä»åˆå§‹å¤œé—´å›¾åƒä¸­è·å¾—äºŒè¿›åˆ¶æ©ç  MGM^GMGï¼Œå…¶ä¸­1è¡¨ç¤ºå—çœ©å…‰å½±å“çš„åƒç´ ï¼Œ0è¡¨ç¤ºæœªå—çœ©å…‰å½±å“çš„åƒç´ ã€‚è¯¥äºŒè¿›åˆ¶æ©ç ä½œä¸ºè¾“å…¥åŒ…å«åœ¨çœ©å…‰æŠ‘åˆ¶æ¨¡å—ä¸­ï¼Œå¹¶ä¸ç‰¹å¾å¼ é‡ T0NightT_0^{Night}T0Nightâ€‹ è¿›è¡Œè°ƒåˆ¶ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬å°†ç‰¹å¾å¼ é‡ T0NightT_0^{Night}T0Nightâ€‹ ä¸äºŒè¿›åˆ¶æ©ç  MGM^GMG è¿æ¥ï¼Œç„¶åå°†å®ƒä»¬è¾“å…¥åˆ°ä¸€ä¸ªå¯å­¦ä¹ çš„æŠ•å½±å‘é‡ VâˆˆR(C0+1)Ã—1V\\in \\mathbb{R}^{(C^0+1)\\times 1}VâˆˆR(C0+1)Ã—1 ä¸­ï¼š M0Night=Sigmoid(concat(T0Night,MG)V),M_0^{Night} = \\text{Sigmoid}(\\text{concat}(T_0^{Night}, M^G)V), M0Nightâ€‹=Sigmoid(concat(T0Nightâ€‹,MG)V), å…¶ä¸­ M0NightâˆˆRH0Ã—W0Ã—1M_0^{Night}\\in\\mathbb{R}^{H^0\\times W^0\\times 1}M0Nightâ€‹âˆˆRH0Ã—W0Ã—1 è¡¨ç¤ºå­¦ä¹ åˆ°çš„åŸŸæŠ‘åˆ¶æ©ç ï¼ŒSigmoidæŒ‡çš„æ˜¯Så½¢å‡½æ•°ã€‚ é™¤äº†å¤œé—´å›¾åƒå¤–ï¼Œæˆ‘ä»¬çš„NGSæ¨¡å—è¿˜å—åˆ°ç™½å¤©å›¾åƒçš„æŒ‡å¯¼ã€‚åŸºæœ¬æ€æƒ³æ˜¯åˆ©ç”¨ä¸€ä¸ªè™šæ‹Ÿæ©ç  zeros(MG)\\text{zeros}(M^G)zeros(MG) æ¥æç¤ºæ— çœ©å…‰ç™½å¤©ç‰¹å¾å’Œæœ‰çœ©å…‰å¤œé—´ç‰¹å¾ä¹‹é—´çš„å·®å¼‚ï¼š M0Day=Sigmoid(concat(T0Day,zeros(MG))V),M_0^{Day} = \\text{Sigmoid}(\\text{concat}(T_0^{Day}, \\text{zeros}(M^G))V), M0Dayâ€‹=Sigmoid(concat(T0Dayâ€‹,zeros(MG))V), åœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œè¾“å…¥ä¹‹ä¸€æ˜¯ T0NightT_0^{Night}T0Nightâ€‹ å’Œ MGM^GMG çš„è¿æ¥ã€‚å¦ä¸€ä¸ªè¾“å…¥æ˜¯ä¸€ä¸ªæ— çœ©å…‰çš„ç™½å¤©ç‰¹å¾å¼ é‡ T0DayT_0^{Day}T0Dayâ€‹ï¼Œä¸ä¸€ä¸ªå…¨é›¶æ©ç  zeros(MG)\\text{zeros}(M^G)zeros(MG) è¿æ¥ã€‚åŸºäºåŸŸæŠ‘åˆ¶æ©ç  M0mM_0^mM0mâ€‹ï¼Œæœ€ç»ˆçš„æŠ‘åˆ¶è¿‡ç¨‹å¯ä»¥è¡¨ç¤ºä¸ºï¼š T0m=T0mâˆ’Î±M0mâŠ™T0m,T_0^m = T_0^m - \\alpha M_0^m \\odot T_0^m, T0mâ€‹=T0mâ€‹âˆ’Î±M0mâ€‹âŠ™T0mâ€‹, å…¶ä¸­ T0mT_0^mT0mâ€‹ è¡¨ç¤ºç»è¿‡çœ©å…‰æŠ‘åˆ¶æ“ä½œåçš„æ˜¼å¤œç‰¹å¾ï¼ŒÎ±=0.5\\alpha = 0.5Î±=0.5 æ˜¯ç”¨äºå¹³è¡¡åŸå§‹ç‰¹å¾å’Œå¼±åŒ–ç‰¹å¾çš„è¶…å‚æ•°ã€‚å›¾3(b)å±•ç¤ºäº†æˆ‘ä»¬NGSæ¨¡å—çš„ç»“æœï¼Œè¯´æ˜äº†çœ©å…‰åŒºåŸŸçš„æˆåŠŸåˆ†ç¦»ã€‚åœ¨æ‰§è¡Œä¸Šè¿°æ“ä½œåï¼Œæˆ‘ä»¬å°† T0mT_0^mT0mâ€‹ åé¦ˆåˆ°éª¨å¹²ç½‘ç»œä¸­ä»¥è·å–ç›¸åº”çš„ç‰¹å¾å¼ é‡ TsmT_s^mTsmâ€‹ã€‚ æ€»ç»“ æœ¬æ–‡æå‡ºçš„å¤œé—´åŸŸçœ©å…‰æŠ‘åˆ¶ï¼ˆNGSï¼‰æ¨¡å—åˆ©ç”¨è§†è§‰æç¤ºæœ‰æ•ˆå‡å°‘è½¦ç¯çœ©å…‰çš„å½±å“ã€‚é€šè¿‡å¯¹å¤œé—´å›¾åƒè¿›è¡Œç‰¹å¾æå–ã€ç°åº¦è½¬æ¢å’Œäº®åº¦é˜ˆå€¼å¤„ç†ï¼Œæˆ‘ä»¬ç”Ÿæˆäº†äºŒè¿›åˆ¶æ©ç æ¥è¯†åˆ«å—çœ©å…‰å½±å“çš„åŒºåŸŸã€‚è¯¥æ©ç ç”¨äºè°ƒåˆ¶ç‰¹å¾å¼ é‡ï¼Œä»è€Œå¢å¼ºæ— çœ©å…‰åŒºåŸŸçš„ç‰¹å¾è¡¨ç¤ºã€‚NGSæ¨¡å—è¿˜ç»“åˆäº†ç™½å¤©å›¾åƒä¿¡æ¯ï¼Œä»¥æç¤ºæ˜¼å¤œç‰¹å¾ä¹‹é—´çš„å·®å¼‚ã€‚æœ€ç»ˆï¼Œé€šè¿‡è¿™äº›æ“ä½œï¼ŒæˆåŠŸå®ç°äº†æ˜¼å¤œç‰¹å¾çš„åˆ†ç¦»å’Œå¢å¼ºï¼Œæ˜¾è‘—æé«˜äº†è½¦è¾†å†è¯†åˆ«çš„å‡†ç¡®æ€§ã€‚ ä»£ç å®ç° 1 3.4 DSE å¸¸è§çš„è½¦è¾†å†è¯†åˆ«ç½‘ç»œä¸»è¦å…³æ³¨æå–è½¦è¾†å¤–è§‚ç‰¹å¾ã€‚ç„¶è€Œï¼Œå¤–è§‚ç‰¹å¾å®¹æ˜“å—åˆ°ä½å…‰ç¯å¢ƒçš„å½±å“ã€‚ä¸ºäº†æé«˜æ˜¼å¤œè½¦è¾†å›¾åƒå¯¹çš„ç‰¹å¾ä¸€è‡´æ€§ï¼Œæˆ‘ä»¬å¼•å…¥äº†åŒåŸŸç»“æ„å¢å¼ºï¼ˆDual-domain Structure Enhancement, DSEï¼‰æ¨¡å—ã€‚DSEæ¨¡å—çš„ä¸»è¦æ€æƒ³æ˜¯é€šè¿‡é€åƒç´ æ¢¯åº¦ä»å¤–è§‚ç‰¹å¾ä¸­æå–ç»“æ„ä¿¡æ¯ã€‚å…·ä½“æ¥è¯´ï¼ŒDSEæ¨¡å—å¤„ç†ä¸­é—´ç‰¹å¾å›¾ TsmT_s^mTsmâ€‹ï¼Œå¹¶è®¡ç®—æ¯ä¸ªåƒç´ ä½ç½® xxx åŠå…¶å‘¨å›´åŒºåŸŸå¤§å°ä¸º NÃ—NN \\times NNÃ—N çš„é€åƒç´ éè´Ÿå±€éƒ¨æ¢¯åº¦ GGG: G(x,c,d)=maxâ¡(0,Tsm(x+d,c)âˆ’Tsm(x,c))G(x, c, d) = \\max(0, T_s^m(x + d, c) - T_s^m(x, c)) G(x,c,d)=max(0,Tsmâ€‹(x+d,c)âˆ’Tsmâ€‹(x,c)) å…¶ä¸­ câˆˆ[1,Cs]c \\in [1, C^s]câˆˆ[1,Cs] è¡¨ç¤ºé€šé“ç»´åº¦çš„ç´¢å¼•ï¼Œdâˆˆ[âˆ’dn,dn]Ã—[âˆ’dn,dn]d \\in [-d_n, d_n]\\times[-d_n, d_n]dâˆˆ[âˆ’dnâ€‹,dnâ€‹]Ã—[âˆ’dnâ€‹,dnâ€‹] è¡¨ç¤ºæ¯ä¸ªåƒç´  xxx åœ¨å…¶å‘¨å›´åŒºåŸŸçš„é‚»å±…ä½ç½®ã€‚åŒºåŸŸå¤§å°ä¸º NÃ—NN \\times NNÃ—Nï¼Œdn=(Nâˆ’1)/2d_n = (N-1)/2dnâ€‹=(Nâˆ’1)/2ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§ç‰¹å¾åŠ æƒæ“ä½œï¼Œå°†è¯¦ç»†çš„å±€éƒ¨æ¢¯åº¦æ•´åˆæˆä¸€ä¸ªç®€æ˜çš„ç»“æ„æè¿°ç¬¦ï¼Œä½¿å¾—èƒ½å¤ŸåŒæ—¶ä»ä¸¤ä¸ªåŸŸä¸­å­¦ä¹ å‡ ä½•ç»“æ„ï¼š S(x,c,d)=G(x,c,d)1+âˆ‘dG(x,c,d)Tsm(x+d,c),S(x, c, d) = \\frac{G(x, c, d)}{1 + \\sum_d G(x, c, d)} T_s^m(x + d, c), S(x,c,d)=1+âˆ‘dâ€‹G(x,c,d)G(x,c,d)â€‹Tsmâ€‹(x+d,c), S(x,c)=âˆ‘dS(x,c,d),S(x, c) = \\sum_d S(x, c, d), S(x,c)=dâˆ‘â€‹S(x,c,d), å…¶ä¸­ SâˆˆRHsÃ—WsÃ—CsS \\in \\mathbb{R}^{H^s \\times W^s \\times C^s}SâˆˆRHsÃ—WsÃ—Cs å…·æœ‰ä¸åŸå§‹ç‰¹å¾å¼ é‡ TsmT_s^mTsmâ€‹ ç›¸åŒçš„ç©ºé—´å’Œé€šé“å°ºå¯¸ã€‚æ¢¯åº¦å¼•å¯¼çš„ç‰¹å¾åŠ æƒæ“ä½œå°†é‚»å±…ç‰¹å¾èšåˆæˆç»“æ„ç‰¹å¾ï¼Œä»è€Œå°†å…¶ç©ºé—´ç»´åº¦ä» NÃ—NN \\times NNÃ—N é™è‡³ 1Ã—11 \\times 11Ã—1ã€‚è¿™ç§è½¬æ¢å°†åŸå§‹å±€éƒ¨æ¢¯åº¦ GGG è½¬æ¢ä¸ºç»“æ„æè¿°ç¬¦ SSSã€‚ç®€è€Œè¨€ä¹‹ï¼Œç»“æ„æè¿°ç¬¦ç”±åŠ æƒçš„å¤–è§‚æè¿°ç¬¦å¯¼å‡ºã€‚ç„¶åï¼Œæˆ‘ä»¬åˆ©ç”¨ç»“æ„æè¿°ç¬¦ä½œä¸ºå¤–è§‚æè¿°ç¬¦çš„é™„åŠ è¾“å…¥ï¼š Tsâ€¾m=Tsm+Î²S,\\overline{T_s}^m = T_s^m + \\beta S, Tsâ€‹â€‹m=Tsmâ€‹+Î²S, å…¶ä¸­ Tsâ€¾m\\overline{T_s}^mTsâ€‹â€‹m è¡¨ç¤ºç»“æ„å¢å¼ºæ“ä½œåçš„æ˜¼å¤œç‰¹å¾ï¼Œè¶…å‚æ•° Î²=0.25\\beta = 0.25Î²=0.25 ç”¨äºå¹³è¡¡åŸå§‹ç‰¹å¾å’Œå¢å¼ºç‰¹å¾ã€‚ ä»£ç å®ç° 123456789101112131415161718192021222324252627282930class GradientComputation4(nn.Module): def __init__(self): super(GradientComputation4, self).__init__() self.conv_layers = &#123;&#125; self.relu = nn.ReLU() def get_masked_conv(self, channels): if channels not in self.conv_layers: mask_conv = nn.Conv2d(in_channels=channels, out_channels=channels, kernel_size=5, padding=2, groups=channels, bias=False) mask = 1 * torch.ones(1, 1, 5, 5) mask[0, 0, 2, 2] = -24 # è¦å°†æ‰€æœ‰æ±‚å’Œå-æœ€ä¸­é—´24æ¬¡ï¼Œæ‰€ä»¥æ˜¯1-25æ¬¡ mask_conv.weight.data = mask.repeat(channels, 1, 1, 1) for param in mask_conv.parameters(): param.requires_grad = False self.conv_layers[channels] = mask_conv return self.conv_layers[channels] def forward(self, img): b, c, h, w = img.shape mask_conv = self.get_masked_conv(c) mask_conv.cuda() masked_output = mask_conv(img) masked_output = self.relu(masked_output) sum_output = masked_output / 24.0 # åšå¹³å‡ x = 0.9 * img + 0.25 * sum_output # ç„¶åæŒ‰ç…§è¯¥å¼å­è¿›è¡ŒåŠ æƒå°±å¯ä»¥äº† return x æ€»ç»“ åŒåŸŸç»“æ„å¢å¼ºï¼ˆDSEï¼‰æ¨¡å—é€šè¿‡é€åƒç´ æ¢¯åº¦ä»è½¦è¾†å›¾åƒçš„å¤–è§‚ç‰¹å¾ä¸­æå–ç»“æ„ä¿¡æ¯ï¼Œä»¥æé«˜æ˜¼å¤œå›¾åƒå¯¹çš„ç‰¹å¾ä¸€è‡´æ€§ã€‚DSEæ¨¡å—è®¡ç®—æ¯ä¸ªåƒç´ åŠå…¶å‘¨å›´åŒºåŸŸçš„å±€éƒ¨æ¢¯åº¦ï¼Œå°†å±€éƒ¨æ¢¯åº¦æ•´åˆæˆç»“æ„æè¿°ç¬¦ï¼Œå¹¶å°†å…¶ä½œä¸ºé™„åŠ è¾“å…¥ï¼Œå¢å¼ºå¤–è§‚ç‰¹å¾è¡¨ç¤ºã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼ŒDSEæ¨¡å—åœ¨ä½å…‰ç¯å¢ƒä¸‹æ”¹å–„äº†è½¦è¾†å†è¯†åˆ«çš„é²æ£’æ€§å’Œå‡†ç¡®æ€§ã€‚ 3.5 CCA åœ¨æˆ‘ä»¬çš„ç½‘ç»œä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆä½¿ç”¨ResNet-50ä»æ˜¼å¤œè·¨åŸŸè½¦è¾†å›¾åƒä¸­æå–å¤–è§‚ç‰¹å¾ã€‚ç„¶åï¼Œæˆ‘ä»¬åº”ç”¨çœ©å…‰æŠ‘åˆ¶æ¨¡å—æ¥å‡å°‘å¤œé—´å›¾åƒä¸­è½¦ç¯çœ©å…‰çš„å½±å“ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¼•å…¥ç»“æ„å¢å¼ºæ¨¡å—æ¥æ”¹è¿›å¤–è§‚ç‰¹å¾ã€‚ç„¶è€Œï¼Œè¿™äº›æ¨¡å—æœªèƒ½è€ƒè™‘æ˜¼å¤œåŸŸä¹‹é—´çš„å·®å¼‚ã€‚ ä¸ºäº†åº”å¯¹æ˜¼å¤œåŸŸé—´å·®å¼‚ï¼Œæˆ‘ä»¬ä¸ºDN-ReIDé—®é¢˜å¼•å…¥äº†è·¨åŸŸç±»åˆ«æ„ŸçŸ¥ï¼ˆCross-domain Class Awareness, CCAï¼‰æ¨¡å—ã€‚ç»™å®šæ˜¼å¤œè·¨åŸŸè½¦è¾†ç‰¹å¾ TsmâˆˆRHsÃ—WsÃ—CsT_s^m \\in \\mathbb{R}^{H^s \\times W^s \\times C^s}Tsmâ€‹âˆˆRHsÃ—WsÃ—Csï¼Œå…¶ä¸­ sâˆˆ{1,2,3,4}s \\in \\{1,2,3,4\\}sâˆˆ{1,2,3,4}ï¼Œæˆ‘ä»¬ä½¿ç”¨å·ç§¯å±‚å°†å…¶è½¬æ¢ä¸ºæŠ•å½± PsmP_s^mPsmâ€‹ã€‚è¿™ä¸ªè°ƒæ•´æ—¨åœ¨åŒ¹é…å…¨è¿æ¥å±‚ FCclassFC_{class}FCclassâ€‹ çš„è¾“å…¥å¤§å°ï¼Œå¦‚å…¬å¼(1)æ‰€è¿°ã€‚æ•°å­¦è¡¨è¾¾å¦‚ä¸‹ï¼š Psm=BN(conv1Ã—1(Tsm)),P_s^m = \\text{BN}(\\text{conv}_{1 \\times 1}(T_s^m)), Psmâ€‹=BN(conv1Ã—1â€‹(Tsmâ€‹)), å…¶ä¸­ conv1Ã—1\\text{conv}_{1 \\times 1}conv1Ã—1â€‹ è¡¨ç¤º1Ã—1å·ç§¯æ“ä½œï¼ŒBNè¡¨ç¤ºæ‰¹å½’ä¸€åŒ–æ“ä½œã€‚å—ç±»æ¿€æ´»æ˜ å°„ï¼ˆCAMï¼‰æ“ä½œçš„å¯å‘ï¼ŒCAMå¯ä»¥çªå‡ºç±»ç‰¹å®šçš„åˆ¤åˆ«åŒºåŸŸã€‚æˆ‘ä»¬å¼•å…¥æŠ•å½± PsmP_s^mPsmâ€‹ æ¥è®¡ç®—æ˜¼å¤œå›¾åƒçš„ç±»æ¿€æ´»æ˜ å°„ï¼š Aim=Sigmoid(FCclass(Psm)),A_i^{m} = \\text{Sigmoid}(FC_{class}(P_s^m)), Aimâ€‹=Sigmoid(FCclassâ€‹(Psmâ€‹)), å…¶ä¸­ Câ€²C&#x27;Câ€² ä»£è¡¨è®­ç»ƒé›†ä¸­ç±»çš„æ€»æ•°ã€‚å¯¹äºç¬¬ yyy ç±»çš„ç±»æ¿€æ´»æ˜ å°„åˆ†åˆ«è¡¨ç¤ºä¸º AyDayA_y^{Day}AyDayâ€‹ å’Œ AyNightA_y^{Night}AyNightâ€‹ï¼Œå…¶ä¸­ yyy è¡¨ç¤ºè½¦è¾†èº«ä»½æ ‡ç­¾ã€‚Sigmoidå‡½æ•°ç”¨äºå½’ä¸€åŒ–CAMã€‚ ä¸ºäº†ä¿ƒè¿›æ˜¼å¤œè·¨åŸŸç‰¹å¾çš„ç›¸äº’ä½œç”¨ï¼Œæˆ‘ä»¬å»ºè®®åœ¨è®­ç»ƒé˜¶æ®µäº¤æ¢æ˜¼å¤œæ ·æœ¬çš„ç±»æ„ŸçŸ¥ä¿¡æ¯ï¼š PsDay=PsDayâŠ™AyNight,P_s^{Day} = P_s^{Day} \\odot A_y^{Night}, PsDayâ€‹=PsDayâ€‹âŠ™AyNightâ€‹, PsNight=PsNightâŠ™AyDay,P_s^{Night} = P_s^{Night} \\odot A_y^{Day}, PsNightâ€‹=PsNightâ€‹âŠ™AyDayâ€‹, å…¶ä¸­ âŠ™\\odotâŠ™ è¡¨ç¤ºå…ƒç´ çº§åˆ«çš„ä¹˜æ³•ã€‚é‡è¦çš„æ˜¯ï¼Œè¿™ç§äº¤æ¢è¿‡ç¨‹ä»…åœ¨è®­ç»ƒé˜¶æ®µå‘ç”Ÿï¼Œæµ‹è¯•é˜¶æ®µä¸äº¤æ¢ç±»æ¿€æ´»æ˜ å°„ã€‚ä¸ºäº†ç¡®ä¿ PsDayP_s^{Day}PsDayâ€‹ å’Œ PsNightP_s^{Night}PsNightâ€‹ å…·æœ‰ç›¸åŒçš„é€šé“æ•°ï¼Œæˆ‘ä»¬å°† conv1Ã—1+BN+ReLU\\text{conv}_{1 \\times 1} + \\text{BN} + \\text{ReLU}conv1Ã—1â€‹+BN+ReLU æ“ä½œçº³å…¥CCAæ¨¡å—ã€‚ç»“æœç‰¹å¾è¡¨ç¤ºä¸ºï¼š Tsm=Tsm+ReLU(BN(conv1Ã—1(Psm))).T_s^m = T_s^m + \\text{ReLU}(\\text{BN}(\\text{conv}_{1 \\times 1}(P_s^m))). Tsmâ€‹=Tsmâ€‹+ReLU(BN(conv1Ã—1â€‹(Psmâ€‹))). æ€»ä½“æŸå¤± æˆ‘ä»¬é‡‡ç”¨å¹¿æ³›ä½¿ç”¨çš„ResNet-50ä½œä¸ºéª¨å¹²ç½‘ç»œã€‚åœ¨ç¬¬ä¸€ä¸ªå—ä¹‹å‰é›†æˆäº†æå‡ºçš„å¤œé—´åŸŸçœ©å…‰æŠ‘åˆ¶ï¼ˆNGSï¼‰æ¨¡å—ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬åœ¨æ¯ä¸ªå·ç§¯å—ä¹‹åé›†æˆäº†åŒåŸŸç»“æ„å¢å¼ºï¼ˆDSEï¼‰æ¨¡å—å’Œè·¨åŸŸç±»åˆ«æ„ŸçŸ¥ï¼ˆCCAï¼‰æ¨¡å—ã€‚æ•´ä¸ªç½‘ç»œä»¥ç«¯åˆ°ç«¯æ–¹å¼è¿›è¡Œè®­ç»ƒã€‚æ€»ä½“æŸå¤±å‡½æ•°å¦‚ä¸‹ï¼š L=Lce+Ltri.\\mathcal{L} = \\mathcal{L}_{ce} + \\mathcal{L}_{tri}. L=Lceâ€‹+Ltriâ€‹. æ€»ç»“ è·¨åŸŸç±»åˆ«æ„ŸçŸ¥ï¼ˆCCAï¼‰æ¨¡å—æ—¨åœ¨è§£å†³æ˜¼å¤œåŸŸä¹‹é—´çš„å·®å¼‚ã€‚é€šè¿‡å°†è½¦è¾†ç‰¹å¾è½¬æ¢ä¸ºæŠ•å½±å¹¶è®¡ç®—ç±»æ¿€æ´»æ˜ å°„ï¼ŒCCAæ¨¡å—ä¿ƒè¿›äº†æ˜¼å¤œæ ·æœ¬ä¹‹é—´çš„ç‰¹å¾äº¤äº’ã€‚ç»“åˆå¤œé—´åŸŸçœ©å…‰æŠ‘åˆ¶ï¼ˆNGSï¼‰æ¨¡å—å’ŒåŒåŸŸç»“æ„å¢å¼ºï¼ˆDSEï¼‰æ¨¡å—ï¼ŒCCAæ¨¡å—å¢å¼ºäº†è½¦è¾†å†è¯†åˆ«ç³»ç»Ÿåœ¨æ˜¼å¤œè·¨åŸŸåœºæ™¯ä¸­çš„é²æ£’æ€§ã€‚é€šè¿‡ç«¯åˆ°ç«¯è®­ç»ƒï¼Œç½‘ç»œåœ¨ç‰¹å¾æå–å’ŒåŸŸé€‚åº”æ–¹é¢è¡¨ç°å‡ºè‰²ï¼Œæ˜¾è‘—æå‡äº†å†è¯†åˆ«çš„å‡†ç¡®æ€§ã€‚ å®éªŒç»“æœ DN-348ä¸Šçš„æµ‹è¯•ç»“æœ æ¯”è¾ƒäº†DNDMå’Œæœ€å…ˆè¿›çš„VI-ReIDæ–¹æ³•åœ¨DN-348æ•°æ®é›†ä¸Šçš„æ€§èƒ½ã€‚DNDMåœ¨å¤„ç†å¤œé—´è½¦è¾†å›¾åƒæ—¶è¡¨ç°æ›´ä½³ï¼Œå°¤å…¶æ˜¯åœ¨æ˜¼å¤œè½¬æ¢å’Œå¤œæ˜¼è½¬æ¢è®¾ç½®ä¸­æ˜¾è‘—ä¼˜äºVI-ReIDæ–¹æ³•ã€‚é€šè¿‡å¤œé—´é¢†åŸŸçœ©å…‰æŠ‘åˆ¶å’ŒåŒé¢†åŸŸç»“æ„å¢å¼ºï¼ŒDNDMæœ‰æ•ˆæå‡äº†å¤œé—´è½¦è¾†å›¾åƒçš„ç‰¹å¾å­¦ä¹ èƒ½åŠ›ã€‚ç ”ç©¶è¡¨æ˜ï¼ŒDN-ReIDåœ¨å¤œé—´åŒ¹é…è½¦è¾†å›¾åƒæ–¹é¢å…·æœ‰æŒ‘æˆ˜æ€§ï¼Œä½†æ½œåŠ›å·¨å¤§ã€‚ DN-Wildä¸Šçš„æµ‹è¯•ç»“æœ æœ¬æ–‡æ¯”è¾ƒäº†DNDMå’Œæœ€å…ˆè¿›çš„æ–¹æ³•åœ¨DN-Wildæ•°æ®é›†ä¸Šçš„æ€§èƒ½ã€‚DNDMåœ¨æ˜¼å¤œè½¬æ¢å’Œå¤œæ˜¼è½¬æ¢è®¾ç½®ä¸­å‡è¡¨ç°å‡ºè‰²ï¼Œæ˜¾è‘—ä¼˜äºReIDå¼ºåŸºçº¿BOTã€‚é€šè¿‡çœ©å…‰æŠ‘åˆ¶ã€ç»“æ„å¢å¼ºå’Œç±»åˆ«æ„ŸçŸ¥çš„è®­ç»ƒï¼ŒDNDMæœ‰æ•ˆåœ°å­¦ä¹ äº†æ˜¼å¤œè·¨åŸŸç‰¹å¾ã€‚ç„¶è€Œï¼ŒPMTåœ¨DN-Wildæ•°æ®é›†ä¸Šçš„è¡¨ç°ä¸å¦‚åœ¨DN-348æ•°æ®é›†ä¸Šï¼Œè¿™è¡¨æ˜ä»…è€ƒè™‘åŸŸé—´å·®å¼‚æ˜¯ä¸å¤Ÿçš„ï¼Œéœ€è§£å†³æ ·æœ¬ä¸å¹³è¡¡é—®é¢˜ã€‚æ€»ä½“ä¸Šï¼ŒDNDMåœ¨å¤§è§„æ¨¡æ•°æ®é›†ä¸Šæ˜¾ç¤ºäº†å¼ºæ³›åŒ–èƒ½åŠ›ã€‚ æ¶ˆèå®éªŒ æ¯ä¸ªç»„ä»¶çš„æœ‰æ•ˆæ€§ é€šè¿‡åœ¨DN-348æ•°æ®é›†ä¸Šçš„æ¶ˆèç ”ç©¶ï¼Œæœ¬æ–‡éªŒè¯äº†NGSã€DSEå’ŒCCAæ¨¡å—å¯¹æ¨¡å‹æ€§èƒ½çš„æ˜¾è‘—è´¡çŒ®ã€‚å•ç‹¬å¯ç”¨NGSæ¨¡å—æ—¶ï¼ŒRank-1æ€§èƒ½è¾¾åˆ°69.0%ï¼›å¯ç”¨NGSå’ŒDSEæ¨¡å—æ—¶ï¼Œæ€§èƒ½æå‡è‡³69.9%ï¼›ä¸‰è€…ç»“åˆæ—¶ï¼Œæ€§èƒ½è¾¾åˆ°70.7%ã€‚è¿™äº›ç»“æœè¯æ˜äº†å„æ¨¡å—å•ç‹¬åŠè”åˆä½¿ç”¨æ—¶çš„ä¸€è‡´æ€§æ€§èƒ½æå‡ã€‚ ResNet-50çš„å“ªä¸ªé˜¶æ®µæ’å…¥DSEæ¨¡å—å’ŒCCAæ¨¡å—çš„å½±å“ æœ¬æ–‡åˆ†æäº†åœ¨ResNet-50çš„ä¸åŒé˜¶æ®µæ’å…¥DSEå’ŒCCAæ¨¡å—å¯¹æ€§èƒ½çš„å½±å“ã€‚å®éªŒè¡¨æ˜ï¼Œéšç€æ¨¡å—åœ¨ResNet-50å„é˜¶æ®µçš„é€æ­¥é›†æˆï¼ŒDN-348æ•°æ®é›†çš„Rank-1åˆ†æ•°ä»69.6%æå‡è‡³70.7%ï¼ŒmAPä»47.0%æå‡è‡³47.5%ã€‚è¿™äº›ç»“æœéªŒè¯äº†æ˜¼å¤œåŒåŸŸè°ƒåˆ¶æ¡†æ¶åœ¨å­¦ä¹ æ˜¼å¤œè·¨åŸŸä¿¡æ¯ä»¥æå‡DN-ReIDæ€§èƒ½æ–¹é¢çš„æœ‰æ•ˆæ€§ã€‚ Other Analysis è¶…å‚æ•°åˆ†æï¼šä¸ºäº†è¯„ä¼°ä¸¤ä¸ªè¶…å‚æ•°çš„å½±å“ï¼Œæˆ‘ä»¬è¿›è¡Œäº†å®šé‡æ¯”è¾ƒå¹¶åœ¨å›¾4ä¸­æŠ¥å‘Šäº†ç»“æœã€‚Î±å’ŒÎ²çš„ä¸åŒå€¼æ˜¾ç€å½±å“NGSå’ŒDSEæ¨¡å—çš„æ€§èƒ½ã€‚æ®è§‚å¯Ÿï¼Œå½“ Î± å’Œ Î² å€¼åˆ†åˆ«è®¾ç½®ä¸º 0.5 å’Œ 0.25 æ—¶ï¼Œå¯å®ç°æœ€ä½³æ€§èƒ½ã€‚ å¯è§†åŒ–ç ”ç©¶ï¼šä¸ºäº†è¿›ä¸€æ­¥åˆ†ææˆ‘ä»¬DNDMçš„æœ‰æ•ˆæ€§ï¼Œæˆ‘ä»¬åœ¨DN-348æ•°æ®é›†ä¸Šè¿›è¡Œå®éªŒï¼Œä»¥è®¡ç®—è·¨èº«ä»½å’ŒåŒèº«ä»½è·ç¦»çš„é¢‘ç‡ã€‚å›¾5ï¼ˆaï¼Œbï¼‰åˆ†åˆ«æ˜¾ç¤ºäº†åŸºçº¿æ–¹æ³•å’Œæå‡ºçš„DNDMè·å–çš„è·ç¦»åˆ†å¸ƒã€‚å°†å›¾5ï¼ˆbï¼‰ä¸å›¾5ï¼ˆaï¼‰è¿›è¡Œæ¯”è¾ƒï¼Œæˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°Î´1 &lt; Î´2ã€‚è¿™è¡¨æ˜ä½¿ç”¨æ‰€æå‡ºçš„æ–¹æ³•ï¼Œè·¨èº«ä»½å’ŒåŒèº«ä»½è·ç¦»æ˜¾è‘—åˆ†ç¦»ã€‚ æ­¤å¤–ï¼Œæˆ‘ä»¬ä½¿ç”¨T-SNEæ–¹æ³•åœ¨äºŒç»´ç‰¹å¾ç©ºé—´ä¸­å¯è§†åŒ–äº†20è¾†è½¦çš„ç‰¹å¾åˆ†å¸ƒã€‚åœ¨å›¾5ï¼ˆcï¼Œdï¼‰ä¸­ï¼Œå¯ä»¥æ˜æ˜¾çœ‹å‡ºï¼Œæ‰€æå‡ºçš„DNDMæ˜¾è‘—å‡å°‘äº†åŒä¸€èº«ä»½ç™½å¤©å’Œå¤œé—´å›¾åƒä¹‹é—´çš„è·ç¦»ï¼Œå¹¶æˆåŠŸåœ°æœ€å°åŒ–äº†åŸŸé—´å·®å¼‚ã€‚ æ€»ç»“ æ®æˆ‘ä»¬æ‰€çŸ¥ï¼Œè¿™æ˜¯é¦–ä¸ªè§£å†³æ˜¼å¤œè·¨åŸŸè½¦è¾†é‡è¯†åˆ«ï¼ˆDN-ReIDï¼‰é—®é¢˜çš„ç ”ç©¶ã€‚æˆ‘ä»¬è´¡çŒ®äº†ä¸¤ä¸ªæ–°çš„DN-ReIDæ•°æ®é›†ï¼Œå¹¶æå‡ºäº†ä¸€ç§åˆ›æ–°çš„DN-ReIDæ–¹æ³•ã€‚ä¸ç™½å¤©åˆ°ç™½å¤©çš„è½¦è¾†é‡è¯†åˆ«ç›¸æ¯”ï¼ŒDN-ReIDé¢ä¸´è½¦ç¯çœ©å…‰ã€ä½å…‰ç¯å¢ƒå’ŒåŸŸé—´å·®å¼‚å¸¦æ¥çš„æŒ‘æˆ˜ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æå‡ºäº†æ˜¼å¤œåŒåŸŸè°ƒåˆ¶ï¼ˆDNDMï¼‰ç½‘ç»œï¼Œè¯¥ç½‘ç»œç»“åˆäº†çœ©å…‰æŠ‘åˆ¶ã€ç»“æ„å¢å¼ºå’Œç±»åˆ«æ„ŸçŸ¥çš„å­¦ä¹ ï¼Œä»¥åŠ¨æ€è°ƒåˆ¶æ˜¼å¤œè·¨åŸŸè½¦è¾†ç‰¹å¾ã€‚å¹¿æ³›çš„å®éªŒè¡¨æ˜ï¼Œæ‰€æå‡ºæ–¹æ³•å…·æœ‰è‰¯å¥½çš„æ€§èƒ½ã€‚ æ­¤å¤–ï¼ŒåŸºäºæˆ‘ä»¬çš„ç ”ç©¶ï¼Œæˆ‘ä»¬å¼ºè°ƒäº†DN-ReIDçš„å‡ ä¸ªé‡è¦å‘ç°ã€‚é¦–å…ˆï¼Œä¸ºå¤œé—´çš„è½¦è¾†å›¾åƒæ³¨é‡Šæ˜¯ä¸€é¡¹æŒ‘æˆ˜ã€‚å…¶æ¬¡ï¼Œå¢å¼ºå¤œé—´è½¦è¾†å›¾åƒä¸­çš„ç‰¹å¾è¢«è¯æ˜æ˜¯æœ‰æ•ˆçš„ã€‚æœ€åï¼Œè€ƒè™‘æ˜¼å¤œè·¨åŸŸæ•°æ®è¯†åˆ«ç›¸åŒIDçš„èƒ½åŠ›æ˜¯å€¼å¾—çš„ã€‚æœªæ¥ï¼Œæˆ‘ä»¬å°†å¢å¼ºä¸Šè¿°ç»„ä»¶ï¼Œä»¥æ¨è¿›DN-ReIDçš„æœ€æ–°æŠ€æœ¯ï¼Œå¹¶æ¢ç´¢æ— æ ‡ç­¾çš„DN-ReIDã€‚","tags":["ReID","2024","CVPR","Vehicle-ReID"],"categories":["ReID","Others"]},{"title":"ã€è®ºæ–‡ç¬”è®°ã€‘DEEN","path":"/2024/09/26/MudSynth/ReID/ã€è®ºæ–‡ç¬”è®°ã€‘DEEN/","content":"æ–‡ç« åŸºæœ¬ä¿¡æ¯ æ–‡ç« åç§°ï¼šDiverse Embedding Expansion Network and Low-Light Cross-Modality Benchmark for Visible-Infrared Person Re-identification å‘è¡¨ä¼šè®®/å¹´ä»½ï¼šCVPR 2023 ä½œè€…ï¼šYukang Zhang, Hanzi Wang å•ä½ï¼šFujian Key Laboratory of Sensing and Computing for Smart City,School of Informatics, Xiamen University, 361005, P.R. China.2Key Laboratory of Multimedia Trusted Perception and Efficient Computing,Ministry of Education of China, Xiamen University, 361005, P.R. China.3Shanghai Artificial Intelligence Laboratory, Shanghai, 200232, China. æ‘˜è¦ å¯¹äºå¯è§å…‰-çº¢å¤–è¡Œäººé‡è¯†åˆ«ï¼ˆVI-ReIDï¼‰ä»»åŠ¡ï¼Œä¸»è¦æŒ‘æˆ˜ä¹‹ä¸€æ˜¯å¯è§å…‰ï¼ˆVISï¼‰å’Œçº¢å¤–ï¼ˆIRï¼‰å›¾åƒä¹‹é—´çš„æ¨¡æ€å·®è·ã€‚ç„¶è€Œï¼Œè®­ç»ƒæ ·æœ¬é€šå¸¸æœ‰é™ï¼Œè€Œæ¨¡æ€å·®è·è¿‡å¤§ï¼Œå¯¼è‡´ç°æœ‰æ–¹æ³•æ— æ³•æœ‰æ•ˆæŒ–æ˜å¤šæ ·åŒ–çš„è·¨æ¨¡æ€çº¿ç´¢ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé™åˆ¶ï¼Œæˆ‘ä»¬åœ¨åµŒå…¥ç©ºé—´ä¸­æå‡ºäº†ä¸€ç§æ–°é¢–çš„å¢å¼ºç½‘ç»œï¼Œç§°ä¸ºå¤šæ ·åŒ–åµŒå…¥æ‰©å±•ç½‘ç»œï¼ˆDEENï¼‰ã€‚æ‰€æå‡ºçš„ DEEN å¯ä»¥æœ‰æ•ˆåœ°ç”Ÿæˆå¤šæ ·åŒ–çš„åµŒå…¥æ¥å­¦ä¹ ä¿¡æ¯ä¸°å¯Œçš„ç‰¹å¾è¡¨ç¤ºå¹¶å‡å°‘å¯è§å…‰å’Œçº¢å¤–å›¾åƒä¹‹é—´çš„æ¨¡æ€å·®å¼‚ã€‚æ­¤å¤–ï¼ŒVIReIDæ¨¡å‹å¯èƒ½ä¼šå—åˆ°å‰§çƒˆå…‰ç…§å˜åŒ–çš„ä¸¥é‡å½±å“ï¼Œè€Œæ‰€æœ‰ç°æœ‰çš„VIReIDæ•°æ®é›†éƒ½æ˜¯åœ¨è¶³å¤Ÿçš„å…‰ç…§ä¸‹æ•è·çš„ï¼Œæ²¡æœ‰æ˜æ˜¾çš„å…‰ç…§å˜åŒ–ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªä½å…‰è·¨æ¨¡æ€ï¼ˆLLCMï¼‰æ•°æ®é›†ï¼Œå…¶ä¸­åŒ…å«ç”± 9 ä¸ª RGB/IR ç›¸æœºæ•è·çš„ 1,064 ä¸ªèº«ä»½çš„ 46,767 ä¸ªè¾¹ç•Œæ¡†ã€‚åœ¨ SYSU-MM01ã€RegDB å’Œ LLCM æ•°æ®é›†ä¸Šè¿›è¡Œçš„å¤§é‡å®éªŒè¡¨æ˜ï¼Œæ‰€æå‡ºçš„ DEEN ç›¸å¯¹äºå…¶ä»–å‡ ç§æœ€å…ˆè¿›çš„æ–¹æ³•å…·æœ‰ä¼˜è¶Šæ€§ã€‚ä»£ç å’Œæ•°æ®é›†å‘å¸ƒäºï¼š https://github.com/ZYK100/LLCM ä¹‹å‰å·¥ä½œå­˜åœ¨çš„é—®é¢˜ ä¹‹å‰æ–¹æ³•ä¸»è¦é€šè¿‡ä¸¤ç§ç±»å‹çš„æ–¹æ³•æ¥å‡å°‘VI-ReIDé—®é¢˜ä¸­æ‰€å­˜åœ¨çš„æ¨¡æ€å·®å¼‚ã€‚ç‰¹å¾çº§æ–¹æ³•ï¼Œå›¾åƒçº§æ–¹æ³•ã€‚ä½†æ˜¯è¿™äº›æ–¹æ³•å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š ç‰¹å¾çº§æ–¹æ³•ï¼Œç”±äºæ¨¡æ€å·®å¼‚å¤§ï¼Œæ— æ³•ç›´æ¥æŠ•å…¥åˆ°ä¸€ä¸ªå…±äº«ç©ºé—´ä¸­å» è™½ç„¶å›¾åƒçº§æ–¹æ³•å¯ä»¥å‡å°‘æ¨¡æ€å·®å¼‚ï¼Œä½†ç”Ÿæˆçš„è·¨æ¨¡æ€å›¾åƒé€šå¸¸ä¼´æœ‰å™ªå£°ï¼Œè¿™æ˜¯ç”±äºç¼ºä¹VIS-IRå›¾åƒå¯¹æ‰€è‡´ã€‚ ä¸»è¦è´¡çŒ®/åˆ›æ–° æå‡ºäº†ä¸€ç§æ–°é¢–çš„å¤šæ ·åŒ–åµŒå…¥æ‰©å±•ï¼ˆDEEï¼‰æ¨¡å—ï¼Œå…·æœ‰ä¸­å¿ƒå¼•å¯¼å¯¹æŒ–æ˜ï¼ˆCPMï¼‰æŸå¤±ï¼Œä»¥ç”Ÿæˆæ›´å¤šåµŒå…¥æ¥å­¦ä¹ å¤šæ ·åŒ–çš„ç‰¹å¾è¡¨ç¤ºã€‚æˆ‘ä»¬æ˜¯ç¬¬ä¸€ä¸ªåœ¨ VIReID çš„åµŒå…¥ç©ºé—´ä¸­å¢å¼ºåµŒå…¥çš„äººã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜æå‡ºäº†ä¸€ç§æœ‰æ•ˆçš„å¤šçº§ç‰¹å¾èšåˆï¼ˆMFAï¼‰å—æ¥æŒ–æ˜æ½œåœ¨çš„é€šé“å’Œç©ºé—´ç‰¹å¾è¡¨ç¤ºã€‚ï¼ˆDEE MFA CPMï¼‰ é€šè¿‡å°† DEEã€CPM æŸå¤±å’Œ MFA çº³å…¥ç«¯åˆ°ç«¯å­¦ä¹ æ¡†æ¶ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§æœ‰æ•ˆçš„å¤šæ ·åŒ–åµŒå…¥æ‰©å±•ç½‘ç»œï¼ˆDEENï¼‰ï¼Œå¯ä»¥æœ‰æ•ˆå‡å°‘ VIS å’Œ IR å›¾åƒä¹‹é—´çš„æ¨¡æ€å·®å¼‚ã€‚ æˆ‘ä»¬æ”¶é›†äº†ä¸€ä¸ªä½å…‰è·¨æ¨¡æ€ï¼ˆLLCMï¼‰æ•°æ®é›†ï¼Œå…¶ä¸­åŒ…å«åœ¨å…‰ç…§å˜åŒ–å’Œä½ç…§åº¦ç¯å¢ƒä¸‹æ•è·çš„ 1,064 ä¸ªèº«ä»½çš„ 46,767 å¼ å›¾åƒã€‚ LLCMæ•°æ®é›†å…·æœ‰æ›´å¤šæ–°çš„é‡è¦ç‰¹å¾ï¼Œå¯ä»¥ä¿ƒè¿›VIReIDç ”ç©¶èµ°å‘å®é™…åº”ç”¨ã€‚ å¤§é‡å®éªŒè¡¨æ˜ï¼Œåœ¨ä¸‰ä¸ªå…·æœ‰æŒ‘æˆ˜æ€§çš„æ•°æ®é›†ä¸Šï¼Œæ‰€æå‡ºçš„ DEEN ä¼˜äº VIReID ä»»åŠ¡çš„å…¶ä»–æœ€å…ˆè¿›æ–¹æ³•ã€‚ æ–¹æ³• æ•´ä½“æµç¨‹å›¾ ä¸Šå›¾å±•ç¤ºäº†æ‰€æDEENç½‘ç»œçš„æµç¨‹æ¡†æ¶ï¼ŒåŒ…æ‹¬ DEE æ¨¡å—å’Œ MFA å—ã€‚ DEE æ¨¡å—å¯ä»¥é€šè¿‡æ–°é¢–çš„ CPM æŸå¤±ç”Ÿæˆæ›´å¤šåµŒå…¥ï¼Œä»¥å­¦ä¹ ä¸åŒçš„ç‰¹å¾è¡¨ç¤ºã€‚ MFA å—å¯ä»¥èšåˆæ¥è‡ªä¸åŒé˜¶æ®µçš„åµŒå…¥ï¼Œä»¥æŒ–æ˜ä¸åŒçš„é€šé“å’Œç©ºé—´ç‰¹å¾è¡¨ç¤ºã€‚ æ¨¡å‹æ¶æ„ ä¸Šå›¾æ¦‚è¿°äº†æ‰€æå‡ºçš„å¤šæ ·åŒ–åµŒå…¥æ‰©å±•ç½‘ç»œï¼ˆDEENï¼‰ï¼Œè¯¥ç½‘ç»œåˆ©ç”¨åŒæµ ResNet-50 ç½‘ç»œä½œä¸ºä¸»å¹²ã€‚VIS-IR ç‰¹å¾è¢«é¦ˆé€åˆ°æ‰€æå‡ºçš„å¤šæ ·åŒ–åµŒå…¥æ‰©å±•ï¼ˆDEEï¼‰ä¸­æ¨¡å—æ¥ç”Ÿæˆæ›´å¤šåµŒå…¥ã€‚ç„¶åï¼Œæå‡ºäº†ä¸­å¿ƒå¼•å¯¼å¯¹æŒ–æ˜ï¼ˆCPMï¼‰æŸå¤±ï¼Œä»¥ä½¿ç”Ÿæˆçš„åµŒå…¥å°½å¯èƒ½å¤šæ ·åŒ–ï¼Œä»¥å­¦ä¹ ä¿¡æ¯ä¸°å¯Œçš„ç‰¹å¾è¡¨ç¤ºã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬é‡‡ç”¨æœ‰æ•ˆçš„ MFA å—æ¥èšåˆä¸åŒé˜¶æ®µçš„ç‰¹å¾ï¼Œä»¥æŒ–æ˜ä¸åŒçš„é€šé“å’Œç©ºé—´ç‰¹å¾äº¤æ¶‰ã€‚åœ¨è®­ç»ƒé˜¶æ®µï¼Œæ‰¹é‡å½’ä¸€åŒ–ï¼ˆBNï¼‰å±‚ä¹‹å‰å’Œä¹‹åçš„æ‰€æœ‰ç‰¹å¾éƒ½è¢«è¾“å…¥åˆ°ä¸åŒçš„æŸå¤±ä¸­ï¼Œä»¥å…±åŒä¼˜åŒ– DEENã€‚ Diverse Embedding Expansion Moduleï¼ˆDEEï¼‰ æ‰€æå‡ºçš„DEEæ¨¡å—ç”¨äºç”Ÿæˆæ›´å¤šçš„åµŒå…¥ï¼Œä»¥ç¼“è§£ç”±äºè®­ç»ƒæ•°æ®ä¸è¶³è€Œå¸¦æ¥çš„é—®é¢˜ï¼Œè¯¥æ¨¡å—ä½¿ç”¨å¤šåˆ†æ”¯å·ç§¯ç”Ÿæˆç»“æ„ã€‚å…·ä½“æ¥è¯´ï¼Œå¯¹äºæ¯ä¸ªDEEåˆ†æ”¯ï¼Œæˆ‘ä»¬é¦–å…ˆä½¿ç”¨ä¸‰ä¸ª3x3çš„è†¨èƒ€å·ç§¯å±‚Ï†3Ã—31\\varphi_{3 \\times 3}^{1}Ï†3Ã—31â€‹ã€Ï†3Ã—32\\varphi_{3 \\times 3}^{2}Ï†3Ã—32â€‹ã€Ï†3Ã—33\\varphi_{3 \\times 3}^{3}Ï†3Ã—33â€‹ï¼Œè¿™äº›å±‚å…·æœ‰ä¸åŒçš„è†¨èƒ€æ¯”ç‡ï¼ˆ1, 2, 3ï¼‰ï¼Œä»¥å°†ç‰¹å¾å›¾ f\\mathbf{f}f çš„æ•°é‡å‡å°‘åˆ°å…¶è‡ªèº«å¤§å°çš„1/4ï¼Œç„¶åæˆ‘ä»¬é€šè¿‡å°†è¿™äº›ç‰¹å¾å›¾åˆå¹¶æˆä¸€ä¸ªç‰¹å¾å›¾æ¥è·å¾—ç‰¹å¾å›¾ï¼Œæ¥ç€é€šè¿‡ReLUæ¿€æ´»å±‚ FReLUF_{\\text{ReLU}}FReLUâ€‹ æ¥æé«˜DEEçš„éçº¿æ€§è¡¨ç¤ºèƒ½åŠ›ã€‚ç„¶åï¼Œå°†å¦ä¸€ä¸ªå·ç§¯å±‚ Î¸1Ã—1\\theta_{1 \\times 1}Î¸1Ã—1â€‹ åº”ç”¨äºè·å¾—çš„ç‰¹å¾å›¾ä»¥æ”¹å˜å…¶å°ºå¯¸ä¸ f\\mathbf{f}f ç›¸åŒã€‚å› æ­¤ï¼Œç¬¬ iii ä¸ªåˆ†æ”¯ç”Ÿæˆçš„åµŒå…¥ f+i\\mathbf{f}_{+}^{i}f+iâ€‹ å¯ä»¥å†™æˆå¦‚ä¸‹å½¢å¼ï¼š f+i=Î¸1Ã—1(FReLU(Ï†3Ã—31(f)+Ï†3Ã—32(f)+Ï†3Ã—33(f)))\\mathbf{f}_{+}^{i} = \\theta_{1 \\times 1} ( F_{\\text{ReLU}} (\\varphi_{3 \\times 3}^{1}(\\mathbf{f}) + \\varphi_{3 \\times 3}^{2}(\\mathbf{f}) + \\varphi_{3 \\times 3}^{3}(\\mathbf{f}))) f+iâ€‹=Î¸1Ã—1â€‹(FReLUâ€‹(Ï†3Ã—31â€‹(f)+Ï†3Ã—32â€‹(f)+Ï†3Ã—33â€‹(f))) ç„¶åï¼Œæ‰€æœ‰ç”Ÿæˆçš„åµŒå…¥è¢«è¿æ¥åœ¨ä¸€èµ·å¹¶ç”¨ä½œéª¨å¹²ç½‘ç»œä¸‹ä¸€é˜¶æ®µçš„è¾“å…¥ã€‚ ä»£ç å®ç°å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031class DEE_module(nn.Module): def __init__(self, channel, reduction=16): super(DEE_module, self).__init__() self.FC11 = nn.Conv2d(channel, channel//4, kernel_size=3, stride=1, padding=1, bias=False, dilation=1) self.FC11.apply(weights_init_kaiming) self.FC12 = nn.Conv2d(channel, channel//4, kernel_size=3, stride=1, padding=2, bias=False, dilation=2) self.FC12.apply(weights_init_kaiming) self.FC13 = nn.Conv2d(channel, channel//4, kernel_size=3, stride=1, padding=3, bias=False, dilation=3) self.FC13.apply(weights_init_kaiming) self.FC1 = nn.Conv2d(channel//4, channel, kernel_size=1) self.FC1.apply(weights_init_kaiming) self.FC21 = nn.Conv2d(channel, channel//4, kernel_size=3, stride=1, padding=1, bias=False, dilation=1) self.FC21.apply(weights_init_kaiming) self.FC22 = nn.Conv2d(channel, channel//4, kernel_size=3, stride=1, padding=2, bias=False, dilation=2) self.FC22.apply(weights_init_kaiming) self.FC23 = nn.Conv2d(channel, channel//4, kernel_size=3, stride=1, padding=3, bias=False, dilation=3) self.FC23.apply(weights_init_kaiming) self.FC2 = nn.Conv2d(channel//4, channel, kernel_size=1) self.FC2.apply(weights_init_kaiming) self.dropout = nn.Dropout(p=0.01) def forward(self, x): x1 = (self.FC11(x) + self.FC12(x) + self.FC13(x))/3 x1 = self.FC1(F.relu(x1)) x2 = (self.FC21(x) + self.FC22(x) + self.FC23(x))/3 x2 = self.FC2(F.relu(x2)) out = torch.cat((x, x1, x2), 0) out = self.dropout(out) return out FCnmçš„ä¸»è¦å·®åˆ«åœ¨ä¸åŒçš„dilationå’Œä¸åŒçš„paddingå¤§å° Center-Guided Pair Mining Loss(CPM) ä»ä¸Šé¢çš„æ“ä½œå¯ä»¥çœ‹å‡ºï¼ŒDEE æ¨¡å—åªèƒ½ä½¿ç”¨å¤šåˆ†æ”¯å·ç§¯å—ç”Ÿæˆæ›´å¤šçš„åµŒå…¥ã€‚ç„¶è€Œï¼Œè¯¥æ“ä½œæ— æ³•æœ‰æ•ˆåœ°è·å¾—å¤šæ ·åŒ–çš„åµŒå…¥ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”ç”¨ä»¥ä¸‹ä¸‰ä¸ªå±æ€§æ¥é™åˆ¶ç”Ÿæˆçš„åµŒå…¥å°½å¯èƒ½å¤šæ ·åŒ–ï¼Œä»¥æœ‰æ•ˆå‡å°‘å¯è§å…‰å’Œçº¢å¤–å›¾åƒä¹‹é—´çš„æ¨¡æ€å·®å¼‚ï¼š ç”Ÿæˆçš„embeddingåº”è¯¥å°½å¯èƒ½å¤šæ ·åŒ–ï¼Œä»¥æœ‰æ•ˆåœ°å­¦ä¹ ä¿¡æ¯ä¸°å¯Œçš„ç‰¹å¾è¡¨ç¤ºã€‚ï¼ˆæ„å‘³ç›®æ ‡å‡½æ•°éœ€è¦æ‹‰å¼€ç”Ÿæˆembeddingå’ŒåŸå§‹embeddingä¹‹é—´çš„è·ç¦»ï¼‰ ç”Ÿæˆçš„embeddingåº”æœ‰åŠ©äºå‡å°‘å¯è§å…‰å’Œçº¢å¤–å›¾åƒä¹‹é—´çš„æ¨¡æ€å·®å¼‚ã€‚ï¼ˆæ„å‘³ç›®æ ‡å‡½æ•°éœ€è¦æ‹‰è¿‘VISç”Ÿæˆembeddingå’ŒIRåŸå§‹embeddingçš„è·ç¦»ï¼Œä»¥åŠ IRç”Ÿæˆembeddingå’ŒVISåŸå§‹embeddingçš„è·ç¦»ï¼‰ ç±»å†…è·ç¦»åº”è¯¥å°äºç±»é—´è·ç¦»ï¼ˆç”±äºä¸Šé¢ç¬¬äºŒç‚¹çš„ä½œç”¨ï¼Œå¯èƒ½ä¼šå¯¼è‡´ä¸åŒçš„æ¨¡æ€ä¹‹é—´çš„è·ç¦»ä¼šå°äºç›¸åŒæ¨¡æ€ä¹‹é—´çš„è·ç¦»ã€‚è¿™æ˜¯ä¸å¥½çš„ï¼Œéœ€è¦æ»¡è¶³ç¬¬ä¸‰ç‚¹ï¼‰ã€‚ ä¸Šå›¾ä¸ºCPMçš„å·¥ä½œç¤ºæ„å›¾ï¼Œå¯¹äºç”±VISæ¨¡æ€ç”Ÿæˆçš„åµŒå…¥ï¼ŒCPMæŸå¤±å¯ä»¥è¡¨ç¤ºä¸ºï¼š L(fv,fn,fv+i)=[D(fnj,fv+i,j)âˆ’D(fvj,fv+i,j)âˆ’D(fvj,fvk)]+,(2)\\mathcal{L}(f_v, f_n, f_{v+}^{i}) = [D(f_{n}^{j}, f_{v+}^{i,j}) - D(f_{v}^{j}, f_{v+}^{i,j}) - D(f_{v}^{j}, f_{v}^{k})]_{+}, \\quad (2) L(fvâ€‹,fnâ€‹,fv+iâ€‹)=[D(fnjâ€‹,fv+i,jâ€‹)âˆ’D(fvjâ€‹,fv+i,jâ€‹)âˆ’D(fvjâ€‹,fvkâ€‹)]+â€‹,(2) å…¶ä¸­ D(â‹…,â‹…)D(\\cdot, \\cdot)D(â‹…,â‹…) æ˜¯ä¸¤ä¸ªåµŒå…¥ä¹‹é—´çš„æ¬§å‡ é‡Œå¾—è·ç¦»ã€‚fvf_vfvâ€‹ å’Œ fnf_nfnâ€‹ æ˜¯æ¥è‡ªVISå’ŒIRæ¨¡æ€çš„åŸå§‹åµŒå…¥ï¼Œfv+if_{v+}^{i}fv+iâ€‹ æ˜¯ä»VISæ¨¡æ€çš„ç¬¬iä¸ªåˆ†æ”¯ç”Ÿæˆçš„åµŒå…¥ã€‚jå’Œkæ˜¯minibatchä¸­çš„ä¸åŒèº«ä»½ï¼Œä¸” [z]+=maxâ¡(z,0)[z]_{+} = \\max(z, 0)[z]+â€‹=max(z,0)ã€‚åœ¨å…¬å¼ï¼ˆ2ï¼‰ä¸­ï¼Œç¬¬ä¸€ä¸ªé¡¹å¯ä»¥å°†ç”Ÿæˆçš„åµŒå…¥ fv+if_{v+}^{i}fv+iâ€‹ å‘åŸå§‹IRçš„åµŒå…¥ fnf_nfnâ€‹ æ‹‰è¿‘ï¼Œä»¥å‡å°‘ fv+if_{v+}^{i}fv+iâ€‹ å’Œ fnf_nfnâ€‹ ä¹‹é—´çš„æ¨¡æ€å·®å¼‚ã€‚ç¬¬äºŒé¡¹å¯ä»¥å°†ç”Ÿæˆçš„åµŒå…¥ fv+f_{v+}fv+â€‹ æ¨ç¦»VISçš„åµŒå…¥ fvf_vfvâ€‹ï¼Œä»¥ä½¿ fvf_vfvâ€‹ å­¦ä¹ åˆ°ä¿¡æ¯ä¸°å¯Œçš„ç‰¹å¾è¡¨ç¤ºã€‚ç¬¬ä¸‰é¡¹å¯ä»¥ä½¿ç±»å†…è·ç¦»å°äºç±»é—´è·ç¦»ã€‚ ç„¶åï¼Œæˆ‘ä»¬ä½¿ç”¨æ¯ä¸ªç±»çš„åµŒå…¥ä¸­å¿ƒ cvc_vcvâ€‹ å’Œ cnc_ncnâ€‹ æ¥ä½¿ç”Ÿæˆçš„åµŒå…¥ä¸­å¿ƒ cv+ic_{v+}^{i}cv+iâ€‹ å’Œ cn+ic_{n+}^{i}cn+iâ€‹ æ›´å…·åˆ¤åˆ«åŠ›ï¼Œå¹¶å¼•å…¥ä¸€ä¸ªè¾¹è·é¡¹ Î±\\alphaÎ± æ¥å¹³è¡¡å…¬å¼ï¼ˆ2ï¼‰ä¸­çš„ä¸‰ä¸ªé¡¹ã€‚å› æ­¤ï¼Œå¯¹äºæ¥è‡ªVISçš„åµŒå…¥ï¼ŒCPMæŸå¤±è¡¨ç¤ºä¸ºï¼š L(cv,cn,cv+i)=[D(cnj,cv+i,j)âˆ’D(cvj,cv+i,j)âˆ’D(cvj,cvk)+Î±]+,(3)\\mathcal{L}(c_v, c_n, c_{v+}^{i}) = [D(c_{n}^{j}, c_{v+}^{i,j}) - D(c_{v}^{j}, c_{v+}^{i,j}) - D(c_{v}^{j}, c_{v}^{k}) + \\alpha]_{+}, \\quad (3) L(cvâ€‹,cnâ€‹,cv+iâ€‹)=[D(cnjâ€‹,cv+i,jâ€‹)âˆ’D(cvjâ€‹,cv+i,jâ€‹)âˆ’D(cvjâ€‹,cvkâ€‹)+Î±]+â€‹,(3) ç±»ä¼¼åœ°ï¼Œå¯¹äºç”±IRç”Ÿæˆçš„åµŒå…¥çš„ç±»ä¸­å¿ƒ cn+ic_{n+}^{i}cn+iâ€‹ï¼Œæˆ‘ä»¬æœ‰ï¼š L(cv,cn,cn+i)=[D(cv,cn+j)âˆ’D(cn,cn+j)âˆ’D(cnj,cnk)+Î±]+,(4)\\mathcal{L}(c_v, c_n, c_{n+}^{i}) = [D(c_{v}, c_{n+}^{j}) - D(c_{n}, c_{n+}^{j}) - D(c_{n}^{j}, c_{n}^{k}) + \\alpha]_{+}, \\quad (4) L(cvâ€‹,cnâ€‹,cn+iâ€‹)=[D(cvâ€‹,cn+jâ€‹)âˆ’D(cnâ€‹,cn+jâ€‹)âˆ’D(cnjâ€‹,cnkâ€‹)+Î±]+â€‹,(4) å› æ­¤ï¼Œæœ€ç»ˆçš„CPMæŸå¤±å¯ä»¥è¡¨ç¤ºä¸ºï¼š Lcpm=L(cv,cn,cv+i)+L(cv,cn,cn+i).(5)\\mathcal{L}_{cpm} = \\mathcal{L}(c_v, c_n, c_{v+}^{i}) + \\mathcal{L}(c_v, c_n, c_{n+}^{i}). \\quad (5) Lcpmâ€‹=L(cvâ€‹,cnâ€‹,cv+iâ€‹)+L(cvâ€‹,cnâ€‹,cn+iâ€‹).(5) æ­¤å¤–ï¼Œä¸ºäº†ç¡®ä¿ä¸åŒåˆ†æ”¯ç”Ÿæˆçš„åµŒå…¥èƒ½å¤Ÿæ•è·ä¸åŒçš„ä¿¡æ¯ä¸°å¯Œçš„ç‰¹å¾è¡¨ç¤ºï¼Œæˆ‘ä»¬å¼ºåˆ¶è¿™äº›ä¸åŒåˆ†æ”¯ç”Ÿæˆçš„åµŒå…¥å½¼æ­¤æ­£äº¤ï¼Œä»¥æœ€å°åŒ–é‡å å…ƒç´ ã€‚å› æ­¤ï¼Œæ­£äº¤æŸå¤±å¯ä»¥è¡¨ç¤ºä¸ºï¼š Lort=âˆ‘m=1iâˆ’1âˆ‘n=m+1i(f+mTf+n),(6)\\mathcal{L}_{ort} = \\sum_{m=1}^{i-1} \\sum_{n=m+1}^{i} (\\mathbf{f}_{+}^{m{T}} \\mathbf{f}_{+}^{n}), \\quad (6) Lortâ€‹=m=1âˆ‘iâˆ’1â€‹n=m+1âˆ‘iâ€‹(f+mTâ€‹f+nâ€‹),(6) å…¶ä¸­m,nm,nm,nåˆ†åˆ«ä»£è¡¨çš„æ˜¯ç¬¬å‡ ä¸ªåˆ†æ”¯ç”Ÿæˆçš„embeddingã€‚ æˆ‘ä»¬è®¤ä¸ºé€šè¿‡æ­£äº¤æŸå¤±å¯ä»¥å¼ºåˆ¶ç”Ÿæˆçš„åµŒå…¥å­¦ä¹ æ›´å¤šä¿¡æ¯çš„ç‰¹å¾è¡¨ç¤ºã€‚ Multistage Feature Aggregation Blockï¼ˆMFAï¼‰ ä¸åŒå±‚æ¬¡ç‰¹å¾çš„èšåˆå·²è¢«è¯æ˜å¯¹è¯­ä¹‰åˆ†å‰²ã€åˆ†ç±»å’Œæ£€æµ‹ä»»åŠ¡æœ‰å¸®åŠ©ã€‚ä¸ºäº†ä»ä¸åŒé˜¶æ®µèšåˆç‰¹å¾ä»¥æŒ–æ˜å¤šæ ·çš„é€šé“çº§å’Œç©ºé—´ç‰¹å¾è¡¨ç¤ºï¼Œæˆ‘ä»¬ç»“åˆäº†ä¸€ä¸ªæœ‰æ•ˆçš„é€šé“-ç©ºé—´å¤šé˜¶æ®µç‰¹å¾èšåˆï¼ˆMFAï¼‰æ¨¡å—ï¼Œä»¥èšåˆå¤šé˜¶æ®µç‰¹å¾ï¼Œçµæ„Ÿæ¥è‡ªäºã€‚ æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è¯¦ç»†é˜è¿°äº†MFAæ¨¡å—çš„ç»†èŠ‚ï¼Œå¦‚ä¸Šå›¾æ‰€ç¤ºã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬åœ¨éª¨å¹²ç½‘ç»œçš„æ¯ä¸ªé˜¶æ®µä¸ºé€šé“-ç©ºé—´èšåˆæ¨¡å—è€ƒè™‘äº†ä¸¤ç§ç±»å‹çš„æºç‰¹å¾ï¼šé˜¶æ®µå‰çš„ä½çº§ç‰¹å¾å›¾ flâˆˆRClÃ—HlÃ—Wl\\mathbf{f}_{l} \\in \\mathbb{R}^{C_{l} \\times H_{l} \\times W_{l}}flâ€‹âˆˆRClâ€‹Ã—Hlâ€‹Ã—Wlâ€‹ å’Œé˜¶æ®µåçš„é«˜çº§ç‰¹å¾å›¾ fhâˆˆRChÃ—HhÃ—Wh\\mathbf{f}_{h} \\in \\mathbb{R}^{C_{h} \\times H_{h} \\times W_{h}}fhâ€‹âˆˆRChâ€‹Ã—Hhâ€‹Ã—Whâ€‹ï¼Œå…¶ä¸­Cã€Wå’ŒHåˆ†åˆ«è¡¨ç¤ºé€šé“æ•°ã€å®½åº¦å’Œé«˜åº¦ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸‰ä¸ª1x1å·ç§¯å±‚ Ïˆq1,Ïˆv1,Ïˆk1\\psi_{q}^{1}, \\psi_{v}^{1}, \\psi_{k}^{1}Ïˆq1â€‹,Ïˆv1â€‹,Ïˆk1â€‹ å°† f\\mathbf{f}f è½¬æ¢ä¸ºä¸‰ä¸ªç´§å‡‘çš„åµŒå…¥ï¼šÏˆq1(fh)\\psi_{q}^{1}(\\mathbf{f}_{h})Ïˆq1â€‹(fhâ€‹), Ïˆv1(fl)\\psi_{v}^{1}(\\mathbf{f}_{l})Ïˆv1â€‹(flâ€‹) å’Œ Ïˆk1(fl)\\psi_{k}^{1}(\\mathbf{f}_{l})Ïˆk1â€‹(flâ€‹)ã€‚ç„¶åï¼Œé€šè¿‡çŸ©é˜µä¹˜æ³•å’Œsoftmaxè®¡ç®—é€šé“ç›¸ä¼¼åº¦çŸ©é˜µ McâˆˆRCâ€²Ã—Câ€²\\mathbf{M}^{c} \\in \\mathbb{R}^{C&#x27; \\times C&#x27;}McâˆˆRCâ€²Ã—Câ€²ï¼š Mc=Fsoftmax(Ïˆq1(fh)Ã—Ïˆk1(fl)).(7)\\mathbf{M}^{c} = F_{\\text{softmax}}(\\psi_{q}^{1}(\\mathbf{f}_{h}) \\times \\psi_{k}^{1}(\\mathbf{f}_{l})). \\quad (7) Mc=Fsoftmaxâ€‹(Ïˆq1â€‹(fhâ€‹)Ã—Ïˆk1â€‹(flâ€‹)).(7) å› æ­¤ï¼Œæˆ‘ä»¬é€šè¿‡çŸ©é˜µä¹˜æ³•æ¢å¤ Ïˆv1(fl)\\psi_{v}^{1}(\\mathbf{f}_{l})Ïˆv1â€‹(flâ€‹) å’Œ Mc\\mathbf{M}^{c}Mc çš„é€šé“ç»´åº¦æ¥å®ç°é€šé“çº§å¤šé˜¶æ®µç‰¹å¾èšåˆã€‚åœ¨è¿™ä¹‹åï¼Œå¦ä¸€ä¸ª1x1å·ç§¯å±‚ Ï‰c\\omega^{c}Ï‰c è¢«åº”ç”¨äºå°†ä¸Šè¿°ç‰¹å¾å›¾çš„å°ºå¯¸è½¬æ¢ä¸º fh\\mathbf{f}_{h}fhâ€‹ çš„å°ºå¯¸ã€‚æœ€åï¼Œæˆ‘ä»¬é€šè¿‡çŸ©é˜µåŠ æ³•å°† fh\\mathbf{f}_{h}fhâ€‹ åŠ åˆ°å®ƒä¸Šé¢æ¥è·å¾—è¾“å‡ºï¼š fhc=Ï‰c(Ïˆv1(fl)Ã—Mc)+fh.(8)\\mathbf{f}_{h}^{c} = \\omega^{c}(\\psi_{v}^{1}(\\mathbf{f}_{l}) \\times \\mathbf{M}^{c}) + \\mathbf{f}_{h}. \\quad (8) fhcâ€‹=Ï‰c(Ïˆv1â€‹(flâ€‹)Ã—Mc)+fhâ€‹.(8) ä¹‹åï¼Œé€šè¿‡ä¸Šè¿°æ“ä½œè·å¾—çš„ fhc\\mathbf{f}_{h}^{c}fhcâ€‹ å’Œä½çº§ç‰¹å¾å›¾ fl\\mathbf{f}_{l}flâ€‹ è¢«ç”¨æ¥æ‰§è¡Œç©ºé—´ç‰¹å¾èšåˆæ“ä½œï¼Œè¿™ç±»ä¼¼äºé€šé“çº§å¤šé˜¶æ®µç‰¹å¾èšåˆæ“ä½œã€‚æœ€åï¼Œæˆ‘ä»¬å¾—åˆ°MFAçš„è¾“å‡ºå¦‚ä¸‹ï¼š fss=Ï‰s(Ïˆv2(fl)Ã—Ms)+fh,(9)\\mathbf{f}_{s}^{s} = \\omega^{s}(\\psi_{v}^{2}(\\mathbf{f}_{l}) \\times \\mathbf{M}^{s}) + \\mathbf{f}_{h}, \\quad (9) fssâ€‹=Ï‰s(Ïˆv2â€‹(flâ€‹)Ã—Ms)+fhâ€‹,(9) å…¶ä¸­ Ï‰s\\omega^{s}Ï‰s å’Œ Ïˆv2\\psi_{v}^{2}Ïˆv2â€‹ æ˜¯ä¸¤ä¸ª1x1å·ç§¯å±‚ï¼ŒMs\\mathbf{M}^{s}Ms æ˜¯ç©ºé—´ç›¸ä¼¼åº¦çŸ©é˜µã€‚ Multi-Loss Optimization é™¤äº†æ‰€æå‡ºçš„ Lcpm\\mathcal{L}_{cpm}Lcpmâ€‹ å’Œ Lort\\mathcal{L}_{ort}Lortâ€‹ å¤–ï¼Œæˆ‘ä»¬è¿˜ç»“åˆäº†äº¤å‰ç†µæŸå¤± Lce\\mathcal{L}_{ce}Lceâ€‹ å’Œä¸‰é‡æ€æŸå¤± Ltri\\mathcal{L}_{tri}Ltriâ€‹ ä»¥ç«¯åˆ°ç«¯çš„æ–¹å¼è”åˆä¼˜åŒ–ç½‘ç»œï¼Œé€šè¿‡æœ€å°åŒ–è¿™å››ä¸ªæŸå¤±çš„æ€»å’Œ Ltotal\\mathcal{L}_{total}Ltotalâ€‹ï¼Œå…¶å…¬å¼å¦‚ä¸‹ï¼š Ltotal=Lce+Ltri+Î»1Lcpm+Î»2Lort,(10)\\mathcal{L}_{total} = \\mathcal{L}_{ce} + \\mathcal{L}_{tri} + \\lambda_1 \\mathcal{L}_{cpm} + \\lambda_2 \\mathcal{L}_{ort}, \\quad (10) Ltotalâ€‹=Lceâ€‹+Ltriâ€‹+Î»1â€‹Lcpmâ€‹+Î»2â€‹Lortâ€‹,(10) å…¶ä¸­ Î»1\\lambda_1Î»1â€‹ å’Œ Î»2\\lambda_2Î»2â€‹ æ˜¯æ§åˆ¶æŸå¤±é¡¹ç›¸å¯¹é‡è¦æ€§çš„ç³»æ•°ã€‚ LLCMæ•°æ®é›† ç®€ä»‹ åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æ”¶é›†äº†ä¸€ä¸ªæ–°çš„å…·æœ‰æŒ‘æˆ˜æ€§çš„ä½å…‰è·¨æ¨¡æ€æ•°æ®é›†ï¼Œç§°ä¸º LLCM æ•°æ®é›†ã€‚ LLCMæ•°æ®é›†åˆ©ç”¨éƒ¨ç½²åœ¨å¼±å…‰ç¯å¢ƒä¸­çš„9ä¸ªæ‘„åƒå¤´ç½‘ç»œï¼Œå¯ä»¥åœ¨ç™½å¤©æ•è·VISå›¾åƒï¼Œåœ¨å¤œé—´æ•è·IRå›¾åƒã€‚ä¸ºäº†ä¿æŠ¤ä¸ªäººéšç§ä¿¡æ¯ï¼Œæˆ‘ä»¬åˆ©ç”¨ MTCNNæ¥è·å–äººè„¸çš„è¾¹ç•Œæ¡†å¹¶æ¨¡ç³Šè¿™äº›åŒºåŸŸã€‚æˆ‘ä»¬ç¡®ä¿æ¯ä¸ªå¸¦æ³¨é‡Šçš„èº«ä»½éƒ½è¢«å¯è§å…‰å’Œçº¢å¤–æ‘„åƒæœºæ•è·ã€‚ä¸Šå›¾æ˜¾ç¤ºäº† LLCM æ•°æ®é›†çš„ä¸€äº›ç¤ºä¾‹ã€‚ä¸ç°æœ‰çš„VIReIDæ•°æ®é›†ç›¸æ¯”ï¼ŒLLCMæ•°æ®é›†å…·æœ‰ä»¥ä¸‹æ–°çš„é‡è¦ç‰¹å¾ï¼šé¦–å…ˆï¼ŒLLCMæ•°æ®é›†ä¸­çš„å›¾åƒæ˜¯åœ¨VISå’ŒIRæ¨¡æ€çš„å¤æ‚ä½å…‰ç¯å¢ƒä¸‹æ•è·çš„ï¼Œå…¶ä¸­åŒ…å«ä¸¥é‡çš„å…‰ç…§å˜åŒ–å’Œæ˜¯ç°å®åœºæ™¯ä¸­å¸¸è§çš„é—®é¢˜ã€‚å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œæ¶åŠ£çš„å…‰ç…§æ¡ä»¶ä¼šæ”¹å˜äººè¡£æœçš„é¢œè‰²å¹¶å¯¼è‡´è¡£æœçº¹ç†ä¿¡æ¯çš„ä¸¢å¤±ï¼Œè¿™ç»™VIReIDå¸¦æ¥äº†å·¨å¤§çš„æŒ‘æˆ˜ã€‚å…¶æ¬¡ï¼ŒLLCM æ•°æ®é›†å…·æœ‰å¤§é‡çš„èº«ä»½å’Œè¾¹ç•Œæ¡†ã€‚è¯¥æ•°æ®é›†åŒ…å« 1,064 ä¸ªèº«ä»½çš„ 46,767 ä¸ªè¾¹ç•Œæ¡†ï¼Œä½¿å…¶æˆä¸ºç›®å‰æœ€å¤§çš„ VIReID æ•°æ®é›†ã€‚ç¬¬ä¸‰ï¼ŒLLCMæ•°æ®é›†æ˜¯ä»ä¸€æœˆåˆ°å››æœˆçš„100å¤šå¤©æ”¶é›†çš„ï¼Œè€ƒè™‘äº†ä¸åŒçš„æ°”å€™æ¡ä»¶å’Œå¸ƒæ–™é£æ ¼ã€‚é•¿æœŸæ•°æ®æ”¶é›†æœ‰åŠ©äºç ”ç©¶ä¸åŒæ°”å€™å’Œæœè£…é£æ ¼ä¸‹çš„ VIReID ä»»åŠ¡ï¼Œä»è€Œå¢åŠ äº† VIReID æ¨¡å‹çš„æ³›åŒ–æ€§ã€‚ è¯„ä¼°åè®® æˆ‘ä»¬å°†LLCMæ•°æ®é›†æŒ‰çº¦2:1çš„æ¯”ä¾‹åˆ’åˆ†ä¸ºè®­ç»ƒé›†å’Œæµ‹è¯•é›†ã€‚è®­ç»ƒé›†åŒ…å«30,921ä¸ªè¾¹ç•Œæ¡†ï¼Œå…±713ä¸ªèº«ä»½ï¼ˆå…¶ä¸­16,946ä¸ªè¾¹ç•Œæ¡†æ¥è‡ªå¯è§å…‰ï¼ˆVISï¼‰æ¨¡æ€ï¼Œ13,975ä¸ªè¾¹ç•Œæ¡†æ¥è‡ªçº¢å¤–ï¼ˆIRï¼‰æ¨¡æ€ï¼‰ï¼›æµ‹è¯•é›†åŒ…å«13,909ä¸ªè¾¹ç•Œæ¡†ï¼Œå…±351ä¸ªèº«ä»½ï¼ˆå…¶ä¸­8,680ä¸ªè¾¹ç•Œæ¡†æ¥è‡ªå¯è§å…‰æ¨¡æ€ï¼Œ7,166ä¸ªè¾¹ç•Œæ¡†æ¥è‡ªçº¢å¤–æ¨¡æ€ï¼‰ã€‚ä¸RegDBæ•°æ®é›†ç›¸ä¼¼ï¼Œæˆ‘ä»¬ä½¿ç”¨ä»å¯è§å…‰åˆ°çº¢å¤–ï¼ˆVIS to IRï¼‰å’Œä»çº¢å¤–åˆ°å¯è§å…‰ï¼ˆIR to VISï¼‰ä¸¤ç§æ¨¡å¼è¯„ä¼°VI-ReIDæ¨¡å‹çš„æ€§èƒ½ã€‚åœ¨æµ‹è¯•é˜¶æ®µï¼Œæˆ‘ä»¬éšæœºé€‰æ‹©æ¯ä¸ªèº«ä»½çš„ä¸€ä¸ªå›¾åƒï¼Œå½¢æˆç”»å»Šé›†ç”¨äºæ¨¡å‹æ€§èƒ½çš„è¯„ä¼°ã€‚æˆ‘ä»¬éšæœºåˆ†å‰²ç”»å»Šé›†å¹¶è¿›è¡Œ10æ¬¡ä»¥ä¸Šçš„è¯„ä¼°ï¼ŒæŠ¥å‘Šå¹³å‡æ€§èƒ½ã€‚ å®éªŒç»“æœ å¯ä»¥çœ‹åˆ°DEENåœ¨ä¸‰ä¸ªæ•°æ®é›†ä¸Šç›¸æ¯”ä¹‹å‰çš„æ–¹æ³•éƒ½å–å¾—äº†SOTAçš„æ•ˆæœ æ¶ˆèå®éªŒ å„ç»„ä»¶æ¶ˆè ä¸ºäº†è¯„ä¼°DEENä¸­å„ç»„ä»¶çš„è´¡çŒ®ï¼Œè¿›è¡Œäº†æ¶ˆèç ”ç©¶ã€‚ç»“æœæ˜¾ç¤ºï¼Œå°½ç®¡DEEæ¨¡å—ç•¥å¾®æå‡äº†åŸºçº¿æ€§èƒ½ï¼Œä½†æ•ˆæœæœ‰é™ã€‚ç„¶è€Œï¼Œç»“åˆCPMæŸå¤±åï¼ŒDEEæ˜¾è‘—æå‡äº†æ¨¡å‹æ€§èƒ½ï¼Œå¹¶å‡å°‘äº†VISå’ŒIRå›¾åƒä¹‹é—´çš„æ¨¡æ€å·®å¼‚ã€‚æ­¤å¤–ï¼ŒMFAæ¨¡å—é€šè¿‡èšåˆä¸åŒé˜¶æ®µçš„ç‰¹å¾ï¼Œè¿›ä¸€æ­¥æé«˜äº†æ€§èƒ½ã€‚ç»¼åˆDEEã€CPMå’ŒMFAçš„ç«¯åˆ°ç«¯å­¦ä¹ æ¡†æ¶åœ¨ä¸¤ä¸ªå…·æœ‰æŒ‘æˆ˜æ€§çš„VIRReIDæ•°æ®é›†ä¸Šè¡¨ç°å‡ºæ˜¾è‘—çš„æ€§èƒ½æå‡ï¼Œè¡¨æ˜è¿™äº›æ¨¡å—èƒ½äº’ç›¸å—ç›Šï¼Œç”Ÿæˆå¤šæ ·åŒ–çš„åµŒå…¥ã€‚ DEEæ’å…¥ä½ç½®æ¶ˆè å®éªŒç ”ç©¶äº†åœ¨ResNet-50çš„ä¸åŒé˜¶æ®µæ’å…¥DEEæ¨¡å—å¯¹DEENæ€§èƒ½çš„å½±å“ã€‚ç»“æœè¡¨æ˜ï¼Œå½“DEEæ¨¡å—æ’å…¥åœ¨stage-0åˆ°stage-3ä¹‹åæ—¶ï¼Œæ€§èƒ½é€æ­¥æé«˜ï¼Œè¯´æ˜æ¨¡æ€å·®è·å‡å°‘ï¼ŒDEEåœ¨ç½‘ç»œæ›´æ·±å±‚çš„ç”Ÿæˆèƒ½åŠ›æ›´å¼ºã€‚åœ¨stage-3ä¹‹åæ’å…¥DEEåœ¨LLCMå’ŒSYSU-MM01æ•°æ®é›†ä¸Šè¾¾åˆ°äº†æœ€ä½³æ•ˆæœã€‚ç„¶è€Œï¼Œåœ¨stage-4ä¹‹åæ’å…¥DEEæ—¶ï¼Œæ€§èƒ½æ˜¾è‘—ä¸‹é™ï¼Œå› ä¸ºCPMæŸå¤±ç›´æ¥ä½œç”¨äºåµŒå…¥ï¼Œå¢å¤§äº†ç”ŸæˆåµŒå…¥ä¸åŸå§‹åµŒå…¥ä¹‹é—´çš„è·ç¦»ï¼Œå¢åŠ äº†æ¨¡å‹ä¼˜åŒ–éš¾åº¦ã€‚å› æ­¤ï¼Œé™¤éç‰¹åˆ«æŒ‡å®šï¼Œæˆ‘ä»¬é»˜è®¤å°†DEEæ’å…¥åœ¨ResNet-50çš„stage-3ä¹‹åã€‚ DEEåˆ†æ”¯æ•°æ¶ˆè ç ”ç©¶è¡¨æ˜ï¼ŒDEEæ¨¡å—çš„æ€§èƒ½éšç€åˆ†æ”¯æ•°é‡ä»2å¢åŠ åˆ°3è€Œé€æ¸æé«˜ï¼Œå› ç”Ÿæˆäº†æ›´å¤šçš„åµŒå…¥æ¥å‡å°‘æ¨¡æ€å·®è·ã€‚ç„¶è€Œï¼Œå½“åˆ†æ”¯æ•°é‡è¶…è¿‡3æ—¶ï¼Œæ€§èƒ½å› å†—ä½™ç‰¹å¾è¿‡å¤šè€Œä¸‹é™ã€‚å› æ­¤ï¼Œå…·æœ‰ä¸‰ä¸ªåˆ†æ”¯çš„DEEåœ¨LLCMå’ŒSYSU-MM01æ•°æ®é›†ä¸Šè¡¨ç°æœ€ä½³ï¼Œè¡¨æ˜è¿™æ˜¯ç”Ÿæˆå¤šæ ·åŒ–åµŒå…¥çš„æœ€ä½³é…ç½®ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼ŒDEEæ¨¡å—ä½¿ç”¨ä¸‰ä¸ªåˆ†æ”¯ã€‚ MFAä¸NLå¯¹æ¯”æ¶ˆè ä¸Šè¡¨å®éªŒç»“æœè¡¨æ˜ï¼ŒMFAå—æ¯”Non-Localå—åœ¨Rank-1å‡†ç¡®ç‡å’ŒmAPä¸Šåˆ†åˆ«é«˜å‡º1.1%å’Œ2.2%ï¼ŒéªŒè¯äº†MFAå—çš„æœ‰æ•ˆæ€§ã€‚æ­¤å¤–ï¼ŒMFAå—å’ŒDEEæ¨¡å—åœ¨ç”Ÿæˆå¤šæ ·åŒ–åµŒå…¥ã€å‡å°‘VISå’ŒIRå›¾åƒä¹‹é—´çš„æ¨¡æ€å·®è·æ–¹é¢ç›¸è¾…ç›¸æˆã€‚ è¶…å‚æ•°æ¶ˆè ä¸»è¦æ˜¯å¯¹Î»1\\lambda_1Î»1â€‹,Î»2\\lambda_2Î»2â€‹å’ŒÎ±\\alphaÎ±ä¸‰ä¸ªè¶…å‚æ•°è¿›è¡Œæ¶ˆèå®éªŒï¼Œæœ€åå‘ç°Î»1=0.8\\lambda_1=0.8Î»1â€‹=0.8ï¼ŒÎ»2=0.1\\lambda_2=0.1Î»2â€‹=0.1ï¼ŒÎ±=0.2\\alpha=0.2Î±=0.2èƒ½å¤Ÿå–å¾—æ›´å¥½çš„å®éªŒç»“æœã€‚ å¯è§†åŒ– ç‰¹å¾åˆ†å¸ƒ ä¸ºäº†ç ”ç©¶ DEEN æœ‰æ•ˆçš„åŸå› ï¼Œæˆ‘ä»¬åœ¨ LLCM æ•°æ®é›†ä¸Šå¯è§†åŒ–ç±»é—´å’Œç±»å†…è·ç¦»ï¼Œå¦‚ä¸Šå›¾ (a-e) æ‰€ç¤ºã€‚æ¯”è¾ƒä¸Šå›¾ï¼ˆc-eï¼‰å’Œä¸Šå›¾ï¼ˆa-bï¼‰ï¼Œç±»é—´å’Œç±»å†…è·ç¦»çš„å‡å€¼ï¼ˆå³å‚ç›´çº¿ï¼‰è¢«MFAã€DEEå’ŒDEENæ¨å¼€ï¼Œå…¶ä¸­Î´1 &lt;Î´2 &lt;Î´3å¹¶ä¸”Î´1&lt;Î´2&lt;Î´4&lt;Î´5ã€‚è¿™è¡¨æ˜ï¼Œä¸åˆå§‹ç‰¹å¾ï¼ˆå›¾7ï¼ˆaï¼‰ï¼‰å’ŒåŸºçº¿ç‰¹å¾ï¼ˆå›¾7ï¼ˆbï¼‰ï¼‰çš„ç±»å†…è·ç¦»ç›¸æ¯”ï¼ŒDEENçš„ç±»å†…è·ç¦»æ˜¾ç€å‡å°ã€‚å› æ­¤ï¼ŒDEENå¯ä»¥æœ‰æ•ˆåœ°å‡å°‘å¯è§å…‰å’Œçº¢å¤–å›¾åƒä¹‹é—´çš„æ¨¡æ€å·®å¼‚ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬è¿˜åœ¨ä¸Šå›¾ï¼ˆf-jï¼‰ä¸­ç”¨t-SNEå¯è§†åŒ–2Dç‰¹å¾ç©ºé—´ä¸­çš„ç‰¹å¾åˆ†å¸ƒï¼Œè¿™è¡¨æ˜MFAã€DEEå’ŒDEENå¯ä»¥æœ‰æ•ˆåœ°åŒºåˆ†å’ŒèšåˆåŒä¸€ä¸ªäººçš„ç‰¹å¾åµŒå…¥ï¼Œå¹¶å‡å°‘æ¨¡æ€å·®å¼‚ã€‚ æ£€ç´¢ç»“æœ ä¸ºäº†è¿›ä¸€æ­¥æ˜¾ç¤º DEEN çš„æœ‰æ•ˆæ€§ï¼Œä¸ºäº†è¿›ä¸€æ­¥å±•ç¤ºDEENçš„æœ‰æ•ˆæ€§ï¼Œæˆ‘ä»¬åœ¨å›¾8ä¸­å±•ç¤ºäº†DEENåœ¨æˆ‘ä»¬çš„LLCMæ•°æ®é›†ä¸Šçš„ä¸€äº›æ£€ç´¢ç»“æœã€‚å¯¹äºæ¯ä¸ªæ£€ç´¢æ¡ˆä¾‹ï¼Œç»¿è‰²æ¡†è¡¨ç¤ºä¸ç»™å®šæŸ¥è¯¢å¯¹åº”çš„æ­£ç¡®åŒ¹é…å›¾åƒï¼Œè€Œçº¢è‰²æ¡†è¡¨ç¤ºä¸æ­£ç¡®çš„åŒ¹é…å›¾åƒã€‚æ€»ä½“è€Œè¨€ï¼Œä¸åŸºçº¿ç›¸æ¯”ï¼ŒDEENå¯ä»¥æœ‰æ•ˆåœ°æ”¹è¿›æ’åºç»“æœï¼Œä½¿æ›´å¤šæ­£ç¡®åŒ¹é…çš„å›¾åƒæ’åœ¨å‰é¢çš„ä½ç½®ã€‚ æ€»ç»“ åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§æ–°é¢–çš„å¤šæ ·åŒ–åµŒå…¥æ‰©å±•ç½‘ç»œï¼ˆDEENï¼‰ï¼Œç”¨äºVIRelDä»»åŠ¡çš„åµŒå…¥ç©ºé—´ã€‚æ‰€æå‡ºçš„DEENå¯ä»¥ç”Ÿæˆå¤šæ ·åŒ–çš„åµŒå…¥ï¼Œå¹¶æŒ–æ˜å¤šæ ·çš„é€šé“çº§å’Œç©ºé—´åµŒå…¥ï¼Œä»¥å­¦ä¹ ä¿¡æ¯ä¸°å¯Œçš„ç‰¹å¾è¡¨ç¤ºï¼Œä»è€Œå‡å°‘VISå’ŒIRå›¾åƒä¹‹é—´çš„æ¨¡æ€å·®å¼‚ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜æä¾›äº†ä¸€ä¸ªå…·æœ‰æŒ‘æˆ˜æ€§çš„ä½å…‰è·¨æ¨¡æ€ï¼ˆLLCMï¼‰æ•°æ®é›†ï¼Œè¯¥æ•°æ®é›†åŒ…å«æ›´å¤šæ–°çš„é‡è¦ç‰¹å¾ï¼Œå¯ä»¥è¿›ä¸€æ­¥ä¿ƒè¿›VIRelDç ”ç©¶å‘å®é™…åº”ç”¨è¿ˆè¿›ã€‚å¯¹SYSU-MM01ã€RegDBå’ŒLLCMæ•°æ®é›†çš„å¹¿æ³›å®éªŒè¡¨æ˜ï¼Œæ‰€æå‡ºçš„DEENåœ¨å¤šç§æœ€æ–°æ–¹æ³•ä¸­å…·æœ‰ä¼˜è¶Šæ€§ã€‚","tags":["ReID","VI-ReID","CVPR","2023","DEEN"],"categories":["ReID","VI-ReID"]},{"title":"ã€è®ºæ–‡ç¬”è®°ã€‘AUL","path":"/2024/09/26/MudSynth/ReID/ã€è®ºæ–‡ç¬”è®°ã€‘AUL/","content":"æ–‡ç« åŸºæœ¬ä¿¡æ¯ æ–‡ç« åç§°ï¼šAdaptive Uncertainty-Based Learning for Text-Based Person Retrieval å‘è¡¨ä¼šè®®/å¹´ä»½ï¼šAAAI 2024 ä½œè€…ï¼šShenshen Li, Chen He, Xing Xu*, Fumin Shen, Yang Yang, Heng Tao Shen å•ä½ï¼šSchool of Computer Science and Engineering and Center for Future Media, University of Electronic Science and Technology of China, China æ‘˜è¦ åŸºäºæ–‡æœ¬çš„è¡Œäººæ£€ç´¢æ—¨åœ¨æ ¹æ®æ–‡æœ¬æè¿°ä»å›¾åº“ä¸­æ£€ç´¢ç‰¹å®šçš„è¡Œäººå›¾åƒã€‚ä¸»è¦æŒ‘æˆ˜æ˜¯å¦‚ä½•åœ¨æ˜¾è‘—çš„ç±»å†…å˜åŒ–å’Œæœ€å°çš„ç±»é—´å˜åŒ–æƒ…å†µä¸‹å…‹æœå›ºæœ‰çš„å¼‚è´¨æ¨¡æ€å·®è·ã€‚ç°æœ‰çš„æ–¹æ³•é€šå¸¸é‡‡ç”¨è§†è§‰-è¯­è¨€é¢„è®­ç»ƒæˆ–æ³¨æ„åŠ›æœºåˆ¶ï¼Œä»å™ªå£°è¾“å…¥ä¸­å­¦ä¹ é€‚å½“çš„è·¨æ¨¡æ€å¯¹é½ã€‚å°½ç®¡å–å¾—äº†æ˜¾è‘—è¿›å±•ï¼Œå½“å‰çš„æ–¹æ³•ä¸å¯é¿å…åœ°å­˜åœ¨ä¸¤ä¸ªç¼ºé™·ï¼š1) åŒ¹é…æ­§ä¹‰ï¼Œä¸»è¦æºäºä¸å¯é çš„åŒ¹é…å¯¹ï¼›2) å•æ–¹é¢çš„è·¨æ¨¡æ€å¯¹é½ï¼Œæºäºç¼ºä¹æ¢ç´¢ä¸€å¯¹å¤šå¯¹åº”å…³ç³»ï¼Œå³ç²—ç²’åº¦è¯­ä¹‰å¯¹é½ã€‚è¿™äº›å…³é”®é—®é¢˜æ˜¾è‘—é™ä½äº†æ£€ç´¢æ€§èƒ½ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§æ–°é¢–çš„æ¡†æ¶ï¼Œç§°ä¸ºåŸºäºè‡ªé€‚åº”ä¸ç¡®å®šæ€§çš„å­¦ä¹ ï¼ˆAdaptive Uncertainty-Based Learningï¼ŒAULï¼‰ï¼Œç”¨äºä»ä¸ç¡®å®šæ€§è§’åº¦è¿›è¡ŒåŸºäºæ–‡æœ¬çš„è¡Œäººæ£€ç´¢ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬çš„AULæ¡†æ¶ç”±ä¸‰ä¸ªå…³é”®ç»„ä»¶ç»„æˆï¼š1) ä¸ç¡®å®šæ€§æ„ŸçŸ¥åŒ¹é…è¿‡æ»¤ï¼Œåˆ©ç”¨ä¸»è§‚é€»è¾‘ï¼ˆSubjective Logicï¼‰ æœ‰æ•ˆå‡å°‘ä¸å¯é åŒ¹é…å¯¹çš„å¹²æ‰°ï¼Œå¹¶é€‰æ‹©é«˜ç½®ä¿¡åº¦çš„è·¨æ¨¡æ€åŒ¹é…è¿›è¡Œè®­ç»ƒï¼›2) åŸºäºä¸ç¡®å®šæ€§çš„å¯¹é½ä¼˜åŒ–ï¼Œä¸ä»…é€šè¿‡æ„å»ºä¸ç¡®å®šæ€§è¡¨ç¤ºæ¥æ¨¡æ‹Ÿç²—ç²’åº¦å¯¹é½ï¼Œè¿˜è¿›è¡Œæ¸è¿›å­¦ä¹ ï¼Œä»¥é€‚å½“åœ°ç»“åˆç²—ç²’åº¦å’Œç»†ç²’åº¦å¯¹é½ï¼›3) è·¨æ¨¡æ€æ©ç å»ºæ¨¡ï¼Œæ—¨åœ¨æ¢ç´¢è§†è§‰å’Œè¯­è¨€ä¹‹é—´æ›´å…¨é¢çš„å…³ç³»ã€‚å¤§é‡å®éªŒè¡¨æ˜ï¼Œæˆ‘ä»¬çš„AULæ–¹æ³•åœ¨ç›‘ç£ã€å¼±ç›‘ç£å’ŒåŸŸæ³›åŒ–è®¾ç½®ä¸‹çš„ä¸‰ä¸ªåŸºå‡†æ•°æ®é›†ä¸Šå§‹ç»ˆå®ç°äº†æœ€å…ˆè¿›çš„æ€§èƒ½ã€‚æˆ‘ä»¬çš„ä»£ç å¯åœ¨ https://github.com/CFM-MSG/Code-AUL è·å–ã€‚ ä¹‹å‰å·¥ä½œå­˜åœ¨çš„é—®é¢˜ åŒ¹é…æ¨¡ç³Šæ€§ï¼šç”±äºä»…è€ƒè™‘ä¸€å¯¹ä¸€åŒ¹é…ï¼Œå¿½ç•¥äº†è¯­è¨€å’Œè§†è§‰ä¹‹é—´çš„ä¸€å¯¹å¤šå¯¹åº”å…³ç³»ï¼Œå¯¼è‡´åŒ¹é…æ¨¡ç³Šï¼Œé™åˆ¶äº†æ¨¡å‹çš„æ€§èƒ½å’Œæ³›åŒ–èƒ½åŠ›ã€‚ å•æ–¹é¢çš„è·¨æ¨¡æ€å¯¹é½ï¼šè¿™äº›æ–¹æ³•å¾€å¾€æ— æ³•å…¨é¢æ•æ‰è§†è§‰å’Œè¯­è¨€ä¹‹é—´çš„å…³ç³»ï¼Œå¯¼è‡´å¯¹é½è¿‡ç¨‹å•æ–¹é¢ä¸”ä¸å®Œæ•´ã€‚ ä¸å¯é çš„åŒ¹é…å¯¹ï¼šç”±äºç±»å†…å˜åŒ–å¤§å’Œç±»é—´å˜åŒ–å°å¼•å…¥çš„å›ºæœ‰æ•°æ®å™ªå£°ï¼ŒåŸºäºç›¸ä¼¼æ€§é€‰æ‹©çš„è·¨æ¨¡æ€åŒ¹é…å¯¹å¾€å¾€ä¸å‡†ç¡®ï¼Œå¯èƒ½ä¼šé”™è¯¯åœ°å°†è´Ÿæ ·æœ¬è¯†åˆ«ä¸ºçœŸå®æ ‡ç­¾ï¼Œè¿›ä¸€æ­¥é™ä½äº†åŒ¹é…çš„å‡†ç¡®æ€§ã€‚ ä¸»è¦è´¡çŒ®/åˆ›æ–° åŸºäºä¸Šè¿°è§‚å¯Ÿï¼Œæå‡ºäº†ä¸€ç§åä¸ºè‡ªé€‚åº”ä¸ç¡®å®šæ€§å­¦ä¹ ï¼ˆAULï¼ŒAdaptive Uncertainty-based Learningï¼‰çš„æ–°æ¡†æ¶ï¼Œç”¨äºä»ä¸ç¡®å®šæ€§è§’åº¦è¿›è¡ŒåŸºäºæ–‡æœ¬çš„äººå‘˜æ£€ç´¢ã€‚æˆ‘ä»¬çš„ä¸»è¦è´¡çŒ®å¯ä»¥æ€»ç»“å¦‚ä¸‹ï¼š ä¸ç¡®å®šæ€§æ„ŸçŸ¥åŒ¹é…è¿‡æ»¤ç­–ç•¥ï¼šé€šè¿‡ä»”ç»†è€ƒè™‘åŒ¹é…ä¸ç¡®å®šæ€§ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€ç§ä¸ç¡®å®šæ€§æ„ŸçŸ¥åŒ¹é…è¿‡æ»¤ï¼ˆUncertainty-aware Matching Filtrationï¼‰ç­–ç•¥ï¼Œè¯¥ç­–ç•¥åˆ©ç”¨ä¸»è§‚é€»è¾‘ï¼ˆSubjective Logicï¼‰è‡ªé€‚åº”åœ°é€‰æ‹©é«˜ç½®ä¿¡åº¦çš„è·¨æ¨¡æ€åŒ¹é…ï¼Œå‡è½»ä¸å¯é åŒ¹é…å¯¹å¯¹è®­ç»ƒçš„å¹²æ‰°ã€‚ åŸºäºä¸ç¡®å®šæ€§çš„å¯¹é½ä¼˜åŒ–æ¨¡å—ï¼šæˆ‘ä»¬æå‡ºäº†ä¸€ä¸ªåŸºäºä¸ç¡®å®šæ€§çš„å¯¹é½ä¼˜åŒ–ï¼ˆUncertainty-based Alignment Refinementï¼‰æ¨¡å—ï¼Œè¯¥æ¨¡å—ä¸ä»…é€šè¿‡æ„å»ºä¸ç¡®å®šæ€§è¡¨ç¤ºæ¥æ¨¡æ‹Ÿç²—ç²’åº¦å¯¹é½ï¼Œè¿˜é€æ­¥ç»„ç»‡å¤šç²’åº¦å¯¹é½ã€‚ è·¨æ¨¡æ€æ©ç å»ºæ¨¡æ¨¡å—ï¼šæˆ‘ä»¬éƒ¨ç½²äº†ä¸€ä¸ªè·¨æ¨¡æ€æ©ç å»ºæ¨¡ï¼ˆCross-modal Masked Modelingï¼‰æ¨¡å—ï¼Œé€šè¿‡å…¨é¢çš„è·¨æ¨¡æ€äº¤äº’é‡æ„å›¾åƒå’Œæ–‡æœ¬æ¨¡æ€ä¿¡å·ï¼Œè¿›ä¸€æ­¥æ¢ç´¢ä¸¤ç§æ¨¡æ€ä¹‹é—´çš„å¯¹åº”å…³ç³»ã€‚ æ–¹æ³• Preliminary åŸºäºæ–‡æœ¬çš„äººå‘˜æ£€ç´¢ä»»åŠ¡çš„ç›®æ ‡æ˜¯ä»å€™é€‰åº“ä¸­åˆ†è¾¨å¹¶æ£€ç´¢åˆ°ä¸æä¾›çš„æ–‡æœ¬æŸ¥è¯¢æœ€åŒ¹é…çš„äººå‘˜å›¾åƒã€‚ä¸ºäº†è·å–æ­£ç¡®çš„è¡Œäººå›¾åƒï¼Œæˆ‘ä»¬æå‡ºçš„æ¡†æ¶ä¾§é‡äºé€šè¿‡å­¦ä¹ æ–‡æœ¬æè¿°ä¸å¯¹åº”äººå‘˜å›¾åƒä¹‹é—´çš„ç›¸ä¼¼æ€§æ¥ä¿ƒè¿›ç²¾ç¡®çš„å¯¹é½ã€‚ å½¢å¼ä¸Šï¼Œæˆ‘ä»¬å®šä¹‰{Ii,Ti}\\{I_i, T_i\\}{Iiâ€‹,Tiâ€‹}ä¸ºè®­ç»ƒæ•°æ®é›†ä¸­çš„å›¾åƒ-æ–‡æœ¬å¯¹ã€‚æ¯å¯¹åŒ…æ‹¬ä¸€å¼ äººå‘˜å›¾åƒIiI_iIiâ€‹åŠå…¶å¯¹åº”çš„æ–‡æœ¬æè¿°TiT_iTiâ€‹ã€‚æˆ‘ä»¬é¦–å…ˆå°†å›¾åƒIiI_iIiâ€‹è¾“å…¥åˆ°å›¾åƒç¼–ç å™¨ä¸­ï¼Œç”Ÿæˆä¸€ç³»åˆ—è§†è§‰ç‰¹å¾{vicls,vi1,â€¦,vin}\\{v_{i}^{cls}, v_{i}^{1}, \\ldots, v_{i}^{n}\\}{viclsâ€‹,vi1â€‹,â€¦,vinâ€‹}ï¼Œå…¶ä¸­viclsv_{i}^{cls}viclsâ€‹ä½œä¸ºå…¨å±€è§†è§‰ç‰¹å¾ï¼Œ{vi1,â€¦,vin}\\{v_{i}^{1}, \\ldots, v_{i}^{n}\\}{vi1â€‹,â€¦,vinâ€‹}è¡¨ç¤ºè§†è§‰è¡¥ä¸ç‰¹å¾ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬åˆ©ç”¨æ–‡æœ¬ç¼–ç å™¨è·å¾—ä¸€ç³»åˆ—æ–‡æœ¬è¡¨ç¤º{ticls,ti1,â€¦,tin}\\{t_{i}^{cls}, t_{i}^{1}, \\ldots, t_{i}^{n}\\}{ticlsâ€‹,ti1â€‹,â€¦,tinâ€‹}ï¼Œå…¶ä¸­ticlst_{i}^{cls}ticlsâ€‹å’Œ{ti1,â€¦,tin}\\{t_{i}^{1}, \\ldots, t_{i}^{n}\\}{ti1â€‹,â€¦,tinâ€‹}åˆ†åˆ«è¡¨ç¤ºå…¨å±€æ–‡æœ¬ç‰¹å¾å’Œæ ‡è®°ç‰¹å¾ã€‚ Uncertainty-aware Matching Filtration(UMF) æ¨¡å—ç›®çš„ï¼š ä½¿ç”¨ä¸»è§‚é€»è¾‘å¯¹æ–‡æœ¬å›¾åƒå¯¹åŒ¹é…çš„ä¸ç¡®å®šæ€§è¿›è¡Œå»ºæ¨¡ï¼Œç”¨äºç­›é€‰å¯é åŒ¹é…ï¼Œå‡è½»ç”±äºä¸å¯é åŒ¹é…å¯¹ å¸¦æ¥çš„ä¸ç¡®å®šæ€§å½±å“ ä¸»è§‚é€»è¾‘èƒŒæ™¯ ä¸»è§‚é€»è¾‘ï¼ˆSubjective Logicï¼ŒSLï¼‰æä¾›äº†å¯¹Dempster-Shaferç†è®ºï¼ˆYager å’Œ Liu 2008ï¼‰ä¸ç¡®å®šæ€§åˆ†é…åŸåˆ™çš„å½¢å¼åŒ–è¡¨ç¤ºï¼Œå»ºæ¨¡ä¸ºç‹„åˆ©å…‹é›·åˆ†å¸ƒã€‚å› æ­¤ï¼Œå®ƒæä¾›äº†åˆ©ç”¨SLç†è®ºé‡åŒ–ä¸ç¡®å®šæ€§çš„æ–¹æ³•ï¼Œåœ¨ä¸¥æ ¼å»ºç«‹çš„ç†è®ºæ¡†æ¶å†…è¿›è¡Œã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬é¦–å…ˆè·å¾—é’ˆå¯¹ç¬¬iiiä¸ªå•å…ƒé¢„æµ‹çš„è¯æ®å‘é‡ei\\mathbf{e}_ieiâ€‹ã€‚ç„¶åæˆ‘ä»¬ä¸ºæ¯ä¸ªå•å…ƒå»ºæ¨¡ä¸ç¡®å®šæ€§u\\mathbf{u}uå’Œä¿¡ä»»è´¨é‡p={pk}k=1N\\mathbf{p} = \\{p_k\\}_{k=1}^Np={pkâ€‹}k=1Nâ€‹ï¼Œå…¶å…¬å¼å¦‚ä¸‹ï¼š pk=ekS,u=NS,p_k = \\frac{e_k}{S}, \\quad u = \\frac{N}{S}, pkâ€‹=Sekâ€‹â€‹,u=SNâ€‹, å…¶ä¸­ï¼ŒS=âˆ‘k=1N(ek+1)S = \\sum_{k=1}^{N}(e_k + 1)S=âˆ‘k=1Nâ€‹(ekâ€‹+1)å¯ä»¥è¢«è®¤ä¸ºæ˜¯ç‹„åˆ©å…‹é›·åˆ†å¸ƒçš„å¼ºåº¦ï¼Œè€Œä¿¡ä»»æ¦‚ç‡pkp_kpkâ€‹å¯¹åº”äºç‹„åˆ©å…‹é›·åˆ†å¸ƒÎ±={ek+1}k=1N\\alpha = \\{e_k + 1\\}_{k=1}^NÎ±={ekâ€‹+1}k=1Nâ€‹çš„å‚æ•°ã€‚æ³¨æ„ï¼Œä¸ç¡®å®šæ€§u\\mathbf{u}uä¸æ€»è¯æ®å‘ˆåæ¯”å…³ç³»ã€‚æœ€åï¼Œç”±Î±\\alphaÎ±æè¿°çš„ç‹„åˆ©å…‹é›·åˆ†å¸ƒå¯ä»¥å®šä¹‰ä¸ºï¼š D(pâˆ£Î±)={1B(Î±)âˆj=1NpjÎ±jâˆ’1forÂ pâˆˆSN,0otherwise, D(\\mathbf{p}|\\alpha) = \\begin{cases} \\frac{1}{B(\\alpha)} \\prod_{j=1}^{N} p_j^{\\alpha_j - 1} &amp; \\text{for } \\mathbf{p} \\in \\mathbb{S}_N, \\\\ 0 &amp; \\text{otherwise}, \\end{cases} D(pâˆ£Î±)={B(Î±)1â€‹âˆj=1Nâ€‹pjÎ±jâ€‹âˆ’1â€‹0â€‹forÂ pâˆˆSNâ€‹,otherwise,â€‹ å…¶ä¸­B(Î±)B(\\alpha)B(Î±)è¡¨ç¤ºNç»´è´å¡”å‡½æ•°ï¼ŒSN\\mathbb{S}_NSNâ€‹æ˜¯Nç»´å•çº¯å½¢ã€‚ ä¸ç¡®å®šæ€§æ„ŸçŸ¥å­¦ä¹  ä¸ºäº†æœ‰æ•ˆå‡è½»ç”±äºä¸å¯é åŒ¹é…å¯¹å¸¦æ¥çš„ä¸ç¡®å®šæ€§å½±å“ï¼Œéœ€è¦å¯¹åŒ¹é…ä¸ç¡®å®šæ€§è¿›è¡Œå»ºæ¨¡ã€‚å°½ç®¡ä¸»è§‚é€»è¾‘ï¼ˆSubjective Logic, SLï¼‰ç†è®ºåœ¨ä¸ç¡®å®šæ€§å»ºæ¨¡æ–¹é¢æ˜¾ç¤ºäº†æ˜¾è‘—çš„è¿›å±•ï¼Œä½†ç›´æ¥å°†å…¶åº”ç”¨äºåŸºäºæ–‡æœ¬çš„äººå‘˜æ£€ç´¢å¹¶ä¸åˆé€‚ã€‚ä¸ºäº†å°†SLæ‰©å±•åˆ°è¿™ä¸€ç‰¹å®šä»»åŠ¡ï¼Œåˆæ­¥æ­¥éª¤æ˜¯è¡¨ç¤ºç¬¬iiiä¸ªæ–‡æœ¬ä¸ç¬¬jjjä¸ªå›¾åƒä¹‹é—´çš„è·¨æ¨¡æ€åŒ¹é…è¯æ®eij=expâ¡f(Sim(ticls,vicls))e_{ij} = \\exp^{f(Sim(t_i^{cls}, v_i^{cls}))}eijâ€‹=expf(Sim(ticlsâ€‹,viclsâ€‹))ï¼Œå…¶ä¸­Sim(â‹…)Sim(\\cdot)Sim(â‹…)å’Œfffåˆ†åˆ«è¡¨ç¤ºä½™å¼¦ç›¸ä¼¼åº¦å’ŒReLUå‡½æ•°ã€‚ç¬¬iiiä¸ªæ–‡æœ¬çš„æ‰€æœ‰åŒ¹é…çš„æ€»è¯æ®ei\\mathbf{e}_ieiâ€‹å¯ä»¥è¡¨ç¤ºä¸ºei={eij}j=1N\\mathbf{e}_i = \\{e_{ij}\\}_{j=1}^Neiâ€‹={eijâ€‹}j=1Nâ€‹ã€‚ æ ¹æ®å‰ä¸€éƒ¨åˆ†æåˆ°çš„ä¸»è§‚é€»è¾‘ï¼Œæˆ‘ä»¬è·å¾—äº†Î±i\\alpha_iÎ±iâ€‹å¹¶å°†åŒ¹é…ä¸ç¡®å®šæ€§u\\mathbf{u}uå»ºæ¨¡å¦‚ä¸‹ï¼š Î±i=ei+1,u=NS,\\alpha_i = e_i + 1, \\quad \\mathbf{u} = \\frac{N}{S}, Î±iâ€‹=eiâ€‹+1,u=SNâ€‹, å…¶ä¸­ï¼ŒS=âˆ‘i=1N(Î±i)S = \\sum_{i=1}^{N}(\\alpha_i)S=âˆ‘i=1Nâ€‹(Î±iâ€‹)å¯ä»¥è¢«è§†ä¸ºç‹„åˆ©å…‹é›·åˆ†å¸ƒçš„å¼ºåº¦ã€‚åŸºäºè·å¾—çš„åŒ¹é…ä¸ç¡®å®šæ€§ï¼Œæˆ‘ä»¬æ‰§è¡Œä¸ç¡®å®šæ€§æ„ŸçŸ¥å­¦ä¹ ï¼Œè‡ªé€‚åº”åœ°è¿‡æ»¤ä¸å¯é çš„åŒ¹é…å¯¹å¹¶é€‰æ‹©é«˜ç½®ä¿¡åº¦çš„è·¨æ¨¡æ€åŒ¹é…ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬è®¾è®¡äº†å…·æœ‰ä¸ç¡®å®šæ€§æ„ŸçŸ¥åŠ¨æ€æƒé‡å‡½æ•°Ï†(m(i))\\varphi(m(i))Ï†(m(i))çš„äº¤å‰ç†µæŸå¤±Lu\\mathcal{L}_uLuâ€‹ï¼Œåœ¨ä¼˜åŒ–è¿‡ç¨‹ä¸­ä¸ºå…·æœ‰è¾ƒä½åŒ¹é…ä¸ç¡®å®šæ€§çš„è·¨æ¨¡æ€åŒ¹é…åˆ†é…è¾ƒå¤§çš„æƒé‡ï¼Œä¸ºå…·æœ‰è¾ƒé«˜åŒ¹é…ä¸ç¡®å®šæ€§çš„åŒ¹é…åˆ†é…è¾ƒå°çš„æƒé‡ï¼Œä»è€Œå‡å°‘ç”±ä¸å¯é åŒ¹é…å¯¹é€ æˆçš„è´Ÿé¢å½±å“ã€‚æŸå¤±å‡½æ•°Lu\\mathcal{L}_uLuâ€‹å¯ä»¥è¡¨ç¤ºä¸ºï¼š Lu=Î»âˆ‘i=1NÏ†(m(i))Yi(logâ¡(Si)âˆ’logâ¡(Î±i)),\\mathcal{L}_u = \\lambda \\sum_{i=1}^{N} \\varphi(m(i)) Y_i \\left( \\log(S_i) - \\log(\\alpha_i) \\right), Luâ€‹=Î»i=1âˆ‘Nâ€‹Ï†(m(i))Yiâ€‹(log(Siâ€‹)âˆ’log(Î±iâ€‹)), å…¶ä¸­ï¼ŒÎ»\\lambdaÎ»æ˜¯è¶…å‚æ•°ï¼ŒYiY_iYiâ€‹æ˜¯ç¬¬iiiä¸ªæ ·æœ¬çš„one-hotæ ‡ç­¾ï¼ŒÏ†(m(i))=m(i)Nâˆˆ(0,1]\\varphi(m(i)) = \\frac{m(i)}{N} \\in (0, 1]Ï†(m(i))=Nm(i)â€‹âˆˆ(0,1]ï¼Œm(i)m(i)m(i)è¡¨ç¤ºé€šè¿‡æŒ‰é™åºæ’åˆ—ä¸ç¡®å®šæ€§u\\mathbf{u}uè·å¾—çš„ç¬¬iiiä¸ªè·¨æ¨¡æ€åŒ¹é…çš„åºå·ã€‚ æ¨¡å—äº®ç‚¹ï¼šä¸åŒäºä¹‹å‰ReIDé—®é¢˜æ‰€é‡‡ç”¨çš„tripletç­‰æŸå¤±å‡½æ•°ï¼Œä»–æ˜¯ä¸€ä¸ªæ¯”è¾ƒè½¯çš„çº¦æŸæ¡ä»¶ï¼Œtripletç­‰å‡½æ•°ä»æ ‡ç­¾åˆ¤å®šï¼Œæ ‡ç­¾ä¸ä¸€è‡´ï¼Œç›´æ¥æƒé‡å°±æ˜¯0ï¼Œè¿™é‡Œé€šè¿‡ç›¸ä¼¼åº¦è®¡ç®—çš„ä¸ç¡®å®šæ€§è¿›è¡Œçº¦æŸï¼Œæˆ–è®¸èƒ½è®©æ¨¡å‹æ‹¥æœ‰æ›´å¼ºçš„æ³›åŒ–æ€§èƒ½ Uncertainty-based Alignment Refinement æ¨¡å—ç›®çš„ï¼š Uncertainty-based Alignment Refinementï¼ˆUARï¼‰æ¨¡å—æ—¨åœ¨è§£å†³è§†è§‰å’Œè¯­è¨€ä¹‹é—´ç¼ºä¹ä¸€å¯¹å¤šå¯¹åº”å…³ç³»çš„é—®é¢˜ï¼Œå¯¼è‡´æ£€ç´¢æ€§èƒ½é€€åŒ–ã€‚é€šè¿‡æ„å»ºå…·æœ‰ä¸ç¡®å®šæ€§çš„è§†è§‰è¡¨ç¤ºï¼Œå¹¶é‡‡ç”¨æ¸è¿›å­¦ä¹ æ–¹æ³•ï¼ŒUAR æ¨¡å—åœ¨è®­ç»ƒè¿‡ç¨‹ä¸­é€æ­¥ä¼˜åŒ–ç²—ç²’åº¦å’Œç»†ç²’åº¦å¯¹é½ï¼Œæœ€ç»ˆæé«˜è·¨æ¨¡æ€æ£€ç´¢æ€§èƒ½ã€‚ ç”±äºè§†è§‰å’Œè¯­è¨€ä¹‹é—´ç¼ºä¹ä¸€å¯¹å¤šçš„å¯¹åº”å…³ç³»ï¼Œç°æœ‰æ–¹æ³•ä¸»è¦é›†ä¸­äºæ¢ç´¢å•æ–¹é¢çš„è·¨æ¨¡æ€å¯¹é½ï¼Œå³ä¸€å¯¹ä¸€çš„å¯¹åº”å…³ç³»ï¼Œå¯¼è‡´æ£€ç´¢æ€§èƒ½é€€åŒ–ã€‚ä¸ºäº†è§£å†³è¿™ä¸€é™åˆ¶ï¼Œæˆ‘ä»¬æå‡ºäº†åŸºäºä¸ç¡®å®šæ€§çš„å¯¹é½ä¼˜åŒ–ï¼ˆUncertainty-based Alignment Refinementï¼ŒUARï¼‰æ¨¡å—ï¼Œè¯¥æ¨¡å—æ¨¡æ‹Ÿç²—ç²’åº¦å¯¹é½ï¼Œå¹¶é‡‡ç”¨æ¸è¿›å­¦ä¹ ä»¥æ˜“åˆ°éš¾çš„æ–¹å¼ååŒä¼˜åŒ–ç²—ç²’åº¦å’Œç»†ç²’åº¦å¯¹é½ã€‚ ä¸ç¡®å®šæ€§è¡¨ç¤ºæ„å»ºï¼šé‰´äºNNNä¸ªå›¾åƒ-æ–‡æœ¬å¯¹çš„å…¨å±€è¡¨ç¤º(vcls,tcls)(v^{cls}, t^{cls})(vcls,tcls)ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦æ˜¾å¼æ„å»ºå…·æœ‰ä¸ç¡®å®šæ€§çš„è§†è§‰è¡¨ç¤ºï¼Œè¿™é€šè¿‡å°†é«˜æ–¯å™ªå£°æ·»åŠ åˆ°åŸå§‹ç‰¹å¾åˆ†å¸ƒä¸­æ¥å®ç°ã€‚é«˜æ–¯å™ªå£°çš„å‡å€¼Î¼\\muÎ¼å’Œæ ‡å‡†å·®Ïƒ\\sigmaÏƒä»åŸå§‹ç‰¹å¾vclsv^{cls}vclsä¸­å¾—å‡ºã€‚ç„¶åæˆ‘ä»¬é€šè¿‡å°†ç”Ÿæˆçš„é«˜æ–¯å™ªå£°æ·»åŠ åˆ°å½’ä¸€åŒ–åçš„ç‰¹å¾vË‰cls\\bar{v}^{cls}vË‰clsæ¥æ„å»ºå…·æœ‰ä¸ç¡®å®šæ€§çš„è§†è§‰è¡¨ç¤ºv^cls\\hat{v}^{cls}v^clsï¼Œå…¶å…¬å¼å¦‚ä¸‹ï¼š v^cls=Î±vâ‹…vË‰cls+Î²v,\\hat{v}^{cls} = \\alpha_v \\cdot \\bar{v}^{cls} + \\beta_v, v^cls=Î±vâ€‹â‹…vË‰cls+Î²vâ€‹, å…¶ä¸­ï¼ŒÎ±v\\alpha_vÎ±vâ€‹å’ŒÎ²v\\beta_vÎ²vâ€‹æ˜¯å¼•å…¥å™ªå£°çš„ä¸ç¡®å®šæ€§å‘é‡ï¼ŒÎ±vâˆ¼N(1,Ïƒ)\\alpha_v \\sim N(1, \\sigma)Î±vâ€‹âˆ¼N(1,Ïƒ)ï¼ŒÎ²vâˆ¼N(Î¼,Ïƒ)\\beta_v \\sim N(\\mu, \\sigma)Î²vâ€‹âˆ¼N(Î¼,Ïƒ)ï¼ŒvË‰cls\\bar{v}^{cls}vË‰clsæ˜¯å½’ä¸€åŒ–åçš„ç‰¹å¾ï¼š vË‰cls=vclsâˆ’Î¼Ïƒ.\\bar{v}^{cls} = \\frac{v^{cls} - \\mu}{\\sigma}. vË‰cls=Ïƒvclsâˆ’Î¼â€‹. æ¸è¿›å¯¹é½å­¦ä¹ ï¼šåŸºäºè·å¾—çš„ä¸ç¡®å®šæ€§è§†è§‰è¡¨ç¤ºv^icls\\hat{v}^{cls}_iv^iclsâ€‹å’Œæ–‡æœ¬è¡¨ç¤ºticlst^{cls}_iticlsâ€‹ï¼Œæˆ‘ä»¬é‡‡ç”¨InfoNCEæŸå¤±ï¼ˆInfoNCE lossï¼‰Linfo\\mathcal{L}_{info}Linfoâ€‹ï¼ˆLee, Kim, and Han 2021ï¼›Yang et al. 2023ï¼‰è¿›è¡Œç²—ç²’åº¦å¯¹é½ï¼Œå¹¶è¿›ä¸€æ­¥æ¢ç´¢ä¸€å¯¹å¤šå¯¹åº”å…³ç³»ã€‚ç²—ç²’åº¦å¯¹é½æŸå¤±å¯ä»¥å®šä¹‰ä¸ºï¼š Lca=Linfo(v^icls,ticls)2Ïƒ2+12logâ¡Ïƒ2,\\mathcal{L}_{ca} = \\frac{\\mathcal{L}_{info} (\\hat{v}^{cls}_i, t^{cls}_i)}{2\\sigma^2} + \\frac{1}{2} \\log \\sigma^2, Lcaâ€‹=2Ïƒ2Linfoâ€‹(v^iclsâ€‹,ticlsâ€‹)â€‹+21â€‹logÏƒ2, Linfo(v^icls,ticls)=âˆ’logâ¡expâ¡(sim(v^icls,ticls)/Ï„)expâ¡(sim(v^icls,ticls)/Ï„)+âˆ‘k=1Nexpâ¡(sim(v^icls,tnegcls)/Ï„)\\mathcal{L}_{info}(\\hat{v}_i^{cls}, t_i^{cls}) = -\\log \\frac{\\exp(\\text{sim}(\\hat{v}_i^{cls}, t_i^{cls})/\\tau)}{\\exp(\\text{sim}(\\hat{v}_i^{cls}, t_i^{cls})/\\tau) + \\sum_{k=1}^{N} \\exp(\\text{sim}(\\hat{v}_i^{cls}, t_{neg}^{cls})/\\tau)}Linfoâ€‹(v^iclsâ€‹,ticlsâ€‹)=âˆ’logexp(sim(v^iclsâ€‹,ticlsâ€‹)/Ï„)+âˆ‘k=1Nâ€‹exp(sim(v^iclsâ€‹,tnegclsâ€‹)/Ï„)exp(sim(v^iclsâ€‹,ticlsâ€‹)/Ï„)â€‹ å¯¹äºç»†ç²’åº¦å¯¹é½ï¼Œå³ä¸€å¯¹ä¸€å¯¹åº”å…³ç³»ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€ç§æˆå¯¹æŸå¤±å‡½æ•°Lfa\\mathcal{L}_{fa}Lfaâ€‹ä»¥ç¼“è§£å¯†é›†é‡‡æ ·æœºåˆ¶çš„è´Ÿé¢å½±å“ï¼ˆZhou et al. 2023ï¼‰ã€‚æˆå¯¹æŸå¤±å‡½æ•°ä½¿ç”¨ä¸€ä¸ªè´Ÿæ ·æœ¬tnegclst^{cls}_{neg}tnegclsâ€‹å†™ä¸ºï¼š Lfa=âˆ’logâ¡Ïˆ(v^icls,ticls)Ïˆ(v^icls,ticls)+Ïˆ(v^icls,tnegcls),\\mathcal{L}_{fa} = - \\log \\frac{\\psi (\\hat{v}^{cls}_i, t^{cls}_i)}{\\psi (\\hat{v}^{cls}_i, t^{cls}_i) + \\psi (\\hat{v}^{cls}_i, t^{cls}_{neg})}, Lfaâ€‹=âˆ’logÏˆ(v^iclsâ€‹,ticlsâ€‹)+Ïˆ(v^iclsâ€‹,tnegclsâ€‹)Ïˆ(v^iclsâ€‹,ticlsâ€‹)â€‹, ç›´è§‚ä¸Šï¼Œè¿›è¡Œç»†ç²’åº¦å¯¹é½æ¯”ç²—ç²’åº¦å¯¹é½æ›´å…·æŒ‘æˆ˜æ€§ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„ç­–ç•¥æ˜¯åœ¨è®­ç»ƒè¿‡ç¨‹ä¸­é€æ­¥ä¸ºç²—ç²’åº¦å¯¹é½åˆ†é…è¾ƒé«˜çš„æƒé‡ï¼Œè€Œä¸ºç»†ç²’åº¦å¯¹é½åˆ†é…è¾ƒä½çš„æƒé‡ï¼Œæœ€ç»ˆé€æ­¥é€†è½¬è¿™ç§åˆ†é…ã€‚æˆ‘ä»¬æå‡ºäº†å¯¹é½æ¸è¿›å­¦ä¹ ï¼ˆAlignment Progressive Learningï¼ŒAPLï¼‰ï¼Œå°†åŠ¨æ€æƒé‡å¼•å…¥æŸå¤±å‡½æ•°ï¼Œä½¿å…¶é€æ­¥å…³æ³¨å¤šç²’åº¦å¯¹é½ï¼Œå¹¶åœ¨ä¼˜åŒ–è¿‡ç¨‹ä¸­æŒ‰â€œæ˜“åˆ°éš¾â€çš„æ–¹å¼é€æ­¥ä¼˜åŒ–ç›®æ ‡La\\mathcal{L}_aLaâ€‹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š La=âˆ‘i=1NÏ†(m(i))(Î³Lca+(1âˆ’Î³)Lfa),\\mathcal{L}_a = \\sum_{i=1}^{N} \\varphi(m(i)) \\left( \\gamma \\mathcal{L}_{ca} + (1 - \\gamma) \\mathcal{L}_{fa} \\right), Laâ€‹=i=1âˆ‘Nâ€‹Ï†(m(i))(Î³Lcaâ€‹+(1âˆ’Î³)Lfaâ€‹), å…¶ä¸­ï¼ŒÎ³=expâ¡(âˆ’Î³0â‹…epochtotal_epoch)\\gamma = \\exp\\left( -\\frac{\\gamma_0 \\cdot \\text{epoch}}{\\text{total\\_epoch}} \\right)Î³=exp(âˆ’total_epochÎ³0â€‹â‹…epochâ€‹)ï¼ŒÎ³0\\gamma_0Î³0â€‹æ˜¯åˆå§‹æƒé‡ã€‚ Cross-modal Masked Modeling æ¨¡å—ç›®çš„ï¼š å—MAEçš„å¯å‘ï¼Œé€šè¿‡è‡ªç›‘ç£å­¦ä¹ æå‡æ¨¡å‹çš„æ€§èƒ½ï¼Œå¢åŠ ä¸¤ç§æ¨¡æ€çš„äº¤äº’ï¼Œæ¶ˆé™¤æ¨¡æ€å·®å¼‚é€ æˆçš„å½±å“ ä¸ºäº†å¢å¼ºå›¾åƒå’Œæ–‡æœ¬ä¹‹é—´çš„äº¤äº’ï¼Œæˆ‘ä»¬è®¾è®¡äº†è·¨æ¨¡æ€æ©ç å»ºæ¨¡ï¼ˆCross-modal Masked Modelingï¼ŒCMMï¼‰ï¼Œé€šè¿‡ä½¿ç”¨æ©ç è¾“å…¥æ¥é‡æ„ä¸€ç§æ¨¡æ€çš„å†…åœ¨ä¿¡å·ï¼Œè¯¥è¾“å…¥ä¾èµ–äºå›¾åƒå’Œæ–‡æœ¬æ¨¡æ€çš„æœªæ©ç è¾“å…¥ã€‚CMMå¯ä»¥è¿›ä¸€æ­¥åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼šè·¨æ¨¡æ€æ©ç å›¾åƒå»ºæ¨¡ï¼ˆCross-modal Masked Image Modelingï¼ŒCMIMï¼‰å’Œè·¨æ¨¡æ€æ©ç è¯­è¨€å»ºæ¨¡ï¼ˆCross-modal Masked Language Modelingï¼ŒCMLMï¼‰ã€‚ ä»¥CMIMä¸ºä¾‹ï¼ŒæŒ‰ç…§MAEï¼ˆHeç­‰ï¼Œ2022ï¼‰çš„æ–¹å¼ï¼Œæˆ‘ä»¬è·å¾—æ©ç å›¾åƒçš„è¡¨ç¤ºVmi={vij}j=1nu\\mathbf{V}_{mi} = \\{v_{i}^{j}\\}_{j=1}^{n_u}Vmiâ€‹={vijâ€‹}j=1nuâ€‹â€‹ï¼Œå…¶ä¸­nun_unuâ€‹è¡¨ç¤ºæœªæ©ç æ ‡è®°çš„æ•°é‡ã€‚ç„¶åï¼Œæˆ‘ä»¬åˆ©ç”¨åŒ…æ‹¬å¤šå¤´äº¤å‰æ³¨æ„åŠ›å±‚å’Œä¸‰å±‚å˜æ¢å™¨å—çš„è·¨æ¨¡æ€ç¼–ç å™¨fef_efeâ€‹ï¼Œæ ¹æ®æ©ç å›¾åƒVmi\\mathbf{V}_{mi}Vmiâ€‹å’ŒåŸå§‹æ–‡æœ¬è¡¨ç¤ºEi={tij}j=1n\\mathbf{E}_i = \\{t_i^j\\}_{j=1}^nEiâ€‹={tijâ€‹}j=1nâ€‹çš„è¡¨ç¤ºï¼Œé¢„æµ‹æ‰€æœ‰åŸå§‹æ ‡è®°ã€‚æœ€åï¼Œé€šè¿‡å›¾åƒè·¨æ¨¡æ€è§£ç å™¨fdf_dfdâ€‹å°†é¢„æµ‹ç»“æœæ˜ å°„å›RGBå›¾åƒç©ºé—´ï¼Œè§£ç å™¨çš„ç»“æ„ä¸ç¼–ç å™¨ç›¸åŒï¼Œåæ¥ä¸€ä¸ªçº¿æ€§å±‚ã€‚CMIMçš„æ€»è¿‡ç¨‹è¡¨ç¤ºä¸ºï¼š Lcmim=1Î©(Ii)âˆ¥Iiâˆ’fd(fe(Vmi,Ei))âˆ¥1,\\mathcal{L}_{cmim} = \\frac{1}{\\Omega(I_i)} \\|I_i - f_d(f_e(\\mathbf{V}_{mi}, \\mathbf{E}_i))\\|_1, Lcmimâ€‹=Î©(Iiâ€‹)1â€‹âˆ¥Iiâ€‹âˆ’fdâ€‹(feâ€‹(Vmiâ€‹,Eiâ€‹))âˆ¥1â€‹, å…¶ä¸­ï¼ŒÎ©(â‹…)\\Omega(\\cdot)Î©(â‹…)è¡¨ç¤ºåƒç´ çš„æ•°é‡ï¼ŒæŸå¤±å‡½æ•°Lcmim\\mathcal{L}_{cmim}Lcmimâ€‹åŸºäºL1L_1L1â€‹æŸå¤±ã€‚ ç±»ä¼¼äºCMIMï¼Œç»™å®šæ©ç æ–‡æœ¬è¡¨ç¤ºEmi\\mathbf{E}_{mi}Emiâ€‹å’ŒåŸå§‹è§†è§‰è¡¨ç¤ºVi\\mathbf{V}_iViâ€‹ï¼Œæˆ‘ä»¬åˆ©ç”¨äº¤å‰ç†µæŸå¤±å‡½æ•°H\\mathcal{H}Hæ¥æµ‹é‡é¢„æµ‹ä¸æ©ç æ–‡æœ¬æ ‡è®°Emi\\mathbf{E}_{mi}Emiâ€‹ä¹‹é—´çš„è·ç¦»ï¼Œå³è¿›è¡Œè·¨æ¨¡æ€æ©ç è¯­è¨€å»ºæ¨¡ã€‚CMMçš„ç›®æ ‡å¯ä»¥è®¡ç®—ä¸ºï¼š Lcmm=Lcmim+H(ymi,ftd(fte(Vi,Emi))),\\mathcal{L}_{cmm} = \\mathcal{L}_{cmim} + \\mathcal{H}(y_{mi}, f_{td}(f_{te}(\\mathbf{V}_i, \\mathbf{E}_{mi}))), Lcmmâ€‹=Lcmimâ€‹+H(ymiâ€‹,ftdâ€‹(fteâ€‹(Viâ€‹,Emiâ€‹))), å…¶ä¸­ï¼Œymiy_{mi}ymiâ€‹æ˜¯ç¬¬iiiä¸ªæ©ç æ ‡è®°çš„one-hotæ ‡ç­¾ï¼Œftef_{te}fteâ€‹ä¸CMIMçš„è·¨æ¨¡æ€ç¼–ç å™¨ç›¸åŒï¼Œftdf_{td}ftdâ€‹æ˜¯åˆ†ç±»å™¨å¤´ã€‚é€šè¿‡æœ€å°åŒ–Lcmm\\mathcal{L}_{cmm}Lcmmâ€‹ï¼Œæ¨¡å‹è¢«è¿«é€šè¿‡è·¨æ¨¡æ€äº¤äº’æ‰§è¡ŒåŸå§‹ä¿¡å·çš„é‡æ„ã€‚æ­¤è¿‡ç¨‹æœ‰æ•ˆä¿ƒè¿›äº†å›¾åƒå’Œæ–‡æœ¬æ¨¡æ€ä¹‹é—´æ›´æ·±å±‚æ¬¡å…³ç³»çš„æ¢ç´¢ã€‚ æœ€ç»ˆï¼Œè®­ç»ƒçš„æ€»æŸå¤±Ltotal\\mathcal{L}_{total}Ltotalâ€‹è¡¨ç¤ºä¸ºï¼š Ltotal=Lu+La+Lcmm.\\mathcal{L}_{total} = \\mathcal{L}_u + \\mathcal{L}_a + \\mathcal{L}_{cmm}. Ltotalâ€‹=Luâ€‹+Laâ€‹+Lcmmâ€‹. å®éªŒç»“æœ æ¶ˆèå®éªŒ å¦‚è¡¨4æ‰€ç¤ºï¼Œæˆ‘ä»¬å¾—å‡ºä»¥ä¸‹ç»“è®ºï¼š å¯¹æ¯”No.0å’ŒNo.3ï¼Œè¡¨æ˜æˆ‘ä»¬æå‡ºçš„ä¸ç¡®å®šæ€§æ„ŸçŸ¥åŒ¹é…è¿‡æ»¤ï¼ˆUMFï¼‰æ˜¾è‘—æå‡äº†æ£€ç´¢æ€§èƒ½ã€‚è¿™å†æ¬¡è¯æ˜ï¼Œå¼•å…¥ä¸»è§‚é€»è¾‘ï¼ˆSLï¼‰ç†è®ºæ¥å»ºæ¨¡è·¨æ¨¡æ€åŒ¹é…æ¨¡ç³Šçš„ä¸ç¡®å®šæ€§å¯¹äºç­›é€‰é«˜ç½®ä¿¡åº¦å¯¹é½æ˜¯æœ‰æ•ˆçš„ï¼Œä½¿æˆ‘ä»¬çš„æ¨¡å‹èƒ½å¤Ÿä¸“æ³¨äºå¯é çš„æ£€ç´¢ç»“æœã€‚ No.5çš„æ¨¡å‹æ€§èƒ½ä¼˜äºNo.1ï¼Œç‰¹åˆ«æ˜¯åœ¨R@5å’ŒR@10æ–¹é¢ã€‚è¿™è¡¨æ˜åŸºäºä¸ç¡®å®šæ€§çš„å¯¹é½ä¼˜åŒ–ï¼ˆUARï¼‰é€šè¿‡åº”ç”¨åŸºäºé«˜æ–¯å™ªå£°çš„ä¸ç¡®å®šæ€§è¡¨ç¤ºå¯ä»¥æœ‰æ•ˆåœ°æ¢ç´¢ä¸€å¯¹å¤šçš„å¯¹åº”å…³ç³»ã€‚æ­¤å¤–ï¼ŒUARé‡‡ç”¨çš„æ¸è¿›å­¦ä¹ æ–¹æ³•èƒ½å¤Ÿé€‚å½“åœ°ç»“åˆç²—ç²’åº¦å’Œç»†ç²’åº¦å¯¹é½ã€‚ ä»No.6å’ŒNo.3çš„æ¯”è¾ƒä¸­ï¼Œæˆ‘ä»¬æ¨æµ‹æ·»åŠ è·¨æ¨¡æ€æ©ç å»ºæ¨¡ï¼ˆCMMï¼‰å¯¹æ£€ç´¢æ€§èƒ½æœ‰æ›´å¤§çš„å½±å“ã€‚ä¸€ä¸ªå¯èƒ½çš„åŸå› æ˜¯ï¼Œé€šè¿‡è¿›ä¸€æ­¥çš„è·¨æ¨¡æ€äº¤äº’è¿›è¡Œæ©ç è¯­è¨€å»ºæ¨¡ï¼ˆMLMï¼‰å’Œæ©ç å›¾åƒå»ºæ¨¡ï¼ˆMIMï¼‰ï¼Œåœ¨è§†è§‰å’Œè¯­è¨€ä¹‹é—´çš„ç»†ç²’åº¦å’Œç›¸å…³å…³ç³»æŒ–æ˜æ–¹é¢å¸¦æ¥äº†é¢å¤–çš„ä¼˜åŠ¿ã€‚ å…³äºé€‰æ‹©CMLMè¿˜æ˜¯CMIMçš„åˆ†æ å¯¹CMLMå’ŒCMIMé€‰æ‹©çš„åˆ†æã€‚æˆ‘ä»¬è¿›ä¸€æ­¥æ¢è®¨äº†CMLMå’ŒCMIMå„è‡ªçš„é‡è¦æ€§ã€‚å¦‚å›¾4æ‰€ç¤ºï¼Œæˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°ï¼š å«æœ‰Lcmlm\\mathcal{L}_{cmlm}Lcmlmâ€‹çš„æ¶ˆèæ¨¡å‹ï¼ˆw/Lcmlm\\mathcal{L}_{cmlm}Lcmlmâ€‹ï¼‰è¡¨ç°ä¼˜äºåŸºçº¿æ¨¡å‹ã€‚æˆ‘ä»¬è®¤ä¸ºï¼Œæ€§èƒ½æå‡çš„åŸå› åœ¨äºå›¾åƒå’Œæ–‡æœ¬ä¹‹é—´çš„å……åˆ†äº¤äº’ï¼Œè¿™æœ‰åŠ©äºå¼¥åˆè§†è§‰å’Œè¯­è¨€ä¹‹é—´æ˜¾è‘—çš„æ¨¡æ€å·®è·ã€‚ ç„¶è€Œï¼Œä»…åº”ç”¨CMLMçš„Lcmlm\\mathcal{L}_{cmlm}Lcmlmâ€‹æŸå¤±å¹¶ä¸å¦‚åŒæ—¶åº”ç”¨CMIMå’ŒCMLMï¼ˆå³w/ CMMï¼‰çš„ç»„åˆæ•ˆæœå¥½ã€‚è¿™è¡¨æ˜ï¼Œå°†æ©ç æ–‡æœ¬å’Œè§†è§‰æ ‡è®°åŒæ—¶ä½œä¸ºæŒ–æ˜å…¨é¢è·¨æ¨¡æ€å…³ç³»çš„é”šç‚¹æ˜¯ä¸å¯æˆ–ç¼ºçš„ã€‚ å¯¹UARä¸­æ¸è¿›å¯¹é½å­¦ä¹ APLçš„åˆ†æ åœ¨æ­¤ï¼Œæˆ‘ä»¬ç ”ç©¶äº†æˆ‘ä»¬æå‡ºçš„æ¸è¿›å¯¹é½å­¦ä¹ ï¼ˆAlignment Progressive Learningï¼ŒAPLï¼‰çš„è¿›å±•ï¼ŒAPLæ—¨åœ¨å…¨é¢æ¢ç´¢ä¸€å¯¹ä¸€å’Œä¸€å¯¹å¤šçš„å¯¹åº”å…³ç³»ã€‚é€šè¿‡è§‚å¯Ÿå›¾3ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼š å¼•å…¥åŠ¨æ€æƒé‡(\\gamma)çš„æ•ˆæœä¼˜äºä½¿ç”¨å¹³å‡æƒé‡çš„æ¶ˆèæ¨¡å‹ï¼ˆAvgï¼‰ã€‚æˆ‘ä»¬æ¨æµ‹å…¶åŸå› æ˜¯æ¸è¿›å­¦ä¹ çš„åº”ç”¨åœ¨å­¦ä¹ å…¨é¢çš„å¤šç²’åº¦å¯¹é½ä¸­èµ·åˆ°äº†é‡è¦ä½œç”¨ã€‚ æ‰€æå‡ºçš„APLåˆå§‹é˜¶æ®µæœ‰æ•ˆåœ°ä¸ºç²—ç²’åº¦å¯¹é½åˆ†é…äº†è¾ƒé«˜çš„æƒé‡ï¼Œå¹¶é€æ­¥è½¬å‘ä¸ºç»†ç²’åº¦å¯¹é½åˆ†é…æ›´é«˜çš„æƒé‡ã€‚ æ­¤å¤–ï¼Œæˆ‘ä»¬è¿›ä¸€æ­¥æ¢ç´¢äº†ä»¥æ˜“åˆ°éš¾çš„æ–¹å¼å­¦ä¹ å¤šç²’åº¦å¯¹é½çš„æœ‰æ•ˆæ€§ã€‚ç‰¹åˆ«åœ°ï¼Œæˆ‘ä»¬æ¯”è¾ƒäº†åˆ©ç”¨(\\gamma)å’Œ(\\hat{\\gamma})çš„æ€§èƒ½ã€‚æ˜¾ç„¶ï¼Œå‰è€…åœ¨é€‚å½“çš„å¯¹é½æ•´åˆå’Œæ£€ç´¢å‡†ç¡®æ€§æ–¹é¢è¡¨ç°å‡ºæ›´å¥½çš„é€‚åº”æ€§ã€‚è¿™ä¸€å‘ç°æ”¯æŒæˆ‘ä»¬çš„ç›´è§‰ï¼Œå³å¼•å¯¼æ¨¡å‹ä»¥æ˜“åˆ°éš¾çš„æ–¹å¼é€æ­¥å­¦ä¹ é€‚å½“çš„å¤šç²’åº¦å¯¹é½æ˜¯æ¯”å…¶ä»–æ–¹æ³•æ›´åˆç†çš„ã€‚ å¯¹åŒ¹é…ä¸ç¡®å®šæ€§æ„ŸçŸ¥åŠ¨æ€æƒé‡åˆ†é…çš„åˆ†æ ä¸ºäº†è¿›ä¸€æ­¥éªŒè¯åŒ¹é…æ¨¡ç³Šæ€§çš„å­˜åœ¨åŠæˆ‘ä»¬æå‡ºçš„UMFçš„é‡è¦æ€§ï¼Œæˆ‘ä»¬æ·±å…¥ç ”ç©¶äº†å„ç§ä¸ç¡®å®šæ€§æ„ŸçŸ¥æƒé‡åˆ†é…ä¸æ•´ä½“æ€§èƒ½ä¹‹é—´çš„å…³ç³»ã€‚ä»å›¾5ä¸­å¾—å‡ºçš„è§‚å¯Ÿç»“æœå¦‚ä¸‹ï¼š åˆ†å¸ƒåˆ†ææ¸…æ¥šåœ°æ­ç¤ºäº†ä¸å¯é åŒ¹é…å¯¹çš„å­˜åœ¨ï¼Œè¿™äº›å¯¹ç‰¹å¾ä¸ºæ˜¾è‘—çš„åŒ¹é…ä¸ç¡®å®šæ€§ã€‚è¿™ç§ä¸ç¡®å®šæ€§æºäºæ˜¾è‘—çš„ç±»å†…å˜åŒ–å’Œæœ‰é™çš„ç±»é—´å˜åŒ–ï¼Œé˜»ç¢äº†æ£€ç´¢æ€§èƒ½çš„æå‡ã€‚ ä¸ºäº†å¼ºè°ƒåŒ¹é…ä¸ç¡®å®šæ€§æ„ŸçŸ¥åŠ¨æ€æƒé‡åˆ†é…çš„æœ‰æ•ˆæ€§ï¼Œæˆ‘ä»¬æ¯”è¾ƒäº†ä¸åŒæƒé‡åˆ†é…çš„æ€§èƒ½ã€‚å°†é«˜ä¸ç¡®å®šæ€§çš„è·¨æ¨¡æ€åŒ¹é…è®¾ä¸º1(â‹…)çš„æ€§èƒ½æœ€å·®ï¼Œè¿™åæ˜ äº†æˆ‘ä»¬çš„æ¨¡å‹å—ä¸¥é‡åŒ¹é…æ¨¡ç³Šæ€§å½±å“è¿™ä¸€åŠ¨æœºçš„åˆç†æ€§ã€‚ Qualitative Analysis å¦‚å›¾6æ‰€ç¤ºï¼Œæˆ‘ä»¬è¿›è¡Œäº†å®šæ€§åˆ†æï¼Œæ¯”è¾ƒäº†æˆ‘ä»¬æå‡ºçš„AULæ–¹æ³•ä¸è¿‘æœŸçš„APTMæ–¹æ³•ï¼ˆYangç­‰ï¼Œ2023ï¼‰åœ¨å‰6ä¸ªæ£€ç´¢ç»“æœä¸­çš„è¡¨ç°ã€‚æ ¹æ®å¯è§†åŒ–ç»“æœï¼Œæˆ‘ä»¬çš„AULæ–¹æ³•åœ¨æ£€ç´¢å‡†ç¡®æ€§ä¸Šä¼˜äºAPTMæ–¹æ³•ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬çš„æ–¹æ³•AULèƒ½å¤Ÿæ»¡è¶³ç»†ç²’åº¦å’Œç²—ç²’åº¦çš„æ£€ç´¢éœ€æ±‚ï¼Œä¾‹å¦‚â€œé•¿è¢–â€æˆ–â€œé«˜ä¸ªå­ç”·äººâ€ï¼Œå› ä¸ºæˆ‘ä»¬æå‡ºçš„UARèƒ½å¤Ÿé€æ­¥ä¸”å…¨é¢åœ°è·å–å¤šç²’åº¦è¯­ä¹‰ã€‚æ­¤å¤–ï¼ŒAULè¿˜å¯¹åŒ¹é…ä¸ç¡®å®šæ€§è¿›è¡Œå»ºæ¨¡ï¼Œä»¥é‡åŒ–ç”±ç±»å†…å˜åŒ–å¤§å’Œç±»é—´å˜åŒ–å°å¼•èµ·çš„æ¨¡ç³Šæ€§ï¼Œä»è€Œå‡è½»ä¸å¯é åŒ¹é…å¯¹çš„å¹²æ‰°ï¼Œæé«˜æ€§èƒ½ã€‚ æ€»ç»“ åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§æ–°é¢–çš„è‡ªé€‚åº”ä¸ç¡®å®šæ€§å­¦ä¹ ï¼ˆAdaptive Uncertainty-based Learningï¼ŒAULï¼‰æ–¹æ³•ï¼Œä»ä¸ç¡®å®šæ€§è§’åº¦å‡ºå‘è¿›è¡ŒåŸºäºæ–‡æœ¬çš„äººå‘˜æ£€ç´¢ã€‚æˆ‘ä»¬æå‡ºäº†ä¸ç¡®å®šæ€§æ„ŸçŸ¥åŒ¹é…è¿‡æ»¤ï¼ˆUncertainty-aware Matching Filtrationï¼ŒUMFï¼‰æ¥é‡åŒ–å¹¶é˜²æ­¢ç”±äºä¸å¯é åŒ¹é…å¯¹å¼•èµ·çš„æ¨¡ç³Šå½±å“ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è®¾è®¡äº†åŸºäºä¸ç¡®å®šæ€§çš„å¯¹é½ä¼˜åŒ–ï¼ˆUncertainty-based Alignment Refinementï¼ŒUARï¼‰å’Œè·¨æ¨¡æ€æ©ç å»ºæ¨¡ï¼ˆCross-modal Masked Modelingï¼ŒCMMï¼‰æ¥å¢å¼ºå¯¹é½å­¦ä¹ å¹¶å…³æ³¨é€‚å½“çš„è·¨æ¨¡æ€å…³ç³»ã€‚åœ¨ä¸‰ä¸ªåŸºå‡†ä¸Šçš„å¤§é‡å®éªŒè¡¨æ˜äº†æˆ‘ä»¬æå‡ºçš„AULæ–¹æ³•çš„ä¼˜è¶Šæ€§ã€‚æœªæ¥ï¼Œæˆ‘ä»¬å°†æ¢ç´¢å…¶ä»–ç­–ç•¥ä»¥è¿›ä¸€æ­¥æå‡æ£€ç´¢æ€§èƒ½ã€‚","tags":["ReID","TI-ReID","AAAI","2024","AUL"],"categories":["ReID","TI-ReID"]},{"title":"DDPM åŸç†æ¨å¯¼","path":"/2024/09/26/MudSynth/Diffusion/DDPM åŸç†æ¨å¯¼/","content":"æ–‡ç« åŸºæœ¬ä¿¡æ¯ æ–‡ç« åç§°ï¼šDenoising Diffusion Probabilistic Models å‘è¡¨ä¼šè®®/å¹´ä»½ï¼šNeurIPS 2020 ä½œè€…ï¼šJonathan Ho, Ajay Jain, Pieter Abbeel å•ä½ï¼šUC Berkeley å‰ç½®çŸ¥è¯† Markovï¼šå½“å‰ä½ç½®çš„æ¦‚ç‡åªä¼šå—åˆ°å‰ä¸€æ—¶åˆ»æ¦‚ç‡å½±å“ æ­£æ€åˆ†å¸ƒçš„å åŠ æ€§eg.N(Î¼1,Ïƒ12)+N(Î¼2,Ïƒ22)=N(Î¼1+Î¼2,Ïƒ12+Ïƒ22)eg. N(\\mu_1,\\sigma_1^2)+N(\\mu_2,\\sigma_2^2) = N(\\mu_1+\\mu_2,\\sigma_1^2+\\sigma_2^2)eg.N(Î¼1â€‹,Ïƒ12â€‹)+N(Î¼2â€‹,Ïƒ22â€‹)=N(Î¼1â€‹+Î¼2â€‹,Ïƒ12â€‹+Ïƒ22â€‹) è´å¶æ–¯ï¼šP(Aâˆ£B)=P(Bâˆ£A)P(A)P(B)P(A|B) = \\frac{P(B|A)P(A)}{P(B)}P(Aâˆ£B)=P(B)P(Bâˆ£A)P(A)â€‹,P(Aâˆ£B,C)=P(Bâˆ£A,C)P(Aâˆ£C)P(Bâˆ£C)P(A|B,C) = \\frac{P(B|A,C)P(A|C)}{P(B|C)}P(Aâˆ£B,C)=P(Bâˆ£C)P(Bâˆ£A,C)P(Aâˆ£C)â€‹ å¼€å§‹æ¨ç† å‰å‘è¿‡ç¨‹ æˆ‘ä»¬å®šä¹‰æ¯æ¬¡åŠ å…¥çš„å™ªå£°æ˜¯ä¸€ä¸ªæ­£æ€åˆ†å¸ƒï¼Œæ»¡è¶³å¦‚ä¸‹å¼å­ï¼š q(xtâˆ£xtâˆ’1)=N(xt;Î±txtâˆ’1,Î²tI)q(x_t|x_{t-1}) = \\mathcal{N}(x_t; \\sqrt{\\alpha_t} x_{t-1}, \\beta_t I) q(xtâ€‹âˆ£xtâˆ’1â€‹)=N(xtâ€‹;Î±tâ€‹â€‹xtâˆ’1â€‹,Î²tâ€‹I) åœ¨DDPMï¼ˆDenoising Diffusion Probabilistic Modelsï¼‰ä¸­ï¼Œè¿™ä¸ªå…¬å¼è¡¨ç¤ºä»æ—¶é—´æ­¥éª¤ tâˆ’1t-1tâˆ’1 åˆ°æ—¶é—´æ­¥éª¤ ttt çš„çŠ¶æ€è½¬ç§»æ¦‚ç‡ã€‚å…·ä½“æ¥è¯´ï¼Œq(xtâˆ£xtâˆ’1)q(x_t | x_{t-1})q(xtâ€‹âˆ£xtâˆ’1â€‹) è¡¨ç¤ºç»™å®šå‰ä¸€çŠ¶æ€ xtâˆ’1x_{t-1}xtâˆ’1â€‹ æ—¶ï¼ŒçŠ¶æ€ xtx_txtâ€‹ çš„æ¦‚ç‡åˆ†å¸ƒã€‚ ç¬¦å· N\\mathcal{N}N è¡¨ç¤ºé«˜æ–¯ï¼ˆæ­£æ€ï¼‰åˆ†å¸ƒï¼ŒÎ±txtâˆ’1\\sqrt{\\alpha_t} x_{t-1}Î±tâ€‹â€‹xtâˆ’1â€‹ æ˜¯è¯¥é«˜æ–¯åˆ†å¸ƒçš„å‡å€¼ï¼Œè€ŒÎ²tI\\beta_t IÎ²tâ€‹I æ˜¯åˆ†å¸ƒçš„åæ–¹å·®ï¼Œè¿™é‡Œ Î±t\\alpha_tÎ±tâ€‹ å’Œ Î²t\\beta_tÎ²tâ€‹ æ˜¯ä¸æ—¶é—´æ­¥éª¤ ttt ç›¸å…³çš„ç³»æ•°ï¼ŒIII æ˜¯å•ä½çŸ©é˜µï¼Œè¡¨ç¤ºåæ–¹å·®çŸ©é˜µæ˜¯å¯¹è§’çš„ã€‚ åœ¨DDPMä¸­ï¼Œè¿™ä¸ªè¿‡ç¨‹é€šå¸¸è¢«ç”¨æ¥é€æ­¥å¢åŠ æ•°æ®çš„å™ªå£°ï¼Œå…¶ä¸­ Î±t\\alpha_tÎ±tâ€‹ å’Œ Î²t\\beta_tÎ²tâ€‹ æ˜¯éšæ—¶é—´å˜åŒ–çš„ï¼Œé€šå¸¸æ˜¯å‡å°çš„ï¼Œè¿™æ ·éšç€æ—¶é—´çš„æ¨ç§»ï¼Œç”Ÿæˆçš„æ ·æœ¬ä¼šè¶Šæ¥è¶Šå¤šåœ°åç¦»åˆå§‹æ ·æœ¬çš„åˆ†å¸ƒã€‚ç®€è€Œè¨€ä¹‹ï¼ŒDDPMçš„æ ¸å¿ƒæ˜¯ä¸€ç³»åˆ—çš„å™ªå£°æ·»åŠ å’Œå»å™ªæ­¥éª¤ï¼Œè¯¥å…¬å¼æè¿°çš„æ˜¯å…¶ä¸­å™ªå£°æ·»åŠ è¿‡ç¨‹çš„æ¦‚ç‡åˆ†å¸ƒã€‚ xt=Î±txtâˆ’1+Î²tÏµtÏµtâˆ¼N(0,I)x_t = \\sqrt{\\alpha_t} x_{t-1} + \\sqrt{\\beta_t}\\epsilon_t \\quad \\epsilon_t \\sim \\mathcal{N}(0, I) xtâ€‹=Î±tâ€‹â€‹xtâˆ’1â€‹+Î²tâ€‹â€‹Ïµtâ€‹Ïµtâ€‹âˆ¼N(0,I) Î±t=1âˆ’Î²t\\alpha_t = 1-\\beta_t Î±tâ€‹=1âˆ’Î²tâ€‹ æˆ‘ä»¬å¯ä»¥å°†é€’å½’å¼å±•å¼€ï¼Œå˜ä¸ºç›´æ¥O(1)O(1)O(1)è®¡ç®—åˆ°ä»»æ„æ—¶é—´ç‚¹çš„æ­£å‘åŠ å™ªç»“æœ xt=Î±txtâˆ’1+Î²tÏµt=Î±t(Î±tâˆ’1xtâˆ’2+Î²tâˆ’1Ïµtâˆ’1)+Î²tÏµt=â‹¯=(Î±tâ‹¯Î±1)x0+(Î±tâ‹¯Î±2)Î²1Ïµ1+(Î±tâ‹¯Î±3)Î²2Ïµ2+â‹¯+Î±tÎ²tâˆ’1Ïµtâˆ’1+Î²tÏµtâŸN(0,(1âˆ’Î±t2â‹¯Î±22)I)\\begin{align*} x_t &amp;= \\alpha_t x_{t-1} + \\beta_t \\epsilon_t \\\\ &amp;= \\alpha_t (\\alpha_{t-1}x_{t-2} + \\beta_{t-1}\\epsilon_{t-1}) + \\beta_t \\epsilon_t \\\\ &amp;= \\cdots \\\\ &amp;= (\\alpha_t \\cdots \\alpha_1)x_0 + \\underbrace{(\\alpha_t \\cdots \\alpha_2)\\beta_1\\epsilon_1 + (\\alpha_t \\cdots \\alpha_3)\\beta_2\\epsilon_2 + \\cdots + \\alpha_t \\beta_{t-1}\\epsilon_{t-1} + \\beta_t \\epsilon_t}_{\\mathcal{N}(0, (1-\\alpha_t^2 \\cdots \\alpha_2^2)I)} \\end{align*} xtâ€‹â€‹=Î±tâ€‹xtâˆ’1â€‹+Î²tâ€‹Ïµtâ€‹=Î±tâ€‹(Î±tâˆ’1â€‹xtâˆ’2â€‹+Î²tâˆ’1â€‹Ïµtâˆ’1â€‹)+Î²tâ€‹Ïµtâ€‹=â‹¯=(Î±tâ€‹â‹¯Î±1â€‹)x0â€‹+N(0,(1âˆ’Î±t2â€‹â‹¯Î±22â€‹)I)(Î±tâ€‹â‹¯Î±2â€‹)Î²1â€‹Ïµ1â€‹+(Î±tâ€‹â‹¯Î±3â€‹)Î²2â€‹Ïµ2â€‹+â‹¯+Î±tâ€‹Î²tâˆ’1â€‹Ïµtâˆ’1â€‹+Î²tâ€‹Ïµtâ€‹â€‹â€‹â€‹ æˆ‘ä»¬è®¾:Î±â€¾t=Î±1â‹¯Î±t\\overline{\\alpha}_t=\\alpha_1\\cdots \\alpha_tÎ±tâ€‹=Î±1â€‹â‹¯Î±tâ€‹ åŒ–ç®€ä¸Šå¼å¯å¾—ï¼š q(xtâˆ£x0)=Î±â€¾tx0+1âˆ’Î±â€¾tÏµÏµâˆ¼N(0,I)q(x_t|x_0) = \\sqrt{\\overline{\\alpha}_t}x_0+\\sqrt{1-\\overline{\\alpha}_t}\\epsilon\\quad\\epsilon\\sim\\mathcal{N}(0,I) q(xtâ€‹âˆ£x0â€‹)=Î±tâ€‹â€‹x0â€‹+1âˆ’Î±tâ€‹â€‹ÏµÏµâˆ¼N(0,I) q(xtâˆ£x0)=N(xt;Î±â€¾tx0,(1âˆ’Î±â€¾t)I)q(x_t|x_0) = \\mathcal{N}(x_t; \\sqrt{\\overline\\alpha_t} x_0, (1 - \\overline\\alpha_t)I) q(xtâ€‹âˆ£x0â€‹)=N(xtâ€‹;Î±tâ€‹â€‹x0â€‹,(1âˆ’Î±tâ€‹)I) è¿™é‡Œ Ïµ\\epsilonÏµ æ˜¯å¦ä¸€ä¸ªæœä» N(0,1)\\mathcal{N}(0, 1)N(0,1) çš„åˆ†å¸ƒï¼Œä»¥ä¸Šä¾¿æ˜¯å‰å‘è¿‡ç¨‹æ¶‰åŠåˆ°çš„å…¬å¼æ¨ç† é€†å‘è¿‡ç¨‹ é€†å‘è¿‡ç¨‹åˆç§°å»å™ªè¿‡ç¨‹ï¼Œä¹‹å‰çš„å‰å‘è¿‡ç¨‹æ˜¯ç»™å®šx0x_0x0â€‹æ±‚ä»»ä½•æ—¶å€™çš„xtx_txtâ€‹å³q(xtâˆ£x0)q(x_t|x_0)q(xtâ€‹âˆ£x0â€‹)ï¼Œé‚£ä¹ˆå»å™ªè¿‡ç¨‹æ‰€æ±‚çš„åˆ†å¸ƒå°±æ˜¯ç»™å®šä»»æ„æ—¶åˆ»çš„åˆ†å¸ƒxtx_txtâ€‹æ±‚åˆå§‹åˆ†å¸ƒx0x_0x0â€‹,å³p(x0âˆ£xt)p(x_0|x_t)p(x0â€‹âˆ£xtâ€‹),é€šè¿‡é©¬å°”å¯å¤«å‡è®¾ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹é€†å‘è¿‡ç¨‹è¿›è¡ŒåŒ–ç®€ï¼š p(x0âˆ£xt)=p(x0âˆ£x1)p(x1âˆ£x2)â‹¯p(xtâˆ’1âˆ£xt)=âˆi=0tâˆ’1p(xiâˆ£xi+1)p(x_0 | x_t) = p(x_0 | x_1)p(x_1 | x_2) \\cdots p(x_{t-1} | x_t) = \\prod_{i=0}^{t-1} p(x_i | x_{i+1}) p(x0â€‹âˆ£xtâ€‹)=p(x0â€‹âˆ£x1â€‹)p(x1â€‹âˆ£x2â€‹)â‹¯p(xtâˆ’1â€‹âˆ£xtâ€‹)=i=0âˆtâˆ’1â€‹p(xiâ€‹âˆ£xi+1â€‹) é‚£å¦‚ä½•æ±‚è§£p(xtâˆ’1âˆ£xt)p(x_{t-1}|x_t)p(xtâˆ’1â€‹âˆ£xtâ€‹)å‘¢ï¼Œå‰é¢çš„åŠ å™ªè¿‡ç¨‹æˆ‘ä»¬å·²ç»æ¨å‡ºäº†q(xtâˆ£xtâˆ’1)q(x_t|x_{t-1})q(xtâ€‹âˆ£xtâˆ’1â€‹),æˆ‘ä»¬å¯ä»¥é€šè¿‡è´å¶æ–¯å…¬å¼æŠŠå®ƒä»¬åˆ©ç”¨èµ·æ¥ï¼š p(xtâˆ’1âˆ£xt)=p(xtâˆ£xtâˆ’1)p(xtâˆ’1)p(xt)p(x_{t-1}|x_t) = \\frac{p(x_t|x_{t-1})p(x_{t-1})}{p(x_t)} p(xtâˆ’1â€‹âˆ£xtâ€‹)=p(xtâ€‹)p(xtâ€‹âˆ£xtâˆ’1â€‹)p(xtâˆ’1â€‹)â€‹ æ³¨æ„ï¼šè¿™é‡Œçš„(å»å™ª)på’Œä¸Šé¢çš„(åŠ å™ª)qåªæ˜¯å¯¹åˆ†å¸ƒçš„ä¸€ç§ç¬¦å·è®°æ³•,å®ƒä»¬æ˜¯ç­‰ä»·çš„. ç„¶åå°±åˆæœ‰ä¸€ä¸ªæ–°çš„é—®é¢˜ï¼Œp(xtâˆ’1)p(x_{t-1})p(xtâˆ’1â€‹)å’Œp(xt)p(x_t)p(xtâ€‹)æ˜¯æœªçŸ¥çš„ï¼Œä½†æ ¹æ®ä¹‹å‰çš„æ­£å‘è¿‡ç¨‹æ¨åˆ°ï¼Œæˆ‘ä»¬æ˜¯çŸ¥é“p(xtâˆ’1âˆ£x0)p(x_{t-1}|x_0)p(xtâˆ’1â€‹âˆ£x0â€‹)ä»¥åŠp(xtâˆ£x0)p(x_t|x_0)p(xtâ€‹âˆ£x0â€‹),å› æ­¤ä¸‹é¢çš„å¼å­æˆ‘ä»¬æ˜¯å¯ä»¥æ¨å‡ºçš„ã€‚ p(xtâˆ’1âˆ£xt,x0)=p(xtâˆ£xtâˆ’1,x0)p(xtâˆ’1âˆ£x0)p(xtâˆ£x0)p(x_{t-1} | x_t, x_0) = \\frac{p(x_t | x_{t-1}, x_0) p(x_{t-1} | x_0)}{p(x_t | x_0)} p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)=p(xtâ€‹âˆ£x0â€‹)p(xtâ€‹âˆ£xtâˆ’1â€‹,x0â€‹)p(xtâˆ’1â€‹âˆ£x0â€‹)â€‹ å› ä¸ºæˆ‘ä»¬å®šä¹‰äº†DDPMæ˜¯ä¸€ä¸ªmarkovè¿‡ç¨‹ï¼Œæ‰€ä»¥ä¸Šå¼ä¸­çš„p(xtâˆ£xtâˆ’1,x0)p(x_t|x_{t-1},x_0)p(xtâ€‹âˆ£xtâˆ’1â€‹,x0â€‹)å¯ä»¥ç­‰ä»·äºp(xtâˆ£xtâˆ’1)p(x_t|x_{t-1})p(xtâ€‹âˆ£xtâˆ’1â€‹) ã€‚è¿™æ ·ä¸Šå¼å°±å¯ä»¥åŒ–ç®€ä¸ºï¼š p(xtâˆ’1âˆ£xt,x0)=p(xtâˆ£xtâˆ’1)p(xtâˆ’1âˆ£x0)p(xtâˆ£x0)p(x_{t-1}|x_t,x_0) = \\frac{p(x_t|x_{t-1})p(x_{t-1}|x_0)}{p(x_t|x_0)} p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)=p(xtâ€‹âˆ£x0â€‹)p(xtâ€‹âˆ£xtâˆ’1â€‹)p(xtâˆ’1â€‹âˆ£x0â€‹)â€‹ OK, ç„¶åä¸‹é¢æˆ‘ä»¬æ¥æ•´ç†ä¸€ä¸‹å³ä¾§å¼å­ä¸­çš„æ¯ä¸ªpçš„è¡¨è¾¾å¼ï¼Œçœ‹çœ‹å·¦ä¾§pppæœ€åæ˜¯ä¸€ä¸ªä»€ä¹ˆåˆ†å¸ƒã€‚ é¦–å…ˆæ˜¯p(xtâˆ’1âˆ£x0)p(x_{t-1}|x_0)p(xtâˆ’1â€‹âˆ£x0â€‹)å’Œp(xtâˆ£x0)p(x_t|x_0)p(xtâ€‹âˆ£x0â€‹),ä»–ä»¬çš„è¡¨è¾¾å¼æˆ‘ä»¬åœ¨æ­£å‘è¿‡ç¨‹ä¸­å·²ç»æ¨å¯¼è¿‡äº† p(xtâˆ’1âˆ£x0)=Î±Ë‰tâˆ’1x0+1âˆ’Î±Ë‰tâˆ’1Ïµâˆ¼N(Î±Ë‰tâˆ’1x0,1âˆ’Î±Ë‰tâˆ’1)p(x_{t-1}|x_0) = \\sqrt{\\bar\\alpha_{t-1}}x_0+\\sqrt{1-\\bar\\alpha_{t-1}}\\epsilon\\sim\\mathcal{N}(\\sqrt{\\bar{\\alpha}_{t-1}}x_0,1-\\bar\\alpha_{t-1}) p(xtâˆ’1â€‹âˆ£x0â€‹)=Î±Ë‰tâˆ’1â€‹â€‹x0â€‹+1âˆ’Î±Ë‰tâˆ’1â€‹â€‹Ïµâˆ¼N(Î±Ë‰tâˆ’1â€‹â€‹x0â€‹,1âˆ’Î±Ë‰tâˆ’1â€‹) p(xtâˆ£x0)=Î±Ë‰tx0+1âˆ’Î±Ë‰tÏµÂ N(Î±Ë‰tx0,1âˆ’Î±Ë‰t)p(x_t|x_0) = \\sqrt{\\bar\\alpha_t}x_0 + \\sqrt{1-\\bar{\\alpha}_t}\\epsilon~\\mathcal{N}(\\sqrt{\\bar\\alpha_t}x_0,1-\\bar\\alpha_t) p(xtâ€‹âˆ£x0â€‹)=Î±Ë‰tâ€‹â€‹x0â€‹+1âˆ’Î±Ë‰tâ€‹â€‹ÏµÂ N(Î±Ë‰tâ€‹â€‹x0â€‹,1âˆ’Î±Ë‰tâ€‹) ç„¶åæ˜¯p(xtâˆ£xtâˆ’1)p(x_t|x_{t-1})p(xtâ€‹âˆ£xtâˆ’1â€‹)ï¼Œå°±æ˜¯åŸå§‹çš„æ­£å‘é€’æ¨è¿‡ç¨‹ï¼š p(xtâˆ£xtâˆ’1)=Î±txtâˆ’1+1âˆ’Î±tÏµâˆ¼N(Î±txtâˆ’1,1âˆ’Î±t)p(x_t|x_{t-1}) = \\sqrt{\\alpha_t}x_{t-1} + \\sqrt{1-\\alpha_t}\\epsilon\\sim\\mathcal{N}(\\sqrt\\alpha_tx_{t-1},1-\\alpha_t) p(xtâ€‹âˆ£xtâˆ’1â€‹)=Î±tâ€‹â€‹xtâˆ’1â€‹+1âˆ’Î±tâ€‹â€‹Ïµâˆ¼N(Î±â€‹tâ€‹xtâˆ’1â€‹,1âˆ’Î±tâ€‹) è¿™æ ·æˆ‘ä»¬ä¸éš¾æ¨å‡ºï¼š p(xtâˆ’1âˆ£xt,x0)âˆexpâ¡(âˆ’12((xtâˆ’Î±txtâˆ’1)2Î²t)+(xtâˆ’1âˆ’Î±Ë‰tâˆ’1x0)21âˆ’Î±Ë‰tâˆ’1âˆ’(xtâˆ’Î±Ë‰tx0)21âˆ’Î±Ë‰t)p(x_{t-1}|x_t, x_0) \\propto \\exp\\left(-\\frac{1}{2}(\\frac{\\left(x_t - \\sqrt{\\alpha_{t}}x_{t-1}\\right)^2}{\\beta_t}) + \\frac{(x_{t-1}-\\sqrt{\\bar\\alpha_{t-1}}x_0)^2}{1-\\bar\\alpha_{t-1}} - \\frac{(x_t - \\sqrt{\\bar\\alpha_t }x_0)^2}{1-\\bar\\alpha_t}\\right) p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)âˆexp(âˆ’21â€‹(Î²tâ€‹(xtâ€‹âˆ’Î±tâ€‹â€‹xtâˆ’1â€‹)2â€‹)+1âˆ’Î±Ë‰tâˆ’1â€‹(xtâˆ’1â€‹âˆ’Î±Ë‰tâˆ’1â€‹â€‹x0â€‹)2â€‹âˆ’1âˆ’Î±Ë‰tâ€‹(xtâ€‹âˆ’Î±Ë‰tâ€‹â€‹x0â€‹)2â€‹) å¯ä»¥å‘ç°ä¸Šå¼p(xtâˆ’1âˆ£xt,x0)p(x_{t-1}|x_t, x_0)p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)ä¹Ÿæ˜¯ç¬¦åˆæ­£æ€åˆ†å¸ƒè¡¨è¾¾å¼ï¼Œæ•´ç†å¾—ï¼š p(xtâˆ’1âˆ£xt,x0)=N(xtâˆ’1;Î±t(1âˆ’Î±Ë‰tâˆ’1)1âˆ’Î±Ë‰txt+Î±Ë‰tâˆ’1(1âˆ’Î±t)1âˆ’Î±Ë‰tx0,(1âˆ’Î±Ë‰tâˆ’11âˆ’Î±Ë‰t(1âˆ’Î±t))I)p(x_{t-1}|x_t, x_0) = \\mathcal{N}\\left(x_{t-1}; \\frac{\\sqrt{\\alpha_t}(1 - \\bar\\alpha_{t-1})}{1 - \\bar\\alpha_t}x_t + \\frac{\\sqrt{\\bar\\alpha_{t-1}}(1 - \\alpha_t)}{1 - \\bar\\alpha_t}x_0, \\left(\\frac{ 1 - \\bar\\alpha_{t-1}}{ 1 - \\bar\\alpha_t} ( 1-\\alpha_t )\\right)I\\right) p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)=N(xtâˆ’1â€‹;1âˆ’Î±Ë‰tâ€‹Î±tâ€‹â€‹(1âˆ’Î±Ë‰tâˆ’1â€‹)â€‹xtâ€‹+1âˆ’Î±Ë‰tâ€‹Î±Ë‰tâˆ’1â€‹â€‹(1âˆ’Î±tâ€‹)â€‹x0â€‹,(1âˆ’Î±Ë‰tâ€‹1âˆ’Î±Ë‰tâˆ’1â€‹â€‹(1âˆ’Î±tâ€‹))I) ä¸Šå¼çœ‹ç€è¾ƒä¸ºå¤æ‚ï¼Œç¨å¾®è°ƒæ•´ä¸€ä¸‹ï¼š p(xtâˆ’1âˆ£xt,x0)=N(xtâˆ’1;Î¼,Ïƒ2)p(x_{t-1}|x_t, x_0) = \\mathcal{N}\\left(x_{t-1};\\mu,\\sigma^2\\right) p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)=N(xtâˆ’1â€‹;Î¼,Ïƒ2) Î¼=Î±t(1âˆ’Î±Ë‰tâˆ’1)1âˆ’Î±Ë‰txt+Î±Ë‰tâˆ’1(1âˆ’Î±t)1âˆ’Î±Ë‰tx0\\mu = \\frac{\\sqrt{\\alpha_t}(1 - \\bar\\alpha_{t-1})}{1 - \\bar\\alpha_t}x_t + \\frac{\\sqrt{\\bar\\alpha_{t-1}}(1 - \\alpha_t)}{1 - \\bar\\alpha_t}x_0 Î¼=1âˆ’Î±Ë‰tâ€‹Î±tâ€‹â€‹(1âˆ’Î±Ë‰tâˆ’1â€‹)â€‹xtâ€‹+1âˆ’Î±Ë‰tâ€‹Î±Ë‰tâˆ’1â€‹â€‹(1âˆ’Î±tâ€‹)â€‹x0â€‹ Ïƒ2=1âˆ’Î±Ë‰tâˆ’11âˆ’Î±Ë‰t(1âˆ’Î±t)\\sigma^2 = \\frac{ 1 - \\bar\\alpha_{t-1}}{ 1 - \\bar\\alpha_t} ( 1-\\alpha_t ) Ïƒ2=1âˆ’Î±Ë‰tâ€‹1âˆ’Î±Ë‰tâˆ’1â€‹â€‹(1âˆ’Î±tâ€‹) æˆ‘ä»¬å…ˆæ•´ç†ä¸€ä¸‹æ€è·¯ï¼Œç°åœ¨æˆ‘ä»¬æ¨å‡ºçš„p(xtâˆ’1âˆ£xt,x0)p(x_{t-1}|x_t,x_0)p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)æ˜¯çœŸå®çš„æ¡ä»¶åˆ†å¸ƒï¼Œç›®æ ‡æ˜¯è®©æ¨¡å‹å­¦åˆ°çš„æ¡ä»¶åˆ†å¸ƒpÎ¸(xtâˆ’1âˆ£xt)p_{\\theta}(x_{t-1}|x_t)pÎ¸â€‹(xtâˆ’1â€‹âˆ£xtâ€‹)å°½å¯èƒ½çš„æ¥è¿‘çœŸå®çš„æ¡ä»¶åˆ†å¸ƒp(xtâˆ’1âˆ£xt,x0)p(x_{t-1}|x_t,x_0)p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)ã€‚ä»ä¸Šå¼å¯ä»¥çœ‹åˆ°æ–¹å·®æ˜¯ä¸ªå›ºå®šé‡,é‚£ä¹ˆæˆ‘ä»¬è¦åšçš„å°±æ˜¯è®©Â p(xtâˆ’1âˆ£xt,x0)p(x_{t-1}|x_t,x_0)p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)Â ä¸Â pÎ¸(xtâˆ’1âˆ£xt)p_{\\theta}(x_{t-1}|x_t)pÎ¸â€‹(xtâˆ’1â€‹âˆ£xtâ€‹)Â çš„å‡å€¼å°½å¯èƒ½çš„å¯¹é½ã€‚ ä½†è§‚å¯Ÿå‡å€¼å…¬å¼ï¼Œä¸éš¾å‘ç°å…¶ä¸­çš„x0x_0x0â€‹æ˜¯æœªçŸ¥çš„ï¼Œè¿™æ˜¯æˆ‘ä»¬ä¸å¸Œæœ›çœ‹åˆ°çš„æƒ…å†µï¼Œä½†æ˜¯ç»“åˆæˆ‘ä»¬ä¹‹å‰å·²ç»æ¨å‡ºçš„ï¼š xt=Î±â€¾tx0+1âˆ’Î±â€¾tÏµÏµâˆ¼N(0,I)x_t= \\sqrt{\\overline{\\alpha}_t}x_0+\\sqrt{1-\\overline{\\alpha}_t}\\epsilon\\quad\\epsilon\\sim\\mathcal{N}(0,I) xtâ€‹=Î±tâ€‹â€‹x0â€‹+1âˆ’Î±tâ€‹â€‹ÏµÏµâˆ¼N(0,I) å°†x0x_0x0â€‹ç§»è‡³å·¦è¾¹,å¾—åˆ°å…³äºx0x_0x0â€‹çš„è¡¨è¾¾å¼ x0=1Î±Ë‰t(xtâˆ’1âˆ’Î±Ë‰tÏµ)x_0 = \\frac{1}{\\sqrt{\\bar\\alpha_t}}(x_t-\\sqrt{1-\\bar\\alpha_t}\\epsilon) x0â€‹=Î±Ë‰tâ€‹â€‹1â€‹(xtâ€‹âˆ’1âˆ’Î±Ë‰tâ€‹â€‹Ïµ) ä»£å…¥Î¼\\muÎ¼è¡¨è¾¾å¼ä¸­å¯å¾—ï¼š Î¼=Î±t(1âˆ’Î±Ë‰tâˆ’1)1âˆ’Î±Ë‰txt+Î±Ë‰tâˆ’1(1âˆ’Î±t)1âˆ’Î±Ë‰t1Î±Ë‰t(xtâˆ’1âˆ’Î±Ë‰tÏµ)=Î±t(1âˆ’Î±Ë‰tâˆ’1)1âˆ’Î±Ë‰txt+(1âˆ’Î±t)1âˆ’Î±Ë‰t1Î±t(xtâˆ’1âˆ’Î±Ë‰tÏµ)=Î±t(1âˆ’Î±Ë‰tâˆ’1)+(1âˆ’Î±t)Î±t(1âˆ’Î±Ë‰t)xtâˆ’(1âˆ’Î±t)1âˆ’Î±Ë‰tÎ±t(1âˆ’Î±Ë‰t)Ïµ=1âˆ’Î±Ë‰tÎ±t(1âˆ’Î±Ë‰t)xtâˆ’1âˆ’Î±tÎ±t1âˆ’Î±Ë‰tÏµ=1Î±txtâˆ’1âˆ’Î±tÎ±t1âˆ’Î±Ë‰tÏµ\\begin{align*} \\mu &amp;= \\frac{\\sqrt{\\alpha_t}(1 - \\bar{\\alpha}_{t-1})}{1 - \\bar{\\alpha}_t} x_t + \\frac{\\sqrt{\\bar\\alpha_{t-1}}(1 - \\alpha_t)}{1 - \\bar{\\alpha}_t} \\frac{1}{\\sqrt{\\bar\\alpha_t}} \\left(x_t - \\sqrt{1 - \\bar{\\alpha}_t} \\epsilon \\right) \\\\ &amp;= \\frac{\\sqrt{\\alpha_t}(1 - \\bar{\\alpha}_{t-1})}{1 - \\bar{\\alpha}_t} x_t + \\frac{(1 - \\alpha_t)}{1 - \\bar{\\alpha}_t} \\frac{1}{\\sqrt{\\alpha_t}} \\left(x_t - \\sqrt{1 - \\bar{\\alpha}_t} \\epsilon \\right) \\\\ &amp;= \\frac{\\alpha_t(1 - \\bar{\\alpha}_{t-1}) + (1 - \\alpha_t)}{\\sqrt{\\alpha_t}(1 - \\bar{\\alpha}_t)} x_t - \\frac{(1 - \\alpha_t) \\sqrt{1 - \\bar{\\alpha}_t}}{\\sqrt{\\alpha_t}(1 - \\bar{\\alpha}_t)} \\epsilon \\\\ &amp;= \\frac{1 - \\bar{\\alpha}_t}{\\sqrt{\\alpha_t}(1 - \\bar{\\alpha}_t)} x_t - \\frac{1 - \\alpha_t }{\\sqrt{\\alpha_t}\\sqrt{1 - \\bar{\\alpha}_t}} \\epsilon \\\\ &amp;= \\frac{1}{\\sqrt{\\alpha_t}} x_t - \\frac{1 - \\alpha_t}{\\sqrt{\\alpha_t} \\sqrt{1 - \\bar{\\alpha}_t}} \\epsilon \\end{align*} Î¼â€‹=1âˆ’Î±Ë‰tâ€‹Î±tâ€‹â€‹(1âˆ’Î±Ë‰tâˆ’1â€‹)â€‹xtâ€‹+1âˆ’Î±Ë‰tâ€‹Î±Ë‰tâˆ’1â€‹â€‹(1âˆ’Î±tâ€‹)â€‹Î±Ë‰tâ€‹â€‹1â€‹(xtâ€‹âˆ’1âˆ’Î±Ë‰tâ€‹â€‹Ïµ)=1âˆ’Î±Ë‰tâ€‹Î±tâ€‹â€‹(1âˆ’Î±Ë‰tâˆ’1â€‹)â€‹xtâ€‹+1âˆ’Î±Ë‰tâ€‹(1âˆ’Î±tâ€‹)â€‹Î±tâ€‹â€‹1â€‹(xtâ€‹âˆ’1âˆ’Î±Ë‰tâ€‹â€‹Ïµ)=Î±tâ€‹â€‹(1âˆ’Î±Ë‰tâ€‹)Î±tâ€‹(1âˆ’Î±Ë‰tâˆ’1â€‹)+(1âˆ’Î±tâ€‹)â€‹xtâ€‹âˆ’Î±tâ€‹â€‹(1âˆ’Î±Ë‰tâ€‹)(1âˆ’Î±tâ€‹)1âˆ’Î±Ë‰tâ€‹â€‹â€‹Ïµ=Î±tâ€‹â€‹(1âˆ’Î±Ë‰tâ€‹)1âˆ’Î±Ë‰tâ€‹â€‹xtâ€‹âˆ’Î±tâ€‹â€‹1âˆ’Î±Ë‰tâ€‹â€‹1âˆ’Î±tâ€‹â€‹Ïµ=Î±tâ€‹â€‹1â€‹xtâ€‹âˆ’Î±tâ€‹â€‹1âˆ’Î±Ë‰tâ€‹â€‹1âˆ’Î±tâ€‹â€‹Ïµâ€‹ ç»è¿‡ä¸Šè¿°åŒ–ç®€ï¼Œæˆ‘ä»¬æˆåŠŸå°†Î¼(x0,xt)â‡’Î¼(xt,Ïµ)\\mu(x_0,x_t)\\Rightarrow \\mu(x_t,\\epsilon)Î¼(x0â€‹,xtâ€‹)â‡’Î¼(xtâ€‹,Ïµ) æ­¤æ—¶ï¼Œå¼å­ä¸­æœªçŸ¥çš„éƒ¨åˆ†åªå‰©ä¸‹Ïµ\\epsilonÏµ,è¿™æ ·å¯¹é½å‡å€¼çš„é—®é¢˜è½¬åŒ–ä¸ºäº†å·²çŸ¥xt,tx_t,txtâ€‹,tä½¿ç”¨ç¥ç»ç½‘ç»œ( ÏµÎ¸(xt,t)\\epsilon_\\theta(x_t,t)ÏµÎ¸â€‹(xtâ€‹,t) )é¢„æµ‹åŠ å…¥çš„å™ªå£°Ïµ\\epsilonÏµé—®é¢˜ï¼Œä»è€Œæˆ‘ä»¬ä¹ŸçŸ¥é“äº†ä¼˜åŒ–ç›®æ ‡â€”â€”æœ€å°åŒ–âˆ£âˆ£Ïµâˆ’ÏµÎ¸(xt,t)âˆ£âˆ£2||\\epsilon-\\epsilon_\\theta(x_t,t)||^2âˆ£âˆ£Ïµâˆ’ÏµÎ¸â€‹(xtâ€‹,t)âˆ£âˆ£2 Î¼â‰ƒÎ¼Î¸(xt,t)=1Î±txtâˆ’1âˆ’Î±tÎ±t1âˆ’Î±Ë‰tÏµÎ¸(xt,t)\\mu \\simeq \\mu_\\theta(\\mathbf{x}_t, t) = \\frac{1}{\\sqrt{\\alpha_t}} \\mathbf{x}_t - \\frac{1 - \\alpha_t}{\\sqrt{\\alpha_t} \\sqrt{1 - \\bar{\\alpha}_t}} \\epsilon_\\theta(\\mathbf{x}_t, t) Î¼â‰ƒÎ¼Î¸â€‹(xtâ€‹,t)=Î±tâ€‹â€‹1â€‹xtâ€‹âˆ’Î±tâ€‹â€‹1âˆ’Î±Ë‰tâ€‹â€‹1âˆ’Î±tâ€‹â€‹ÏµÎ¸â€‹(xtâ€‹,t) ä»¥ä¸Šä¾¿æ˜¯DDPMæ•´ä¸ªæµç¨‹çš„å…¬å¼æ¨å¯¼ã€‚ ä»£ç éƒ¨åˆ† è¯¦ç»†ä»£ç å¯ä»¥çœ‹æˆ‘forkçš„ä»“åº“Mudrobot/Diffusion_models_tutorial (github.com)ä¸­çš„Diffusers_library.ipynbæ–‡ä»¶è¿›è¡Œç†è§£ï¼Œè¿™é‡Œä¸»è¦å±•ç¤ºå’Œè®²è§£ä¸€ä¸‹ä¸¤ä¸ªé‡è¦çš„è¿‡ç¨‹ä»¥åŠè®­ç»ƒå’Œæ¨ç†éƒ¨åˆ†ã€‚ æ­£å‘è¿‡ç¨‹ 12345678def q_sample(self, x_start, t, noise=None):\tif noise is None: noise = torch.randn_like(x_start) # å™ªå£°é‡‡æ ·\tsqrt_alphas_cumprod_t = self._extract(self.sqrt_alphas_cumprod, t, x_start.shape)\tsqrt_one_minus_alphas_cumprod_t = self._extract(self.sqrt_one_minus_alphas_cumprod, t, x_start.shape)\treturn sqrt_alphas_cumprod_t * x_start + sqrt_one_minus_alphas_cumprod_t * noise æœ€åä¸€ä¸ªreturnå°±æ˜¯xt=Î±txtâˆ’1+Î²tÏµtÏµtâˆ¼N(0,I)x_t = \\sqrt{\\alpha_t} x_{t-1} + \\sqrt{\\beta_t}\\epsilon_t \\quad \\epsilon_t \\sim \\mathcal{N}(0, I)xtâ€‹=Î±tâ€‹â€‹xtâˆ’1â€‹+Î²tâ€‹â€‹Ïµtâ€‹Ïµtâ€‹âˆ¼N(0,I) å¯ä»¥ä½¿ç”¨ä¸‹é¢ä»£ç å¯è§†åŒ–ä¸€ä¸‹è¾“å‡ºç»“æœï¼š 12345678for idx, t in enumerate([0, 50, 100, 200, 499]): x_noisy = gaussian_diffusion.q_sample(x_start, t=torch.tensor([t])) noisy_image = (x_noisy.squeeze().permute(1, 2, 0) + 1) * 127.5 noisy_image = noisy_image.numpy().astype(np.uint8) plt.subplot(1, 5, 1 + idx) plt.imshow(noisy_image) plt.axis(&quot;off&quot;) plt.title(f&quot;t=&#123;t&#125;&quot;) è®­ç»ƒç›®æ ‡ è®­ç»ƒç›®æ ‡å¦‚ä¹‹å‰æœ€åæ‰€è¯´ï¼Œå°±æ˜¯ä½¿ç”¨ç¥ç»ç½‘ç»œ(ç¬¬7è¡Œçš„model)å»é¢„æµ‹ä¹‹å‰å…¬å¼ä¸­å¯¹å›¾åƒæ·»åŠ çš„å™ªå£°Ïµ\\epsilonÏµ,ç„¶åç›®æ ‡å‡½æ•°å°±æ˜¯æœ€å°åŒ–æ¨¡å‹é¢„æµ‹çš„ÏµÎ¸(xt,t)\\epsilon_\\theta(x_t,t)ÏµÎ¸â€‹(xtâ€‹,t)å’ŒÏµ\\epsilonÏµçš„å‡æ–¹è¯¯å·®ã€‚ ä»£ç å¦‚ä¸‹ï¼š 123456789# compute train lossesdef train_losses(self, model, x_start, t):\t# generate random noise\tnoise = torch.randn_like(x_start)\t# get x_t\tx_noisy = self.q_sample(x_start, t, noise=noise)\tpredicted_noise = model(x_noisy, t)\tloss = F.mse_loss(noise, predicted_noise)\treturn loss è®­ç»ƒéƒ¨åˆ† ç†è§£åˆ°é€†å‘è¿‡ç¨‹åï¼Œæ¥ç€æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹è®­ç»ƒè¿‡ç¨‹ï¼Œå…¶å®å°±æ˜¯å¯¹äºæ¯ä¸ªbatchä¸­çš„æ‰€æœ‰å›¾åƒéƒ½éœ€è¦éšæœºé‡‡æ ·ä¸€ä¸ªæ—¶é—´ç‚¹ï¼Œç”¨äºè®¡ç®—è¦åŠ çš„å™ªå£°é‡ã€‚ 1234567891011121314151617181920# trainepochs = 10for epoch in range(epochs): for step, (images, labels) in enumerate(train_loader): optimizer.zero_grad() batch_size = images.shape[0] images = images.to(device) # sample t uniformally for every example in the batch t = torch.randint(0, timesteps, (batch_size,), device=device).long() loss = gaussian_diffusion.train_losses(model, images, t) if step % 200 == 0: print(&quot;Loss:&quot;, loss.item()) loss.backward() optimizer.step() é€†å‘è¿‡ç¨‹ è®­ç»ƒçš„æ—¶å€™æ¨¡å‹å­¦ä¹ çš„æ˜¯Ïµ\\epsilonÏµ, ä½†æ¨ç†çš„æ—¶å€™æ¨¡å‹éœ€è¦æ ¹æ®å½“å‰çš„æ—¶é—´æ­¥å¯¹é¢„æµ‹çš„Ïµ\\epsilonÏµåšå˜æ¢å¾—åˆ°å½“å‰æ­¥çš„é¢„æµ‹å™ªå£°Ïµt\\epsilon_tÏµtâ€‹çš„Î¼\\muÎ¼ï¼Œä»è€Œé‡‡æ ·å½“å‰æ­¥çš„é™å™ªå™ªå£°ÏµtâˆˆN(Î¼,Ïƒ)\\epsilon_t\\in\\mathcal{N}(\\mu,\\sigma)Ïµtâ€‹âˆˆN(Î¼,Ïƒ) (Ïƒ\\sigmaÏƒå·²çŸ¥) é¢„æµ‹å½“å‰æ—¶é—´æ­¥å™ªå£°å‡å€¼å’Œæ–¹å·®çš„ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 1234567891011121314151617181920# Compute the mean and variance of the diffusion posterior: q(x_&#123;t-1&#125; | x_t, x_0)def q_posterior_mean_variance(self, x_start, x_t, t):\tposterior_mean = ( self._extract(self.posterior_mean_coef1, t, x_t.shape) * x_start + self._extract(self.posterior_mean_coef2, t, x_t.shape) * x_t\t)\tposterior_variance = self._extract(self.posterior_variance, t, x_t.shape)\tposterior_log_variance_clipped = self._extract(self.posterior_log_variance_clipped, t, x_t.shape)\treturn posterior_mean, posterior_variance, posterior_log_variance_clipped# compute predicted mean and variance of p(x_&#123;t-1&#125; | x_t)def p_mean_variance(self, model, x_t, t, clip_denoised=True):\t# predict noise using model\tpred_noise = model(x_t, t)\t# get the predicted x_0: different from the algorithm2 in the paper\tx_recon = self.predict_start_from_noise(x_t, t, pred_noise)\tif clip_denoised: x_recon = torch.clamp(x_recon, min=-1., max=1.)\tmodel_mean, posterior_variance, posterior_log_variance = \\ self.q_posterior_mean_variance(x_recon, x_t, t)\treturn model_mean, posterior_variance, posterior_log_variance é‡‡æ ·å¹¶æ¶ˆé™¤å™ªå£°ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š ç¬¬10è¡Œä¸­ï¼Œå¯¹æ•°æ–¹å·®ä¹˜0.5å–æŒ‡æ•°çš„å«ä¹‰æ˜¯ï¼Œå°†å¯¹æ•°æ–¹å·®è½¬åŒ–ä¸ºæ–¹å·®åå¼€æ ¹å·å¾—æ ‡å‡†å·®ã€‚ å…¬å¼æ˜¯ï¼šÏƒ=Ïƒ2=elogâ¡(Ïƒ2)=e0.5â‹…logâ¡(Ïƒ2)\\sigma = \\sqrt{\\sigma^2} = \\sqrt{e^{\\log(\\sigma^2)}} = e^{0.5 \\cdot \\log(\\sigma^2)}Ïƒ=Ïƒ2â€‹=elog(Ïƒ2)â€‹=e0.5â‹…log(Ïƒ2) 1234567891011@torch.no_grad()def p_sample(self, model, x_t, t, clip_denoised=True):\t# predict mean and variance\tmodel_mean, _, model_log_variance = self.p_mean_variance(model, x_t, t, clip_denoised=clip_denoised)\tnoise = torch.randn_like(x_t)\t# no noise when t == 0\tnonzero_mask = ((t != 0).float().view(-1, *([1] * (len(x_t.shape) - 1))))\t# compute x_&#123;t-1&#125;\tpred_img = model_mean + nonzero_mask * (0.5 * model_log_variance).exp() * noise\treturn pred_img æ¨ç†éƒ¨åˆ† ç†è§£äº†ä¸Šé¢çš„é€†å‘è¿‡ç¨‹åï¼Œæ¨ç†éƒ¨åˆ†çš„ç”Ÿæˆå°±éå¸¸å¥½ç†è§£äº†ã€‚å°±æ˜¯ä¸æ–­çš„è°ƒç”¨p_sampleå‡½æ•°é€æ¸ä»ä¸€ä¸ªå…¨å™ªå£°ç”Ÿæˆå›¾åƒçš„è¿‡ç¨‹(ä¸»å‡½æ•°å…ˆè°ƒç”¨sample)ã€‚ 1234567891011121314151617# denoise: reverse diffusion@torch.no_grad()def p_sample_loop(self, model, shape):\tbatch_size = shape[0]\tdevice = next(model.parameters()).device\t# start from pure noise (for each example in the batch)\timg = torch.randn(shape, device=device)\timgs = []\tfor i in tqdm(reversed(range(0, timesteps)), desc=&#x27;sampling loop time step&#x27;, total=timesteps): img = self.p_sample(model, img, torch.full((batch_size,), i, device=device, dtype=torch.long)) imgs.append(img.cpu().numpy())\treturn imgs# sample new images@torch.no_grad()def sample(self, model, image_size, batch_size=8, channels=3):\treturn self.p_sample_loop(model, shape=(batch_size, channels, image_size, image_size)) å¦‚æœè¦æ§åˆ¶diffusionç”Ÿæˆç‰¹å®šç±»åˆ«çš„å›¾åƒï¼Œä¼šä½¿ç”¨classifier free guidanceæ–¹æ³•ï¼Œåç»­ä¼šè®²è§£ã€‚ è¯¥ipynbæ–‡ä»¶æœ€åå¯¹äºMNISTæ‰‹å†™æ•°æ®é›†çš„ç”Ÿæˆæ•ˆæœå¦‚ä¸‹ï¼š","tags":["Diffusion","IMPORTANT","DDPM","NeurIPS","2020"],"categories":["Diffusion"]},{"title":"DDIM åŸç†æ¨å¯¼","path":"/2024/09/26/MudSynth/Diffusion/DDIM åŸç†æ¨å¯¼/","content":"å­¦ä¹ æ•´ç†è‡ªï¼šdiffusion model(äºŒ)ï¼šDDIMæŠ€æœ¯å°ç»“ (denoising diffusion implicit model) | è«å¶ä½•ç«¹ğŸ€ (myhz0606.com)ï¼Œæ¬¢è¿é˜…è¯»åŸæ–‡ æ–‡ç« åŸºæœ¬ä¿¡æ¯ æ–‡ç« åç§°ï¼šDenoising Diffusion Implicit Models å‘è¡¨ä¼šè®®/å¹´ä»½ï¼šICLR 2021 ä½œè€…ï¼šJiaming Song, Chenlin Meng &amp; Stefano Ermon å•ä½ï¼šStanford University èƒŒæ™¯ å°½ç®¡å»å™ªæ‰©æ•£æ¦‚ç‡æ¨¡å‹ï¼ˆDDPMï¼‰æ— éœ€å¯¹æŠ—è®­ç»ƒå³å¯å®ç°é«˜è´¨é‡å›¾åƒç”Ÿæˆï¼Œä½†å…¶é‡‡æ ·è¿‡ç¨‹ä¾èµ–äºé©¬å°”å¯å¤«å‡è®¾ï¼Œéœ€è¦è¾ƒå¤šçš„æ—¶é—´æ­¥æ‰èƒ½å¾—åˆ°è¾ƒå¥½çš„ç”Ÿæˆæ•ˆæœã€‚æœ¬æ–‡ä»‹ç»çš„å»å™ªæ‰©æ•£éšå¼æ¨¡å‹ï¼ˆDDIMï¼‰æ˜¯ä¸€ç§æ›´æœ‰æ•ˆçš„è¿­ä»£éšå¼æ¦‚ç‡æ¨¡å‹ï¼Œè®­ç»ƒè¿‡ç¨‹ä¸DDPMç›¸åŒï¼Œä½†é‡‡æ ·è¿‡ç¨‹æ¯”DDPMå¿«10åˆ°50å€ã€‚ DDPMä¸ºä½•æ…¢ ä»DDPMä¸­æˆ‘ä»¬çŸ¥é“ï¼Œå…¶æ‰©æ•£è¿‡ç¨‹ï¼ˆå‰å‘è¿‡ç¨‹ï¼Œæˆ–åŠ å™ªè¿‡ç¨‹ï¼Œforward processï¼‰è¢«å®šä¹‰ä¸ºä¸€ä¸ªé©¬å°”å¯å¤«è¿‡ç¨‹ï¼š q(x1:Tâˆ£x0):=âˆt=1Tq(xtâˆ£xtâˆ’1),q(x_{1:T}|x_0) := \\prod_{t=1}^{T} q(x_t|x_{t-1}), q(x1:Tâ€‹âˆ£x0â€‹):=t=1âˆTâ€‹q(xtâ€‹âˆ£xtâˆ’1â€‹), å…¶ä¸­ï¼š q(xtâˆ£xtâˆ’1)=N(xt;Î±txtâˆ’1,(1âˆ’Î±t)I)q(x_t|x_{t-1}) = \\mathcal{N}(x_t; \\sqrt{\\alpha_t}x_{t-1}, (1-\\alpha_t)\\mathbf{I}) q(xtâ€‹âˆ£xtâˆ’1â€‹)=N(xtâ€‹;Î±tâ€‹â€‹xtâˆ’1â€‹,(1âˆ’Î±tâ€‹)I) é€šè¿‡è¿™æ ·è®¾ç½®ï¼Œå‰å‘è¿‡ç¨‹æœ‰ä¸€ä¸ªå¾ˆå¥½çš„æ€§è´¨ï¼Œå¯ä»¥é€šè¿‡ x0x_0x0â€‹ å¾—åˆ°ä»»æ„æ—¶åˆ» xtx_txtâ€‹ çš„åˆ†å¸ƒï¼Œè€Œæ— éœ€ç¹ççš„é“¾å¼è®¡ç®—ï¼š q(xtâˆ£x0):=âˆ«q(x1:tâˆ£x0)dx1:(tâˆ’1)=N(xt;Î±tË‰x0,(1âˆ’Î±tË‰)I)(1)q(x_t|x_0) := \\int q(x_{1:t}|x_0) dx_{1:(t-1)} = \\mathcal{N}(x_t; \\sqrt{\\bar{\\alpha_t}}x_0, (1-\\bar{\\alpha_t})\\mathbf{I})\\tag{1} q(xtâ€‹âˆ£x0â€‹):=âˆ«q(x1:tâ€‹âˆ£x0â€‹)dx1:(tâˆ’1)â€‹=N(xtâ€‹;Î±tâ€‹Ë‰â€‹â€‹x0â€‹,(1âˆ’Î±tâ€‹Ë‰â€‹)I)(1) å…¶å»å™ªè¿‡ç¨‹ï¼ˆä¹Ÿæœ‰å«é€†å‘è¿‡ç¨‹ï¼Œreverse processï¼‰ä¹Ÿæ˜¯ä¸€ä¸ªé©¬å°”å¯å¤«è¿‡ç¨‹ï¼š pÎ¸(x0:T)=p(xT)âˆt=1TpÎ¸(xtâˆ’1âˆ£xt),p_\\theta(x_{0:T}) = p(x_T) \\prod_{t=1}^{T} p_\\theta(x_{t-1}|x_t), pÎ¸â€‹(x0:Tâ€‹)=p(xTâ€‹)t=1âˆTâ€‹pÎ¸â€‹(xtâˆ’1â€‹âˆ£xtâ€‹), å…¶ä¸­ï¼š p(xT):=N(0,I),p(x_T) := \\mathcal{N}(0, \\mathbf{I}), p(xTâ€‹):=N(0,I), å¹¶ä¸”ï¼š pÎ¸(xtâˆ’1âˆ£xt)=N(xtâˆ’1;Î¼Î¸(xt,t),ÏƒtI)p_\\theta(x_{t-1}|x_t) = \\mathcal{N}(x_{t-1}; \\mu_\\theta(x_t, t), \\sigma_t\\mathbf{I}) pÎ¸â€‹(xtâˆ’1â€‹âˆ£xtâ€‹)=N(xtâˆ’1â€‹;Î¼Î¸â€‹(xtâ€‹,t),Ïƒtâ€‹I) ä»å¼ (1) å¯ä»¥çœ‹å‡ºï¼Œå½“ ttt è¶³å¤Ÿå¤§æ—¶ï¼Œ q(xtâˆ£x0)q(x_t|x_0)q(xtâ€‹âˆ£x0â€‹) å¯¹æ‰€æœ‰ x0x_0x0â€‹ éƒ½æ”¶æ•›äºæ ‡å‡†é«˜æ–¯åˆ†å¸ƒã€‚å› æ­¤DDPMåœ¨å»å™ªè¿‡ç¨‹ä¸­å®šä¹‰ï¼š pÎ¸(xT):=N(0,I)p_\\theta(x_T) := \\mathcal{N}(0, \\mathbf{I}) pÎ¸â€‹(xTâ€‹):=N(0,I) å¹¶ä¸”é‡‡ç”¨ä¸€ä¸ªè¾ƒå¤§çš„é‡‡æ ·æ—¶é—´æ­¥æ•° TTTã€‚åœ¨å¯¹ pÎ¸(xtâˆ’1âˆ£xt)p_\\theta(x_{t-1}|x_t)pÎ¸â€‹(xtâˆ’1â€‹âˆ£xtâ€‹) çš„æ¨å¯¼ä¸­ï¼ŒDDPMç”¨åˆ°äº†ä¸€é˜¶é©¬å°”å¯å¤«å‡è®¾ï¼Œä½¿å¾— p(xtâˆ£xtâˆ’1,x0)=p(xtâˆ£xtâˆ’1)p(x_t|x_{t-1}, x_0) = p(x_t|x_{t-1})p(xtâ€‹âˆ£xtâˆ’1â€‹,x0â€‹)=p(xtâ€‹âˆ£xtâˆ’1â€‹)ï¼Œå› æ­¤é‡å»ºçš„æ­¥é•¿éå¸¸é•¿ï¼Œå¯¼è‡´é€Ÿåº¦æ…¢ã€‚ DDIMæ¨ç† DDPMé€Ÿåº¦æ…¢çš„æœ¬è´¨åŸå› æ˜¯å¯¹é©¬å°”å¯å¤«å‡è®¾çš„ä¾èµ–ï¼Œå¯¼è‡´é‡å»ºéœ€è¦è¾ƒå¤šçš„æ­¥é•¿ã€‚é‚£ä¹ˆä¸ç”¨ä¸€é˜¶é©¬å°”å¯å¤«å‡è®¾ï¼Œæœ‰æ²¡æœ‰å¦ä¸€ç§æ–¹æ³•æ¨å¯¼å‡ºé‡‡æ ·åˆ†å¸ƒp(xtâˆ’1âˆ£xt,x0)p(x_{t-1}|x_t,x_0)p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)å‘¢ï¼Ÿ DDIMæ‰€æå‡ºçš„åˆè¡·å°±æ˜¯ï¼š ç»´æŒDDPMå‰å‘æ¨ç†è¿‡ç¨‹ä¸­çš„é©¬å°”å¯å¤«å‡è®¾ï¼ˆå¯ä»¥ç›´æ¥ä½¿ç”¨DDPMä¸­æ‰€è®­ç»ƒçš„å™ªå£°é¢„æµ‹æ¨¡å‹ï¼‰ æ”¹å˜DDPMåå‘æ¨ç†ä¸­çš„é©¬å°”å¯å¤«å‡è®¾è®©é‡‡æ ·åˆ†å¸ƒçš„æ¨å¯¼ä¸ä¾èµ–é©¬å°”å¯å¤«å‡è®¾ï¼ˆè¿™æ ·ä¸éœ€è¦ä¸€æ­¥ä¸€æ­¥æ¨å›å»ï¼‰ DDIMé‡‡æ ·åˆ†å¸ƒæ±‚è§£ å›åˆ°æˆ‘ä»¬çš„ç›®æ ‡,å¦‚ä½•æ¨å‡ºå¼å­å·¦è¾¹ï¼š p(xtâˆ’1âˆ£xt,x0)=p(xtâˆ£xtâˆ’1,x0)â‹…p(xtâˆ’1âˆ£x0)p(xtâˆ£x0)p(x_{t-1} | x_t, x_0) = \\frac{p(x_t | x_{t-1}, x_0) \\cdot p(x_{t-1} | x_0)}{p(x_t | x_0)} p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)=p(xtâ€‹âˆ£x0â€‹)p(xtâ€‹âˆ£xtâˆ’1â€‹,x0â€‹)â‹…p(xtâˆ’1â€‹âˆ£x0â€‹)â€‹ ä½†æ˜¯è¿™é‡Œå³è¾¹å¼å­ä¸­p(xtâˆ£xtâˆ’1,x0)p(x_t|x_{t-1},x_0)p(xtâ€‹âˆ£xtâˆ’1â€‹,x0â€‹)æˆ‘ä»¬æ˜¯ä¸çŸ¥é“çš„ï¼Œä¸ºäº†æ±‚è§£å¼å­å·¦è¾¹ï¼Œåœ¨DDPMä¸­æˆ‘ä»¬æ˜¯æ ¹æ®ä¸€é˜¶é©¬å°”å¯å¤«å‡è®¾å‡è®¾äº†p(xtâˆ£xtâˆ’1,x0)=p(xtâˆ£xtâˆ’1)p(x_t|x_{t-1},x_0)=p(x_t|x_{t-1})p(xtâ€‹âˆ£xtâˆ’1â€‹,x0â€‹)=p(xtâ€‹âˆ£xtâˆ’1â€‹)ã€‚ä»è€Œæ¨å‡ºå·¦è¾¹p(xtâˆ’1âˆ£xt,x0)p(x_{t-1}|x_t,x_0)p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)ä¸ºæ­£æ€åˆ†å¸ƒï¼Œç„¶åå¾—å‡ºç­”æ¡ˆã€‚ æ ¹æ®DDPMçš„ç»“æœå‚è€ƒï¼Œé‡‡æ ·åˆ†å¸ƒp(xtâˆ’1âˆ£xt,x0)p(x_{t-1}|x_t,x_0)p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)æ˜¯ä¸€ä¸ªé«˜æ–¯åˆ†å¸ƒï¼Œä¸”å‡å€¼æ˜¯x0,xtx_0,x_tx0â€‹,xtâ€‹çš„çº¿æ€§å‡½æ•°ã€‚ åœ¨DDIMä¸­ï¼Œä¸ºäº†ä¸ä¾èµ–p(xtâˆ£xtâˆ’1,x0)p(x_t|x_{t-1},x_0)p(xtâ€‹âˆ£xtâˆ’1â€‹,x0â€‹)ï¼ˆé©¬å°”å¯å¤«å‡è®¾ï¼‰ï¼Œä½œè€…åšå‡ºäº†æ›´ä¸ºå¤§èƒ†çš„å‡è®¾ï¼Œä½œè€…å‡è®¾p(xtâˆ’1âˆ£xt,x0)p(x_{t-1}|x_t,x_0)p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)ä¸ºä»»æ„æ­£æ€åˆ†å¸ƒï¼Œåªéœ€è¦æ»¡è¶³ä¸‹è¿°ç­‰å¼å³å¯ï¼š p(xtâˆ’1âˆ£xt,x0)=N(xtâˆ’1;Î»x0+kxt,Ïƒt2I)p(x_{t-1}|x_t,x_0)=\\mathcal{N}(x_{t-1};\\lambda x_0+kx_t,\\sigma^2_tI) p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)=N(xtâˆ’1â€‹;Î»x0â€‹+kxtâ€‹,Ïƒt2â€‹I) è¯¥é‡‡æ ·åˆ†å¸ƒæœ‰3ä¸ªè‡ªç”±å˜é‡Î»,k,Ïƒt\\lambda,k,\\sigma_tÎ»,k,Ïƒtâ€‹ï¼Œä½†æ˜¯DDIMè¦ç»´æŒä¸DDPMä¸€è‡´çš„æ­£å‘æ¨ç†åˆ†å¸ƒï¼šq(xtâˆ£x0)=N(xt;Î±Ë‰tx0,(1âˆ’Î±Ë‰t)I)q(x_t|x_0)=\\mathcal{N}(x_t;\\sqrt{\\bar\\alpha_t}x_0,(1-\\bar{\\alpha}_t)I)q(xtâ€‹âˆ£x0â€‹)=N(xtâ€‹;Î±Ë‰tâ€‹â€‹x0â€‹,(1âˆ’Î±Ë‰tâ€‹)I) ã€‚ æ ¹æ®æ•°å­¦å½’çº³æ³•ï¼Œåªéœ€è¦ä¿è¯q(xtâˆ’1âˆ£x0)=N(xtâˆ’1;Î±Ë‰tâˆ’1x0,(1âˆ’Î±Ë‰tâˆ’1)I)q(x_{t-1}|x_0) = \\mathcal{N}(x_{t-1};\\sqrt{\\bar\\alpha_{t-1}}x_0,(1-\\bar{\\alpha}_{t-1})I)q(xtâˆ’1â€‹âˆ£x0â€‹)=N(xtâˆ’1â€‹;Î±Ë‰tâˆ’1â€‹â€‹x0â€‹,(1âˆ’Î±Ë‰tâˆ’1â€‹)I). æ‰€ä»¥æœ€ç»ˆé—®é¢˜å˜ä¸ºäº†ï¼Œå·²çŸ¥q(xtâˆ£x0)=N(xt;Î±Ë‰tx0,(1âˆ’Î±Ë‰t)I)q(x_t|x_0)=\\mathcal{N}(x_t;\\sqrt{\\bar\\alpha_t}x_0,(1-\\bar{\\alpha}_t)I)q(xtâ€‹âˆ£x0â€‹)=N(xtâ€‹;Î±Ë‰tâ€‹â€‹x0â€‹,(1âˆ’Î±Ë‰tâ€‹)I)ï¼Œè¯·å¯»æ‰¾p(xtâˆ’1âˆ£xt,x0)=N(xtâˆ’1;Î»x0+kxt,Ïƒt2I)p(x_{t-1}|x_t,x_0)=\\mathcal{N}(x_{t-1};\\lambda x_0+kx_t,\\sigma^2_tI)p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)=N(xtâˆ’1â€‹;Î»x0â€‹+kxtâ€‹,Ïƒt2â€‹I)çš„ä¸€ç»„è§£Î»âˆ—,kâˆ—,Ïƒtâˆ—\\lambda^*,k^*,\\sigma_t^*Î»âˆ—,kâˆ—,Ïƒtâˆ—â€‹ï¼Œä½¿å¾—q(xtâˆ’1âˆ£x0)=N(xtâˆ’1;Î±Ë‰tâˆ’1x0,(1âˆ’Î±Ë‰tâˆ’1)I)q(x_{t-1}|x_0) = \\mathcal{N}(x_{t-1};\\sqrt{\\bar\\alpha_{t-1}}x_0,(1-\\bar{\\alpha}_{t-1})I)q(xtâˆ’1â€‹âˆ£x0â€‹)=N(xtâˆ’1â€‹;Î±Ë‰tâˆ’1â€‹â€‹x0â€‹,(1âˆ’Î±Ë‰tâˆ’1â€‹)I)ã€‚ å³ä½¿å¾—ä¸‹å¼æˆç«‹ï¼š âˆ«xtp(xtâˆ’1âˆ£xt,x0)q(xtâˆ£x0)dxt=q(xtâˆ’1âˆ£x0)\\int_{x_t} p(x_{t-1} | x_t, x_0) q(x_t | x_0) dx_t = q(x_{t-1} | x_0) âˆ«xtâ€‹â€‹p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)q(xtâ€‹âˆ£x0â€‹)dxtâ€‹=q(xtâˆ’1â€‹âˆ£x0â€‹) å¯ä»¥ä½¿ç”¨å¾…å®šç³»æ•°æ³•è¿›è¡Œæ±‚è§£ é¦–å…ˆå¯¹xtâˆ’1x_{t-1}xtâˆ’1â€‹å’ŒÏµtâˆ’1â€²\\epsilon&#x27;_{t-1}Ïµtâˆ’1â€²â€‹è¿›è¡Œé‡‡æ ·å¾—ï¼šxtâˆ’1=Î»x0+kxt+ÏƒtÏµtâˆ’1â€²Ïµtâˆ’1â€²âˆ¼N(0,I)x_{t-1} = \\lambda x_0+kx_t+\\sigma_t\\epsilon&#x27;_{t-1}\\quad\\epsilon&#x27;_{t-1}\\sim\\mathcal{N}(0,I)xtâˆ’1â€‹=Î»x0â€‹+kxtâ€‹+Ïƒtâ€‹Ïµtâˆ’1â€²â€‹Ïµtâˆ’1â€²â€‹âˆ¼N(0,I) æ ¹æ®q(xtâˆ£x0)=N(xt;Î±Ë‰tx0,(1âˆ’Î±Ë‰t)I)q(x_t | x_0) = \\mathcal{N}(x_t; \\sqrt{\\bar\\alpha_t}x_0, (1 - \\bar\\alpha_t)I)q(xtâ€‹âˆ£x0â€‹)=N(xtâ€‹;Î±Ë‰tâ€‹â€‹x0â€‹,(1âˆ’Î±Ë‰tâ€‹)I),å¯é‡‡æ ·xt,Ïµtâ€²âˆ¼N(0,I)x_t,\\epsilon_t&#x27;\\sim\\mathcal{N}(0,I)xtâ€‹,Ïµtâ€²â€‹âˆ¼N(0,I): xt=Î±Ë‰tx0+1âˆ’Î±Ë‰tÏµtâ€²x_t = \\sqrt{\\bar\\alpha_t} x_0 + \\sqrt{1 - \\bar\\alpha_t} \\epsilon_t&#x27; xtâ€‹=Î±Ë‰tâ€‹â€‹x0â€‹+1âˆ’Î±Ë‰tâ€‹â€‹Ïµtâ€²â€‹ æˆ‘ä»¬ç›´æ¥å¸¦å…¥ï¼š xtâˆ’1=Î»x0+k(Î±Ë‰tx0+1âˆ’Î±Ë‰tÏµtâ€²)+ÏƒtÏµtâˆ’1â€²x_{t-1} = \\lambda x_0 + k\\left(\\sqrt{\\bar{\\alpha}_{t}}x_0 + \\sqrt{1-\\bar\\alpha_t }\\epsilon_t&#x27;\\right) + \\sigma_t \\epsilon_{t-1}&#x27; xtâˆ’1â€‹=Î»x0â€‹+k(Î±Ë‰tâ€‹â€‹x0â€‹+1âˆ’Î±Ë‰tâ€‹â€‹Ïµtâ€²â€‹)+Ïƒtâ€‹Ïµtâˆ’1â€²â€‹ åˆå¹¶åŒç±»é¡¹å¾—åˆ°ï¼š xtâˆ’1=(Î»+kÎ±Ë‰t)x0+(k2(1âˆ’Î±Ë‰t)+Ïƒt2)ÏµË‰tâˆ’1ÏµË‰tâˆ’1âˆ¼N(0,I)x_{t-1} = (\\lambda + k\\sqrt{\\bar{\\alpha}_t})x_0 +\\sqrt{(k^2(1-\\bar\\alpha_t)+\\sigma_t^2)} \\bar\\epsilon_{t-1} \\quad \\quad \\bar\\epsilon_{t-1} \\sim \\mathcal{N}(0, I) xtâˆ’1â€‹=(Î»+kÎ±Ë‰tâ€‹â€‹)x0â€‹+(k2(1âˆ’Î±Ë‰tâ€‹)+Ïƒt2â€‹)â€‹ÏµË‰tâˆ’1â€‹ÏµË‰tâˆ’1â€‹âˆ¼N(0,I) æ ¹æ®q(xtâˆ£x0)=N(xt;Î±Ë‰tx0,(1âˆ’Î±Ë‰t)I)q(x_t | x_0) = \\mathcal{N}(x_t; \\sqrt{\\bar\\alpha_t}x_0, (1 - \\bar\\alpha_t)I)q(xtâ€‹âˆ£x0â€‹)=N(xtâ€‹;Î±Ë‰tâ€‹â€‹x0â€‹,(1âˆ’Î±Ë‰tâ€‹)I),å¯é‡‡æ ·xtâˆ’1,Ïµtâˆ’1âˆ¼N(0,I)x_{t-1},\\epsilon_{t-1}\\sim\\mathcal{N}(0,I)xtâˆ’1â€‹,Ïµtâˆ’1â€‹âˆ¼N(0,I): xtâˆ’1=Î±Ë‰tâˆ’1x0+1âˆ’Î±Ë‰tâˆ’1Ïµtâˆ’1x_{t-1} = \\sqrt{\\bar\\alpha_{t-1}} x_0 + \\sqrt{1 - \\bar\\alpha_{t-1}} \\epsilon_{t-1} xtâˆ’1â€‹=Î±Ë‰tâˆ’1â€‹â€‹x0â€‹+1âˆ’Î±Ë‰tâˆ’1â€‹â€‹Ïµtâˆ’1â€‹ ç»“åˆä¸Šé¢ä¸¤ä¸ªå¼å­ï¼Œä¸éš¾å¾—åˆ°ï¼š {Î»+kÎ±Ë‰t=Î±Ë‰tâˆ’1k2(1âˆ’Î±Ë‰t)+Ïƒt2=1âˆ’Î±Ë‰tâˆ’1\\begin{cases} \\lambda + k\\sqrt{\\bar{\\alpha}_t} = \\sqrt{\\bar{\\alpha}_{t-1}} \\\\ k^2(1 - \\bar{\\alpha}_t) + \\sigma_t^2 = 1 - \\bar{\\alpha}_{t-1} \\end{cases} {Î»+kÎ±Ë‰tâ€‹â€‹=Î±Ë‰tâˆ’1â€‹â€‹k2(1âˆ’Î±Ë‰tâ€‹)+Ïƒt2â€‹=1âˆ’Î±Ë‰tâˆ’1â€‹â€‹ ç„¶åè§£å¾—ï¼š kâˆ—=1âˆ’Î±Ë‰tâˆ’1âˆ’Ïƒt21âˆ’Î±Ë‰tk^* = \\frac{\\sqrt{1 - \\bar{\\alpha}_{t-1} - \\sigma_t^2}}{\\sqrt{1 - \\bar{\\alpha}_t}} kâˆ—=1âˆ’Î±Ë‰tâ€‹â€‹1âˆ’Î±Ë‰tâˆ’1â€‹âˆ’Ïƒt2â€‹â€‹â€‹ Î»âˆ—=Î±Ë‰tâˆ’1âˆ’1âˆ’Î±Ë‰tâˆ’1âˆ’Ïƒt2Î±Ë‰t1âˆ’Î±Ë‰t\\lambda^* = \\sqrt{\\bar{\\alpha}_{t-1}} - \\sqrt{1 - \\bar{\\alpha}_{t-1} - \\sigma_t^2} \\frac{\\sqrt{\\bar{\\alpha}_t}}{\\sqrt{1 - \\bar{\\alpha}_t}} Î»âˆ—=Î±Ë‰tâˆ’1â€‹â€‹âˆ’1âˆ’Î±Ë‰tâˆ’1â€‹âˆ’Ïƒt2â€‹â€‹1âˆ’Î±Ë‰tâ€‹â€‹Î±Ë‰tâ€‹â€‹â€‹ Ïƒtâˆ—=Ïƒ\\sigma_t^* = \\sigma Ïƒtâˆ—â€‹=Ïƒ ç»¼ä¸Šå°†ä¸Šé¢ä¸‰ä¸ªå‚æ•°kâˆ—,Î»âˆ—,Ïƒtâˆ—k^*,\\lambda^*,\\sigma_t^*kâˆ—,Î»âˆ—,Ïƒtâˆ—â€‹å¸¦å…¥æˆ‘ä»¬å¯ä»¥å¾—åˆ°ï¼š p(xtâˆ’1âˆ£xt,x0)=N(xtâˆ’1;Î±Ë‰tâˆ’1x0+1âˆ’Î±Ë‰tâˆ’1âˆ’Ïƒt2xtâˆ’Î±Ë‰tx01âˆ’Î±Ë‰t,Ïƒt2I)p(x_{t-1}|x_t,x_0) = \\mathcal{N}\\left(x_{t-1};\\sqrt{\\bar{\\alpha}_{t-1}}x_0 + \\sqrt{1 - \\bar{\\alpha}_{t-1} - \\sigma_t^2}\\frac{ x_t- \\sqrt{\\bar{\\alpha}_t}x_0}{\\sqrt{1 - \\bar{\\alpha}_t}}, \\sigma_t^2I\\right) p(xtâˆ’1â€‹âˆ£xtâ€‹,x0â€‹)=N(xtâˆ’1â€‹;Î±Ë‰tâˆ’1â€‹â€‹x0â€‹+1âˆ’Î±Ë‰tâˆ’1â€‹âˆ’Ïƒt2â€‹â€‹1âˆ’Î±Ë‰tâ€‹â€‹xtâ€‹âˆ’Î±Ë‰tâ€‹â€‹x0â€‹â€‹,Ïƒt2â€‹I) ç»¼ä¸Šï¼Œè¯´æ˜å¯ä»¥æ‰¾åˆ°ä¸€ç»„è§£æ»¡è¶³é¢˜è¿°æ¡ä»¶ã€‚å…¶ä¸­ï¼Œä¸åŒçš„Ïƒt\\sigma_tÏƒtâ€‹å¯¹åº”ä¸åŒçš„ç”Ÿæˆè¿‡ç¨‹ã€‚ç”±äºå‰å‘è¿‡ç¨‹æ²¡å˜ï¼Œæ•…å¯ä»¥ç›´æ¥ç”¨DDPMè®­ç»ƒçš„å™ªå£°é¢„æµ‹æ¨¡å‹ã€‚é‡‡æ ·è¿‡ç¨‹å¦‚ä¸‹ï¼š xtâˆ’1=Î±Ë‰tâˆ’1x0+1âˆ’Î±Ë‰tâˆ’1âˆ’Ïƒt2(xtâˆ’Î±Ë‰tx01âˆ’Î±Ë‰t)+ÏƒtÏµx_{t-1} = \\sqrt{\\bar{\\alpha}_{t-1}} x_0 + \\sqrt{1 - \\bar{\\alpha}_{t-1} - \\sigma_t^2} \\left( \\frac{x_t - \\sqrt{\\bar{\\alpha}_t} x_0}{\\sqrt{1 - \\bar{\\alpha}_t}} \\right) + \\sigma_t \\epsilon xtâˆ’1â€‹=Î±Ë‰tâˆ’1â€‹â€‹x0â€‹+1âˆ’Î±Ë‰tâˆ’1â€‹âˆ’Ïƒt2â€‹â€‹(1âˆ’Î±Ë‰tâ€‹â€‹xtâ€‹âˆ’Î±Ë‰tâ€‹â€‹x0â€‹â€‹)+Ïƒtâ€‹Ïµ ç„¶ååŒDDPMï¼Œæˆ‘ä»¬å°†x0x_0x0â€‹ç”¨xtx_txtâ€‹å’ŒÏµÎ¸\\epsilon_\\thetaÏµÎ¸â€‹æ›¿ä»£ã€‚ x0=1Î±Ë‰t(xtâˆ’1âˆ’Î±Ë‰tÏµÎ¸(xt,t))x_0 = \\frac{1}{\\sqrt{\\bar{\\alpha}_t}} \\left( x_t - \\sqrt{1 - \\bar{\\alpha}_t} \\epsilon_\\theta(x_t, t) \\right) x0â€‹=Î±Ë‰tâ€‹â€‹1â€‹(xtâ€‹âˆ’1âˆ’Î±Ë‰tâ€‹â€‹ÏµÎ¸â€‹(xtâ€‹,t)) æœ€ç»ˆåŒ–ç®€å¾—: xtâˆ’1=Î±Ë‰tâˆ’1xtâˆ’1âˆ’Î±Ë‰tÏµÎ¸(xt,t)Î±Ë‰t+1âˆ’Î±Ë‰tâˆ’1âˆ’Ïƒt2ÏµÎ¸(xt,t)+ÏƒtÏµx_{t-1} = \\sqrt{\\bar{\\alpha}_{t-1}}\\frac{ x_t - \\sqrt{1 - \\bar\\alpha_t} \\epsilon_{\\theta}(x_t, t)}{\\sqrt{\\bar\\alpha_t}} + \\sqrt{1 - \\bar{\\alpha}_{t-1} - \\sigma_t^2 }\\epsilon_{\\theta}(x_t, t) + \\sigma_t \\epsilon xtâˆ’1â€‹=Î±Ë‰tâˆ’1â€‹â€‹Î±Ë‰tâ€‹â€‹xtâ€‹âˆ’1âˆ’Î±Ë‰tâ€‹â€‹ÏµÎ¸â€‹(xtâ€‹,t)â€‹+1âˆ’Î±Ë‰tâˆ’1â€‹âˆ’Ïƒt2â€‹â€‹ÏµÎ¸â€‹(xtâ€‹,t)+Ïƒtâ€‹Ïµ å…¶ä¸­åªæœ‰Ïƒt\\sigma_tÏƒtâ€‹æ˜¯æœªçŸ¥çš„ï¼Œéœ€è¦æ³¨æ„ä»¥ä¸‹ä¸¤ä¸ªÏƒt\\sigma_tÏƒtâ€‹çš„ç‰¹æ®Šå–å€¼ï¼š å½“Ïƒt=(1âˆ’Î±Ë‰tâˆ’1)/(1âˆ’Î±Ë‰t)1âˆ’Î±Ë‰t/Î±Ë‰tâˆ’1\\sigma_t=\\sqrt{(1-\\bar\\alpha_{t-1})/(1-\\bar\\alpha_t)}\\sqrt{1-\\bar\\alpha_t/\\bar\\alpha_{t-1}}Ïƒtâ€‹=(1âˆ’Î±Ë‰tâˆ’1â€‹)/(1âˆ’Î±Ë‰tâ€‹)â€‹1âˆ’Î±Ë‰tâ€‹/Î±Ë‰tâˆ’1â€‹â€‹,æ­¤æ—¶çš„ç”Ÿæˆè¿‡ç¨‹ä¸DDPMä¸€è‡´ å½“Ïƒt\\sigma_tÏƒtâ€‹ä¸º0æ—¶ï¼Œæ­¤æ—¶é‡‡æ ·è¿‡ç¨‹ä¸­æ·»åŠ çš„éšæœºå™ªå£°é¡¹ä¸º0ï¼Œé‡‡æ ·è¿‡ç¨‹æ˜¯ç¡®å®šçš„ï¼Œå°±æ˜¯ä½œè€…æ‰€æå‡ºçš„DDIMï¼Œæ­¤æ—¶çš„é€’æ¨å…¬å¼ä¸ºï¼š xtâˆ’1=Î±Ë‰tâˆ’1xtâˆ’1âˆ’Î±Ë‰tÏµÎ¸(xt,t)Î±Ë‰t+1âˆ’Î±Ë‰tâˆ’1ÏµÎ¸(xt,t)x_{t-1} = \\sqrt{\\bar{\\alpha}_{t-1}}\\frac{ x_t - \\sqrt{1 - \\bar\\alpha_t} \\epsilon_{\\theta}(x_t, t)}{\\sqrt{\\bar\\alpha_t}} + \\sqrt{1 - \\bar{\\alpha}_{t-1}} \\epsilon_{\\theta}(x_t, t) xtâˆ’1â€‹=Î±Ë‰tâˆ’1â€‹â€‹Î±Ë‰tâ€‹â€‹xtâ€‹âˆ’1âˆ’Î±Ë‰tâ€‹â€‹ÏµÎ¸â€‹(xtâ€‹,t)â€‹+1âˆ’Î±Ë‰tâˆ’1â€‹â€‹ÏµÎ¸â€‹(xtâ€‹,t) DDIMå¦‚ä½•åŠ é€Ÿé‡‡æ · ä¸Šé¢æˆ‘ä»¬å·²ç»æ¨å¯¼äº†DDIMå¦‚ä½•ä»çŠ¶æ€tttæ¨å¯¼åˆ°çŠ¶æ€tâˆ’1t-1tâˆ’1ï¼Œä½†æ˜¯ç”±äºDDIMçš„åå‘è¿‡ç¨‹æ²¡æœ‰å—åˆ°é©¬å°”å¯å¤«çš„é™åˆ¶ï¼Œå› æ­¤ä»–å…¶å®æ˜¯å¯ä»¥ä»çŠ¶æ€tç›´æ¥æ¨åˆ°å‰é¢ä»»æ„ä¸€ä¸ªçŠ¶æ€çš„ï¼Œä»çŠ¶æ€tttæ¨å¯¼åˆ°å‰é¢çš„çŠ¶æ€tâˆ’m(m&lt;t)t-m(m &lt; t)tâˆ’m(m&lt;t)å¯ä»¥è¡¨ç¤ºä¸ºå¦‚ä¸‹å¼å­ï¼š xtâˆ’m=Î±Ë‰tâˆ’mxtâˆ’1âˆ’Î±Ë‰tÏµÎ¸(xt,t)Î±Ë‰t+1âˆ’Î±Ë‰tâˆ’mÏµÎ¸(xt,t)x_{t-m} = \\sqrt{\\bar{\\alpha}_{t-m}} \\frac{x_{t} -\\sqrt{1 - \\bar\\alpha_{t}} \\epsilon_{\\theta}(x_{t}, t)}{\\sqrt{\\bar\\alpha_{t}}} + \\sqrt{1 - \\bar{\\alpha}_{t-m}} \\epsilon_{\\theta}(x_{t}, t) xtâˆ’mâ€‹=Î±Ë‰tâˆ’mâ€‹â€‹Î±Ë‰tâ€‹â€‹xtâ€‹âˆ’1âˆ’Î±Ë‰tâ€‹â€‹ÏµÎ¸â€‹(xtâ€‹,t)â€‹+1âˆ’Î±Ë‰tâˆ’mâ€‹â€‹ÏµÎ¸â€‹(xtâ€‹,t) ä¸€èˆ¬åŠ é€Ÿå°±æ˜¯å°†åŸå…ˆæ˜¯ä¸€æ­¥ä¸€æ­¥é¢„æµ‹å˜æˆnnnæ­¥nnnæ­¥è¿›è¡Œé¢„æµ‹ã€‚ è®ºæ–‡ä¸­ä¹Ÿå±•ç¤ºäº†ä½¿ç”¨ä¸åŒçš„næ‰€å¸¦æ¥çš„ç»“æœï¼Œå¯ä»¥çœ‹åˆ°DDIMåœ¨è¾ƒå°é‡‡æ ·æ­¥é•¿æ—¶å°±èƒ½è¾¾åˆ°è¾ƒå¥½çš„ç”Ÿæˆæ•ˆæœã€‚å¦‚CIFAR10 S=50å°±è¾¾åˆ°äº†S=1000çš„90%çš„æ•ˆæœï¼Œä¸ä¹‹ç›¸å¯¹DDPMåªèƒ½è¾¾åˆ°10%å·¦å³çš„FIDæ•ˆæœã€‚ å…¶ä¸­ï¼Œdim(L)dim(L)dim(L)è¡¨ç¤ºçš„æ˜¯é‡‡æ ·åºåˆ—çš„é•¿åº¦ DDIMåŒºåˆ«äºDDPMä¸¤ä¸ªé‡è¦çš„ç‰¹æ€§ é‡‡æ ·ä¸€è‡´æ€§ æˆ‘ä»¬çŸ¥é“DDIMå°†Ïƒt\\sigma_tÏƒtâ€‹â€‹è®¾ç½®ä¸º0ï¼Œè¿™è®©é‡‡æ ·è¿‡ç¨‹æ˜¯ç¡®å®šçš„ï¼Œåªå—â€‹xTx_TxTâ€‹å½±å“ã€‚ä½œè€…å‘ç°ï¼Œå½“ç»™å®šxTx_TxTâ€‹â€‹ï¼Œä¸åŒçš„çš„é‡‡æ ·æ—¶é—´åºåˆ—Ï„\\tauÏ„æ‰€ç”Ÿæˆå›¾ç‰‡éƒ½å¾ˆç›¸è¿‘ï¼ŒxTx_TxTâ€‹â€‹ä¼¼ä¹å¯ä»¥è§†ä½œç”Ÿæˆå›¾ç‰‡çš„éšç¼–ç ä¿¡æ¯ã€‚ æœ‰ä¸ªå°trickï¼Œæˆ‘ä»¬åœ¨å®é™…çš„ç”Ÿæˆä¸­å¯ä»¥å…ˆè®¾ç½®è¾ƒå°çš„é‡‡æ ·æ­¥é•¿(è¿­ä»£æ¬¡æ•°)è¿›è¡Œç”Ÿæˆï¼Œè‹¥ç”Ÿæˆçš„å›¾ç‰‡æ˜¯æˆ‘ä»¬æƒ³è¦çš„ï¼Œåˆ™ç”¨è¾ƒå¤§çš„æ­¥é•¿é‡æ–°ç”Ÿæˆé«˜è´¨é‡çš„å›¾ç‰‡ã€‚ è¯­ä¹‰æ’å€¼æ•ˆåº”(sementic interpolation effect) å³ç„¶xTx_TxTâ€‹â€‹å¯èƒ½æ˜¯ç”Ÿæˆå›¾ç‰‡çš„éšç©ºé—´ç¼–ç ï¼Œé‚£ä¹ˆå®ƒæ˜¯å¦å…·å¤‡å…¶å®ƒéšæ¦‚ç‡æ¨¡å‹(å¦‚GAN2ï¼ŒVAE)æ‰€è§‚å¯Ÿåˆ°çš„è¯­ä¹‰æ’å€¼æ•ˆåº”å‘¢? é¦–å…ˆä»é«˜æ–¯åˆ†å¸ƒé‡‡æ ·ä¸¤ä¸ªéšæœºå˜é‡xT(0),xT(1)x_T^{(0)},x_T^{(1)}xT(0)â€‹,xT(1)â€‹â€‹ï¼Œå¹¶ç”¨ä»–ä»¬åšå›¾åƒç”Ÿæˆå¾—åˆ°ä¸‹å›¾æœ€å·¦ä¾§ä¸æœ€å³ä¾§çš„ç»“æœã€‚éšåç”¨çƒé¢çº¿æ€§æ’å€¼æ–¹æ³•ï¼ˆspherical linear interpolationï¼ŒSlerpï¼‰å¯¹xT(1),xT(2)x_T^{(1)},x_T^{(2)}xT(1)â€‹,xT(2)â€‹ä»–ä»¬è¿›è¡Œæ’å€¼ï¼Œå¾—åˆ°ä¸€ç³»åˆ—ä¸­é—´ç»“æœ: xT(Î±)=sinâ¡((1âˆ’Î±)Î¸)sinâ¡(Î¸)xT(0)+sinâ¡(Î±Î¸)sinâ¡(Î¸)xT(1)x_{T}^{(\\alpha)} = \\frac{\\sin((1 - \\alpha) \\theta)}{\\sin(\\theta)} x_{T}^{(0)} + \\frac{\\sin(\\alpha \\theta)}{\\sin(\\theta)} x_{T}^{(1)} xT(Î±)â€‹=sin(Î¸)sin((1âˆ’Î±)Î¸)â€‹xT(0)â€‹+sin(Î¸)sin(Î±Î¸)â€‹xT(1)â€‹ å…¶ä¸­Î¸=arccosâ¡((xT(0))TxT(1)âˆ¥xT(0)âˆ¥âˆ¥xT(1)âˆ¥)\\theta = \\arccos \\left( \\frac{(x_{T}^{(0)})^T x_{T}^{(1)}}{\\| x_{T}^{(0)} \\| \\| x_{T}^{(1)} \\|} \\right)Î¸=arccos(âˆ¥xT(0)â€‹âˆ¥âˆ¥xT(1)â€‹âˆ¥(xT(0)â€‹)TxT(1)â€‹â€‹) ,ç»“æœå¦‚ä¸‹æ‰€ç¤ºï¼Œå¯ä»¥æ˜ç¡®çœ‹å‡ºæ¥è¿˜æ˜¯æœ‰ä¸€å®šè¯­ä¹‰æ’å€¼æ•ˆåº”çš„ã€‚","tags":["Diffusion","DDIM","ICLR","2021","IMPORTANT"],"categories":["Diffusion"]},{"title":"Hello World","path":"/2024/09/26/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment a=aba = \\frac{a}{b} a=baâ€‹ w(n)=0.54âˆ’0.46cosâ¡(2Ï€nN),0â‰¤nâ‰¤Nw(n)=0.54-0.46\\cos(2\\pi\\frac{n}{N}),\\quad 0\\le n\\le N w(n)=0.54âˆ’0.46cos(2Ï€Nnâ€‹),0â‰¤nâ‰¤N è¯•è¯•è¡Œå†…a=abca=\\frac{a}{\\frac{b}{c}}a=cbâ€‹aâ€‹ è¿™æ ·è¡Œå—a=asa=\\frac{a}{s}a=saâ€‹"},{"title":"Gitå…¥é—¨æ•™ç¨‹","path":"/wiki/Git/Gitå…¥é—¨æ•™ç¨‹.html","content":"åˆ†å¸ƒå¼ç‰ˆæœ¬æ§åˆ¶ æ¯ä¸ªäººéƒ½æ‹¥æœ‰å…¨éƒ¨çš„ä»£ç ï¼ä¸ä¼šå› ä¸ºæœåŠ¡å™¨æŸåæˆ–è€…ç½‘ç»œé—®é¢˜ï¼Œé€ æˆä¸èƒ½å·¥ä½œçš„æƒ…å†µã€‚ æ‰€æœ‰ç‰ˆæœ¬ä¿¡æ¯ä»“åº“å…¨éƒ¨åŒæ­¥åˆ°æœ¬åœ°çš„æ¯ä¸ªç”¨æˆ·ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨æœ¬åœ°æŸ¥çœ‹æ‰€æœ‰ç‰ˆæœ¬å†å²ï¼Œå¯ä»¥ç¦»çº¿åœ¨æœ¬åœ°æäº¤ï¼Œåªéœ€åœ¨è”ç½‘æ—¶pushåˆ°ç›¸åº”çš„æœåŠ¡å™¨æˆ–å…¶ä»–ç”¨æˆ·é‚£é‡Œã€‚ç”±äºæ¯ä¸ªç”¨æˆ·é‚£é‡Œä¿å­˜çš„éƒ½æ˜¯æ‰€æœ‰çš„ç‰ˆæœ¬æ•°æ®ï¼Œåªè¦æœ‰ä¸€ä¸ªç”¨æˆ·çš„è®¾å¤‡æ²¡æœ‰é—®é¢˜å°±å¯ä»¥æ¢å¤æ‰€æœ‰çš„æ•°æ®ï¼Œä½†è¿™å¢åŠ äº†æœ¬åœ°å­˜å‚¨ç©ºé—´çš„å ç”¨ã€‚ Gitæ—¶ç›®å‰ä¸–ç•Œä¸Šæœ€å…ˆè¿›çš„åˆ†å¸ƒå¼ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿã€‚ å› ä¸ºGit Bashæˆ‘ä»¬åœ¨æ—¥å¸¸ä¸­æ˜¯ä½¿ç”¨æœ€å¤šçš„ï¼Œè€ŒGit BashåŸºç¡€å‘½ä»¤é£æ ¼æ˜¯åŸºäºLinuxç³»ç»Ÿçš„ï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘ä»¬å…ˆä»‹ç»ä¸€äº›åŸºæœ¬çš„Linuxå‘½ä»¤ åŸºæœ¬Linuxå‘½ä»¤ cdï¼šæ”¹å˜ç›®å½• cd ..ï¼šå›åˆ°ä¸Šä¸€çº§ç›®å½• pwdï¼šæ˜¾ç¤ºå½“å‰æ‰€åœ¨çš„ç›®å½•çš„è·¯å¾„ lsï¼šåˆ—å‡ºå½“å‰ç›®å½•ä¸­çš„æ‰€æœ‰æ–‡ä»¶ llï¼šåŒä¸Šä¹Ÿæ˜¯åˆ—å‡ºå½“å‰ç›®å½•ä¸­çš„æ‰€æœ‰æ–‡ä»¶ï¼Œä½†æ˜¯ç›¸æ¯”äºlsåˆ—å‡ºçš„å†…å®¹ä¼šæ›´ä¸ºè¯¦ç»†ã€‚ touchï¼šæ–°å»ºä¸€ä¸ªæ–‡ä»¶ã€‚egï¼štouch index.jså°±ä¼šåœ¨å½“å‰ç›®å½•ä¸‹æ–°å»ºä¸€ä¸ªindex.jsçš„æ–‡ä»¶ã€‚ rmï¼šåˆ é™¤ä¸€ä¸ªæ–‡ä»¶ã€‚egï¼šrm index.jså°±ä¼šåœ¨å°†å½“å‰ç›®å½•ä¸‹çš„index.jsæ–‡ä»¶åˆ é™¤ã€‚ mkdirï¼šæ–°å»ºä¸€ä¸ªç›®å½•ï¼Œå°±æ˜¯æ–°å»ºä¸€ä¸ªæ–‡ä»¶å¤¹ã€‚ rm-rï¼šåˆ é™¤ä¸€ä¸ªæ–‡ä»¶å¤¹ï¼Œegï¼šrm-r srcåˆ é™¤srcç›®å½• `rm-rf /` åˆ‡å‹¿åœ¨Linuxç”µè„‘ä¸­å°è¯•æ­¤å‘½ä»¤ï¼Œfæ˜¯é€’å½’åˆ é™¤çš„æ„æ€ï¼Œè¿™é‡Œçš„å«ä¹‰å°±æ˜¯å°†æ ¹ç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶å¤¹å…¨éƒ¨åˆ æ‰ã€‚ mvç§»åŠ¨æ–‡ä»¶ï¼Œeg:mv index.html src å‘½ä»¤å‰é¢çš„index.htmlæ–‡ä»¶æ˜¯æˆ‘ä»¬è¦ç§»åŠ¨çš„æ–‡ä»¶ã€‚srcæ˜¯ç›®æ ‡æ–‡ä»¶å¤¹ï¼Œæ–‡ä»¶å’Œç›®æ ‡æ–‡ä»¶å¤¹å¿…é¡»åœ¨åŒä¸€ç›®å½•ä¸‹ã€‚ resetï¼šé‡æ–°åˆå§‹åŒ–ç»ˆç«¯/æ¸…å±ã€‚ clearï¼šæ¸…å±ã€‚ historyï¼šæŸ¥çœ‹å‘½ä»¤å†å²ã€‚ helpï¼šå¸®åŠ© exitï¼šé€€å‡º #ï¼šè¡¨ç¤ºæ³¨é‡Š Gitçš„å¿…è¦é…ç½® æŸ¥çœ‹ä¸åŒçº§åˆ«çš„é…ç½®æ–‡ä»¶ 12345# æŸ¥çœ‹ç³»ç»Ÿconfig$ git config --system --list# æŸ¥çœ‹å½“å‰ç”¨æˆ·(global)é…ç½®$ git config --global --list è®¾ç½®ç”¨æˆ·åå’Œé‚®ç®± 12$ git config --global user.name &quot;xxxxx&quot; #ç”¨æˆ·å$ git config --global user.email 2604932485@qq.com #é‚®ç®± æŸ¥çœ‹ç”¨æˆ·åå’Œé‚®ç®± GitåŸºæœ¬ç†è®º Gitæœ¬åœ°æœ‰ä¸‰ä¸ªå·¥ä½œåŒºåŸŸï¼šå·¥ä½œç›®å½•ï¼ˆWorking Directoryï¼‰ã€æš‚å­˜åŒºï¼ˆStage/Indexï¼‰ã€èµ„æºåº“ï¼ˆRepositoryæˆ–Git Directoryï¼‰ã€‚å¦‚æœåœ¨åŠ ä¸Šè¿œç¨‹çš„gitä»“åº“ï¼ˆRemote Directoryï¼‰å°±å¯ä»¥åˆ†ä¸ºå››ä¸ªå·¥ä½œåŒºåŸŸï¼Œæ–‡ä»¶åœ¨è¿™å››ä¸ªåŒºåŸŸä¹‹é—´çš„è½¬æ¢å…³ç³»å¦‚ä¸‹ï¼š åŸºæœ¬å·¥ä½œæµç¨‹ åœ¨å·¥ä½œç›®å½•ä¸­æ·»åŠ ã€ä¿®æ”¹æ–‡ä»¶ å°†éœ€è¦è¿›è¡Œç‰ˆæœ¬ç®¡ç†çš„æ–‡ä»¶æ”¾å…¥æš‚å­˜åŒºï¼ˆgit add .ï¼‰ å°†æš‚å­˜åŒºåŸŸçš„æ–‡ä»¶æäº¤åˆ°gitä»“åº“ï¼ˆgit commitï¼‰ å°†æœ¬åœ°ä»“åº“æ¨é€åˆ°è¿œç¨‹gitä»“åº“ï¼ˆgit pushï¼‰ å› æ­¤ï¼Œgitç®¡ç†çš„æ–‡ä»¶æœ‰ä¸‰ç§çŠ¶æ€ï¼šå·²ä¿®æ”¹ï¼ˆmodifiedï¼‰ï¼Œå·²æš‚å­˜ï¼ˆstagedï¼‰ï¼Œå·²æäº¤ï¼ˆcommittedï¼‰ Gité¡¹ç›®æ­å»º æœ¬åœ°æ­å»ºä»“åº“ è¿œç¨‹å…‹éš†ä»“åº“ æœ¬åœ°æ­å»ºä»“åº“ åˆ›å»ºä¸€ä¸ªå†™çš„ä»“åº“ï¼Œæˆ‘ä»¬å…ˆåœ¨gitç»ˆç«¯ä¸­ä½¿ç”¨cdå‘½ä»¤è¿›å…¥æˆ‘ä»¬æƒ³è¦åˆ›å»ºä»“åº“çš„ç›®å½•ï¼Œç„¶åæˆ‘ä»¬ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤å°†ä¸€ä¸ªå½“å‰ç›®å½•ï¼ˆæ­£å¸¸çš„çš„æ–‡ä»¶å¤¹ï¼‰åˆå§‹åŒ–æˆgitä»“åº“ 12# å°†å½“å‰ç›®å½•æ–‡ä»¶å¤¹åˆå§‹åŒ–ä¸ºä¸€ä¸ªgitä»“åº“$ git init æ‰§è¡Œåå¯ä»¥çœ‹åˆ°ï¼Œåœ¨å½“å‰ç›®å½•ä¸­å¤šå‡ºäº†ä¸€ä¸ª.gitç›®å½•ï¼Œå…³äºç‰ˆæœ¬ç­‰çš„æ‰€æœ‰ä¿¡æ¯éƒ½åœ¨è¿™ä¸ªç›®å½•é‡Œé¢ã€‚ å…‹éš†è¿œç¨‹ä»“åº“åˆ°æœ¬åœ° ä½¿ç”¨git cloneå‘½ä»¤å°†è¿œç¨‹æœåŠ¡å™¨ä¸Šçš„ä»“åº“å®Œå…¨é•œåƒä¸€ä»½åˆ°æœ¬åœ° 12# å…‹éš†ä¸€ä¸ªé¡¹ç›®å’Œä»–çš„æ•´ä¸ªä»£ç å†å²ï¼ˆç‰ˆæœ¬ä¿¡æ¯ï¼‰$ git clone [url] Gitæ–‡ä»¶æ“ä½œ ç‰ˆæœ¬æ§åˆ¶å°±æ˜¯å¯¹æ–‡ä»¶çš„ç‰ˆæœ¬æ§åˆ¶ï¼Œè¦å¯¹æ–‡ä»¶è¿›è¡Œä¿®æ”¹ã€æäº¤ç­‰æ“ä½œï¼Œé¦–å…ˆè¦çŸ¥é“æ–‡ä»¶å½“å‰åœ¨ä»€ä¹ˆçŠ¶æ€ï¼Œä¸ç„¶å¯èƒ½ä¼šæäº¤äº†ç°åœ¨è¿˜ä¸æƒ³æäº¤çš„æ–‡ä»¶ï¼Œæˆ–è€…è¦æäº¤çš„æ–‡ä»¶æ²¡æœ‰æäº¤ä¸Šã€‚ æ–‡ä»¶çš„4ç§çŠ¶æ€ Untrackedï¼šæœªè·Ÿè¸ªï¼Œæ­¤æ–‡ä»¶åœ¨æ–‡ä»¶å¤¹ä¸­ï¼Œä½†å¹¶æ²¡æœ‰åŠ å…¥åˆ°gitåº“ä¸­ï¼Œä¸å‚ä¸ç‰ˆæœ¬æ§åˆ¶ã€‚é€šè¿‡git addçŠ¶æ€å˜ä¸ºStaged Unmodifyï¼šæ–‡ä»¶å·²ç»å…¥åº“(historyçŠ¶æ€)ï¼Œæœªä¿®æ”¹ï¼Œå³ç‰ˆæœ¬åº“ä¸­çš„æ–‡ä»¶å¿«ç…§å†…å®¹ä¸æ–‡ä»¶å¤¹ä¸­å®Œå…¨ä¸€è‡´ï¼Œè¿™ç§ç±»å‹çš„æ–‡ä»¶æœ‰ä¸¤ç§å»å¤„ï¼Œå¦‚æœå®ƒè¢«ä¿®æ”¹ï¼Œè€Œå˜ä¸ºModifiedï¼Œå¦‚æœä½¿ç”¨git rmç§»å‡ºç‰ˆæœ¬åº“ï¼Œåˆ™æˆä¸ºUntrackedæ–‡ä»¶ Modifiedï¼šæ–‡ä»¶å·²ä¿®æ”¹ï¼Œä»…ä»…æ˜¯ä¿®æ”¹ï¼Œå¹¶æ²¡æœ‰è¿›è¡Œå…¶ä»–çš„æ“ä½œï¼Œè¿™ä¸ªæ–‡ä»¶ä¹Ÿæœ‰ä¸¤ä¸ªå»å¤„ï¼Œé€šè¿‡git addå¯è¿›å…¥StagedçŠ¶æ€ï¼Œä½¿ç”¨git checkoutåˆ™ä¸¢å¼ƒä¿®æ”¹è¿‡ï¼Œè¿”å›åˆ°unmodifyçŠ¶æ€ï¼Œè¿™ä¸ªgit checkoutå³ä»åº“ä¸­å–å‡ºæ–‡ä»¶ï¼Œè¦†ç›–å½“å‰ä¿®æ”¹ï¼ Stagedï¼šæš‚å­˜çŠ¶æ€ï¼Œæ‰§è¡Œgit commitåˆ™å°†ä¿®æ”¹åŒæ­¥åˆ°åº“ä¸­ï¼Œè¿™æ—¶åº“ä¸­çš„æ–‡ä»¶å’Œæœ¬åœ°æ–‡ä»¶åˆå˜ä¸ºä¸€è‡´ï¼Œæ–‡ä»¶ä¸ºUnmodifyçŠ¶æ€ã€‚æ‰§è¡Œgit reset HEAD filenameå–æ¶ˆæš‚å­˜ï¼Œæ–‡ä»¶çŠ¶æ€å˜ä¸ºModified æŸ¥çœ‹æ–‡ä»¶çš„çŠ¶æ€ 1234567# æŸ¥çœ‹æŒ‡å®šæ–‡ä»¶çŠ¶æ€$ git status [filename]# æŸ¥çœ‹æ‰€æœ‰æ–‡ä»¶çš„çŠ¶æ€$ git status ä¸Šä¼ æäº¤æ–‡ä»¶ 1234# æ·»åŠ æ‰€æœ‰æ–‡ä»¶åˆ°æš‚å­˜åŒº$ git add .# æäº¤æš‚å­˜åŒºä¸­çš„å†…å®¹$ git commit -m &quot;xxx&quot; # -m åè·Ÿç€çš„æ˜¯æäº¤ä¿¡æ¯ å›æ»š 12345# å¯¹äºå°šæœªæäº¤çš„å¤„äºæš‚å­˜åŒºä¸­çš„æ–‡ä»¶ï¼Œå¦‚æœè¦æ’¤é”€ä¿®æ”¹$ git checkout [filename]# å¯¹äºå·²ç»æäº¤çš„ä¸€æ¬¡commitï¼Œå¦‚æœè¦æ’¤é”€è¿™æ¬¡æäº¤$ git reset HEAD^1 ä¸‹é¢æˆ‘ä»¬ä¸¾ä¸€ä¸ªå®Œæ•´çš„æ¡ˆä¾‹ï¼Œå°±æ˜¯å°†ä¸€ä¸ªç©ºçš„æ–‡ä»¶å¤¹åˆå§‹åŒ–æˆä¸€ä¸ªgitä»“åº“ï¼Œç„¶åæ–°å»ºä¸€ä¸ªtest.txtæ–‡ä»¶å¹¶å°†å…¶åŠ å…¥åˆ°ä»“åº“ä¸­çš„æ•´ä¸ªè¿‡ç¨‹ã€‚ æˆ‘ä»¬é‡‡ç”¨æœ¬åœ°åˆå§‹åŒ–ä»“åº“çš„æ–¹å¼ï¼Œé¦–å…ˆåœ¨ç”µè„‘æ¡Œé¢ä¸Šæ–°å»ºæ–‡ä»¶å¤¹ex1ï¼Œç„¶åå³é”®è¯¥æ–‡ä»¶å¤¹è¿›è¡Œgit bash å¯ä»¥å‘ç°git initåè¯¥æ–‡ä»¶å¤¹ä¸­å¤šå‡ºæ¥ä¸€ä¸ªéšè—æ–‡ä»¶å¤¹ï¼Œç„¶åæˆ‘ä»¬åœ¨è¯¥æ–‡ä»¶å¤¹ä¸‹æ–°å»ºä¸€ä¸ªtest.txtæ–‡ä»¶ã€‚ ç„¶åè¿›å…¥gitç»ˆç«¯ï¼Œclearåæ‰§è¡Œä¸‹é¢çš„å‘½ä»¤ï¼Œç»“æœå¦‚ä¸‹å›¾ ç°åœ¨æˆ‘ä»¬çš„æ–‡ä»¶æˆåŠŸè¿›å…¥äº†æš‚å­˜åŒºï¼Œä¸‹é¢è¿›è¡Œæäº¤æ“ä½œï¼Œç»“æœå¦‚ä¸‹ å¯ä»¥å‘ç°æœ€åæŸ¥çœ‹çŠ¶æ€çš„æ—¶å€™å·²ç»æ˜¾ç¤ºworking tree cleanã€‚æ‰€ä»¥è¯æ˜æäº¤æˆåŠŸï¼ å¿½ç•¥æ–‡ä»¶â€”â€”.gitgnore æœ‰äº›æ—¶å€™æˆ‘ä»¬ä¸æƒ³æŠŠæŸäº›æ–‡ä»¶çº³å…¥ç‰ˆæœ¬æ§åˆ¶ä¸­ï¼Œæ¯”å¦‚æ•°æ®åº“æ–‡ä»¶ï¼Œä¸´æ—¶æ–‡ä»¶ï¼Œè®¾è®¡æ–‡ä»¶ç­‰ è¿™æ—¶æˆ‘ä»¬å¯ä»¥åœ¨ä¸»ç›®å½•ä¸‹å»ºç«‹&quot;.gitgnore&quot;æ–‡ä»¶ï¼Œæ­¤æ–‡ä»¶æœ‰å¦‚ä¸‹è§„åˆ™ æ–‡ä»¶ä¸­çš„ç©ºè¡Œæˆ–ä»¥ï¼ƒå¼€å§‹çš„è¡Œéƒ½ä¼šè¢«å¿½ç•¥ã€‚ å¯ä»¥ä½¿ç”¨Linuxé€šé…ç¬¦ã€‚ æ˜Ÿå·ï¼ˆ*ï¼‰ä»£è¡¨ä»»æ„å¤šä¸ªå­—ç¬¦ï¼Œé—®å·ï¼ˆ?ï¼‰ä»£è¡¨ä¸€ä¸ªå­—ç¬¦ï¼Œæ–¹æ‹¬å·ï¼ˆ[abc]ï¼‰ä»£è¡¨å¯é€‰å­—ç¬¦èŒƒå›´ï¼Œå¤§æ‹¬å·ï¼ˆ{string1,string2,â€¦}ï¼‰ä»£è¡¨å¯é€‰çš„å­—ç¬¦ä¸²ç­‰ã€‚ å¦‚æœåç§°çš„æœ€å‰é¢æœ‰ä¸€ä¸ªæ„Ÿå¹å·ï¼ˆ!ï¼‰ï¼Œè¡¨ç¤ºä¾‹å¤–è§„åˆ™ï¼Œå°†ä¸è¢«å¿½ç•¥ã€‚ å¦‚æœåç§°çš„æœ€å‰é¢æ˜¯ä¸€ä¸ªè·¯å¾„åˆ†éš”ç¬¦ï¼ˆ/ï¼‰ï¼Œè¡¨ç¤ºè¦å¿½ç•¥çš„æ–‡ä»¶åœ¨æ­¤ç›®å½•ä¸‹ï¼Œè€Œå­ç›®å½•ä¸­çš„æ–‡ä»¶ä¸å¿½ç•¥ã€‚ å¦‚æœåç§°çš„æœ€åé¢æ˜¯ä¸€ä¸ªè·¯å¾„åˆ†éš”ç¬¦ï¼ˆ/ï¼‰ï¼Œè¡¨ç¤ºè¦å¿½ç•¥çš„æ˜¯æ­¤ç›®å½•ä¸‹è¯¥åç§°çš„å­ç›®å½•ï¼Œè€Œéæ–‡ä»¶ï¼ˆé»˜è®¤æ–‡ä»¶æˆ–ç›®å½•éƒ½å¿½ç•¥ï¼‰ 123456# ä¸ºæ³¨é‡Š*.txt # å¿½ç•¥æ‰€æœ‰.txtç»“å°¾çš„æ–‡ä»¶!lib.txt # ä½†æ˜¯lib.txté™¤å¤–/temp # ä»…å¿½ç•¥é¡¹ç›®æ ¹ç›®å½•ä¸‹çš„tempæ–‡ä»¶å¤¹ï¼Œä¸åŒ…æ‹¬å…¶ä»–ç›®å½•tempbuild/ # å¿½ç•¥buildç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶doc/*.txt # ä¼šå¿½ç•¥ doc/notes.txt ä½†ä¸åŒ…æ‹¬ doc/server/arch.txt åˆ›å»ºè¿œç¨‹ä»“åº“ ä»¥GitHubä¸ºä¾‹ï¼Œå…¶å®éå¸¸çš„ç®€å•ï¼Œåªéœ€è¦è·Ÿç€GitHubçš„æ­¥éª¤ä¸€æ­¥ä¸€æ­¥è¿›è¡Œè®¾ç½®å°±å¯ä»¥æˆåŠŸåˆ›å»ºä¸€ä¸ªä»“åº“äº†ã€‚ å¡«å†™å¥½ä»“åº“åä»¥åŠä»“åº“æè¿°åï¼Œç‚¹å‡»åˆ›å»ºä»“åº“ã€‚GitHubä¼šæä¾›ä¸‹é¢çš„ä»£ç ï¼Œè®©ä½ å°†æœ¬åœ°çš„ä»“åº“å…³è”åˆ°è¿œç«¯è¿™ä¸ªæ–°åˆ›å»ºçš„ä»“åº“ã€‚ï¼ˆå…³è”å·²æœ‰ä»“åº“ä»£ç ç”¨æœ€ä¸‹é¢ä¸‰è¡Œä»£ç ï¼‰ æœ€å¸¸ç”¨çš„ä¸¤ä¸ªå‘½ä»¤ï¼š 1234# æ¨é€å½“å‰åˆ†æ”¯æœ€æ–°çš„æäº¤åˆ°è¿œç¨‹$ git push# æ‹‰å–è¿œç¨‹åˆ†æ”¯æœ€æ–°çš„æäº¤åˆ°æœ¬åœ°$ git pull Gitåˆ†æ”¯ Gitåˆ†æ”¯ä¸­å¸¸ç”¨å‘½ä»¤ 123456789101112131415161718192021222324252627# åˆ—å‡ºæ‰€æœ‰æœ¬åœ°åˆ†æ”¯$ git branch# åˆ—å‡ºæ‰€æœ‰è¿œç¨‹åˆ†æ”¯$ git branch -r# æ–°å»ºä¸€ä¸ªåˆ†æ”¯ï¼Œä½†ä¾ç„¶åœç•™åœ¨å½“å‰åˆ†æ”¯$ git branch [branch-name]# æ–°å»ºä¸€ä¸ªåˆ†æ”¯ï¼Œå¹¶åˆ‡æ¢åˆ°è¯¥åˆ†æ”¯(å·²å½“å‰åˆ†æ”¯ä¸ºåŸºç¡€)$ git checkout -b [branch]# å•çº¯åœ°åˆ‡æ¢åˆ°æŸä¸ªåˆ†æ”¯$ git checkout [branch-name]# åˆå¹¶æŒ‡å®šåˆ†æ”¯åˆ°å½“å‰åˆ†æ”¯$ git merge [branch]# æ”¾å¼ƒè¿™æ¬¡åˆå¹¶$ git merge --abort# åˆ é™¤åˆ†æ”¯$ git branch -d [branch-name]# åˆ é™¤è¿œç¨‹åˆ†æ”¯$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] å¤šä¸ªåˆ†æ”¯å¦‚æœå¹¶è¡Œæ‰§è¡Œï¼Œå°±ä¼šå¯¼è‡´æˆ‘ä»¬çš„ä»£ç ä¸å†²çªï¼Œä¹Ÿå°±æ˜¯åŒæ—¶å­˜åœ¨å¤šä¸ªç‰ˆæœ¬ï¼ å¦‚æœåŒä¸€ä¸ªæ–‡ä»¶åœ¨åˆå¹¶åˆ†æ”¯æ—¶éƒ½è¢«ä¿®æ”¹äº†ï¼Œåˆ™ä¼šå¼•èµ·å†²çªï¼šè§£å†³çš„åŠæ³•æ˜¯æˆ‘ä»¬å¯ä»¥ä¿®æ”¹å†²çªæ–‡ä»¶åé‡æ–°æäº¤ï¼é€‰æ‹©è¦ä¿ç•™ä»–çš„ä»£ç è¿˜æ˜¯ä½ çš„ä»£ç ï¼ masterä¸»åˆ†æ”¯ä¸€èˆ¬éå¸¸ç¨³å®šï¼Œç”¨æ¥å‘å¸ƒæ–°çš„ç‰ˆæœ¬ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ä¸å…è®¸åœ¨ä¸Šé¢è¿›è¡Œå¼€å‘ï¼Œå·¥ä½œä¸€èˆ¬æƒ…å†µä¸‹åœ¨æ–°å»ºçš„devåˆ†æ”¯ä¸Šå·¥ä½œï¼Œå·¥ä½œå®Œæˆåï¼Œæ¯”å¦‚è¦å‘å¸ƒï¼Œåˆ™å¯å°†devåˆ†æ”¯åˆå¹¶åˆ°ä¸»åˆ†æ”¯masterä¸Šæ¥ã€‚ Vscode æ’ä»¶æ¨è GitLens â€” Git supercharged Git History Diff"},{"title":"InfoNCE","path":"/wiki/DL-Techniques/InfoNCE.html","content":"åœ¨æ·±åº¦å­¦ä¹ ä¸­ï¼Œå¯¹æ¯”å­¦ä¹ ï¼ˆContrastive Learningï¼‰æ˜¯ä¸€ç§å¼ºå¤§çš„æ–¹æ³•ï¼Œç”¨äºå­¦ä¹ æ— ç›‘ç£æˆ–è‡ªç›‘ç£è¡¨ç¤ºã€‚InfoNCEï¼ˆInformation Noise Contrastive Estimationï¼‰æ˜¯ä¸€ç§ç”¨äºå¯¹æ¯”å­¦ä¹ çš„æŸå¤±å‡½æ•°ï¼Œå®ƒåœ¨è¡¨å¾å­¦ä¹ ä¸­å‘æŒ¥äº†é‡è¦ä½œç”¨ã€‚æœ¬æ–‡å°†è¯¦ç»†ä»‹ç»InfoNCE lossçš„å®šä¹‰ã€åŸç†åŠå…¶åœ¨å®é™…åº”ç”¨ä¸­çš„ä½œç”¨ã€‚ åŸºæœ¬ä»‹ç» InfoNCEæŸå¤±æœ€åˆç”±Aaron van den Oordç­‰äººåœ¨å…¶è®ºæ–‡ã€ŠRepresentation Learning with Contrastive Predictive Codingã€‹ä¸­æå‡ºã€‚å®ƒçš„ä¸»è¦æ€æƒ³æ˜¯é€šè¿‡æœ€å¤§åŒ–ç›®æ ‡æ ·æœ¬å’Œæ­£æ ·æœ¬ä¹‹é—´çš„ç›¸ä¼¼åº¦ï¼ŒåŒæ—¶æœ€å°åŒ–ç›®æ ‡æ ·æœ¬ä¸ä¸€ç»„è´Ÿæ ·æœ¬ä¹‹é—´çš„ç›¸ä¼¼åº¦ï¼Œä»è€Œå­¦ä¹ æœ‰ç”¨çš„ç‰¹å¾è¡¨ç¤ºã€‚ å®šä¹‰ åœ¨å¯¹æ¯”å­¦ä¹ ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªç›®æ ‡æ ·æœ¬ï¼ˆanchorï¼‰ã€ä¸€ä¸ªæ­£æ ·æœ¬ï¼ˆpositive sampleï¼‰å’Œä¸€ç»„è´Ÿæ ·æœ¬ï¼ˆnegative samplesï¼‰ã€‚InfoNCEæŸå¤±å‡½æ•°å¯ä»¥å®šä¹‰ä¸ºï¼š LInfoNCE=âˆ’logâ¡expâ¡(sim(zi,zi+))expâ¡(sim(zi,zi+))+âˆ‘j=1Kexpâ¡(sim(zi,zjâˆ’))\\mathcal{L}_{\\text{InfoNCE}} = -\\log \\frac{\\exp(\\text{sim}(\\mathbf{z}_i, \\mathbf{z}_i^+))}{\\exp(\\text{sim}(\\mathbf{z}_i, \\mathbf{z}_i^+)) + \\sum_{j=1}^{K} \\exp(\\text{sim}(\\mathbf{z}_i, \\mathbf{z}_j^-))} LInfoNCEâ€‹=âˆ’logexp(sim(ziâ€‹,zi+â€‹))+âˆ‘j=1Kâ€‹exp(sim(ziâ€‹,zjâˆ’â€‹))exp(sim(ziâ€‹,zi+â€‹))â€‹ å…¶ä¸­ï¼š zi\\mathbf{z}_iziâ€‹ æ˜¯ç›®æ ‡æ ·æœ¬çš„è¡¨ç¤ºã€‚ zi+\\mathbf{z}_i^+zi+â€‹ æ˜¯æ­£æ ·æœ¬çš„è¡¨ç¤ºã€‚ zjâˆ’\\mathbf{z}_j^-zjâˆ’â€‹ æ˜¯è´Ÿæ ·æœ¬çš„è¡¨ç¤ºã€‚ sim(â‹…,â‹…)\\text{sim}(\\cdot, \\cdot)sim(â‹…,â‹…) æ˜¯ç›¸ä¼¼åº¦å‡½æ•°ï¼Œé€šå¸¸é‡‡ç”¨ä½™å¼¦ç›¸ä¼¼åº¦æˆ–ç‚¹ç§¯ã€‚ å·¥ä½œåŸç† InfoNCEæŸå¤±é€šè¿‡ä»¥ä¸‹è¿‡ç¨‹æ¥ä¼˜åŒ–æ¨¡å‹ï¼š ç›¸ä¼¼åº¦è®¡ç®—ï¼šè®¡ç®—ç›®æ ‡æ ·æœ¬ä¸æ­£æ ·æœ¬ä¹‹é—´çš„ç›¸ä¼¼åº¦ï¼Œä»¥åŠç›®æ ‡æ ·æœ¬ä¸æ¯ä¸ªè´Ÿæ ·æœ¬ä¹‹é—´çš„ç›¸ä¼¼åº¦ã€‚ å½’ä¸€åŒ–ï¼šå°†æ­£æ ·æœ¬å’Œè´Ÿæ ·æœ¬ä¹‹é—´çš„ç›¸ä¼¼åº¦è¿›è¡Œå½’ä¸€åŒ–ï¼Œä»¥ç¡®ä¿æ­£æ ·æœ¬çš„ç›¸ä¼¼åº¦åœ¨è´Ÿæ ·æœ¬çš„ç›¸ä¼¼åº¦ä¹‹ä¸Šã€‚ æœ€å¤§åŒ–å¯¹æ¯”ï¼šé€šè¿‡æœ€å¤§åŒ–ç›®æ ‡æ ·æœ¬å’Œæ­£æ ·æœ¬ä¹‹é—´çš„ç›¸ä¼¼åº¦ï¼ŒåŒæ—¶æœ€å°åŒ–ç›®æ ‡æ ·æœ¬ä¸è´Ÿæ ·æœ¬ä¹‹é—´çš„ç›¸ä¼¼åº¦ï¼Œæ¨¡å‹èƒ½å¤Ÿå­¦ä¹ åˆ°æ›´å¥½çš„ç‰¹å¾è¡¨ç¤ºã€‚ åº”ç”¨åœºæ™¯ InfoNCE lossåœ¨ä»¥ä¸‹å‡ ä¸ªé¢†åŸŸä¸­å¾—åˆ°äº†å¹¿æ³›åº”ç”¨ï¼š è‡ªç„¶è¯­è¨€å¤„ç†ï¼ˆNLPï¼‰ï¼šç”¨äºå­¦ä¹ è¯å‘é‡å’Œå¥å­è¡¨ç¤ºï¼Œä¾‹å¦‚åœ¨GPTå’ŒBERTç­‰æ¨¡å‹ä¸­ã€‚ è®¡ç®—æœºè§†è§‰ï¼ˆCVï¼‰ï¼šç”¨äºæ— ç›‘ç£å­¦ä¹ å›¾åƒè¡¨ç¤ºï¼Œå¦‚SimCLRå’ŒMoCoç­‰æ–¹æ³•ã€‚ è¯­éŸ³å¤„ç†ï¼šç”¨äºå­¦ä¹ éŸ³é¢‘ä¿¡å·çš„è¡¨ç¤ºï¼Œå¦‚åœ¨Contrastive Predictive Coding (CPC) ä¸­ã€‚ å®é™…åº”ç”¨ç¤ºä¾‹ ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨PyTorchå®ç°InfoNCE lossçš„ç®€å•ç¤ºä¾‹ï¼š 1234567891011121314151617181920212223242526272829import torchimport torch.nn.functional as Fdef info_nce_loss(anchor, positive, negatives, temperature=0.07): # è®¡ç®—ç›¸ä¼¼åº¦ anchor_positive_similarity = F.cosine_similarity(anchor, positive) anchor_negative_similarity = F.cosine_similarity(anchor.unsqueeze(1), negatives, dim=2) # è®¡ç®—æ­£æ ·æœ¬å’Œè´Ÿæ ·æœ¬çš„ç›¸ä¼¼åº¦ positives_exp = torch.exp(anchor_positive_similarity / temperature) negatives_exp = torch.exp(anchor_negative_similarity / temperature).sum(dim=1) # è®¡ç®—InfoNCE loss loss = -torch.log(positives_exp / (positives_exp + negatives_exp)).mean() return loss# ç¤ºä¾‹è¾“å…¥batch_size = 16embedding_dim = 128num_negatives = 10anchor = torch.randn(batch_size, embedding_dim)positive = torch.randn(batch_size, embedding_dim)negatives = torch.randn(batch_size, num_negatives, embedding_dim)# è®¡ç®—InfoNCE lossloss = info_nce_loss(anchor, positive, negatives)print(f&#x27;InfoNCE Loss: &#123;loss.item()&#125;&#x27;) ä¸Triplet Lossçš„å¯¹æ¯” æ€»ç»“ InfoNCE lossåœ¨å¯¹æ¯”å­¦ä¹ ä¸­æ‰®æ¼”äº†é‡è¦è§’è‰²ï¼Œå®ƒé€šè¿‡å¯¹ç›®æ ‡æ ·æœ¬ã€æ­£æ ·æœ¬å’Œè´Ÿæ ·æœ¬ä¹‹é—´çš„ç›¸ä¼¼åº¦è¿›è¡Œå¯¹æ¯”ï¼Œä»è€Œå¸®åŠ©æ¨¡å‹å­¦ä¹ åˆ°æ›´å¥½çš„ç‰¹å¾è¡¨ç¤ºã€‚æ— è®ºæ˜¯åœ¨è‡ªç„¶è¯­è¨€å¤„ç†ã€è®¡ç®—æœºè§†è§‰è¿˜æ˜¯è¯­éŸ³å¤„ç†é¢†åŸŸï¼ŒInfoNCE losséƒ½å±•ç¤ºå‡ºäº†å…¶å¼ºå¤§çš„èƒ½åŠ›å’Œå¹¿æ³›çš„åº”ç”¨å‰æ™¯ã€‚äº†è§£å’ŒæŒæ¡InfoNCE lossçš„åŸç†å’Œåº”ç”¨ï¼Œå°†ä¸ºä»äº‹ç›¸å…³é¢†åŸŸçš„ç ”ç©¶äººå‘˜å’Œå·¥ç¨‹å¸ˆæä¾›é‡è¦çš„å·¥å…·å’Œæ–¹æ³•ã€‚"},{"title":"äº¤å¹¶æ¯” (IOU)","path":"/wiki/DL-Techniques/äº¤å¹¶æ¯” (IOU).html","content":"ä»€ä¹ˆæ˜¯IOUï¼Ÿ IOU (Intersection over Union) æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„æŒ‡æ ‡ï¼Œç”¨äºè¯„ä¼°å›¾åƒåˆ†å‰²æˆ–ç›®æ ‡æ£€æµ‹ä»»åŠ¡çš„æ€§èƒ½ã€‚å®ƒè®¡ç®—äº†é¢„æµ‹çš„è¾¹ç•Œæ¡†æˆ–åˆ†å‰²åŒºåŸŸä¸å®é™…çš„è¾¹ç•Œæ¡†æˆ–åˆ†å‰²åŒºåŸŸçš„é‡å éƒ¨åˆ†å æ€»åŒºåŸŸçš„æ¯”ä¾‹ã€‚å…·ä½“æ¥è¯´ï¼ŒIOU æ˜¯å®é™…åŒºåŸŸä¸é¢„æµ‹åŒºåŸŸçš„äº¤é›†é¢ç§¯ä¸å¹¶é›†é¢ç§¯ä¹‹æ¯”ã€‚ å…¬å¼å¦‚ä¸‹ï¼š IOU=IntersectionÂ AreaUnionÂ Area\\text{IOU} = \\frac{\\text{Intersection Area}}{\\text{Union Area}} IOU=UnionÂ AreaIntersectionÂ Areaâ€‹ å…¶ä¸­ï¼š Intersection Area æ˜¯é¢„æµ‹åŒºåŸŸä¸å®é™…åŒºåŸŸçš„é‡å éƒ¨åˆ†ã€‚ Union Area æ˜¯é¢„æµ‹åŒºåŸŸå’Œå®é™…åŒºåŸŸçš„å¹¶é›†éƒ¨åˆ†ã€‚ ä»€ä¹ˆæ˜¯ mIOUï¼Ÿ mIOU (Mean Intersection over Union) æ˜¯å¯¹å¤šä¸ªæ ·æœ¬çš„IOUè¿›è¡Œå¹³å‡ï¼Œä»¥è¯„ä¼°æ¨¡å‹åœ¨æ•´ä¸ªæ•°æ®é›†ä¸Šçš„è¡¨ç°ã€‚å®ƒé€šè¿‡è®¡ç®—æ‰€æœ‰æ ·æœ¬çš„IOUï¼Œå¹¶å–å¹³å‡å€¼æ¥å¾—åˆ°ã€‚ mIOU çš„è®¡ç®—å…¬å¼å¦‚ä¸‹ï¼š mIOU=1Nâˆ‘i=1NIOUi\\text{mIOU} = \\frac{1}{N} \\sum_{i=1}^{N} \\text{IOU}_i mIOU=N1â€‹i=1âˆ‘Nâ€‹IOUiâ€‹ å…¶ä¸­ï¼š NNN æ˜¯æ ·æœ¬çš„æ•°é‡ã€‚ IOUi\\text{IOU}_iIOUiâ€‹ æ˜¯ç¬¬ iii ä¸ªæ ·æœ¬çš„ IOU å€¼ã€‚ ä»€ä¹ˆæ˜¯ oIOUï¼Ÿ oIOU (Overall Intersection over Union) æ˜¯é€šè¿‡ç´¯è®¡æ‰€æœ‰æ ·æœ¬çš„äº¤é›†é¢ç§¯å’Œå¹¶é›†é¢ç§¯æ¥è®¡ç®—çš„IOUã€‚ä¸ mIOU ä¸åŒçš„æ˜¯ï¼ŒoIOU ç›´æ¥è®¡ç®—æ€»çš„äº¤é›†é¢ç§¯å’Œå¹¶é›†é¢ç§¯çš„æ¯”ä¾‹ï¼Œè€Œä¸æ˜¯å¯¹å•ä¸ªæ ·æœ¬çš„IOUè¿›è¡Œå¹³å‡ã€‚ oIOU çš„è®¡ç®—å…¬å¼å¦‚ä¸‹ï¼š oIOU=âˆ‘i=1NIntersectionÂ Areaiâˆ‘i=1NUnionÂ Areai\\text{oIOU} = \\frac{\\sum_{i=1}^{N} \\text{Intersection Area}_i}{\\sum_{i=1}^{N} \\text{Union Area}_i} oIOU=âˆ‘i=1Nâ€‹UnionÂ Areaiâ€‹âˆ‘i=1Nâ€‹IntersectionÂ Areaiâ€‹â€‹ å…¶ä¸­ï¼š NNN æ˜¯æ ·æœ¬çš„æ•°é‡ã€‚ IntersectionÂ Areai\\text{Intersection Area}_iIntersectionÂ Areaiâ€‹ å’Œ UnionÂ Areai\\text{Union Area}_iUnionÂ Areaiâ€‹ åˆ†åˆ«æ˜¯ç¬¬ iii ä¸ªæ ·æœ¬çš„äº¤é›†é¢ç§¯å’Œå¹¶é›†é¢ç§¯ã€‚ IOUã€mIOU å’Œ oIOU çš„è®¡ç®—ä»£ç  ä¸‹é¢æ˜¯ä¸€ä¸ªç”¨äºè®¡ç®— IOUã€mIOU å’Œ oIOU çš„ä»£ç ç¤ºä¾‹ï¼Œå®ç°äº†ä¸€ä¸ªæµ‹è¯•å™¨ç±»ï¼Œä½¿ç”¨æ–¹æ³•æ˜¯åˆå§‹åŒ–åä¼ å…¥æ¯æ¬¡çš„é¢„æµ‹å’Œç›®æ ‡maskï¼Œä¼šè®¡ç®—å‡ºiouï¼Œæœ€åè°ƒç”¨evaluteæ–¹æ³•å¯ä»¥è¾“å‡ºæ•´ä¸ªæµ‹è¯•æ•°æ®é›†çš„mIOUå’ŒoIOUå€¼ å®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import numpy as npimport torchclass Evaluator(): def __init__(self): self.counters_by_iou = &#123;iou: 0 for iou in [0.5, 0.6, 0.7, 0.8, 0.9]&#125; self.total_intersection_area = 0 self.total_union_area = 0 self.ious_list = [] pass def compute_mask_iou(self, outputs: torch.Tensor, labels: torch.Tensor, EPS=1e-6): assert outputs.shape[0] == 1; assert outputs.shape == labels.shape; assert len(outputs.shape) == 3 outputs = outputs.int(); labels = labels.int() intersection = (outputs &amp; labels).float().sum((1, 2)) # Will be zero if Truth=0 or Prediction=0 union = (outputs | labels).float().sum((1, 2)) # Will be zero if both are 0 iou = (intersection + EPS) / (union + EPS) # EPS is used to avoid division by zero iou, intersection, union = iou.item(), intersection.item(), union.item() for iou_threshold in self.counters_by_iou.keys(): if iou &gt; iou_threshold: self.counters_by_iou[iou_threshold] += 1 self.total_intersection_area += intersection self.total_union_area += union self.ious_list.append(iou) return iou, intersection, union def evaluate(self): num_samples = len(self.ious_list) if num_samples == 0: print(&quot;No samples to evaluate.&quot;) return precision_at_k = np.array(list(self.counters_by_iou.values())) / num_samples overall_iou = self.total_intersection_area / self.total_union_area mean_iou = np.mean(self.ious_list) print(&quot;Evaluation Result&quot;) iou_thresholds = [0.5, 0.6, 0.7, 0.8, 0.9] for iou, prec in zip(iou_thresholds, precision_at_k): print(f&quot;IoU: &#123;iou:.2f&#125;, Precision: &#123;prec:.4f&#125;&quot;) print(&quot;========================================&quot;) print(f&quot;Overall IoU: &#123;overall_iou:.4f&#125;&quot;) print(f&quot;Mean IoU: &#123;mean_iou:.4f&#125;&quot;) ç»“è®º IOU æ˜¯è¯„ä¼°å›¾åƒåˆ†å‰²å’Œç›®æ ‡æ£€æµ‹ä»»åŠ¡æ€§èƒ½çš„é‡è¦æŒ‡æ ‡ã€‚é€šè¿‡è®¡ç®—æ¯ä¸ªæ ·æœ¬çš„ IOUï¼Œç„¶åæ±‚å¹³å‡å€¼å¯ä»¥å¾—åˆ° mIOUï¼Œè€Œé€šè¿‡è®¡ç®—æ‰€æœ‰æ ·æœ¬çš„æ€»äº¤é›†å’Œæ€»å¹¶é›†çš„æ¯”ä¾‹å¯ä»¥å¾—åˆ° oIOUã€‚ç†è§£å’Œè®¡ç®—è¿™äº›æŒ‡æ ‡æœ‰åŠ©äºå…¨é¢è¯„ä¼°æ¨¡å‹åœ¨åˆ†å‰²ä»»åŠ¡ä¸­çš„è¡¨ç°ã€‚ä¸Šè¿°ä»£ç æä¾›äº†ä¸€ä¸ªè®¡ç®— IOUã€mIOU å’Œ oIOU çš„å®ç°ç¤ºä¾‹ï¼Œå¯ä»¥å¸®åŠ©ä½ åœ¨å®é™…ä»»åŠ¡ä¸­è¿›è¡Œè¯„ä¼°ã€‚"},{"title":"æ¢¯åº¦åè½¬å±‚ (GRL)","path":"/wiki/DL-Techniques/æ¢¯åº¦åè½¬å±‚ (GRL).html","content":"æ¢¯åº¦åè½¬å±‚ï¼ˆGradient Reversal Layer, GRLï¼‰æ˜¯ä¸€ç§åœ¨å¯¹æŠ—è®­ç»ƒä¸­å¸¸ç”¨çš„æŠ€æœ¯ï¼Œç‰¹åˆ«æ˜¯åœ¨é¢†åŸŸè‡ªé€‚åº”ä»»åŠ¡ä¸­ã€‚å…¶æ ¸å¿ƒæ€æƒ³æ˜¯é€šè¿‡åœ¨å‰å‘ä¼ æ’­è¿‡ç¨‹ä¸­ä¿æŒè¾“å…¥ä¸å˜ï¼Œè€Œåœ¨åå‘ä¼ æ’­è¿‡ç¨‹ä¸­å°†æ¢¯åº¦åè½¬ï¼Œå³å°†æ¢¯åº¦ä¹˜ä»¥ä¸€ä¸ªè´Ÿæ•°ï¼Œä»è€Œæ”¹å˜å‚æ•°æ›´æ–°çš„æ–¹å‘ã€‚è¿™æ ·å¯ä»¥è¿«ä½¿ç‰¹å¾æå–å™¨ç”Ÿæˆçš„ç‰¹å¾åœ¨æºåŸŸå’Œç›®æ ‡åŸŸä¹‹é—´è¡¨ç°å¾—æ›´åŠ ä¸€è‡´ï¼Œä½¿å¾—é¢†åŸŸåˆ†ç±»å™¨éš¾ä»¥åŒºåˆ†å®ƒä»¬ï¼Œä»è€Œè¾¾åˆ°é¢†åŸŸè‡ªé€‚åº”çš„ç›®çš„ã€‚æ¢¯åº¦åè½¬å±‚çš„ä½¿ç”¨å¯ä»¥æ˜¾è‘—æé«˜æ¨¡å‹åœ¨ä¸åŒé¢†åŸŸä¸­çš„æ³›åŒ–èƒ½åŠ›ï¼Œè§£å†³é¢†åŸŸé—´åˆ†å¸ƒå·®å¼‚å¯¼è‡´çš„é—®é¢˜ã€‚ æµç¨‹ä»‹ç» è¿™ç§æœºåˆ¶åœ¨å¦‚åŸŸè‡ªé€‚åº”ç­‰ä¸€äº›ç‰¹å®šçš„ä»»åŠ¡ä¸­éå¸¸æœ‰ç”¨ï¼Œç‰¹åˆ«æ˜¯åœ¨å¯¹æŠ—è®­ç»ƒï¼ˆå¦‚é¢†åŸŸè‡ªé€‚åº”ï¼‰ä¸­ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªå…·ä½“çš„è§£é‡Šï¼š æ­£å¸¸è®­ç»ƒè¿‡ç¨‹ åœ¨æ­£å¸¸çš„è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œæ¢¯åº¦åå‘ä¼ æ’­çš„æ­¥éª¤å¦‚ä¸‹ï¼š å‰å‘ä¼ æ’­ï¼šè®¡ç®—æŸå¤±å‡½æ•°çš„å€¼ã€‚ åå‘ä¼ æ’­ï¼šè®¡ç®—æ¯ä¸ªå‚æ•°å¯¹æŸå¤±å‡½æ•°çš„æ¢¯åº¦ã€‚ æ¢¯åº¦æ›´æ–°ï¼šä½¿ç”¨ä¼˜åŒ–å™¨æ ¹æ®æ¢¯åº¦æ›´æ–°å‚æ•°ï¼Œä¾‹å¦‚ä½¿ç”¨éšæœºæ¢¯åº¦ä¸‹é™æ³• (SGD)ï¼šÎ¸=Î¸âˆ’Î·âˆ‡L(Î¸)\\theta = \\theta - \\eta abla L(\\theta) Î¸=Î¸âˆ’Î·âˆ‡L(Î¸) å…¶ä¸­ Î¸\\thetaÎ¸ æ˜¯å‚æ•°ï¼ŒÎ·\\etaÎ· æ˜¯å­¦ä¹ ç‡ï¼Œâˆ‡L(Î¸) abla L(\\theta)âˆ‡L(Î¸) æ˜¯æŸå¤±å‡½æ•° LLL å¯¹å‚æ•° Î¸\\thetaÎ¸ çš„æ¢¯åº¦ã€‚ ä½¿ç”¨æ¢¯åº¦åè½¬å±‚çš„è®­ç»ƒè¿‡ç¨‹ å½“ä½¿ç”¨æ¢¯åº¦åè½¬å±‚æ—¶ï¼Œåå‘ä¼ æ’­è¿‡ç¨‹ä¸­çš„æ¢¯åº¦ä¼šè¢«ä¹˜ä»¥ âˆ’Î±-\\alphaâˆ’Î±ï¼Œä»è€Œå®ç°åå‘æ›´æ–°å‚æ•°ã€‚å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š å‰å‘ä¼ æ’­ï¼šæ¢¯åº¦åè½¬å±‚å¯¹å‰å‘ä¼ æ’­æ²¡æœ‰å½±å“ï¼Œç›´æ¥ä¼ é€’è¾“å…¥æ•°æ®ã€‚ åå‘ä¼ æ’­ï¼šæ¢¯åº¦åè½¬å±‚å¯¹æ¢¯åº¦è¿›è¡Œåè½¬ï¼Œå³ä¹˜ä»¥ âˆ’Î±-\\alphaâˆ’Î±ï¼Œä½¿å¾—åå‘ä¼ æ’­çš„æ¢¯åº¦å˜ä¸º âˆ’Î±âˆ‡L(Î¸)-\\alpha abla L(\\theta)âˆ’Î±âˆ‡L(Î¸)ã€‚ æ¢¯åº¦æ›´æ–°ï¼šä½¿ç”¨ä¼˜åŒ–å™¨æ ¹æ®åè½¬åçš„æ¢¯åº¦æ›´æ–°å‚æ•°ï¼šÎ¸=Î¸âˆ’Î·(âˆ’Î±âˆ‡L(Î¸))=Î¸+Î·Î±âˆ‡L(Î¸)\\theta = \\theta - \\eta (-\\alpha abla L(\\theta)) = \\theta + \\eta \\alpha abla L(\\theta) Î¸=Î¸âˆ’Î·(âˆ’Î±âˆ‡L(Î¸))=Î¸+Î·Î±âˆ‡L(Î¸) å¯ä»¥çœ‹åˆ°ï¼Œå‚æ•°æ›´æ–°çš„æ–¹å‘ä¸æ­£å¸¸è®­ç»ƒç›¸åï¼Œä¸”æ›´æ–°çš„æ­¥é•¿ç”± (\\alpha) æ§åˆ¶ã€‚ åº”ç”¨åœºæ™¯ è¿™ç§åå‘æ›´æ–°å‚æ•°çš„æœºåˆ¶åœ¨é¢†åŸŸè‡ªé€‚åº”ä»»åŠ¡ä¸­éå¸¸æœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œåœ¨è®­ç»ƒä¸€ä¸ªé¢†åŸŸé€‚åº”çš„ç¥ç»ç½‘ç»œæ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›ç‰¹å¾æå–å™¨æå–çš„ç‰¹å¾åœ¨æºåŸŸå’Œç›®æ ‡åŸŸä¸Šéƒ½è¡¨ç°å¾—ä¸€è‡´ã€‚ä¸ºæ­¤ï¼Œå¯ä»¥å¼•å…¥ä¸€ä¸ªé¢†åŸŸåˆ†ç±»å™¨ï¼ˆDomain Classifierï¼‰ï¼Œå¹¶åœ¨å…¶å‰é¢æ·»åŠ æ¢¯åº¦åè½¬å±‚ã€‚åœ¨åå‘ä¼ æ’­è¿‡ç¨‹ä¸­ï¼Œæ¢¯åº¦åè½¬å±‚ä¼šåè½¬é¢†åŸŸåˆ†ç±»å™¨çš„æ¢¯åº¦ï¼Œè¿«ä½¿ç‰¹å¾æå–å™¨æå–çš„ç‰¹å¾åœ¨æºåŸŸå’Œç›®æ ‡åŸŸä¹‹é—´éš¾ä»¥åŒºåˆ†ï¼Œä»è€Œå®ç°é¢†åŸŸè‡ªé€‚åº”ã€‚ å®ç°ä»£ç  æ¢¯åº¦åè½¬å±‚GRLçš„å®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526from torch import nnfrom torch.autograd import Functionclass ReverseGradFunction(Function): @staticmethod def forward(ctx, data, alpha=1.0): ctx.alpha = alpha return data @staticmethod def backward(ctx, grad_outputs): grad = None if ctx.needs_input_grad[0]: grad = -ctx.alpha * grad_outputs return grad, Noneclass ReverseGrad(nn.Module): def __init__(self): super(ReverseGrad, self).__init__() def forward(self, x, alpha=1.0): return ReverseGradFunction.apply(x, alpha) åœ¨é¢†åŸŸè‡ªé€‚åº”ä»»åŠ¡ä¸­ï¼Œæ¢¯åº¦åè½¬å±‚ï¼ˆGradient Reversal Layer, GRLï¼‰é€šå¸¸æ”¾ç½®åœ¨ç‰¹å¾æå–å™¨å’Œé¢†åŸŸåˆ†ç±»å™¨ï¼ˆDomain Classifierï¼‰ä¹‹é—´ï¼Œè€Œä¸æ˜¯åœ¨ä¸»åˆ†ç±»å™¨ï¼ˆPrimary Classifierï¼‰ä¹‹å‰æˆ–ä¹‹åã€‚å…¶ç›®çš„æ˜¯å¯¹é¢†åŸŸåˆ†ç±»å™¨çš„æ¢¯åº¦è¿›è¡Œåè½¬ï¼Œä»è€Œè¿«ä½¿ç‰¹å¾æå–å™¨æå–çš„ç‰¹å¾åœ¨æºåŸŸå’Œç›®æ ‡åŸŸä¹‹é—´è¡¨ç°å¾—æ›´åŠ ä¸€è‡´ã€‚ å…·ä½“çš„ç½‘ç»œç»“æ„å¦‚ä¸‹ï¼š ç‰¹å¾æå–å™¨ï¼ˆFeature Extractorï¼‰ï¼šä»è¾“å…¥æ•°æ®ä¸­æå–ç‰¹å¾ã€‚ æ¢¯åº¦åè½¬å±‚ï¼ˆGradient Reversal Layerï¼‰ï¼šåè½¬åå‘ä¼ æ’­ä¸­çš„æ¢¯åº¦ã€‚ é¢†åŸŸåˆ†ç±»å™¨ï¼ˆDomain Classifierï¼‰ï¼šé¢„æµ‹ç‰¹å¾æ¥è‡ªæºåŸŸè¿˜æ˜¯ç›®æ ‡åŸŸã€‚ ä¸»åˆ†ç±»å™¨ï¼ˆPrimary Classifierï¼‰ï¼šåŸºäºæå–çš„ç‰¹å¾è¿›è¡Œä¸»è¦ä»»åŠ¡ï¼ˆå¦‚åˆ†ç±»ï¼‰ã€‚ è¿™ç§ç»“æ„çš„ç›®çš„æ˜¯åˆ©ç”¨é¢†åŸŸåˆ†ç±»å™¨çš„æ¢¯åº¦åå‘æ›´æ–°ç‰¹å¾æå–å™¨ï¼Œä»è€Œä½¿ç‰¹å¾æå–å™¨ç”Ÿæˆçš„ç‰¹å¾åœ¨ä¸åŒé¢†åŸŸä¹‹é—´æ— æ³•åŒºåˆ†ã€‚ ç¤ºä¾‹ä»£ç  ä»¥ä¸‹æ˜¯ä¸€ä¸ªå¸¦æœ‰æ¢¯åº¦åè½¬å±‚çš„é¢†åŸŸè‡ªé€‚åº”æ¨¡å‹ç¤ºä¾‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import torchimport torch.nn as nnimport torch.optim as optimclass FeatureExtractor(nn.Module): def __init__(self): super(FeatureExtractor, self).__init__() self.features = nn.Sequential( nn.Conv2d(1, 32, kernel_size=3, stride=1, padding=1), nn.ReLU(), nn.MaxPool2d(kernel_size=2, stride=2) ) def forward(self, x): return self.features(x)class DomainClassifier(nn.Module): def __init__(self): super(DomainClassifier, self).__init__() self.classifier = nn.Sequential( nn.Linear(32 * 14 * 14, 128), nn.ReLU(), nn.Linear(128, 2) # å‡è®¾æœ‰ä¸¤ä¸ªé¢†åŸŸ ) def forward(self, x): return self.classifier(x)class PrimaryClassifier(nn.Module): def __init__(self): super(PrimaryClassifier, self).__init__() self.classifier = nn.Sequential( nn.Linear(32 * 14 * 14, 128), nn.ReLU(), nn.Linear(128, 10) # å‡è®¾æœ‰10ä¸ªç±»åˆ« ) def forward(self, x): return self.classifier(x)class FullModel(nn.Module): def __init__(self): super(FullModel, self).__init__() self.feature_extractor = FeatureExtractor() self.domain_classifier = DomainClassifier() self.primary_classifier = PrimaryClassifier() def forward(self, x, alpha=1.0): features = self.feature_extractor(x) features_flattened = features.view(features.size(0), -1) # å¯¹é¢†åŸŸåˆ†ç±»å™¨ä½¿ç”¨æ¢¯åº¦åè½¬å±‚ domain_output = ReverseGrad()(features_flattened, alpha) domain_output = self.domain_classifier(domain_output) # å¯¹ä¸»åˆ†ç±»å™¨ä¸ä½¿ç”¨æ¢¯åº¦åè½¬å±‚ primary_output = self.primary_classifier(features_flattened) return primary_output, domain_output# åˆå§‹åŒ–æ¨¡å‹ã€æŸå¤±å‡½æ•°å’Œä¼˜åŒ–å™¨model = FullModel()criterion_class = nn.CrossEntropyLoss()criterion_domain = nn.CrossEntropyLoss()optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.9)# ç”Ÿæˆéšæœºè¾“å…¥æ•°æ®å’Œæ ‡ç­¾input_data = torch.randn(8, 1, 28, 28) # 8ä¸ª28x28çš„ç°åº¦å›¾åƒlabels_class = torch.randint(0, 10, (8,)) # 8ä¸ªéšæœºä¸»ä»»åŠ¡æ ‡ç­¾labels_domain = torch.randint(0, 2, (8,)) # 8ä¸ªéšæœºé¢†åŸŸæ ‡ç­¾# å‰å‘ä¼ æ’­primary_output, domain_output = model(input_data, alpha=0.5)# è®¡ç®—æŸå¤±loss_class = criterion_class(primary_output, labels_class)loss_domain = criterion_domain(domain_output, labels_domain)loss = loss_class + loss_domain# åå‘ä¼ æ’­å’Œä¼˜åŒ–optimizer.zero_grad()loss.backward()optimizer.step() è§£é‡Š ç‰¹å¾æå–å™¨ï¼šæå–è¾“å…¥æ•°æ®çš„ç‰¹å¾ã€‚ æ¢¯åº¦åè½¬å±‚ï¼šå¯¹ç‰¹å¾æå–å™¨è¾“å‡ºçš„ç‰¹å¾è¿›è¡Œæ¢¯åº¦åè½¬ï¼Œç„¶åè¾“å…¥åˆ°é¢†åŸŸåˆ†ç±»å™¨ä¸­ã€‚ é¢†åŸŸåˆ†ç±»å™¨ï¼šæ ¹æ®åè½¬åçš„ç‰¹å¾åˆ¤æ–­å…¶æ¥è‡ªå“ªä¸ªé¢†åŸŸã€‚ ä¸»åˆ†ç±»å™¨ï¼šæ ¹æ®ç‰¹å¾æå–å™¨è¾“å‡ºçš„ç‰¹å¾è¿›è¡Œä¸»è¦ä»»åŠ¡çš„åˆ†ç±»ã€‚ é€šè¿‡è¿™ç§ç»“æ„ï¼Œæ¢¯åº¦åè½¬å±‚ä¼šåè½¬é¢†åŸŸåˆ†ç±»å™¨çš„æ¢¯åº¦ï¼Œä½¿å¾—ç‰¹å¾æå–å™¨ç”Ÿæˆçš„ç‰¹å¾åœ¨ä¸åŒé¢†åŸŸä¹‹é—´æ›´éš¾åŒºåˆ†ï¼Œä»è€Œå®ç°é¢†åŸŸè‡ªé€‚åº”ã€‚"},{"title":"ç»“æœå›ºå®šä»£ç ","path":"/wiki/DL-Techniques/ç»“æœå›ºå®šä»£ç .html","content":"åœ¨è®­ç»ƒå’Œæµ‹è¯•çš„æ—¶å€™å¯ä»¥åœ¨è„šæœ¬ä¸­åŠ å…¥å¦‚ä¸‹ä»£ç ï¼Œå¯¹ç»“æœè¿›è¡Œå›ºå®šï¼Œç¡®ä¿æ¯æ¬¡è¿è¡Œè„šæœ¬ç»“æœä¿æŒä¸€è‡´ï¼š 1234567def seed_torch(seed): os.environ[&#x27;PYTHONHASHSEED&#x27;] = str(seed) np.random.seed(seed) torch.manual_seed(seed) torch.cuda.manual_seed(seed) torch.backends.cudnn.benchmark = False torch.backends.cudnn.deterministic = True 12345678910111213141516171819202122232425262728def seed_torch(seed): &quot;&quot;&quot; Set the random seed for various modules to ensure reproducibility. Args: seed (int): The seed value to be set. &quot;&quot;&quot; # Set PYTHONHASHSEED environment variable os.environ[&#x27;PYTHONHASHSEED&#x27;] = str(seed) # Set random seed for Python&#x27;s built-in random module random.seed(seed) # Set random seed for numpy np.random.seed(seed) # Set random seed for PyTorch torch.manual_seed(seed) # Set random seed for PyTorch (CUDA) if torch.cuda.is_available(): torch.cuda.manual_seed(seed) torch.cuda.manual_seed_all(seed) # if you are using multi-GPU. # Ensure that the cuDNN library&#x27;s benchmark mode is disabled, and that # cuDNN is deterministic. torch.backends.cudnn.benchmark = False torch.backends.cudnn.deterministic = True"},{"title":"åŠ¨æ€è§„åˆ’","path":"/wiki/Luogu/åŠ¨æ€è§„åˆ’.html","content":"ã€åŠ¨æ€è§„åˆ’1ã€‘åŠ¨æ€è§„åˆ’çš„å¼•å…¥ P1216 [USACO1.5] [IOI1994]æ•°å­—ä¸‰è§’å½¢ Number Triangles é¢˜ç›®ä¼ é€é—¨ï¼šP1216 [USACO1.5] [IOI1994]æ•°å­—ä¸‰è§’å½¢ Number Triangles - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn) éå¸¸åŸºç¡€çš„ä¸€é“é¢˜ç›®ï¼Œç›´æ¥é€’æ¨åˆ·è¡¨å³å¯ã€‚ 123456789101112131415161718192021222324252627282930/* * Problem: P1216 [USACO1.5] [IOI1994]æ•°å­—ä¸‰è§’å½¢ Number Triangles * URL: https://www.luogu.com.cn/problem/P1216 * Description: basic dp * Created by Vegetabot on 2023/12/17. */#include&lt;bits/stdc++.h&gt;#define N 1002using namespace std;vector&lt;vector&lt;int&gt;&gt; dp(N,vector&lt;int&gt;(N,0));vector&lt;vector&lt;int&gt;&gt; nums(N,vector&lt;int&gt;(N,0));int n;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;=i;++j)&#123; scanf(&quot;%d&quot;,&amp;nums[i][j]); &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=i;++j)&#123; dp[i][j] = max(dp[i-1][j-1],dp[i-1][j]) + nums[i-1][j-1]; &#125; &#125; int ans = dp[n][0]; for(int i=1;i&lt;=n;++i) ans = ans&gt;dp[n][i]?ans:dp[n][i]; printf(&quot;%d&quot;,ans); return 0;&#125; P1048 [NOIP2005 æ™®åŠç»„] é‡‡è¯ é¢˜ç›®ä¼ é€é—¨ï¼šP1048 [NOIP2005 æ™®åŠç»„] é‡‡è¯ - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn) 01èƒŒåŒ…æ¿å­é¢˜ï¼ŒèƒŒåŒ…ç›¸å…³çš„çŸ¥è¯†ç‚¹å»ºè®®å¯ä»¥å­¦ä¹ ç½‘ä¸Šéå¸¸çš„æµè¡Œçš„èƒŒåŒ…ä¹è®²æ•™ç¨‹ 12345678910111213141516171819202122232425262728293031/* * Problem: P1048 [NOIP2005 æ™®åŠç»„] é‡‡è¯ * URL: https://www.luogu.com.cn/problem/P1048 * Description: 01èƒŒåŒ… * Created by Vegetabot on 2023/12/17. */#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; dp(101,vector&lt;int&gt;(1001,0));vector&lt;int&gt; times,vals;int M,T;int main()&#123; scanf(&quot;%d%d&quot;,&amp;T,&amp;M); for(int i=0;i&lt;M;++i)&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); times.emplace_back(a); vals.emplace_back(b); &#125; for(int i=1;i&lt;=M;++i)&#123; for(int j=0;j&lt;=T;++j)&#123; if (j &lt; times[i-1]) dp[i][j] = dp[i-1][j]; else dp[i][j] = max(dp[i-1][j],dp[i-1][j-times[i-1]]+vals[i-1]); &#125; &#125; int ans = dp[M][0]; for(int i=0;i&lt;=T;++i) ans = ans&gt;dp[M][i]?ans:dp[M][i]; printf(&quot;%d&quot;,ans); return 0;&#125; æ„Ÿè§‰emplace_backæ€§èƒ½ä¼šæ¯”push_backè¦å¥½ä¸€äº›ï¼Œ ä»¥åéƒ½ç”¨emplace_backå¥½äº† åŒæ ·å› ä¸ºæ˜¯åŠ¨æ€è§„åˆ’é—®é¢˜ï¼Œæ‰€ä»¥æ¯‹åº¸ç½®ç–‘çš„æ˜¯ï¼Œè¿™é“é¢˜ç›®ä¹Ÿå¯ä»¥ä½¿ç”¨è®°å¿†åŒ–æœç´¢çš„æ–¹å¼æ¥è§£å†³ã€‚ ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940/* * Problem: P1048 [NOIP2005 æ™®åŠç»„] é‡‡è¯ * URL: https://www.luogu.com.cn/problem/P1048 * Description: 01èƒŒåŒ… * Created by Vegetabot on 2023/12/17. */#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; dp;vector&lt;int&gt; times, vals;int M, T;int solve(int i, int j) &#123; if (i == 0) return 0; // è¾¹ç•Œæ¡ä»¶ if (dp[i][j] != -1) return dp[i][j]; // å·²ç»è®¡ç®—è¿‡ int notTake = solve(i - 1, j); // ä¸é€‰æ‹©å½“å‰ç‰©å“ int take = 0; if (j &gt;= times[i-1]) &#123; take = vals[i-1] + solve(i - 1, j - times[i-1]); // é€‰æ‹©å½“å‰ç‰©å“ &#125; return dp[i][j] = max(notTake, take); // è®°å¿†åŒ–å­˜å‚¨å¹¶è¿”å›ç»“æœ&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;T, &amp;M); dp.assign(M+1, vector&lt;int&gt;(T + 1, -1)); // åˆå§‹åŒ–è®°å¿†åŒ–æ•°ç»„ times.resize(M); vals.resize(M); for (int i = 0; i &lt; M; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;times[i], &amp;vals[i]); &#125; printf(&quot;%d&quot;, solve(M, T)); // ä»ç¬¬0ä¸ªç‰©å“å¼€å§‹ï¼Œæ€»é™åˆ¶ä¸ºT return 0;&#125; å½“ç„¶01èƒŒåŒ…é—®é¢˜è¿˜å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„å¯¹ç©ºé—´è¿›è¡Œä¼˜åŒ–ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ï¼ˆå› ä¸ºå†™çš„æ¯”è¾ƒå¤šï¼‰"},{"title":"pngå›¾ç‰‡å¡«å……è„šæœ¬","path":"/wiki/Others/pngå›¾ç‰‡å¡«å……è„šæœ¬.html","content":"è„šæœ¬ä½œç”¨ï¼šå°†ç»™å®šPNGå›¾åƒä¸­é€æ˜éƒ¨åˆ†å¡«å……ä¸ºç™½è‰² 123456789101112131415161718192021from PIL import Imageoriginal_path = &#x27;xxxx&#x27;original_file = &#x27;cc.png&#x27;target_path = &#x27;xxx&#x27;# æ‰“å¼€åŸå§‹PNGå›¾åƒimage = Image.open(original_path+original_file).convert(&quot;RGBA&quot;)# åˆ›å»ºä¸€ä¸ªç™½è‰²èƒŒæ™¯white_background = Image.new(&quot;RGBA&quot;, image.size, &quot;WHITE&quot;)# å°†åŸå§‹å›¾åƒç²˜è´´åˆ°ç™½è‰²èƒŒæ™¯ä¸Šï¼Œé€æ˜éƒ¨åˆ†å°†è¢«ç™½è‰²å¡«å……white_background.paste(image, (0, 0), image)# å°†ç»“æœè½¬æ¢ä¸ºRGBæ¨¡å¼å¹¶ä¿å­˜final_image = white_background.convert(&quot;RGB&quot;)final_image.save(target_path+original_file)# æ˜¾ç¤ºç»“æœå›¾åƒï¼ˆå¯é€‰ï¼‰final_image.show()"},{"title":"PyTorch CNNå®æˆ˜","path":"/wiki/PyTorch/PyTorch CNNå®æˆ˜.html","content":"æœ¬åšå®¢ä¸»è¦ä½¿ç”¨PyTorchå…ˆå®ç°ä¸€ä¸ªç®€å•çš„CNNå¯¹CIFAR-10æ•°æ®é›†å¯¹å›¾ç‰‡ç‰©ä½“è¿›è¡Œåˆ†ç±»æ“ä½œï¼Œç„¶åå®ç°ä¸€ä¸ªResNetåŒæ ·ä¹Ÿæ˜¯åº”ç”¨äºCIFAR-10æ•°æ®é›†å¯¹ç‰©ä½“è¿›è¡Œåˆ†ç±»æ“ä½œã€‚ åœ¨å¼€å§‹ä¹‹å‰æˆ‘ä»¬å…ˆä»‹ç»ä¸€ä¸‹æœ¬æ¬¡å®éªŒæ‰€ä½¿ç”¨çš„æ•°æ®é›†CIFAR-10 CIFAR-10 CIFAR-10 æ˜¯ç”± Hinton çš„å­¦ç”Ÿ Alex Krizhevsky å’Œ Ilya Sutskever æ•´ç†çš„ä¸€ä¸ªç”¨äºè¯†åˆ«æ™®é€‚ç‰©ä½“çš„å°å‹æ•°æ®é›†ã€‚ä¸€å…±åŒ…å« 10 ä¸ªç±»åˆ«çš„ RGB å½©è‰²å›¾ ç‰‡ï¼šé£æœºï¼ˆ aå©lane ï¼‰ã€æ±½è½¦ï¼ˆ automobile ï¼‰ã€é¸Ÿç±»ï¼ˆ bird ï¼‰ã€çŒ«ï¼ˆ cat ï¼‰ã€é¹¿ï¼ˆ deer ï¼‰ã€ç‹—ï¼ˆ dog ï¼‰ã€è›™ç±»ï¼ˆ frog ï¼‰ã€é©¬ï¼ˆ horse ï¼‰ã€èˆ¹ï¼ˆ ship ï¼‰å’Œå¡è½¦ï¼ˆ truck ï¼‰ã€‚å›¾ç‰‡çš„å°ºå¯¸ä¸º 32Ã—32 ï¼Œæ•°æ®é›†ä¸­ä¸€å…±æœ‰ 50000 å¼ è®­ç»ƒå›¾ç‰‡å’Œ 10000 å¼ æµ‹è¯•å›¾ç‰‡ï¼ˆæ¯ä¸€ç±»ç‰©ä½“æœ‰6000å¼ ç…§ç‰‡ï¼‰ã€‚ CIFAR-10 çš„å›¾ç‰‡æ ·ä¾‹å¦‚å›¾æ‰€ç¤ºã€‚ ä¸ MNIST æ•°æ®é›†ä¸­ç›®æ¯”ï¼Œ CIFAR-10 å…·æœ‰ä»¥ä¸‹ä¸åŒç‚¹ï¼š â€¢ CIFAR-10 æ˜¯ 3 é€šé“çš„å½©è‰² RGB å›¾åƒï¼Œè€Œ MNIST æ˜¯ç°åº¦å›¾åƒã€‚ â€¢ CIFAR-10 çš„å›¾ç‰‡å°ºå¯¸ä¸º 32Ã—32ï¼Œ è€Œ MNIST çš„å›¾ç‰‡å°ºå¯¸ä¸º 28Ã—28ï¼Œæ¯” MNIST ç¨å¤§ã€‚ â€¢ ç›¸æ¯”äºæ‰‹å†™å­—ç¬¦ï¼Œ CIFAR-10 å«æœ‰çš„æ˜¯ç°å®ä¸–ç•Œä¸­çœŸå®çš„ç‰©ä½“ï¼Œä¸ä»…å™ªå£°å¾ˆå¤§ï¼Œè€Œä¸”ç‰©ä½“çš„æ¯”ä¾‹ã€ ç‰¹å¾éƒ½ä¸å°½ç›¸åŒï¼Œè¿™ä¸ºè¯†åˆ«å¸¦æ¥å¾ˆå¤§å›°éš¾ã€‚ ç›´æ¥çš„çº¿æ€§æ¨¡å‹å¦‚ Softmax åœ¨ CIFAR-10 ä¸Šè¡¨ç°å¾—å¾ˆå·®ã€‚ ä¸‹é¢è¿™å¹…å›¾å°±æ˜¯åˆ—ä¸¾äº†10å„ç±»ï¼Œæ¯ä¸€ç±»å±•ç¤ºäº†éšæœºçš„10å¼ å›¾ç‰‡ï¼š å®ç°ç®€å•çš„CNN åŠ è½½æ•°æ®é›† æ­¥éª¤åˆ†ä¸ºä¸¤æ­¥ï¼Œé¦–å…ˆæ˜¯å¯¼å…¥æ•°æ®é›†ï¼ˆè¿™ä¸€æ­¥ä¹ŸåŒ…å«äº†æ•°æ®çš„å¢å¼ºï¼Œæ¯”å¦‚æ—‹è½¬åˆ‡å‰²ä¹‹ç±»çš„ï¼‰ï¼Œç„¶åå°±æ˜¯ä½¿ç”¨Dataloaderå¯¼å…¥æ•°æ®ã€‚å¯¹äºè®­ç»ƒé›†å’Œæµ‹è¯•é›†éƒ½è¦å¯¼å…¥æ•°æ®ï¼Œä½†æ˜¯è¦è®°ä½ï¼Œæœ‰ä¸ªboolç±»å‹çš„å‚æ•°è¦è®¾ç½®çš„ä¸åŒã€‚ 12345678910111213141516171819batchsz = 32cifar_train =datasets.CIFAR10(&#x27;cifar_data&#x27;,True, # è¿™ä¸ªTrueä»£è¡¨æ˜¯è®­ç»ƒé›† transform=transforms.Compose([ transforms.Resize([32,32]), transforms.ToTensor() ]), download=True )cifar_train = DataLoader(cifar_train,batch_size=batchsz,shuffle=True)cifar_test =datasets.CIFAR10(&#x27;cifar_data&#x27;,True, transform=transforms.Compose([ transforms.Resize([32,32]), transforms.ToTensor() ]), download=True )cifar_test = DataLoader(cifar_test,batch_size=batchsz,shuffle=True) ç„¶åæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä¸¤è¡Œä»£ç æ¥ç®€å•æµ‹è¯•ä¸€ä¸‹æˆ‘ä»¬çš„æ•°æ®æ˜¯å¦å¯¼å…¥æˆåŠŸäº†ï¼š 12x,label = iter(cifar_train).next()print(&#x27;x:&#x27;,x.shape) å®ç°LeNet-5ç½‘ç»œç»“æ„ æ ¹æ®æˆ‘ä»¬å‰é¢æ‰€å­¦çš„ç†è®ºçŸ¥è¯†ï¼Œæˆ‘ä»¬çŸ¥é“LeNet-5ä¸»è¦åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼Œå·ç§¯éƒ¨åˆ†å’Œå…¨è¿æ¥éƒ¨åˆ†ï¼Œä¸­é—´æœ‰ä¸€ä¸ªFlattenæ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨å¦‚ä¸‹è¿™ç§æ–¹å¼å¯¹ç½‘ç»œç»“æ„è¿›è¡Œå®ç°ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class LeNet5(nn.Module): &#x27;&#x27;&#x27; for CIFAR10 dataset &#x27;&#x27;&#x27; def __init__(self): super(LeNet5,self).__init__() self.conv_unit = nn.Sequential( # input: [batchsz,3,32,32] nn.Conv2d(3,6,kernel_size=5, stride=1, padding=0), nn.AvgPool2d(kernel_size=2,stride=2,padding=0), nn.Conv2d(6,16,kernel_size=5,stride=1,padding=0), nn.AvgPool2d(kernel_size=2,stride=2,padding=0), # ç„¶åä¸‹é¢å°±æ˜¯å·ç§¯å±‚è½¬å…¨è¿æ¥å±‚äº†ï¼Œè¿™é‡Œéœ€è¦ä¸€ä¸ªæ‰“å¹³æ“ä½œ ) # Flatten # fc unit self.fc_unit=nn.Sequential( nn.Linear(16*5*5,120), nn.ReLU(inplace=True), nn.Linear(120,84), nn.ReLU(inplace=True), nn.Linear(84,10) ) # ä»¥ä¸‹æ˜¯æµ‹è¯•ç”¨çš„ä»£ç ï¼Œç”¨æ¥æµ‹è¯•å·ç§¯ç¥ç»ç½‘ç»œæœ€åè¾“å‡ºçš„å›¾ç‰‡å¤§å°æ˜¯å¤šå°‘ # [batchsz,3,32,32] tmp = torch.randn(2,3,32,32) out = self.conv_unit(tmp) # æµ‹è¯•è¾“å‡º:[batchsz,16,5,5] print(&#x27;conv out&#x27;,out.shape) def forward(self,x): &#x27;&#x27;&#x27; :param input : [batchsz,3,32,32] :return logits &#x27;&#x27;&#x27; batchsz = x.size(0) # [batchsz,3,32,32] =&gt; [batchsz,16,5,5] x = self.conv_unit(x) x = x.view(batchsz,16*5*5) #view(batchsz,-1) # [batchsz,16*5*5] =&gt; [b,10] logits = self.fc_unit(x) return logits å¯ä»¥å‘ç°ä¸Šé¢æˆ‘ä»¬ä½¿ç”¨äº†ä¸¤ä¸ªSequentialç„¶åæ˜¯æŠŠä»–ä»¬åœ¨forwardä¸­è¿èµ·æ¥çš„ã€‚æˆ–è®¸ä½ å¯èƒ½è§‰å¾—è¿™æ ·å†™æœ‰ä¸€ç‚¹éº»çƒ¦ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¹Ÿå¯ä»¥æŠŠFlattenæ“ä½œç»§æ‰¿ä¸€ä¸ªnn.moduleç±»ï¼Œè¿™æ ·ä»–å°±å¯ä»¥è¢«æ”¾å…¥Sequentialä¸­äº†ï¼Œç„¶åæˆ‘ä»¬å°±æœ‰äº†å¦‚ä¸‹çš„å†™æ³•ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import torchfrom torch import nnimport torch.nn.functional as Fclass Flatten(nn.Module): def __init__(self): super(Flatten,self).__init__() def forward(self,input): return input.view(input.size(0),-1)class LeNet5(nn.Module): &#x27;&#x27;&#x27; for CIFAR10 dataset &#x27;&#x27;&#x27; def __init__(self): super(LeNet5,self).__init__() self.nn_unit = nn.Sequential( # input: [batchsz,3,32,32] nn.Conv2d(3,6,kernel_size=5, stride=1, padding=0), nn.AvgPool2d(kernel_size=2,stride=2,padding=0), nn.Conv2d(6,16,kernel_size=5,stride=1,padding=0), nn.AvgPool2d(kernel_size=2,stride=2,padding=0), # Flatten Flatten(), # fc unit nn.Linear(16*5*5,120), nn.ReLU(inplace=True), nn.Linear(120,84), nn.ReLU(inplace=True), nn.Linear(84,10) # ç„¶åä¸‹é¢å°±æ˜¯å·ç§¯å±‚è½¬å…¨è¿æ¥å±‚äº†ï¼Œè¿™é‡Œéœ€è¦ä¸€ä¸ªæ‰“å¹³æ“ä½œ ) # ä»¥ä¸‹æ˜¯æµ‹è¯•ç”¨çš„ä»£ç  # [batchsz,3,32,32] tmp = torch.randn(2,3,32,32) out = self.nn_unit(tmp) print(&#x27;nn out&#x27;,out.shape) def forward(self,x): &#x27;&#x27;&#x27; :param input : [batchsz,3,32,32] :return logits &#x27;&#x27;&#x27; # [batchsz,3,32,32] =&gt; [batchsz,16,5,5] logits = self.nn_unit(x) return logitsdef main(): net = LeNet5() #æµ‹è¯•ç½‘ç»œç»“æ„ï¼ˆç½‘ç»œèƒ½å¦è·‘é€šï¼‰ tmp = torch.randn(2,3,32,32) out = net(tmp) print(&#x27;LeNet out&#x27;,out.shape)if __name__ == &#x27;__main__&#x27;: main() æ­£å¦‚ä¸Šé¢ä»£ç æ‰€å†™ï¼Œå½“æˆ‘ä»¬ä¸ç¡®å®šCNNè¾“å…¥tensorçš„å½¢çŠ¶çš„æ—¶å€™ï¼Œå¯ä»¥åœ¨mainå‡½æ•°ä¸­å†™ï¼š 1234567def main(): net = LeNet5() #æµ‹è¯•ç½‘ç»œç»“æ„ï¼ˆç½‘ç»œèƒ½å¦è·‘é€šï¼‰ tmp = torch.randn(2,3,32,32) out = net(tmp) print(&#x27;LeNet out&#x27;,out.shape) æˆ–è€…å¯ä»¥åœ¨åˆå§‹åŒ–ç½‘ç»œç»“æ„çš„æ—¶å€™ä¹Ÿå¯ä»¥è¿›è¡Œæµ‹è¯•ï¼Œæˆ‘ä»¬åœ¨æˆ‘ä»¬å®šä¹‰çš„ç±»ä¸‹çš„__init__å‡½æ•°ä¸­å†™ï¼š 123456# ä»¥ä¸‹æ˜¯æµ‹è¯•ç”¨çš„ä»£ç # [batchsz,3,32,32]tmp = torch.randn(2,3,32,32)out = self.nn_unit(tmp)# æµ‹è¯•è¾“å‡º:[batchsz,16,5,5]print(&#x27;nn out&#x27;,out.shape) è®­ç»ƒéƒ¨åˆ† å’Œå‰é¢çš„å…¨è¿æ¥ç¥ç»ç½‘ç»œä¸€æ ·ï¼Œæ­¥éª¤æ˜¯ä¸€æ ·çš„ã€‚è¿™é‡Œå¤šå¢åŠ äº†å¦‚ä½•ä½¿ç”¨GPUè¿›è¡Œè®­ç»ƒï¼Œä»¥åŠé‡‡ç”¨äº†ä¸å‰é¢ä¸ä¸€æ ·çš„CrossEntropyLoss()ä½œä¸ºcriteonï¼Œä½¿ç”¨Adamä½œä¸ºä¼˜åŒ–å™¨ã€‚ 123456789101112131415161718192021222324252627# å®šä¹‰GPUdevice = torch.device(&#x27;cuda&#x27;)# å¯¼å…¥æ¨¡å‹model = LeNet5().to(device) # å°†æ¨¡å‹æ”¾åˆ°æ˜¾å¡ä¸Šprint(model)# è®¾ç½®criteoncriteon=nn.CrossEntropyLoss()# è®¾ç½®ä¼˜åŒ–å™¨(ç›®æ ‡ä¼˜åŒ–å‚æ•°ï¼Œå­¦ä¹ ç‡)optimizer=optim.Adam(model.parameters(),lr=1e-3)# è®­ç»ƒå‡½æ•°for epoch in range(1000): #è®­ç»ƒè½®æ•° for batchidx,(x,label) in enumerate(cifar_train): # x: [batchsz,3,32,32] # label: [batchsz] x, label =x.to(device),label.to(device) # å°†æ•°æ®æ”¾åˆ°æ˜¾å¡ä¸Š logits=model(x) loss = criteon(logits,label) # backprop optimizer.zero_grad() # æ¸…é›¶ loss.backward() # åå‘ä¼ æ’­ optimizer.step() # æ›´æ–°ä¸€æ¬¡ `enumerate`çš„ä½œç”¨å¦‚ä¸‹ï¼Œç›¸å½“äºæ˜¯å¯¹å¯ä»¥æšä¸¾çš„å¯¹è±¡å‰é¢åŠ ä¸Šç´¢å¼•ï¼š 123arr=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]for idx,item in enumerate(arr): print(idx,&quot;:&quot;,item) 12340 : a1 : b2 : c3 : d å®ç°Val æˆ‘ä»¬æ¯æ¬¡è®­ç»ƒå®Œäº†ä¸€ä¸ªepochéƒ½è¦è¿›è¡ŒValï¼Œè¿™æ ·æˆ‘ä»¬æ‰çŸ¥é“æˆ‘ä»¬çš„æ¨¡å‹æ˜¯å¦è®­ç»ƒçš„åˆé€‚ã€‚Valéƒ¨åˆ†å…¶å®å’Œä¹‹å‰çš„å…¨è¿æ¥ç¥ç»ç½‘ç»œæ˜¯å·®ä¸å¤šçš„ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ã€‚ 123456789101112131415# valtotal_correct=0total_num=0for x,label in cifar_test: x,label=x.to(device),label.to(device) # [batchsz, 10] logits = model(x) # [batchsz] pred = logits.argmax(dim=1) total_correct += torch.eq(pred,label).float().sum().item() # eq æ˜¯é€ä¸ªæ¯”è¾ƒæœ€åè¾“å‡ºçŸ©é˜µå¤§å°å’Œlabelçš„å¤§å°æ˜¯ä¸€æ ·çš„ total_num += x.size(0) acc =total_correct / total_num print(&#x27;acc&#x27;,acc) æ³¨æ„torch.eqå’Œtorch.equalçš„åŒºåˆ« Train+Val æ•´ä½“ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435# Train+Val for epoch in range(1000): for batchidx,(x,label) in enumerate(cifar_train): # x: [batchsz,3,32,32] # label: [batchsz] x, label =x.to(device),label.to(device) # å°†æ•°æ®æ”¾åˆ°æ˜¾å¡ä¸Š logits=model(x) loss = criteon(logits,label) # backprop optimizer.zero_grad() # æ¸…é›¶ loss.backward() # åå‘ä¼ æ’­ optimizer.step() # æ›´æ–°ä¸€æ¬¡ # è¾“å‡ºæ¯ä¸€è½®è®­ç»ƒç»“æŸåçš„loss print(epoch,loss.item()) # val total_correct=0 total_num=0 for x,label in cifar_test: x,label=x.to(device),label.to(device) # [b, 10] logits = model(x) # [b] pred = logits.argmax(dim=1) total_correct += torch.eq(pred,label).float().sum().item() # eq æ˜¯é€ä¸ªæ¯”è¾ƒæœ€åè¾“å‡ºçŸ©é˜µå¤§å°å’Œlabelçš„å¤§å°æ˜¯ä¸€æ ·çš„ total_num += x.size(0) acc =total_correct / total_num print(&#x27;acc&#x27;,acc) å…¶ä»–ç»†èŠ‚ Valä»£ç ä¼˜åŒ– å› ä¸ºValæ˜¯åšæµ‹è¯•çš„ï¼Œæ˜¯ä¸éœ€è¦æ¢¯åº¦ä¿¡æ¯ï¼Œåå‘ä¼ æ’­å¯¹å‚æ•°è¿›è¡Œä¼˜åŒ–çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠä¸Šè¿°valéƒ¨åˆ†ä»£ç åŒ…å«åˆ°with torch.no_grad():ä¸­ï¼Œè¿™æ®µä»£ç ç›¸å½“äºå‘Šè¯‰PyTorchè¢«è¿™æ®µä»£ç åŒ…å«çš„ä»£ç æ˜¯ä¸éœ€è¦æ¢¯åº¦ä¿¡æ¯çš„ã€‚è¿™ä¹ˆå†™æ›´åŠ çš„å®‰å…¨ã€‚ 12345678910111213141516with torch.no_grad():\t# val total_correct=0 total_num=0 for x,label in cifar_test: x,label=x.to(device),label.to(device) # [batchsz, 10] logits = model(x) # [batchsz] pred = logits.argmax(dim=1) total_correct += torch.eq(pred,label).float().sum().item() # eq æ˜¯é€ä¸ªæ¯”è¾ƒæœ€åè¾“å‡ºçŸ©é˜µå¤§å°å’Œlabelçš„å¤§å°æ˜¯ä¸€æ ·çš„ total_num += x.size(0) acc =total_correct / total_num print(&#x27;acc&#x27;,acc) æ¨¡å‹æ¨¡å¼åˆ‡æ¢ å› ä¸ºå¯¹äºæˆ‘ä»¬æ„é€ çš„éƒ¨åˆ†ç½‘ç»œä¸­çš„ç‰¹å®šå±‚ï¼Œè¿™äº›å±‚åœ¨è®­ç»ƒå’Œæµ‹è¯•ä¸­çš„è¡¨ç°æ˜¯ä¸ä¸€æ ·çš„ï¼Œæ¯”å¦‚BatchNormå±‚ä»–åœ¨è®­ç»ƒçŠ¶æ€ä¸‹å’Œæµ‹è¯•çŠ¶æ€ä¸‹çš„è¡Œä¸ºæ˜¯æœ‰ä¸€äº›å·®å¼‚çš„ï¼Œå¦‚æœæˆ‘ä»¬å¯¹ç½‘ç»œä¸­çš„æ¯ä¸€å±‚éƒ½å»æ‰§è¡Œåˆ‡æ¢çŠ¶æ€çš„æ“ä½œæ˜¯éå¸¸éº»çƒ¦çš„ï¼Œä½†æ˜¯nn.Moduleæ”¯æŒå¯¹è‡ªå®šä¹‰ç½‘ç»œæ•´ä½“çŠ¶æ€çš„åˆ‡æ¢ï¼Œå¤§å¤§ç®€åŒ–äº†æ“ä½œã€‚ è¦æƒ³è¾¾åˆ°è¿™ä¸ªç›®çš„ï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ ä¸¤è¡Œä»£ç  12345678910111213141516171819202122232425262728293031323334353637# Train+Val for epoch in range(1000):+ model.train() for batchidx,(x,label) in enumerate(cifar_train): # x: [batchsz,3,32,32] # label: [batchsz] x, label =x.to(device),label.to(device) # å°†æ•°æ®æ”¾åˆ°æ˜¾å¡ä¸Š logits=model(x) loss = criteon(logits,label) # backprop optimizer.zero_grad() # æ¸…é›¶ loss.backward() # åå‘ä¼ æ’­ optimizer.step() # æ›´æ–°ä¸€æ¬¡ # è¾“å‡ºæ¯ä¸€è½®è®­ç»ƒç»“æŸåæœ€åä¸€ä¸ªBatchçš„loss print(epoch,loss.item()) # val+ model.eval() with torch.no_grad(): total_correct=0 total_num=0 for x,label in cifar_test: x,label=x.to(device),label.to(device) # [b, 10] logits = model(x) # [b] pred = logits.argmax(dim=1) total_correct += torch.eq(pred,label).float().sum().item() # eq æ˜¯é€ä¸ªæ¯”è¾ƒæœ€åè¾“å‡ºçŸ©é˜µå¤§å°å’Œlabelçš„å¤§å°æ˜¯ä¸€æ ·çš„ total_num += x.size(0) acc =total_correct / total_num print(&#x27;acc&#x27;,acc) ä»£ç æ±‡æ€» main.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# CIFAR 10import torch import torch.nn as nnfrom torch.utils.data import DataLoaderfrom torchvision import datasetsfrom torchvision import transformsfrom LeNet5 import LeNet5from torch import optimdef main(): batchsz = 32 cifar_train =datasets.CIFAR10(&#x27;cifar_data&#x27;,True, # è¿™ä¸ªTrueä»£è¡¨æ˜¯è®­ç»ƒé›† transform=transforms.Compose([ transforms.Resize([32,32]), transforms.ToTensor() ]), download=True ) cifar_train = DataLoader(cifar_train,batch_size=batchsz,shuffle=True) cifar_test =datasets.CIFAR10(&#x27;cifar_data&#x27;,True, transform=transforms.Compose([ transforms.Resize([32,32]), transforms.ToTensor() ]), download=True ) cifar_test = DataLoader(cifar_test,batch_size=batchsz,shuffle=True) x,label = iter(cifar_train).next() print(&#x27;x:&#x27;,x.shape) # å®šä¹‰GPU device = torch.device(&#x27;cuda&#x27;) # å¯¼å…¥æ¨¡å‹ model = LeNet5().to(device) # å°†æ¨¡å‹æ”¾åˆ°æ˜¾å¡ä¸Š print(model) # è®¾ç½®criteon criteon=nn.CrossEntropyLoss() # è®¾ç½®ä¼˜åŒ–å™¨(ç›®æ ‡ä¼˜åŒ–å‚æ•°ï¼Œå­¦ä¹ ç‡) optimizer=optim.Adam(model.parameters(),lr=1e-3) # Train+Val for epoch in range(1000): model.train() for batchidx,(x,label) in enumerate(cifar_train): # x: [batchsz,3,32,32] # label: [batchsz] x, label =x.to(device),label.to(device) # å°†æ•°æ®æ”¾åˆ°æ˜¾å¡ä¸Š logits=model(x) loss = criteon(logits,label) # backprop optimizer.zero_grad() # æ¸…é›¶ loss.backward() # åå‘ä¼ æ’­ optimizer.step() # æ›´æ–°ä¸€æ¬¡ # è¾“å‡ºæ¯ä¸€è½®è®­ç»ƒç»“æŸåæœ€åä¸€ä¸ªBatchçš„loss print(epoch,loss.item()) # val model.eval() with torch.no_grad(): total_correct=0 total_num=0 for x,label in cifar_test: x,label=x.to(device),label.to(device) # [b, 10] logits = model(x) # [b] pred = logits.argmax(dim=1) total_correct += torch.eq(pred,label).float().sum().item() # eq æ˜¯é€ä¸ªæ¯”è¾ƒæœ€åè¾“å‡ºçŸ©é˜µå¤§å°å’Œlabelçš„å¤§å°æ˜¯ä¸€æ ·çš„ total_num += x.size(0) acc =total_correct / total_num print(&#x27;acc&#x27;,acc) if __name__ == &#x27;__main__&#x27;: main() LeNet5.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import torchfrom torch import nnimport torch.nn.functional as Fclass LeNet5(nn.Module): &#x27;&#x27;&#x27; for CIFAR10 dataset &#x27;&#x27;&#x27; def __init__(self): super(LeNet5,self).__init__() self.conv_unit = nn.Sequential( # input: [batchsz,3,32,32] nn.Conv2d(3,6,kernel_size=5, stride=1, padding=0), nn.AvgPool2d(kernel_size=2,stride=2,padding=0), nn.Conv2d(6,16,kernel_size=5,stride=1,padding=0), nn.AvgPool2d(kernel_size=2,stride=2,padding=0), # ç„¶åä¸‹é¢å°±æ˜¯å·ç§¯å±‚è½¬å…¨è¿æ¥å±‚äº†ï¼Œè¿™é‡Œéœ€è¦ä¸€ä¸ªæ‰“å¹³æ“ä½œ ) # Flatten # fc unit self.fc_unit=nn.Sequential( nn.Linear(16*5*5,120), nn.ReLU(inplace=True), nn.Linear(120,84), nn.ReLU(inplace=True), nn.Linear(84,10) ) # ä»¥ä¸‹æ˜¯æµ‹è¯•ç”¨çš„ä»£ç ï¼Œç”¨æ¥æµ‹è¯•å·ç§¯ç¥ç»ç½‘ç»œæœ€åè¾“å‡ºçš„å›¾ç‰‡å¤§å°æ˜¯å¤šå°‘ # [batchsz,3,32,32] tmp = torch.randn(2,3,32,32) out = self.conv_unit(tmp) # æµ‹è¯•è¾“å‡º:[batchsz,16,5,5] print(&#x27;conv out&#x27;,out.shape) def forward(self,x): &#x27;&#x27;&#x27; :param input : [batchsz,3,32,32] :return logits &#x27;&#x27;&#x27; batchsz = x.size(0) # [batchsz,3,32,32] =&gt; [batchsz,16,5,5] x = self.conv_unit(x) x = x.view(batchsz,16*5*5) #view(batchsz,-1) # [batchsz,16*5*5] =&gt; [b,10] logits = self.fc_unit(x) return logitsdef main(): net = LeNet5() #æµ‹è¯•ç½‘ç»œç»“æ„ï¼ˆç½‘ç»œèƒ½å¦è·‘é€šï¼‰ tmp = torch.randn(2,3,32,32) out = net(tmp) print(&#x27;LeNet out&#x27;,out.shape)if __name__ == &#x27;__main__&#x27;: main() ç¬¬äºŒç§æ–¹æ³•å†™çš„LeNet5 LeNet5pro.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import torchfrom torch import nnimport torch.nn.functional as Fclass Flatten(nn.Module): def __init__(self): super(Flatten,self).__init__() def forward(self,input): return input.view(input.size(0),-1)class LeNet5(nn.Module): &#x27;&#x27;&#x27; for CIFAR10 dataset &#x27;&#x27;&#x27; def __init__(self): super(LeNet5,self).__init__() self.nn_unit = nn.Sequential( # input: [batchsz,3,32,32] nn.Conv2d(3,6,kernel_size=5, stride=1, padding=0), nn.AvgPool2d(kernel_size=2,stride=2,padding=0), nn.Conv2d(6,16,kernel_size=5,stride=1,padding=0), nn.AvgPool2d(kernel_size=2,stride=2,padding=0), # Flatten Flatten(), # fc unit nn.Linear(16*5*5,120), nn.ReLU(inplace=True), nn.Linear(120,84), nn.ReLU(inplace=True), nn.Linear(84,10) # ç„¶åä¸‹é¢å°±æ˜¯å·ç§¯å±‚è½¬å…¨è¿æ¥å±‚äº†ï¼Œè¿™é‡Œéœ€è¦ä¸€ä¸ªæ‰“å¹³æ“ä½œ ) # ä»¥ä¸‹æ˜¯æµ‹è¯•ç”¨çš„ä»£ç ï¼Œç”¨æ¥æµ‹è¯•å·ç§¯ç¥ç»ç½‘ç»œæœ€åè¾“å‡ºçš„å›¾ç‰‡å¤§å°æ˜¯å¤šå°‘ # [batchsz,3,32,32] tmp = torch.randn(2,3,32,32) out = self.nn_unit(tmp) # æµ‹è¯•è¾“å‡º:[batchsz,16,5,5] print(&#x27;nn out&#x27;,out.shape) def forward(self,x): &#x27;&#x27;&#x27; :param input : [batchsz,3,32,32] :return logits &#x27;&#x27;&#x27; # [batchsz,3,32,32] =&gt; [batchsz,16,5,5] logits = self.nn_unit(x) return logitsdef main(): net = LeNet5() #æµ‹è¯•ç½‘ç»œç»“æ„ï¼ˆç½‘ç»œèƒ½å¦è·‘é€šï¼‰ tmp = torch.randn(2,3,32,32) out = net(tmp) print(&#x27;LeNet out&#x27;,out.shape)if __name__ == &#x27;__main__&#x27;: main() å®ç°ResNet æœ¬æ¬¡å®éªŒä»¥ResNet18ä¸ºä¾‹ï¼Œä½†æ˜¯å’Œè®ºæ–‡ä¸­çš„ResNet18è¿˜æ˜¯æœ‰äº›è®¸å·®å¼‚çš„ ï¼Œå› ä¸ºé‡‡ç”¨çš„æ•°æ®é›†ä¸å¤ªä¸€æ ·ã€‚ å®ç°æ®‹å·®å— æœ¬æ¬¡æ®‹å·®å—çš„å®ç°å’Œä¹‹å‰çš„æœ‰ä¸€äº›åŒºåˆ«ï¼ŒåŠ å…¥äº†æ­¥é•¿ï¼Œè¿™æ ·å°±èƒ½åœ¨æé«˜æ·±åº¦çš„åŒæ—¶ç¼©å°å›¾ç‰‡ï¼Œå…·ä½“ä»£ç å¦‚ä¸‹ã€‚ éœ€è¦æ³¨æ„çš„ç‚¹æ˜¯ï¼Œå¦‚æœè¾“å…¥é€šé“å’Œè¾“å‡ºé€šé“æ•°é‡ä¸ä¸€æ ·ï¼Œshortcutçš„è·¯å¾„ä¸Šå¯èƒ½è¿˜æ˜¯è¦å†åŠ ä¸€å±‚å·ç§¯å±‚ï¼Œæ¥ä½¿é€šé“æ•°é‡ä¸€æ ·ï¼Œè¿™æ ·æ‰èƒ½ç›¸åŠ ã€‚ 123456789101112131415161718192021222324252627282930313233343536class ResBlk(nn.Module): &#x27;&#x27;&#x27; ResNet Block &#x27;&#x27;&#x27; def __init__(self,ch_in,ch_out,stride=1): &#x27;&#x27;&#x27; :param ch_in :param ch_out &#x27;&#x27;&#x27; super(ResBlk,self).__init__() self.conv1 = nn.Conv2d(ch_in,ch_out,kernel_size=3,stride=stride,padding=1) self.bn1 = nn.BatchNorm2d(ch_out) self.conv2 = nn.Conv2d(ch_out,ch_out,kernel_size=3,stride=1,padding=1) self.bn2 = nn.BatchNorm2d(ch_out) self.extra = nn.Sequential() if ch_out!= ch_in: self.extra=nn.Sequential( nn.Conv2d(ch_in,ch_out,kernel_size=1,stride=stride), nn.BatchNorm2d(ch_out) ) def forward(self,x): &#x27;&#x27;&#x27; :param x: [batchsz,ch,h,w] :return: &#x27;&#x27;&#x27; out = F.relu(self.bn1(self.conv1(x))) out = self.bn2(self.conv2(out)) # short_cut ### è¿™é‡Œä¸€å®šè¦å†™extraï¼ï¼ï¼ # extra module : [batchsz,ch_in,h,w] =&gt; [batchsz,ch_out,h,w] # element-wise add: out = self.extra(x) + out return out å®ç°ResNet18ç½‘ç»œç»“æ„ ä»£ç åŸç†å’Œå®ç°LeNet-5ä¸€æ ·ï¼Œè¿™é‡Œä¸å†èµ˜è¿° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class ResNet18(nn.Module): def __init__(self): super(ResNet18, self).__init__() #ä»¥ä¸‹conv1ä¸ºé¢„å¤„ç†å±‚ self.conv1 = nn.Sequential( nn.Conv2d(3,64,kernel_size=3,stride=3,padding=0), nn.BatchNorm2d(64) ) # followed 4 blocks # [batchsz,64,h,w] =&gt; [batchsz,128,h,w] self.blk1=ResBlk(64,128,stride=2) # [batchsz,128,h,w] =&gt; [batchsz,256,h,w] self.blk2=ResBlk(128,256,stride=2) # [batchsz,256,h,w] =&gt; [batchsz,512,h,w] self.blk3=ResBlk(256,512,stride=2) # [batchsz,512,h,w] =&gt; [batchsz,512,h,w] self.blk4=ResBlk(512,512,stride=2) self.outlayer = nn.Linear(512, 10) def forward(self,x): &#x27;&#x27;&#x27; :param x: :return: &#x27;&#x27;&#x27; x = F.relu(self.conv1(x)) # [batchsz,64,h,w] =&gt; [batchsz,512,h,w] x = self.blk1(x) x = self.blk2(x) x = self.blk3(x) x = self.blk4(x) # æµ‹è¯•ä»£ç  # print(&#x27;after convolution&#x27;,x.shape) # [batchsz,512,2,2] # [batchsz,512,h,w] =&gt; [batchsz,512,1,1] x =F.adaptive_max_pool2d(x,[1,1]) # æµ‹è¯•ä»£ç  # print(&#x27;after pool:&#x27;, x.shape) # Flatten x=x.view(x.size(0),-1) # Linear x = self.outlayer(x) return x æ³¨æ„ï¼šä¸­é—´è¿˜æ˜¯æœ‰ä¸€ä¸ªFlattenæ“ä½œ å¯ä»¥ä½¿ç”¨ä¸Šè¿°ä»£ç ä¸­è¢«æ³¨é‡Šæ‰çš„`#æµ‹è¯•ä»£ç `éƒ¨åˆ†æ‰“å‡ºä¸­é—´å±‚tensorçš„å½¢çŠ¶ï¼Œè¿™æ ·æœ‰åŠ©äºæŒæ¡ç½‘ç»œçš„å½¢çŠ¶ã€‚ åç»­ä»£ç  è®­ç»ƒéƒ¨åˆ†å’ŒValéªŒè¯å’Œä¸Šé¢çš„LeNet-5å®ç°ä»£ç å®Œå…¨ä¸€æ ·ï¼Œæˆ‘ä»¬åªéœ€è¦æŠŠloadçš„æ¨¡å‹æ›´æ”¹ä¸€ä¸‹å³å¯ã€‚é¦–å…ˆå¯¼å…¥ResNet 1from ResNet import ResNet18 ç„¶åå¯¼å…¥æ¨¡å‹çš„åœ°æ–¹ç¨ä½œä¿®æ”¹å°±OKäº†ï¼š 1234# å¯¼å…¥æ¨¡å‹# model = LeNet5().to(device) # å°†æ¨¡å‹æ”¾åˆ°æ˜¾å¡ä¸Šmodel = ResNet18().to(device) # å°†æ¨¡å‹æ”¾åˆ°æ˜¾å¡ä¸Šprint(model) ä»£ç ä¼˜åŒ– å½’ä¸€åŒ–&amp;æ•°æ®å¢å¼º æ•°æ®é¢„å¤„ç†æ—¶åŠ å…¥å½’ä¸€åŒ–Normalizeæå‡æ¨¡å‹æ€§èƒ½ å½“ç„¶ä¹Ÿå¯ä»¥åœ¨æ•°æ®å¤„ç†éƒ¨åˆ†åŠ å…¥æ•°æ®å¢å¼ºæ¥ç¨å¾®æé«˜æ¨¡å‹æ€§èƒ½ 12345678910111213141516171819cifar_train =datasets.CIFAR10(&#x27;cifar_data&#x27;,True, # è¿™ä¸ªTrueä»£è¡¨æ˜¯è®­ç»ƒé›† transform=transforms.Compose([ transforms.Resize([32,32]), transforms.ToTensor(), transforms.Normalize(mean=[0.485,0.456,0.406],std=[0.229,0.224,0.225]) ]), download=True )cifar_train = DataLoader(cifar_train,batch_size=batchsz,shuffle=True)cifar_test =datasets.CIFAR10(&#x27;cifar_data&#x27;,True, transform=transforms.Compose([ transforms.Resize([32,32]), transforms.ToTensor(), transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]) ]), download=True ) ä»£ç æ±‡æ€» main.py åŒä¸Šä¸€ä¸ªæ±‡æ€»çš„mainï¼ŒæŒ‰ç…§ä¸Šé¢çš„æŒ‡ç¤ºæ”¹ä¸€ç‚¹å°±è¡Œã€‚ ResNet.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import torchfrom torch import nnimport torch.nn.functional as Fclass ResBlk(nn.Module): &#x27;&#x27;&#x27; ResNet Block &#x27;&#x27;&#x27; def __init__(self,ch_in,ch_out,stride=1): &#x27;&#x27;&#x27; :param ch_in :param ch_out &#x27;&#x27;&#x27; super(ResBlk,self).__init__() self.conv1 = nn.Conv2d(ch_in,ch_out,kernel_size=3,stride=stride,padding=1) self.bn1 = nn.BatchNorm2d(ch_out) self.conv2 = nn.Conv2d(ch_out,ch_out,kernel_size=3,stride=1,padding=1) self.bn2 = nn.BatchNorm2d(ch_out) self.extra = nn.Sequential() if ch_out!= ch_in: self.extra=nn.Sequential( nn.Conv2d(ch_in,ch_out,kernel_size=1,stride=stride), nn.BatchNorm2d(ch_out) ) def forward(self,x): &#x27;&#x27;&#x27; :param x: [batchsz,ch,h,w] :return: &#x27;&#x27;&#x27; out = F.relu(self.bn1(self.conv1(x))) out = self.bn2(self.conv2(out)) # short_cut ### è¿™é‡Œä¸€å®šè¦å†™extraï¼ï¼ï¼ # extra module : [batchsz,ch_in,h,w] =&gt; [batchsz,ch_out,h,w] # element-wise add: out = self.extra(x) + out return outclass ResNet18(nn.Module): def __init__(self): super(ResNet18, self).__init__() #ä»¥ä¸‹conv1ä¸ºé¢„å¤„ç†å±‚ self.conv1 = nn.Sequential( nn.Conv2d(3,64,kernel_size=3,stride=3,padding=0), nn.BatchNorm2d(64) ) # followed 4 blocks # [batchsz,64,h,w] =&gt; [batchsz,128,h,w] self.blk1=ResBlk(64,128,stride=2) # [batchsz,128,h,w] =&gt; [batchsz,256,h,w] self.blk2=ResBlk(128,256,stride=2) # [batchsz,256,h,w] =&gt; [batchsz,512,h,w] self.blk3=ResBlk(256,512,stride=2) # [batchsz,512,h,w] =&gt; [batchsz,512,h,w] self.blk4=ResBlk(512,512,stride=2) self.outlayer = nn.Linear(512, 10) def forward(self,x): &#x27;&#x27;&#x27; :param x: :return: &#x27;&#x27;&#x27; x = F.relu(self.conv1(x)) # [batchsz,64,h,w] =&gt; [batchsz,512,h,w] x = self.blk1(x) x = self.blk2(x) x = self.blk3(x) x = self.blk4(x) # æµ‹è¯•ä»£ç  # print(&#x27;after convolution&#x27;,x.shape) # [batchsz,512,2,2] # [batchsz,512,h,w] =&gt; [batchsz,512,1,1] x =F.adaptive_max_pool2d(x,[1,1]) # æµ‹è¯•ä»£ç  # print(&#x27;after pool:&#x27;, x.shape) # Flatten x=x.view(x.size(0),-1) # Linear x = self.outlayer(x) return xdef main(): # ä»¥ä¸‹ä¸ºæµ‹è¯•ä»£ç  tmp = torch.randn(2,3,32,32) model=ResNet18() blk=ResBlk(3,128,stride=4) out = blk(tmp) out = model(tmp) print(out.shape)if __name__==&#x27;__main__&#x27;: main()"},{"title":"PyTorch CNN","path":"/wiki/PyTorch/PyTorch CNN.html","content":"å·ç§¯ç¥ç»ç½‘ç»œç»“æ„ä»‹ç» å¦‚æœç”¨å…¨è¿æ¥ç¥ç»ç½‘ç»œå¤„ç†å¤§å°ºå¯¸å›¾åƒå…·æœ‰ä¸‰ä¸ªæ˜æ˜¾çš„ç¼ºç‚¹ï¼š ï¼ˆ1ï¼‰é¦–å…ˆå°†å›¾åƒå±•å¼€ä¸ºå‘é‡ä¼šä¸¢å¤±ç©ºé—´ä¿¡æ¯ï¼› ï¼ˆ2ï¼‰å…¶æ¬¡å‚æ•°è¿‡å¤šæ•ˆç‡ä½ä¸‹ï¼Œè®­ç»ƒå›°éš¾ï¼› ï¼ˆ3ï¼‰åŒæ—¶å¤§é‡çš„å‚æ•°ä¹Ÿå¾ˆå¿«ä¼šå¯¼è‡´ç½‘ç»œè¿‡æ‹Ÿåˆã€‚ è€Œä½¿ç”¨å·ç§¯ç¥ç»ç½‘ç»œå¯ä»¥å¾ˆå¥½åœ°è§£å†³ä¸Šé¢çš„ä¸‰ä¸ªé—®é¢˜ã€‚ å·ç§¯ç¥ç»ç½‘ç»œçš„æå‡ºå‚è€ƒäº†äººçœ¼çš„å±€éƒ¨ç›¸å…³æ€§ï¼Œäººçœ¼ç”¨äºè¯†åˆ«ç‰©ä½“ä¹Ÿæ˜¯å…ˆçœ‹ä¸€ä¸ªå±€éƒ¨ï¼Œæ ¹æ®ä¸€äº›ç‰¹ç§°æ‰èƒ½è¾¨åˆ«è¿™ä¸ªç‰©ä½“æ˜¯ä»€ä¹ˆï¼Œç‰¹å¾çš„è¯†åˆ«å’Œåƒç´ ç‚¹çš„æ’åˆ—ä½ç½®å’Œæƒ…å†µæœ‰å…³ã€‚ æ ¹æ®å±€éƒ¨ç›¸å…³æ€§æå‡ºçš„å·ç§¯ç¥ç»ç½‘ç»œç»“æ„ å·ç§¯è¿ç®— é¦–å…ˆæˆ‘ä»¬ä½¿ç”¨å‡ å¼ å›¾æ¥ç›´è§‚æ„Ÿå—ä¸€ä¸‹å·ç§¯æ˜¯å¦‚ä½•è¿ç®—çš„ æœ€å·¦è¾¹çš„é‚£ä¸ªå«åšå·ç§¯æ ¸ æ›´å¤šæ›´è¯¦ç»†å…³äºå·ç§¯ç¥ç»ç½‘ç»œçš„åŸºç¡€çŸ¥è¯†å¯ä»¥è®¿é—®å¦‚ä¸‹è¿™ç¯‡åšå®¢ï¼šæ·±åº¦å­¦ä¹ ï¼šå·ç§¯ç¥ç»ç½‘ç»œï¼ˆCNN å¸¸ç”¨å·ç§¯æ ¸ æ¦‚å¿µè§£æ è¾“å…¥é€šé“ï¼ˆInput_channelsï¼‰:è¾“å…¥æœ‰å¤šå°‘ä¸ªé€šé“ï¼ˆå¤šå°‘å±‚è¾“å…¥ï¼‰ï¼Œæ¯”å¦‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯é»‘ç™½ç…§ç‰‡ï¼Œé‚£ä¹ˆå°±åªæœ‰ä¸€ä¸ªé€šé“ï¼›å¦‚æœæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯rgbå½©è‰²ç…§ç‰‡é‚£ä¹ˆå°±æœ‰ä¸‰ä¸ªé€šé“ã€‚ **æ ¸é€šé“ï¼ˆKernel_channelsï¼‰:**å·ç§¯æ ¸æœ‰å¤šå°‘ä¸ªé€šé“æ•°é‡ã€‚ æ ¸å¤§å°ï¼ˆKernel_sizeï¼‰:å·ç§¯æ ¸çš„å¤§å°ï¼Œä¸€èˆ¬æ˜¯3Ã—3 æ­¥é•¿ï¼ˆStrideï¼‰:æ¯æ¬¡å·ç§¯æ ¸ç§»åŠ¨çš„æ­¥é•¿ï¼Œä¸€èˆ¬é»˜è®¤æ˜¯1 å¡«å……ï¼ˆPaddingï¼‰:ä¸ºäº†ä¿è¯å·ç§¯è¿ç®—æ¯æ¬¡å·ç§¯å®Œæˆä»¥åè¾“å…¥è¾“å‡ºå›¾ç‰‡å¤§å°ç›¸åŒï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦åœ¨å›¾ç‰‡å‘¨å›´å¡«å……ä¸€åœˆ0ã€‚ å¯¹äºæ¯ä¸€ä¸ªå·ç§¯æ ¸ï¼Œå…¶æ‰€åŒ…å«çš„é€šé“æ•°å¿…é¡»å’Œè¾“å…¥çš„å·ç§¯å±‚çš„é€šé“æ•°ä¸€æ ·ï¼æ‰€ä»¥ä¸Šé¢æ ¸é€šé“æœ‰ä¸¤ç§å«ä¹‰ï¼Œä¸€ç§æ˜¯æŒ‡æ¯ä¸€ä¸ªå·ç§¯æ ¸ä¸­æ‰€å«çš„é€šé“æ•°ï¼Œè¿˜æœ‰ä¸€ç§å«ä¹‰æ˜¯æŒ‡æœ‰å¤šå°‘ä¸ªå·ç§¯æ ¸ã€‚ä½†æ˜¯ä¸€èˆ¬æƒ…å†µä¸‹éƒ½æ˜¯æŒ‡åè€…ã€‚ å› æ­¤å¯¹äºbä¸ª28Ã—28ï¼Œ3é€šé“çš„è¾“å…¥x: [b,3,28,28]å¦‚æœæˆ‘ä»¬é‡‡ç”¨16ä¸ª3*3çš„å·ç§¯æ ¸ï¼Œåˆ™å¯¹äºä¸€ä¸ªå·ç§¯æ ¸ä»–çš„sizeæ˜¯one-k: [3,3,3],å¯¹äº16ä¸ªkçš„æ€»sizeæ˜¯multi-k: [16,3,3,3],å› ä¸ºæœ‰16ä¸ªå·ç§¯æ ¸æ‰€ä»¥åç½®ä¹Ÿæœ‰16ä¸ªbias: [16](è¿™é‡Œè¿ç”¨äº†å¹¿æ’­)ã€‚æœ€ç»ˆçš„è¾“å‡ºæ˜¯out: [b,16,28,28]ï¼ˆè€ƒè™‘äº†paddingï¼‰ PyTorchå®ç° äº†è§£äº†åŸºæœ¬çš„å·ç§¯ç¥ç»ç½‘ç»œåï¼Œä¸‹é¢æˆ‘ä»¬å°è¯•ä½¿ç”¨PyTorchç®€å•çš„å®ç°ä¸€ä¸ªç®€å•çš„äºŒç»´å·ç§¯ç¥ç»ç½‘ç»œï¼Œæ‰€ä½¿ç”¨çš„å‡½æ•°æ˜¯nn.Conv2då…¶ä¸­ç¬¬ä¸€ä¸ªå‚æ•°è¡¨ç¤ºçš„æ˜¯è¾“å…¥çš„é€šé“æ•°ï¼Œåé¢çš„å‚æ•°è¡¨ç¤ºçš„æ˜¯è¾“å‡ºçš„é€šé“æ•°ã€‚ 123456789101112131415161718In [3]: import torch.nn as nnIn [4]: layer=nn.Conv2d(1,3,kernel_size=3,stride=1,padding=0)In [5]: x=torch.rand(123,1,28,28)In [6]: out=layer.forward(x)In [7]: out.shapeOut[7]: torch.Size([123, 3, 26, 26])In [8]: layer=nn.Conv2d(1,12,kernel_size=3,stride=1,padding=1)In [9]: out=layer.forward(x)In [10]: out.shapeOut[10]: torch.Size([123, 12, 28, 28])In [11]: layer=nn.Conv2d(1,12,kernel_size=3,stride=2,padding=1)In [12]: out=layer.forward(x)In [13]: out.shapeOut[13]: torch.Size([123, 12, 14, 14])In [14]: out=layer(x) # å¼ºçƒˆæ¨èè¿™ä¸€ç§ä¸ä½¿ç”¨forwardçš„æ–¹æ³•In [15]: out.shapeOut[15]: torch.Size([123, 12, 14, 14]) æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸‹é¢çš„ä»£ç æ¥çœ‹çœ‹æœ€åä¸€æ¬¡è¿™ä¸ªlayerä¸­å­˜æ”¾äº†ä»€ä¹ˆæ ·çš„weightå’Œbias(æ¥ä¸Šé¢çš„ä»£ç ) 1234567891011121314151617181920212223242526272829303132333435363738394041424344In [16]: layer.weightOut[16]: Parameter containing:tensor([[[[-0.2432, -0.2371, 0.2480], [-0.2706, -0.2552, -0.0627], [ 0.1960, -0.3049, -0.0273]]], [[[-0.3008, 0.1268, 0.0518], [ 0.0673, 0.2716, -0.1481], [ 0.1075, -0.2905, 0.1106]]], [[[ 0.1498, -0.0681, -0.1162], [ 0.3015, 0.1400, 0.0372], [-0.1401, 0.1158, -0.0872]]], [[[ 0.1543, -0.0323, -0.2023], [ 0.2972, -0.0344, 0.3114], [ 0.2141, -0.0388, -0.0352]]], [[[ 0.1029, 0.0184, -0.2372], [ 0.2758, -0.1239, 0.2429], [-0.0263, -0.2977, -0.2075]]], [[[ 0.2166, -0.1031, -0.2122], [ 0.2123, -0.1492, -0.0831], [-0.0155, -0.0572, -0.2485]]], [[[-0.0441, -0.3298, 0.2896], [ 0.1438, 0.1364, -0.2721], [ 0.0076, 0.0919, -0.1219]]], [[[ 0.3241, 0.1343, 0.0140], [ 0.2732, -0.1690, -0.3122], [ 0.2933, 0.0007, 0.1548]]], [[[ 0.2695, 0.3256, 0.0424], [-0.2905, -0.1272, -0.1482], [-0.1993, 0.1244, 0.1924]]], [[[ 0.1136, -0.0931, -0.2240], [-0.0278, -0.1714, -0.0614], [-0.0067, -0.1385, -0.2265]]], [[[ 0.3065, 0.1684, -0.0113], [-0.0534, 0.0034, 0.0194], [-0.1013, 0.0573, -0.2356]]], [[[-0.1154, -0.0406, 0.0382], [-0.3318, -0.2613, 0.0636], [-0.2066, 0.3052, -0.2338]]]], requires_grad=True)In [17]: layer.weight.shapeOut[17]: torch.Size([12, 1, 3, 3])In [18]: layer.bias.shapeOut[18]: torch.Size([12]) ä»¥ä¸Šæ˜¯ç±»APIçš„å†™æ³•ï¼ŒPyTorchä¹Ÿæä¾›å‡½æ•°APIï¼Œå…·ä½“ä»£ç å¦‚ä¸‹ï¼š 1234567891011In [3]: import torch.nn.functional as FIn [4]: w=torch.rand(16,3,5,5,requires_grad=True)In [5]: b=torch.rand(16,requires_grad=True)In [6]: x=torch.rand(321,3,28,28)In [7]: out=F.conv2d(x,w,b,stride=1,padding=1)In [8]: out.shapeOut[8]: torch.Size([321, 16, 26, 26])In [9]: out=F.conv2d(x,w,b,stride=2,padding=2)In [10]: out.shapeOut[10]: torch.Size([321, 16, 14, 14]) æ± åŒ–å±‚ä¸é‡‡æ · ä¸‹é‡‡æ ·ï¼ˆDownsampleï¼‰ å°±æ˜¯å°†ä¸‹é¢çš„è¿™ä¸ªå¤§çŸ©é˜µå˜æˆä¸Šé¢çš„é‚£ä¸ªå°çŸ©é˜µï¼Œå…¶å®ä¸‹é‡‡æ ·å’Œæ˜¯ç¼©å°å›¾ç‰‡æœ‰ç‚¹åƒ Max Pooling Max Poolingå’Œä¸‹é‡‡æ ·ç±»ä¼¼ï¼Œä½†æ˜¯æ˜¯æ¯æ¬¡è§‚å¯Ÿä¸€ä¸ªåŒºåŸŸåå–è¯¥åŒºåŸŸå€¼æœ€å¤§çš„å€¼ä¸ºè¯¥åŒºåŸŸçš„é‡‡æ ·å€¼ ç±»ä¼¼çš„è¿˜æœ‰AvgPooling PyTorch å®ç° PyTorchåŒæ ·æä¾›ä¸¤ç§ç±»å‹çš„APIï¼Œè¿™é‡Œæ‰€ä½¿ç”¨çš„å‡½æ•°æ˜¯nn.MaxPool2då’Œnn.AvgPool2då’Œavg_pool2då’Œmax_pool2d 123456789101112131415161718In [3]: import torch.nn as nnIn [4]: x=torch.rand(123,16,14,14)In [5]: layer=nn.MaxPool2d(2,stride=2)In [6]: out=layer(x)In [7]: out.shapeOut[7]: torch.Size([123, 16, 7, 7])In [8]: layer=nn.AvgPool2d(2,stride=2)In [9]: out=layer(x)In [10]: out.shapeOut[10]: torch.Size([123, 16, 7, 7])In [11]: import torch.nn.functional as FIn [12]: out=F.max_pool2d(x,2,stride=2)In [13]: out.shapeOut[13]: torch.Size([123, 16, 7, 7])In [14]: out=F.avg_pool2d(x,2,stride=2)In [15]: out.shapeOut[15]: torch.Size([123, 16, 7, 7]) ä¸Šé‡‡æ ·ï¼ˆUpsampleï¼‰ å°±æ˜¯å°†ä¸Šé¢çš„è¿™ä¸ªå°çŸ©é˜µå˜æˆä¸‹é¢çš„é‚£ä¸ªå¤§çŸ©é˜µï¼Œç›¸å½“äºå›¾ç‰‡çš„æ”¾å¤§ï¼Œå’Œä¸‹é‡‡æ ·æ­£å¥½ç›¸å PyTorch å®ç° ä¸Šé‡‡æ ·æ‰€ä½¿ç”¨çš„å‡½æ•°æ˜¯interpolateå‡½æ•° 123456789101112131415161718192021222324252627282930313233In [3]: import torch.nn.functional as FIn [4]: x=torch.rand(1,1,3,3)In [5]: xOut[5]: tensor([[[[0.0565, 0.2834, 0.3705], [0.4337, 0.8775, 0.8109], [0.8081, 0.8048, 0.3552]]]])In [6]: out=F.interpolate(x,scale_factor=2,mode=&#x27;nearest&#x27;)In [7]: outOut[7]: tensor([[[[0.0565, 0.0565, 0.2834, 0.2834, 0.3705, 0.3705], [0.0565, 0.0565, 0.2834, 0.2834, 0.3705, 0.3705], [0.4337, 0.4337, 0.8775, 0.8775, 0.8109, 0.8109], [0.4337, 0.4337, 0.8775, 0.8775, 0.8109, 0.8109], [0.8081, 0.8081, 0.8048, 0.8048, 0.3552, 0.3552], [0.8081, 0.8081, 0.8048, 0.8048, 0.3552, 0.3552]]]])In [8]: out.shapeOut[8]: torch.Size([1, 1, 6, 6])In [9]: out=F.interpolate(x,scale_factor=3,mode=&#x27;nearest&#x27;)In [10]: outOut[10]: tensor([[[[0.0565, 0.0565, 0.0565, 0.2834, 0.2834, 0.2834, 0.3705, 0.3705, 0.3705], [0.0565, 0.0565, 0.0565, 0.2834, 0.2834, 0.2834, 0.3705, 0.3705, 0.3705], [0.0565, 0.0565, 0.0565, 0.2834, 0.2834, 0.2834, 0.3705, 0.3705, 0.3705], [0.4337, 0.4337, 0.4337, 0.8775, 0.8775, 0.8775, 0.8109, 0.8109, 0.8109], [0.4337, 0.4337, 0.4337, 0.8775, 0.8775, 0.8775, 0.8109, 0.8109, 0.8109], [0.4337, 0.4337, 0.4337, 0.8775, 0.8775, 0.8775, 0.8109, 0.8109, 0.8109], [0.8081, 0.8081, 0.8081, 0.8048, 0.8048, 0.8048, 0.3552, 0.3552, 0.3552], [0.8081, 0.8081, 0.8081, 0.8048, 0.8048, 0.8048, 0.3552, 0.3552, 0.3552], [0.8081, 0.8081, 0.8081, 0.8048, 0.8048, 0.8048, 0.3552, 0.3552, 0.3552]]]])In [11]: out.shapeOut[11]: torch.Size([1, 1, 9, 9]) ReLU å·ç§¯ç¥ç»ç½‘ç»œçš„ReLUå‡½æ•°å’Œä¹‹å‰å…¨è¿æ¥ç¥ç»ç½‘ç»œæ‰€è¯´çš„ReLUå‡½æ•°ä¸€æ ·ï¼Œåœ¨è¿™é‡Œæ˜¯è¢«ç”¨äºå»é™¤å“åº”è¿‡å°çš„ç‚¹ã€‚ PyTorchå®ç° å’ŒåŸæ¥å…¨è¿æ¥ç¥ç»ç½‘ç»œä½¿ç”¨çš„å‡½æ•°ä¸€æ¨¡ä¸€æ · 1234567891011In [3]: import torch.nn as nnIn [4]: import torch.nn.functional as FIn [5]: x=torch.rand(1,16,7,7)In [6]: layer=nn.ReLU(inplace=True)In [7]: out=layer(x)In [8]: out.shapeOut[8]: torch.Size([1, 16, 7, 7])In [9]: out=F.relu(x)In [10]: out.shapeOut[10]: torch.Size([1, 16, 7, 7]) Batch-Normï¼ˆå½’ä¸€åŒ–ï¼‰ normå…¶å®å½’ä¸€åŒ–å°±æ˜¯ç‰¹å¾ç¼©æ”¾ï¼ˆfeature scalingï¼‰ï¼Œä¸€èˆ¬æƒ…å†µæˆ‘ä»¬å°†ç‰¹å¾ç¼©æ”¾æˆä»¥0ä¸ºå‡å€¼1ä¸ºæ–¹å·®çš„æƒ…å†µã€‚ Batch normåœ¨å·ç§¯ç¥ç»ç½‘ç»œä¸­æ˜¯æŒ‡ï¼Œå¯¹æ‰€æœ‰æ ·æœ¬çš„ç›¸åŒå±‚è¿›è¡Œå½’ä¸€åŒ–å¤„ç†ã€‚ Î³,Î²\\gamma,\\betaÎ³,Î²æ˜¯è¦å‚ä¸åå‘ä¼ æ’­çš„ï¼ŒÎ¼,Î±\\mu,\\alphaÎ¼,Î±æ˜¯ä¸å‚ä¸åå‘ä¼ æ’­çš„ï¼Œæ˜¯è¿è¡Œä¸­ç»Ÿè®¡å‡ºæ¥çš„æ•°æ®ã€‚å½“å‰Î¼,Î±\\mu,\\alphaÎ¼,Î±çš„è®¡ç®—ä¹Ÿå’Œä¸Šä¸€æ¬¡Î¼,Î±\\mu,\\alphaÎ¼,Î±çš„å€¼æœ‰å…³ï¼ˆæŒ‡æ•°åŠ æƒå¹³å‡ï¼‰ PyTorch å®ç° ä¸‹é¢å®ç°ä¸€ä¸ªå…¨è¿æ¥å±‚çš„Batchnormï¼Œæ‰€ä½¿ç”¨çš„å‡½æ•°æ˜¯torch.nn.BatchNorm1d,è¾“å…¥å‚æ•°è¡¨ç¤ºæœ‰å¤šå°‘ä¸ªç‰¹å¾ï¼Œåœ¨ä¸‹é¢çš„ä¾‹å­ä¸­æ˜¯æœ‰16ä¸ªç‰¹å¾ 1234567891011121314In [3]: x=torch.rand(100,16)+0.5In [4]: layer=torch.nn.BatchNorm1d(16)In [5]: layer.running_mean,layer.running_varOut[5]: (tensor([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]), tensor([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]))In [6]: out=layer(x)In [7]: layer.running_mean,layer.running_varOut[7]: (tensor([0.0961, 0.0963, 0.1018, 0.1019, 0.1005, 0.1021, 0.1000, 0.1006, 0.0965, 0.1005, 0.1054, 0.0996, 0.0940, 0.1024, 0.0938, 0.1022]), tensor([0.9089, 0.9086, 0.9073, 0.9105, 0.9075, 0.9087, 0.9068, 0.9079, 0.9096, 0.9084, 0.9087, 0.9086, 0.9073, 0.9090, 0.9072, 0.9097])) running_mean,running_varç»Ÿè®¡çš„æ˜¯å½“å‰è¾“å…¥çš„æ•°æ®çš„å‡å€¼å’Œæ–¹å·®çš„ å¯ä»¥å‘ç°running_meanä¸€å¼€å§‹å¹¶æ²¡æœ‰ç›´æ¥åˆ°çœŸå®æ•°æ®çš„å‡å€¼ï¼Œè¿™å°±æ˜¯å› ä¸ºæ¯ä¸€æ¬¡è®¡ç®—çš„å‡å€¼å’Œå‰ä¸€æ¬¡çš„å‡å€¼æ˜¯æœ‰å…³ç³»çš„ç¼˜æ•…ã€‚æ‰€ä»¥å½“æˆ‘ä»¬è¿™æ ·è®¡ç®—å¤šæ¬¡årunning_meanæ‰ä¼šé€æ¸æ¥è¿‘çœŸå®çš„å‡å€¼ï¼ˆè§ä¸‹é¢çš„ä»£ç ï¼‰ 123456789101112In [3]: x=torch.randn(100,16)+0.5In [4]: layer=torch.nn.BatchNorm1d(16) In [5]: for i in range(100): out=layer(x)In [6]: layer.running_meanOut[6]: tensor([0.5601, 0.4520, 0.2556, 0.4875, 0.4371, 0.3810, 0.4296, 0.4426, 0.5163, 0.5468, 0.4442, 0.3907, 0.4959, 0.5350, 0.5775, 0.3721])In [7]: layer.running_varOut[7]: tensor([0.8751, 0.9497, 0.8256, 0.9304, 0.9371, 0.8656, 0.8312, 0.9728, 0.9176, 0.9641, 1.2020, 0.8723, 1.3406, 0.8414, 0.9326, 0.9007]) ä¸‹é¢æˆ‘ä»¬è¿›ä¸€æ­¥æ¥çœ‹çœ‹BatchNormå¯¹äº2dçš„æ•°æ®æ˜¯å¦‚ä½•è¿›è¡Œæ“ä½œçš„ï¼Œè¿™é‡Œæ‰€ä½¿ç”¨çš„å‡½æ•°æ˜¯BatchNorm2dï¼Œå‚æ•°ä»£è¡¨çš„å«ä¹‰æ˜¯æœ‰å¤šå°‘ä¸ªé€šé“ã€‚ 123456789101112131415161718192021222324252627In [3]: import torch.nn as nnIn [4]: x=torch.randn(3,16,7,7)In [5]: layer=nn.BatchNorm2d(16)In [6]: out=layer(x)In [7]: out.shapeOut[7]: torch.Size([3, 16, 7, 7])In [8]: layer.weightOut[8]: Parameter containing:tensor([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.], requires_grad=True)In [9]: layer.biasOut[9]: Parameter containing:tensor([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], requires_grad=True)In [10]: layer.running_meanOut[10]: tensor([-3.1731e-03, -1.3501e-03, -2.2491e-03, 9.6934e-05, -2.5191e-03, -4.5400e-03, -1.0107e-02, 1.9353e-03, -1.2692e-02, 8.8569e-03, 9.0268e-04, -1.6005e-03, -8.5016e-03, -9.6128e-03, 1.5821e-03, 1.9608e-02])In [11]: layer.running_varOut[11]: tensor([1.0157, 0.9935, 0.9906, 1.0245, 1.0056, 1.0123, 1.0102, 1.0013, 0.9842, 0.9849, 0.9979, 0.9973, 1.0035, 0.9945, 0.9796, 1.0021]) `layer.weight`ä»£è¡¨çš„æ˜¯ä¸Šé¢åŸç†å›¾ä¸­çš„$\\gamma$,`layer.bias`ä»£è¡¨çš„æ˜¯ä¸Šé¢åŸç†å›¾ä¸­çš„$\\beta$ï¼Œ`layer.running_mean`ä»£è¡¨çš„æ˜¯$\\mu$ï¼Œ`layer.running_var`ä»£è¡¨çš„æ˜¯Ïƒ\\sigmaÏƒ ä½¿ç”¨varså¯ä»¥æ‰“å‡ºå±‚çš„æ‰€æœ‰ä¿¡æ¯ã€‚ 1234567891011121314151617181920212223242526272829303132In [12]: vars(layer)Out[12]: &#123;&#x27;training&#x27;: True, &#x27;_parameters&#x27;: OrderedDict([(&#x27;weight&#x27;, Parameter containing: tensor([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.], requires_grad=True)), (&#x27;bias&#x27;, Parameter containing: tensor([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], requires_grad=True))]), &#x27;_buffers&#x27;: OrderedDict([(&#x27;running_mean&#x27;, tensor([-3.1731e-03, -1.3501e-03, -2.2491e-03, 9.6934e-05, -2.5191e-03, -4.5400e-03, -1.0107e-02, 1.9353e-03, -1.2692e-02, 8.8569e-03, 9.0268e-04, -1.6005e-03, -8.5016e-03, -9.6128e-03, 1.5821e-03, 1.9608e-02])), (&#x27;running_var&#x27;, tensor([1.0157, 0.9935, 0.9906, 1.0245, 1.0056, 1.0123, 1.0102, 1.0013, 0.9842, 0.9849, 0.9979, 0.9973, 1.0035, 0.9945, 0.9796, 1.0021])), (&#x27;num_batches_tracked&#x27;, tensor(1))]), &#x27;_non_persistent_buffers_set&#x27;: set(), &#x27;_backward_hooks&#x27;: OrderedDict(), &#x27;_is_full_backward_hook&#x27;: None, &#x27;_forward_hooks&#x27;: OrderedDict(), &#x27;_forward_pre_hooks&#x27;: OrderedDict(), &#x27;_state_dict_hooks&#x27;: OrderedDict(), &#x27;_load_state_dict_pre_hooks&#x27;: OrderedDict(), &#x27;_modules&#x27;: OrderedDict(), &#x27;num_features&#x27;: 16, &#x27;eps&#x27;: 1e-05, &#x27;momentum&#x27;: 0.1, &#x27;affine&#x27;: True, &#x27;track_running_stats&#x27;: True&#125; å› ä¸ºBatchnormå±‚åœ¨è®­ç»ƒæ¨¡å¼å’Œæµ‹è¯•æ¨¡å¼ä¸‹çš„è¡Œä¸ºæœ‰æ‰€å·®åˆ«ï¼Œæ‰€ä»¥åœ¨è¿›è¡Œæµ‹è¯•æ—¶ï¼Œè¦ä½¿ç”¨evalæŠŠBatchnormå±‚çš„çŠ¶æ€è½¬æ¢è¿‡æ¥ï¼ˆä»è®­ç»ƒæ¨¡å¼è½¬æ¢ä¸ºæµ‹è¯•æ¨¡å¼ï¼‰ã€‚å› ä¸ºtestçš„æ—¶å€™åªæœ‰ä¸€ä¸ªæ ·æœ¬ï¼Œæ‰€ä»¥Î¼,Ïƒ2\\mu,\\sigma^2Î¼,Ïƒ2æ˜¯æ— æ³•è¢«ç»Ÿè®¡çš„ã€‚ä¸€èˆ¬è¿™ä¸ªæ—¶å€™è¿™ä¸¤ä¸ªå€¼ä¼šè¢«èµ‹å€¼ä¸ºå…¨å±€çš„å€¼ã€‚ åˆç†ä½¿ç”¨BatchNormå¯ä»¥åŠ å¿«æ”¶æ•›é€Ÿåº¦å¹¶ä¸”æé«˜å‡†ç¡®åº¦ï¼Œè€Œä¸”ä½¿ç”¨äº†ä»¥åæ¨¡å‹çš„é²æ£’æ€§ä¼šæå‡ï¼ˆæ¨¡å‹æ›´åŠ ç¨³å®šï¼‰ ç»å…¸çš„å·ç§¯ç¥ç»ç½‘ç»œ å…¶ä¸­å‡ ä¸ªè½¬æŠ˜ç‚¹ AlexNet(2012) ZFNet(2013) VGG(2014) GoogLeNet(2014) ResNetâ€» LeNet-5 LeNetç”±Yann Lecun æå‡ºï¼Œæ˜¯ä¸€ç§ç»å…¸çš„å·ç§¯ç¥ç»ç½‘ç»œï¼Œæ˜¯ç°ä»£å·ç§¯ç¥ç»ç½‘ç»œçš„èµ·æºä¹‹ä¸€ã€‚Yannå°†è¯¥ç½‘ç»œç”¨äºé‚®å±€çš„é‚®æ”¿çš„é‚®æ”¿ç¼–ç è¯†åˆ«ï¼Œæœ‰ç€è‰¯å¥½çš„å­¦ä¹ å’Œè¯†åˆ«èƒ½åŠ›ã€‚LeNetåˆç§°LeNet-5,å…·æœ‰ä¸€ä¸ªè¾“å…¥å±‚ï¼Œä¸¤ä¸ªå·ç§¯å±‚ï¼Œä¸¤ä¸ªæ± åŒ–å±‚ï¼Œ3ä¸ªå…¨è¿æ¥å±‚ï¼ˆå…¶ä¸­æœ€åä¸€ä¸ªå…¨è¿æ¥å±‚ä¸ºè¾“å‡ºå±‚ï¼‰ã€‚ LeNet-5æ˜¯ä¸€ç§ç»å…¸çš„å·ç§¯ç¥ç»ç½‘ç»œç»“æ„ï¼Œäº1998å¹´æŠ•å…¥å®é™…ä½¿ç”¨ä¸­ã€‚è¯¥ç½‘ç»œæœ€æ—©åº”ç”¨äºæ‰‹å†™ä½“å­—ç¬¦è¯†åˆ«åº”ç”¨ä¸­ã€‚æ™®éè®¤ä¸ºï¼Œå·ç§¯ç¥ç»ç½‘ç»œçš„å‡ºç°å¼€å§‹äºLeCun ç­‰æå‡ºçš„LeNet ç½‘ç»œï¼ˆLeCun et al., 1998ï¼‰ï¼Œå¯ä»¥è¯´LeCun ç­‰æ˜¯CNN çš„ç¼”é€ è€…ï¼Œè€ŒLeNet-5 åˆ™æ˜¯LeCun ç­‰åˆ›é€ çš„CNN ç»å…¸ä¹‹ä½œ ã€‚ ç½‘ç»œç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œå…ˆæ˜¯ä¸€ä¸ªå·ç§¯å±‚ï¼Œç„¶åæ˜¯ä¸€ä¸ªä¸‹é‡‡æ ·ï¼Œç„¶ååˆæ˜¯ä¸€ä¸ªå·ç§¯å±‚ï¼Œç„¶ååˆæ˜¯ä¸€ä¸ªä¸‹é‡‡æ ·ï¼Œæœ€åä¸‰ä¸ªå°±æ˜¯ä¸‰ä¸ªå…¨è¿æ¥å±‚ã€‚ AlexNet AlexNetæ˜¯2012å¹´ImageNetç«èµ›å† å†›è·å¾—è€…Hintonå’Œä»–çš„å­¦ç”ŸAlex Krizhevskyè®¾è®¡çš„ã€‚ä¹Ÿæ˜¯åœ¨é‚£å¹´ä¹‹åï¼Œæ›´å¤šçš„æ›´æ·±çš„ç¥ç»ç½‘ç»œè¢«æå‡ºï¼Œæ¯”å¦‚ä¼˜ç§€çš„VGGï¼ŒGoogLeNetã€‚ è¿™å¯¹äºä¼ ç»Ÿçš„æœºå™¨å­¦ä¹ åˆ†ç±»ç®—æ³•è€Œè¨€ï¼Œå·²ç»ç›¸å½“çš„å‡ºè‰²ã€‚ AlexNetä¸­åŒ…å«äº†å‡ ä¸ªæ¯”è¾ƒæ–°çš„æŠ€æœ¯ç‚¹ï¼Œä¹Ÿé¦–æ¬¡åœ¨CNNä¸­æˆåŠŸåº”ç”¨äº†ReLUã€Dropoutå’ŒLRNç­‰Trickã€‚åŒæ—¶AlexNetä¹Ÿä½¿ç”¨äº†GPUè¿›è¡Œè¿ç®—åŠ é€Ÿã€‚ AlexNetå°†LeNetçš„æ€æƒ³å‘æ‰¬å…‰å¤§ï¼ŒæŠŠCNNçš„åŸºæœ¬åŸç†åº”ç”¨åˆ°äº†å¾ˆæ·±å¾ˆå®½çš„ç½‘ç»œä¸­ã€‚AlexNetä¸»è¦ä½¿ç”¨åˆ°çš„æ–°æŠ€æœ¯ç‚¹å¦‚ä¸‹ï¼š ï¼ˆ1ï¼‰æˆåŠŸä½¿ç”¨ReLUä½œä¸ºCNNçš„æ¿€æ´»å‡½æ•°ï¼Œå¹¶éªŒè¯å…¶æ•ˆæœåœ¨è¾ƒæ·±çš„ç½‘ç»œè¶…è¿‡äº†Sigmoidï¼ŒæˆåŠŸè§£å†³äº†Sigmoidåœ¨ç½‘ç»œè¾ƒæ·±æ—¶çš„æ¢¯åº¦å¼¥æ•£é—®é¢˜ã€‚è™½ç„¶ReLUæ¿€æ´»å‡½æ•°åœ¨å¾ˆä¹…ä¹‹å‰å°±è¢«æå‡ºäº†ï¼Œä½†æ˜¯ç›´åˆ°AlexNetçš„å‡ºç°æ‰å°†å…¶å‘æ‰¬å…‰å¤§ã€‚ ï¼ˆ2ï¼‰è®­ç»ƒæ—¶ä½¿ç”¨Dropoutéšæœºå¿½ç•¥ä¸€éƒ¨åˆ†ç¥ç»å…ƒï¼Œä»¥é¿å…æ¨¡å‹è¿‡æ‹Ÿåˆã€‚Dropoutè™½æœ‰å•ç‹¬çš„è®ºæ–‡è®ºè¿°ï¼Œä½†æ˜¯AlexNetå°†å…¶å®ç”¨åŒ–ï¼Œé€šè¿‡å®è·µè¯å®äº†å®ƒçš„æ•ˆæœã€‚åœ¨AlexNetä¸­ä¸»è¦æ˜¯æœ€åå‡ ä¸ªå…¨è¿æ¥å±‚ä½¿ç”¨äº†Dropoutã€‚ ï¼ˆ3ï¼‰åœ¨CNNä¸­ä½¿ç”¨é‡å çš„æœ€å¤§æ± åŒ–ã€‚æ­¤å‰CNNä¸­æ™®éä½¿ç”¨å¹³å‡æ± åŒ–ï¼ŒAlexNetå…¨éƒ¨ä½¿ç”¨æœ€å¤§æ± åŒ–ï¼Œé¿å…å¹³å‡æ± åŒ–çš„æ¨¡ç³ŠåŒ–æ•ˆæœã€‚å¹¶ä¸”AlexNetä¸­æå‡ºè®©æ­¥é•¿æ¯”æ± åŒ–æ ¸çš„å°ºå¯¸å°ï¼Œè¿™æ ·æ± åŒ–å±‚çš„è¾“å‡ºä¹‹é—´ä¼šæœ‰é‡å å’Œè¦†ç›–ï¼Œæå‡äº†ç‰¹å¾çš„ä¸°å¯Œæ€§ã€‚ ï¼ˆ4ï¼‰æå‡ºäº†LRNå±‚ï¼Œå¯¹å±€éƒ¨ç¥ç»å…ƒçš„æ´»åŠ¨åˆ›å»ºç«äº‰æœºåˆ¶ï¼Œä½¿å¾—å…¶ä¸­å“åº”æ¯”è¾ƒå¤§çš„å€¼å˜å¾—ç›¸å¯¹æ›´å¤§ï¼Œå¹¶æŠ‘åˆ¶å…¶ä»–åé¦ˆè¾ƒå°çš„ç¥ç»å…ƒï¼Œå¢å¼ºäº†æ¨¡å‹çš„æ³›åŒ–èƒ½åŠ›ã€‚ ï¼ˆ5ï¼‰ä½¿ç”¨CUDAåŠ é€Ÿæ·±åº¦å·ç§¯ç½‘ç»œçš„è®­ç»ƒï¼Œåˆ©ç”¨GPUå¼ºå¤§çš„å¹¶è¡Œè®¡ç®—èƒ½åŠ›ï¼Œå¤„ç†ç¥ç»ç½‘ç»œè®­ç»ƒæ—¶å¤§é‡çš„çŸ©é˜µè¿ç®—ã€‚AlexNetä½¿ç”¨äº†ä¸¤å—GTXâ€‚580â€‚GPUè¿›è¡Œè®­ç»ƒï¼Œå•ä¸ªGTXâ€‚580åªæœ‰3GBæ˜¾å­˜ï¼Œè¿™é™åˆ¶äº†å¯è®­ç»ƒçš„ç½‘ç»œçš„æœ€å¤§è§„æ¨¡ã€‚å› æ­¤ä½œè€…å°†AlexNetåˆ†å¸ƒåœ¨ä¸¤ä¸ªGPUä¸Šï¼Œåœ¨æ¯ä¸ªGPUçš„æ˜¾å­˜ä¸­å‚¨å­˜ä¸€åŠçš„ç¥ç»å…ƒçš„å‚æ•°ã€‚å› ä¸ºGPUä¹‹é—´é€šä¿¡æ–¹ä¾¿ï¼Œå¯ä»¥äº’ç›¸è®¿é—®æ˜¾å­˜ï¼Œè€Œä¸éœ€è¦é€šè¿‡ä¸»æœºå†…å­˜ï¼Œæ‰€ä»¥åŒæ—¶ä½¿ç”¨å¤šå—GPUä¹Ÿæ˜¯éå¸¸é«˜æ•ˆçš„ã€‚åŒæ—¶ï¼ŒAlexNetçš„è®¾è®¡è®©GPUä¹‹é—´çš„é€šä¿¡åªåœ¨ç½‘ç»œçš„æŸäº›å±‚è¿›è¡Œï¼Œæ§åˆ¶äº†é€šä¿¡çš„æ€§èƒ½æŸè€—ã€‚ ï¼ˆ6ï¼‰æ•°æ®å¢å¼ºï¼Œéšæœºåœ°ä»256256çš„åŸå§‹å›¾åƒä¸­æˆªå–224224å¤§å°çš„åŒºåŸŸï¼ˆä»¥åŠæ°´å¹³ç¿»è½¬çš„é•œåƒï¼‰ï¼Œç›¸å½“äºå¢åŠ äº†2*(256-224)^2=2048å€çš„æ•°æ®é‡ã€‚å¦‚æœæ²¡æœ‰æ•°æ®å¢å¼ºï¼Œä»…é åŸå§‹çš„æ•°æ®é‡ï¼Œå‚æ•°ä¼—å¤šçš„CNNä¼šé™·å…¥è¿‡æ‹Ÿåˆä¸­ï¼Œä½¿ç”¨äº†æ•°æ®å¢å¼ºåå¯ä»¥å¤§å¤§å‡è½»è¿‡æ‹Ÿåˆï¼Œæå‡æ³›åŒ–èƒ½åŠ›ã€‚è¿›è¡Œé¢„æµ‹æ—¶ï¼Œåˆ™æ˜¯å–å›¾ç‰‡çš„å››ä¸ªè§’åŠ ä¸­é—´å…±5ä¸ªä½ç½®ï¼Œå¹¶è¿›è¡Œå·¦å³ç¿»è½¬ï¼Œä¸€å…±è·å¾—10å¼ å›¾ç‰‡ï¼Œå¯¹ä»–ä»¬è¿›è¡Œé¢„æµ‹å¹¶å¯¹10æ¬¡ç»“æœæ±‚å‡å€¼ã€‚åŒæ—¶ï¼ŒAlexNetè®ºæ–‡ä¸­æåˆ°äº†ä¼šå¯¹å›¾åƒçš„RGBæ•°æ®è¿›è¡ŒPCAå¤„ç†ï¼Œå¹¶å¯¹ä¸»æˆåˆ†åšä¸€ä¸ªæ ‡å‡†å·®ä¸º0.1çš„é«˜æ–¯æ‰°åŠ¨ï¼Œå¢åŠ ä¸€äº›å™ªå£°ï¼Œè¿™ä¸ªTrickå¯ä»¥è®©é”™è¯¯ç‡å†ä¸‹é™1%ã€‚ æ¨¡å‹ç‰¹ç‚¹ ä½¿ç”¨äº†ReLUæ¿€æ´»å‡½æ•° ä½¿ç”¨äº†æœ€å¤§æ± åŒ–å±‚ æ ‡å‡†åŒ– Dropout VGG VGGæ¨¡å‹æ˜¯2014å¹´ILSVRCç«èµ›çš„ç¬¬äºŒåï¼Œç¬¬ä¸€åæ˜¯GoogLeNetã€‚ä½†æ˜¯VGGæ¨¡å‹åœ¨å¤šä¸ªè¿ç§»å­¦ä¹ ä»»åŠ¡ä¸­çš„è¡¨ç°è¦ä¼˜äºGoogLeNetã€‚è€Œä¸”ï¼Œä»å›¾åƒä¸­æå–CNNç‰¹å¾ï¼ŒVGGæ¨¡å‹æ˜¯é¦–é€‰ç®—æ³•ã€‚å®ƒçš„ç¼ºç‚¹åœ¨äºï¼Œå‚æ•°é‡æœ‰140Mä¹‹å¤šï¼Œéœ€è¦æ›´å¤§çš„å­˜å‚¨ç©ºé—´ã€‚ä½†æ˜¯è¿™ä¸ªæ¨¡å‹å¾ˆæœ‰ç ”ç©¶ä»·å€¼ã€‚ æ¨¡å‹çš„åç§°â€”â€”â€œVGGâ€ä»£è¡¨äº†ç‰›æ´¥å¤§å­¦çš„Oxford Visual Geometry Groupï¼Œè¯¥å°ç»„éš¶å±äº1985å¹´æˆç«‹çš„Robotics Research Groupï¼Œè¯¥Groupç ”ç©¶èŒƒå›´åŒ…æ‹¬äº†æœºå™¨å­¦ä¹ åˆ°ç§»åŠ¨æœºå™¨äººã€‚ä¸‹é¢æ˜¯ä¸€æ®µæ¥è‡ªç½‘ç»œå¯¹åŒå¹´GoogLeNetå’ŒVGGçš„æè¿°ï¼š â€œGoogLeNetå’ŒVGGçš„Classificationæ¨¡å‹ä»åŸç†ä¸Šå¹¶æ²¡æœ‰ä¸ä¼ ç»Ÿçš„CNNæ¨¡å‹æœ‰å¤ªå¤§ä¸åŒã€‚å¤§å®¶æ‰€ç”¨çš„Pipelineä¹Ÿéƒ½æ˜¯ï¼šè®­ç»ƒæ—¶å€™ï¼šå„ç§æ•°æ®Augmentationï¼ˆå‰ªè£ï¼Œä¸åŒå¤§å°ï¼Œè°ƒäº®åº¦ï¼Œé¥±å’Œåº¦ï¼Œå¯¹æ¯”åº¦ï¼Œåè‰²ï¼‰ï¼Œå‰ªè£é€å…¥CNNæ¨¡å‹ï¼ŒSoftmaxï¼ŒBackpropã€‚æµ‹è¯•æ—¶å€™ï¼šå°½é‡æŠŠæµ‹è¯•æ•°æ®åˆå„ç§Augmentingï¼ˆå‰ªè£ï¼Œä¸åŒå¤§å°ï¼‰ï¼ŒæŠŠæµ‹è¯•æ•°æ®å„ç§Augmentingååœ¨è®­ç»ƒçš„ä¸åŒæ¨¡å‹ä¸Šçš„ç»“æœå†ç»§ç»­Averagingå‡ºæœ€åçš„ç»“æœã€‚â€ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨VGGNetçš„6ç»„å®éªŒä¸­ï¼Œåé¢çš„4ä¸ªç½‘ç»œå‡ä½¿ç”¨äº†pre-trained model Açš„æŸäº›å±‚æ¥åšå‚æ•°åˆå§‹åŒ–ã€‚è™½ç„¶æå‡ºè€…æ²¡æœ‰æè¯¥æ–¹æ³•å¸¦æ¥çš„æ€§èƒ½å¢ç›Šã€‚å…ˆæ¥çœ‹çœ‹VGGçš„ç‰¹ç‚¹ï¼š å°å·ç§¯æ ¸ã€‚ä½œè€…å°†å·ç§¯æ ¸å…¨éƒ¨æ›¿æ¢ä¸º3x3ï¼ˆæå°‘ç”¨äº†1x1ï¼‰ï¼› å°æ± åŒ–æ ¸ã€‚ç›¸æ¯”AlexNetçš„3x3çš„æ± åŒ–æ ¸ï¼ŒVGGå…¨éƒ¨ä¸º2x2çš„æ± åŒ–æ ¸ï¼› å±‚æ•°æ›´æ·±ç‰¹å¾å›¾æ›´å®½ã€‚åŸºäºå‰ä¸¤ç‚¹å¤–ï¼Œç”±äºå·ç§¯æ ¸ä¸“æ³¨äºæ‰©å¤§é€šé“æ•°ã€æ± åŒ–ä¸“æ³¨äºç¼©å°å®½å’Œé«˜ï¼Œä½¿å¾—æ¨¡å‹æ¶æ„ä¸Šæ›´æ·±æ›´å®½çš„åŒæ—¶ï¼Œè®¡ç®—é‡çš„å¢åŠ æ”¾ç¼“ï¼› å…¨è¿æ¥è½¬å·ç§¯ã€‚ç½‘ç»œæµ‹è¯•é˜¶æ®µå°†è®­ç»ƒé˜¶æ®µçš„ä¸‰ä¸ªå…¨è¿æ¥æ›¿æ¢ä¸ºä¸‰ä¸ªå·ç§¯ï¼Œæµ‹è¯•é‡ç”¨è®­ç»ƒæ—¶çš„å‚æ•°ï¼Œä½¿å¾—æµ‹è¯•å¾—åˆ°çš„å…¨å·ç§¯ç½‘ç»œå› ä¸ºæ²¡æœ‰å…¨è¿æ¥çš„é™åˆ¶ï¼Œå› è€Œå¯ä»¥æ¥æ”¶ä»»æ„å®½æˆ–é«˜ä¸ºçš„è¾“å…¥ã€‚ GoogLeNet GoogLeNetæ˜¯2014å¹´Christian Szegedyæå‡ºçš„ä¸€ç§å…¨æ–°çš„æ·±åº¦å­¦ä¹ ç»“æ„ï¼Œåœ¨è¿™ä¹‹å‰çš„AlexNetã€VGGç­‰ç»“æ„éƒ½æ˜¯é€šè¿‡å¢å¤§ç½‘ç»œçš„æ·±åº¦ï¼ˆå±‚æ•°ï¼‰æ¥è·å¾—æ›´å¥½çš„è®­ç»ƒæ•ˆæœï¼Œä½†å±‚æ•°çš„å¢åŠ ä¼šå¸¦æ¥å¾ˆå¤šè´Ÿä½œç”¨ï¼Œæ¯”å¦‚overfitã€æ¢¯åº¦æ¶ˆå¤±ã€æ¢¯åº¦çˆ†ç‚¸ç­‰ã€‚inceptionçš„æå‡ºåˆ™ä»å¦ä¸€ç§è§’åº¦æ¥æå‡è®­ç»ƒç»“æœï¼šèƒ½æ›´é«˜æ•ˆçš„åˆ©ç”¨è®¡ç®—èµ„æºï¼Œåœ¨ç›¸åŒçš„è®¡ç®—é‡ä¸‹èƒ½æå–åˆ°æ›´å¤šçš„ç‰¹å¾ï¼Œä»è€Œæå‡è®­ç»ƒç»“æœã€‚ æ¨¡å‹ç‰¹ç‚¹ ä½¿ç”¨ä¸åŒå¤§å°çš„å·ç§¯æ ¸ï¼Œä»è€Œæ„Ÿå—ä¸åŒèŒƒå›´çš„è§†é‡ ResNetï¼ˆæ·±åº¦æ®‹å·®ç½‘ç»œï¼‰â€» è¿™é‡Œå•ç‹¬å°†ResNetæ–°å¼€ä¸€ä¸ªç« èŠ‚ï¼Œå·²ç»è¡¨æ˜äº†ä»–åœ¨è¿™ä¸€é¢†åŸŸçš„é‡è¦æ€§ã€‚é¦–å…ˆæ¥çœ‹çœ‹ResNetåœ¨2015å¹´çš„æˆ˜ç»©ï¼š ä»ç»éªŒæ¥çœ‹ï¼Œç½‘ç»œçš„æ·±åº¦å¯¹æ¨¡å‹çš„æ€§èƒ½è‡³å…³é‡è¦ï¼Œå½“å¢åŠ ç½‘ç»œå±‚æ•°åï¼Œç½‘ç»œå¯ä»¥è¿›è¡Œæ›´åŠ å¤æ‚çš„ç‰¹å¾æ¨¡å¼çš„æå–ï¼Œæ‰€ä»¥å½“æ¨¡å‹æ›´æ·±æ—¶ç†è®ºä¸Šå¯ä»¥å–å¾—æ›´å¥½çš„ç»“æœï¼Œä½†æ˜¯æ›´æ·±çš„ç½‘ç»œå…¶æ€§èƒ½ä¸€å®šä¼šæ›´å¥½å—ï¼Ÿå®éªŒå‘ç°æ·±åº¦ç½‘ç»œå‡ºç°äº†é€€åŒ–é—®é¢˜ï¼ˆDegradation problemï¼‰ï¼šç½‘ç»œæ·±åº¦å¢åŠ æ—¶ï¼Œç½‘ç»œå‡†ç¡®åº¦å‡ºç°é¥±å’Œï¼Œç”šè‡³å‡ºç°ä¸‹é™ã€‚56å±‚çš„ç½‘ç»œæ¯”20å±‚ç½‘ç»œæ•ˆæœè¿˜è¦å·®ã€‚è¿™ä¸ä¼šæ˜¯è¿‡æ‹Ÿåˆé—®é¢˜ï¼Œå› ä¸º56å±‚ç½‘ç»œçš„è®­ç»ƒè¯¯å·®åŒæ ·é«˜ã€‚æˆ‘ä»¬çŸ¥é“æ·±å±‚ç½‘ç»œå­˜åœ¨ç€æ¢¯åº¦æ¶ˆå¤±æˆ–è€…çˆ†ç‚¸çš„é—®é¢˜ï¼Œè¿™ä½¿å¾—æ·±åº¦å­¦ä¹ æ¨¡å‹å¾ˆéš¾è®­ç»ƒã€‚ä½†æ˜¯ç°åœ¨å·²ç»å­˜åœ¨ä¸€äº›æŠ€æœ¯æ‰‹æ®µå¦‚BatchNormæ¥ç¼“è§£è¿™ä¸ªé—®é¢˜ã€‚å› æ­¤ï¼Œå‡ºç°æ·±åº¦ç½‘ç»œçš„é€€åŒ–é—®é¢˜æ˜¯éå¸¸ä»¤äººè¯§å¼‚çš„ã€‚ä½†æ˜¯ä½•æºæ˜å‘æ˜çš„ResNetæœ‰æ•ˆçš„è§£å†³äº†è¿™ä¸€é—®é¢˜ã€‚ResNetæœ‰æ•ˆè§£å†³äº†æ·±åº¦CNNæ¨¡å‹éš¾è®­ç»ƒçš„é—®é¢˜ï¼ˆç½‘ç»œå¤ªæ·±äº†å®¹æ˜“å‘ç”Ÿæ¢¯åº¦å¼¥æ•£ï¼‰ ResNetæ®‹å·®ç½‘ç»œä¸»è¦æ˜¯é€šè¿‡æ®‹å·®å—ç»„æˆçš„ï¼Œåœ¨æå‡ºæ®‹å·®ç½‘ç»œä¹‹å‰ï¼Œç½‘ç»œç»“æ„æ— æ³•å¾ˆæ·±ï¼Œåœ¨VGGä¸­ï¼Œå·ç§¯ç½‘ç»œè¾¾åˆ°äº†19å±‚ï¼Œåœ¨GoogLeNetä¸­ï¼Œç½‘ç»œè¾¾åˆ°äº†22å±‚ã€‚éšç€ç½‘ç»œå±‚æ•°çš„å¢åŠ ï¼Œç½‘ç»œå‘ç”Ÿäº†é€€åŒ–ï¼ˆdegradationï¼‰çš„ç°è±¡ï¼šéšç€ç½‘ç»œå±‚æ•°çš„å¢å¤šï¼Œè®­ç»ƒé›†lossé€æ¸ä¸‹é™ï¼Œç„¶åè¶‹äºé¥±å’Œï¼Œå½“ä½ å†å¢åŠ ç½‘ç»œæ·±åº¦çš„è¯ï¼Œè®­ç»ƒé›†lossåè€Œä¼šå¢å¤§ã€‚è€Œå¼•å…¥æ®‹å·®å—åï¼Œç½‘ç»œå¯ä»¥è¾¾åˆ°å¾ˆæ·±ï¼Œç½‘ç»œçš„æ•ˆæœä¹Ÿéšä¹‹å˜å¥½ã€‚ è¿™é‡Œæä¾›äº†ä¸€ç§æƒ³æ³•ï¼šæ—¢ç„¶æ·±å±‚ç½‘ç»œç›¸æ¯”äºæµ…å±‚ç½‘ç»œå…·æœ‰é€€åŒ–é—®é¢˜ï¼Œé‚£ä¹ˆæ˜¯å¦å¯ä»¥ä¿ç•™æ·±å±‚ç½‘ç»œçš„æ·±åº¦ï¼Œåˆå¯ä»¥æœ‰æµ…å±‚ç½‘ç»œçš„ä¼˜åŠ¿å»é¿å…é€€åŒ–é—®é¢˜å‘¢ï¼Ÿå¦‚æœå°†æ·±å±‚ç½‘ç»œçš„åé¢è‹¥å¹²å±‚å­¦ä¹ æˆæ’ç­‰æ˜ å°„ h(x)=xh(x)=xh(x)=x ï¼Œé‚£ä¹ˆæ¨¡å‹å°±é€€åŒ–æˆæµ…å±‚ç½‘ç»œã€‚ä½†æ˜¯ç›´æ¥å»å­¦ä¹ è¿™ä¸ªæ’ç­‰æ˜ å°„æ˜¯å¾ˆå›°éš¾çš„ï¼Œé‚£ä¹ˆå°±æ¢ä¸€ç§æ–¹å¼ï¼ŒæŠŠç½‘ç»œè®¾è®¡æˆï¼š H(x)=F(x)+xâ‡’F(x)=H(x)âˆ’xH(x)=F(x)+x \\Rightarrow F(x)=H(x)-x H(x)=F(x)+xâ‡’F(x)=H(x)âˆ’x åªè¦ F(x)=0F(x)=0F(x)=0 å°±æ„æˆäº†ä¸€ä¸ªæ’ç­‰æ˜ å°„ H(x)=xH(x)=xH(x)=x ï¼Œè¿™é‡Œ F(x)F(x)F(x) ä¸ºæ®‹å·®ã€‚ ç›¸å…³èµ„æ–™é“¾æ¥ï¼šæ·±åº¦å­¦ä¹ ä¹‹16â€”â€”æ®‹å·®ç½‘ç»œ(ResNet) PyTorch æ®‹å·®å—å®ç° 12345678910111213141516171819class ResBlk(nn.Module): def __init__(self,ch_in,ch_out): self.conv1=nn.Conv2d(ch_in,ch_out,kernel_size=3,stride=1,padding=1) self.bn1=nn.BatchNorm2d(ch_out) self.conv2=nn.Conv2d(ch_in,ch_out,kernel_size=3,stride=1,padding=1) self.bn2=nn.BatchNorm2d(ch_out) self.extra=nn.Sequential() if ch_out!=ch_in: # å¦‚æœè¾“å…¥è¾“å‡ºé€šé“æ•°é‡ä¸ä¸€æ ·çš„è¯ self.extra!=ch_in: self.extra=nn.Sequential( nn.Conv2d(ch_in,ch_out,kernel_size=1,stride=1), nn.BatchNorm2s(ch_out) ) def forward(self,x): out=F.relu(self.bn1(self.conv1(x))) out=self.bn2(self.conv2(out)) out=self.extra(x)+out return out DenseNet å…¶å®ç›¸å½“äºæ¯ä¸€å±‚éƒ½å’Œå‰é¢æ‰€æœ‰å±‚ä¹‹é—´åˆä¸€ä¸ªshortcut nn.Module PyTorchä¸­çš„nn.Moduleç±»ä¸ºæ‰€æœ‰æˆ‘ä»¬è‡ªå®šä¹‰ç½‘ç»œå±‚çš„ä¸€ä¸ªçˆ¶ç±»ï¼æ‰€ä»¥ä»–éå¸¸çš„é‡è¦ï¼Œä»¥ä¸‹æ˜¯ä»–çš„ä¼˜ç‚¹ æä¾›äº†å¾ˆå¤šçš„æ“ä½œ nn.Linear nn.BatchNorm2d nn.Conv2d etc. æä¾›å®¹å™¨nn.Sequential å¯¹ç½‘ç»œå‚æ•°èƒ½å¤Ÿè¿›è¡Œå¾ˆå¥½çš„ç®¡ç† ä¸‹é¢ä¸¾ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬é‡‡ç”¨çš„æ˜¯ä¸€ä¸ªä¸¤å±‚çš„ç½‘ç»œï¼Œæ‰€ä»¥å‚æ•°æœ‰4ç»„ï¼Œweight0ï¼Œbias0,weight1,bias1 123456789101112131415161718192021In [3]: import torch.nn as nnIn [4]: net=nn.Sequential(nn.Linear(4,2),nn.Linear(2,2))In [5]: dict(net.named_parameters()).items()Out[5]: dict_items([(&#x27;0.weight&#x27;, Parameter containing:tensor([[-0.1411, 0.2698, 0.0457, -0.2939], [-0.3555, -0.3352, -0.3403, 0.4714]], requires_grad=True)), (&#x27;0.bias&#x27;, Parameter containing:tensor([ 0.1076, -0.1325], requires_grad=True)), (&#x27;1.weight&#x27;, Parameter containing:tensor([[ 0.0859, -0.6313], [-0.6823, -0.5285]], requires_grad=True)), (&#x27;1.bias&#x27;, Parameter containing:tensor([ 0.6793, -0.1800], requires_grad=True))])In [6]: list(net.parameters())[0]Out[6]: Parameter containing:tensor([[-0.1411, 0.2698, 0.0457, -0.2939], [-0.3555, -0.3352, -0.3403, 0.4714]], requires_grad=True)In [7]: list(net.parameters())[1]Out[7]: Parameter containing:tensor([ 0.1076, -0.1325], requires_grad=True)In [8]: optimizer=optim.SGD(net.parameters(),lr=1e-3) å¯ä»¥æ¸…æ™°çš„æŸ¥çœ‹ç½‘ç»œç»“æ„ å¯ä»¥å°†ç½‘ç»œæ–¹ä¾¿çš„è½¬ç§»åˆ°GPUä¸Šè¿›è¡ŒåŠ é€Ÿ 123device=torch,device(&#x27;cuda&#x27;)net=Net()net.to(device) å¯ä»¥å¾ˆæ–¹ä¾¿çš„ä¿å­˜å’ŒåŠ è½½ç½‘ç»œçš„ä¸­é—´çŠ¶æ€ è¿™å°±æ–¹ä¾¿æˆ‘ä»¬è¿›è¡Œearly stop 123456789device=torch,device(&#x27;cuda&#x27;)net=Net()net.to(device)net.load_state_dict(torch.load(&#x27;ckpt.mdl&#x27;)) # åŠ è½½æ¨¡å‹# train...torch.save(net.state_dict(),&#x27;ckpt.mdl&#x27;) # ä¿å­˜æ¨¡å‹ æ–¹ä¾¿åˆ‡æ¢ç½‘ç»œçŠ¶æ€ å¯¹äºç½‘ç»œä¸­çš„ä¸€äº›å±‚ï¼Œæ¯”å¦‚BatchNormå±‚ï¼Œä»–åœ¨è®­ç»ƒçŠ¶æ€ä¸‹å’Œæµ‹è¯•çŠ¶æ€ä¸‹çš„è¡Œä¸ºæ˜¯æœ‰ä¸€äº›å·®å¼‚çš„ï¼Œå¦‚æœæˆ‘ä»¬å¯¹ç½‘ç»œä¸­çš„æ¯ä¸€å±‚éƒ½å»æ‰§è¡Œåˆ‡æ¢çŠ¶æ€çš„æ“ä½œæ˜¯éå¸¸éº»çƒ¦çš„ï¼Œä½†æ˜¯nn.Moduleæ”¯æŒå¯¹è‡ªå®šä¹‰ç½‘ç»œæ•´ä½“çŠ¶æ€çš„åˆ‡æ¢ï¼Œå¤§å¤§ç®€åŒ–äº†æ“ä½œã€‚ 12345678910111213device = torch.device(&#x27;cuda&#x27;)net=Net()net.to(device)# trainnet.train()# ...# ...# ...# testnet.eval()# ... æ–¹ä¾¿å®šä¹‰è‡ªå·±çš„ç±» æ¯”å¦‚è¯´PyTorchç°ç›®å‰æš‚æ—¶ä¸æä¾›å°†tensoræ‹å¹³çš„æ“ä½œï¼ˆå±‚ä¹‹é—´ï¼Œä½œç”¨æ˜¯å°†å·ç§¯å±‚è½¬åŒ–ä¸ºå…¨è¿æ¥å±‚ï¼‰ï¼Œå› æ­¤è¿™ä¸ªå±‚éœ€è¦æˆ‘ä»¬è‡ªå·±å»å®ç° 12345class Flatten(nn.Module): def __init__(self): super(Flatten,self).__init__() def forward(self,input): return input.view(input.size(0),-1) ä»¥ä¸Šè¿™ä¸ªç±»ä½¿ç”¨çš„éå¸¸çš„å¹¿æ³› æˆ‘ä»¬ä¹Ÿå¯ä»¥å°è¯•è‡ªå·±å†™ä¸€ä¸ªLinearç±» 123456789101112class MyLinear(nn.Module): def __init__(self,inp,outp): super(MyLinear,self).__init__() # requiers_grad = True self.w = nn.Parameter(torch.randn(outp,inp)) self.b = nn.Parameter(torch.randn(outp)) def forward(self, x): x = x @ self.w.t() + self.b return x æ•°æ®å¢å¼º å…¶å®éå¸¸å¥½ç†è§£ï¼Œæ•°æ®å¢å¼ºè®©æœ‰é™çš„æ•°æ®äº§ç”Ÿæ›´å¤šçš„æ•°æ®ï¼Œå¢åŠ è®­ç»ƒæ ·æœ¬çš„æ•°é‡ä»¥åŠå¤šæ ·æ€§ï¼ˆå™ªå£°æ•°æ®ï¼‰ï¼Œæå‡æ¨¡å‹é²æ£’æ€§ï¼Œä¸€èˆ¬ç”¨äºè®­ç»ƒé›†ã€‚ç¥ç»ç½‘ç»œéœ€è¦å¤§é‡çš„å‚æ•°ï¼Œè®¸è®¸å¤šå¤šçš„ç¥ç»ç½‘è·¯çš„å‚æ•°éƒ½æ˜¯æ•°ä»¥ç™¾ä¸‡è®¡ï¼Œè€Œä½¿å¾—è¿™äº›å‚æ•°å¯ä»¥æ­£ç¡®å·¥ä½œåˆ™éœ€è¦å¤§é‡çš„æ•°æ®è¿›è¡Œè®­ç»ƒï¼Œä½†åœ¨å¾ˆå¤šå®é™…çš„é¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬éš¾ä»¥æ‰¾åˆ°å……è¶³çš„æ•°æ®æ¥å®Œæˆä»»åŠ¡ã€‚éšæœºæ”¹å˜è®­ç»ƒæ ·æœ¬å¯ä»¥é™ä½æ¨¡å‹å¯¹æŸäº›å±æ€§çš„ä¾èµ–ï¼Œä»è€Œæé«˜æ¨¡å‹çš„æ³›åŒ–èƒ½åŠ›ã€‚ å¸¸ç”¨çš„æ•°ä¸¾å¢å¼ºæ–¹æ³•æœ‰ ç¿»è½¬ æ—‹è½¬ éšæœºç§»åŠ¨å’Œè£å‰ª åŠ å™ª GAN ç¿»è½¬ï¼ˆFlipï¼‰ PyTorch å®ç° 12345678910train_loader=torch.utils.dataDataLoader( datasets.MNIST(&#x27;../data&#x27;,train=True,download=True, transform=transforms.Compose([ transforms.RandomHorizontalFlip(),# å› ä¸ºå‰é¢æ˜¯randomï¼Œæ‰€ä»¥è¯¥æ“ä½œæœ‰å¯èƒ½åšä¹Ÿå¯èƒ½ä¸åš transforms.RandomVerticalFlip(), transforms.ToTensor(), # transforms.Normalize((0.1307,),(0.3081,)) ])), batch_size=batch_size,shuffle=True) transformæ˜¯torchvisionä¸­æä¾›çš„æ“ä½œ æ—‹è½¬ï¼ˆRotateï¼‰ PyTorchå®ç° 123456789101112train_loader=torch.utils.dataDataLoader( datasets.MNIST(&#x27;../data&#x27;,train=True,download=True, transform=transforms.Compose([ transforms.RandomHorizontalFlip(), transforms.RandomVerticalFlip(), transforms.RandomRotation(15),# è¿™é‡Œæ˜¯å¯¹äºæ¯å¼ ç…§ç‰‡éšæœºæ—‹è½¬ä¸€ä¸ªè§’åº¦ï¼Œè§’åº¦çš„èŒƒå›´æ˜¯ä»-15Â°åˆ°15Â° transforms.(RandomRotation([90,180,270]))# è¿™é‡Œæ˜¯å¯¹äºæ¯å¼ ç…§ç‰‡éšæœºæ—‹è½¬ä¸€ä¸ªè§’åº¦ï¼Œè§’åº¦æ˜¯ 90Â°æˆ–180Â°æˆ–270Â° transforms.ToTensor(), # transforms.Normalize((0.1307,),(0.3081,)) ])), batch_size=batch_size,shuffle=True) ç¼©æ”¾ï¼ˆscaleï¼‰ PyTorch å®ç° 12345678910111213train_loader=torch.utils.dataDataLoader( datasets.MNIST(&#x27;../data&#x27;,train=True,download=True, transform=transforms.Compose([ transforms.RandomHorizontalFlip(), transforms.RandomVerticalFlip(), transforms.RandomRotation(15), transforms.(RandomRotation([90,180,270])) transforms.Resize([32,32]) # å°†å¤§å°å˜ä¸º32Ã—32 transforms.ToTensor(), # transforms.Normalize((0.1307,),(0.3081,)) ])), batch_size=batch_size,shuffle=True) éšæœºç§»åŠ¨å’Œè£å‰ªï¼ˆCrop partï¼‰ PyTorch å®ç° 1234567891011121314train_loader=torch.utils.dataDataLoader( datasets.MNIST(&#x27;../data&#x27;,train=True,download=True, transform=transforms.Compose([ transforms.RandomHorizontalFlip(), transforms.RandomVerticalFlip(), transforms.RandomRotation(15), transforms.(RandomRotation([90,180,270])) transforms.Resize([32,32]) # å°†å¤§å°å˜ä¸º32Ã—32 transforms.ToTensor(), transforms.RandomCrop([28,28]) # transforms.Normalize((0.1307,),(0.3081,)) ])), batch_size=batch_size,shuffle=True) ä¸€èˆ¬è¿›è¡Œæ•°æ®å¢å¼ºæ˜¯RandomRotationå’ŒRandomCropç»“åˆèµ·æ¥ä¸€èµ·ä½¿ç”¨çš„ åŠ å™ªï¼ˆNoiseï¼‰ æ€»ç»“ è™½ç„¶æ•°æ®å¢å¼ºç¡®å®å¯ä»¥æé«˜æ¨¡å‹çš„è¡¨ç°ï¼Œä½†æ˜¯ä»–ä¸ä¼šå¸®åŠ©å¤ªå¤šã€‚"},{"title":"PyTorch RNN&LSTM","path":"/wiki/PyTorch/PyTorch RNN&LSTM.html","content":"åºåˆ—è¡¨ç¤ºï¼ˆSequence representationï¼‰ æ–¹æ³•ä¸€ å¯¹äºä¸€ä¸ªå¥å­ï¼Œæˆ‘ä»¬é‡‡ç”¨å¦‚ä¸‹çš„è¡¨ç¤ºæ–¹å¼ï¼š [seq_len,feature_len][seq\\_len,feature\\_len] [seq_len,feature_len] seq_lenseq \\_ lenseq_lenè¡¨ç¤ºçš„æ˜¯è¿™ä¸ªå¥å­æ‰€å«çš„å•è¯æ•°é‡ï¼Œfeature_lenfeature \\_ lenfeature_lenè¡¨ç¤ºçš„æ˜¯è¡¨ç¤ºä¸€ä¸ªå•è¯æ‰€éœ€å‘é‡çš„é•¿åº¦ï¼ˆä¸€èˆ¬é‡‡ç”¨ç‹¬çƒ­ç¼–ç ï¼‰ã€‚ ç¼ºç‚¹ï¼šç‹¬çƒ­ç ä½¿å¾—çŸ©é˜µå˜å¾—ç¨€ç–ï¼Œå ç”¨äº†å¤§é‡å­˜å‚¨ç©ºé—´çš„åŒæ—¶ï¼Œè¡¨è¾¾çš„ä¿¡æ¯æµ·éå¸¸å°‘ï¼Œè¿™ä¸æ˜¯æˆ‘ä»¬æƒ³çœ‹åˆ°çš„ç»“æœã€‚ æ–¹æ³•äºŒ ä¸ºäº†è®©ç‰¹å¾å‘é‡å˜å¾—ä¸é‚£ä¹ˆç¨€ç–ï¼Œæˆ‘ä»¬ä¸é‡‡ç”¨ç‹¬çƒ­ç¼–ç æ–¹å¼ã€‚æˆ‘ä»¬è¿˜æ˜¯å¯ä»¥å°†è¦ä½¿ç”¨çš„å•è¯ä½¿ç”¨å‘é‡ç¼–ç ï¼Œåªä¸è¿‡è¿™æ¬¡å‘é‡ç¼–ç æœ‰æ•ˆçš„åˆ©ç”¨äº†è¯­ä¹‰ç›¸å…³æ€§ï¼Œè¯­ä¹‰ç›¸å…³æ€§é«˜çš„ä¸¤ä¸ªå‘é‡ï¼Œä»–ä»¬çš„å¤¹è§’æ›´å°ï¼Œåä¹‹ï¼Œå¤¹è§’ä¼šéå¸¸å¤§ã€‚ç°ç›®å‰å·²ç»æœ‰ä¸¤ç§æŠ€æœ¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ¥è¿›è¡Œè¿™ç§æ–¹å¼çš„ç¼–ç ã€‚ Word2vec GloVe å› ä¸ºä¸ä¼šæ·±å…¥nlpéƒ¨åˆ†ï¼Œæ‰€ä»¥æˆ‘ä»¬æš‚æ—¶ä¸è¯¦ç»†ä»‹ç»è¿™ä¸¤ç§æ–¹å¼ï¼Œå¤§å®¶æœ‰å…´è¶£å¯ä»¥è‡ªè¡Œç™¾åº¦ã€‚ æ–¹æ³•äºŒä¹Ÿæ˜¯ç°ç›®å‰ä½¿ç”¨æœ€å¹¿æ³›çš„ä¸€ç§æ–¹æ³•ã€‚ PyTorchå®ç° ä½¿ç”¨PyTorch å»ºç«‹ç´¢å¼•ç‰¹å¾å‘é‡è¡¨å¹¶æ ¹æ®ç´¢å¼•æŸ¥è¯¢å¯¹åº”å•è¯çš„ç‰¹å¾å‘é‡ 12345678910import torchfrom torch import nnword_to_ix=&#123;&quot;hello&quot;: 0,&quot;world&quot; :1&#125;lookup_tensor = torch.tensor([word_to_ix[&quot;hello&quot;]],dtype=torch.long)embeds=nn.Embedding(2,5)hello_embed=embeds(lookup_tensor)print(hello_embed) è¿è¡Œç»“æœ 12tensor([[-0.4940, -0.9166, 1.2154, 0.4011, -0.6101]], grad_fn=&lt;EmbeddingBackward0&gt;) PyTorch å¯¼å…¥GloVe GloVeæ˜¯ä¸€ç§nlpä¸­å¸¸ç”¨çš„å•è¯çš„å‘é‡ç¼–ç ã€‚ åœ¨PyTorchä¸­ä½¿ç”¨GloVeç¼–ç çš„ä»£ç å¦‚ä¸‹ï¼š 1234from torchnlp.word_to_vector import GloVevectors=GloVe()print(vectors[&#x27;hello&#x27;]) # ç„¶åå°±å¯ä»¥å¾—åˆ°å‘é‡è¡¨ç¤ºçš„ç»“æœ RNNåŸç† æ‰€å…·å¤‡çš„èƒ½åŠ› èƒ½å¤„ç†é•¿å¥å­ï¼Œæ™®é€šçš„å…¨è¿æ¥ç¥ç»ç½‘ç»œä¸è¡Œï¼Œå› ä¸ºè¿™æ ·w,bå‚æ•°å¤ªå¤šäº†ã€‚è§£å†³æ–¹å¼æ˜¯é‡‡ç”¨äº†æƒå€¼å…±äº« èƒ½å¤Ÿè¿æ¥ä¸Šä¸‹æ–‡ï¼Œå…·æœ‰ä¸Šä¸‹æ–‡è¯­å¢ƒä¿¡æ¯ï¼ˆè¯­å¢ƒè´¯ç©¿ï¼‰ å…·ä½“ä¸€èˆ¬æƒ…å†µä¸‹çš„è¡¨è¾¾å¼å¦‚ä¸‹ï¼š ht=fw(htâˆ’1,xt)h_t=f_w(h_{t-1},x_t) htâ€‹=fwâ€‹(htâˆ’1â€‹,xtâ€‹) ht=tanh(Whhhtâˆ’1+Wxhxt)(thereÂ areÂ twoÂ bias!)h_t=tanh(W_{hh}h_{t-1}+W_{xh}x_t)\\qquad(there\\ are \\ two \\ bias!) htâ€‹=tanh(Whhâ€‹htâˆ’1â€‹+Wxhâ€‹xtâ€‹)(thereÂ areÂ twoÂ bias!) yt=Whyhty_t=W_{hy}h_t ytâ€‹=Whyâ€‹htâ€‹ åå‘ä¼ æ’­æ›´æ–°æ¢¯åº¦çš„å…¬å¼ âˆ‚Etâˆ‚Whh=âˆ‘i=0tâˆ‚Etâˆ‚ytâˆ‚ytâˆ‚htâˆ‚htâˆ‚hiâˆ‚hiâˆ‚Whh\\frac{\\partial E_t}{\\partial W_{hh}}=\\sum_{i=0}^t \\frac{\\partial E_t}{\\partial y_t}\\frac{\\partial y_t}{\\partial h_t}\\frac{\\partial h_t}{\\partial h_i}\\frac{\\partial h_i}{\\partial W_{hh}} âˆ‚Whhâ€‹âˆ‚Etâ€‹â€‹=i=0âˆ‘tâ€‹âˆ‚ytâ€‹âˆ‚Etâ€‹â€‹âˆ‚htâ€‹âˆ‚ytâ€‹â€‹âˆ‚hiâ€‹âˆ‚htâ€‹â€‹âˆ‚Whhâ€‹âˆ‚hiâ€‹â€‹ å¦‚æœæˆ‘ä»¬é‡‡ç”¨[seq_len,batch_sz,feature_len][seq\\_len,batch\\_sz,feature\\_len][seq_len,batch_sz,feature_len]æ¥è¡¨ç¤ºæ•°æ®ï¼Œåˆ™å¯¹äºæ•°æ®å¤§å°ä¸º[5,3,100]çš„è¯­ä¹‰æ•°æ®æ¥è¯´ï¼Œæˆ‘ä»¬è¾“å…¥RNNä¸­xix_ixiâ€‹çš„ç»´åº¦åº”è¯¥æ˜¯[3,100]ä¹Ÿå°±æ˜¯[batch_sz,feature_len][batch\\_sz,feature\\_len][batch_sz,feature_len] RNN Layerä½¿ç”¨ è¯·ç‰¢è®° xt@wxh+ht@whhx_t@w_{xh}+h_t@w_{hh} xtâ€‹@wxhâ€‹+htâ€‹@whhâ€‹ nn.RNN é¦–å…ˆä¸¾ä¸€ä¸ªç®€å•çš„ä¾‹å­è®©æˆ‘ä»¬æ¥çœ‹ä¸€çœ‹è¯¥APIä¸­çš„å‚æ•°ä¿¡æ¯ 123456789In [3]: from torch import nnIn [4]: rnn=nn.RNN(100,20)In [5]: rnn._parameters.keys()Out[5]: odict_keys([&#x27;weight_ih_l0&#x27;, &#x27;weight_hh_l0&#x27;, &#x27;bias_ih_l0&#x27;, &#x27;bias_hh_l0&#x27;])In [6]: rnn.weight_hh_l0.shape,rnn.weight_ih_l0.shapeOut[6]: (torch.Size([20, 20]), torch.Size([20, 100]))In [7]: rnn.bias_hh_l0.shape,rnn.bias_ih_l0.shapeOut[7]: (torch.Size([20]), torch.Size([20])) ä¸€èˆ¬æ¥è¯´è¯¥APIå¡«å…¥å‚æ•°æ˜¯`nn.RNN(input_size,hidden_size,byn_layers)`input_size:ä»£è¡¨çš„æ˜¯è¡¨ç¤ºä¸€ä¸ªå•è¯æ‰€éœ€çš„å‘é‡çš„é•¿åº¦ã€‚ hidden_size:ä»£è¡¨çš„æ˜¯è¾“å‡ºçš„æ—¶å€™å‘é‡çš„é•¿åº¦ã€‚ byn_layers:ä»£è¡¨çš„æ˜¯è¾“å…¥åˆ°è¾“å‡ºä¸­é—´å±‚çš„ä¸ªæ•°ï¼Œé»˜è®¤å±‚æ•°ä¸ºä¸€å±‚ å› ä¸ºä¸Šé¢ä»£ç æ²¡å†™`byn_layers`å‚æ•°ï¼Œæ‰€ä»¥é»˜è®¤ä¸€å±‚ï¼Œå› æ­¤ä¸Šé¢çš„ç½‘ç»œå‚æ•°ç»“å°¾æ•°å­—éƒ½æ˜¯0ã€‚ forward 1out,ht=forward(x,h0) xï¼šç½‘ç»œè¾“å…¥ï¼Œtensorå¤§å°ä¸º[seq_len,batchsz,word_vec][seq\\_len,batchsz,word\\_vec][seq_len,batchsz,word_vec] h0ï¼šRNNçš„åˆå§‹è¾“å…¥ï¼Œtensorå¤§å°ä¸º[num_layers,batchsz,h_dim][num\\_layers,batchsz,h\\_dim][num_layers,batchsz,h_dim]å…¶å®å¯ä»¥ä¸å†™ï¼Œforwordå¯¹äºä¸€ä¸ªé•¿åº¦ä¸ºseq_lençš„å¥å­ï¼Œä¼šå°†å¾ªç¯ç¥ç»ç½‘ç»œå…¨éƒ¨æ‰§è¡Œä¸€éï¼ˆæ¯ä¸ªå•è¯æŒ‰é¡ºåºä¸€æ¬¡æ‰”è¿›å»æ›´æ–°æ¨¡å‹å‚æ•°ï¼‰ã€‚ htï¼štensorå¤§å°ä¸º[num_layers,batchsz,h_dim][num\\_layers,batchsz,h\\_dim][num_layers,batchsz,h_dim],è¡¨ç¤ºçš„æ˜¯æœ€åä¸€ä¸ªå•è¯é€å…¥åï¼Œæœ€åä¸€ä¸ªMLPçš„æ¯ä¸€å±‚çš„è¾“å‡º outï¼štensorå¤§å°ä¸º[seq_len,batchsz,h_dim][seq\\_len,batchsz,h\\_dim][seq_len,batchsz,h_dim],è¡¨ç¤ºçš„æ˜¯æ¯é€å…¥ä¸€ä¸ªå•è¯åï¼Œæ¯ä¸€ä¸ªMLPçš„æœ€åä¸€å±‚çš„è¾“å‡º h_dimå°±æ˜¯ä¸Šé¢çš„hidden_size ä¸‹é¢ä¸¾ä¸€ä¸ªä¾‹å­æ›´åŠ å…·ä½“çš„æ¥è¯´æ˜è¿™ä¸ªAPIçš„ä½¿ç”¨æ–¹æ³•ã€‚ è¿™æ˜¯ä¸€ä¸ªå•å±‚çš„RNN 123456789In [3]: from torch import nnIn [4]: rnn=nn.RNN(input_size=100, hidden_size=20,num_layers=1)In [5]: print(rnn)RNN(100, 20)In [6]: x=torch.randn(10,3,100)In [7]: out,ht=rnn(x,torch.zeros(1,3,20))In [8]: print(out.shape)torch.Size([10, 3, 20]) ä»”ç»†é˜…è¯»ä»£ç ä¼šå‘ç°å’Œå‰é¢è¯´çš„ä¸€æ ·ï¼Œå¾ˆå¥½çš„éªŒè¯äº†å‰é¢æˆ‘ä»¬è¯´çš„æ­£ç¡®æ€§ã€‚ å¤šå±‚RNN åŸç†ä¸€æ ·ï¼Œè¿™é‡Œæ”¾ä¸ªä»£ç æ¥è§‚å¯Ÿä¸€ä¸‹PyTorchä¸­RNNæ¨¡å—çš„å‚æ•°å®šä¹‰å’Œå¤šå±‚RNNè®¾è®¡è§„åˆ™ã€‚ 123456789In [3]: from torch import nnIn [4]: rnn=nn.RNN(100,10,num_layers=2)In [5]: rnn._parameters.keys()Out[5]: odict_keys([&#x27;weight_ih_l0&#x27;, &#x27;weight_hh_l0&#x27;, &#x27;bias_ih_l0&#x27;, &#x27;bias_hh_l0&#x27;, &#x27;weight_ih_l1&#x27;, &#x27;weight_hh_l1&#x27;, &#x27;bias_ih_l1&#x27;, &#x27;bias_hh_l1&#x27;])In [6]: rnn.weight_hh_l0.shape, rnn.weight_ih_l0.shapeOut[6]: (torch.Size([10, 10]), torch.Size([10, 100]))In [7]: rnn.weight_hh_l1.shape, rnn.weight_ih_l1.shapeOut[7]: (torch.Size([10, 10]), torch.Size([10, 10])) æ³¨æ„è§‚å¯Ÿrnn.weight_ih_l0.shapeå’Œrnn.weight_ih_l1.shapeçš„ç»´åº¦åŒºåˆ« åŒç†æˆ‘ä»¬ä¹Ÿç»™å‡ºå’Œä¸Šé¢å•å±‚æ¯”è¾ƒåƒçš„4å±‚RNNä»£ç ï¼Œå¸®åŠ©å¤§å®¶ç†è§£ã€‚ 123456789In [3]: from torch import nnIn [4]: rnn=nn.RNN(input_size=100,hidden_size=20,num_layers=4)In [5]: print(rnn)RNN(100, 20, num_layers=4)In [6]: x=torch.randn(10,3,100)In [7]: out,h=rnn(x)In [8]: print(out.shape,h.shape)torch.Size([10, 3, 20]) torch.Size([4, 3, 20]) nn.RNNCell ä¸åŒäºnn.RNN,è¯¥å‡½æ•°éœ€è¦æˆ‘ä»¬å¤šæ¬¡inputæ‰èƒ½è¿­ä»£å‡ºæœ€åçš„ç»“æœã€‚æ‰“æ¯”æ–¹å°±æ˜¯æ¯”å¦‚è¯´æˆ‘æœ‰ä¸€å¥è¯ï¼Œå…¶ä¸­æœ‰10ä¸ªå•è¯ã€‚å¯¹äºnn.RNNæˆ‘ä»¬åªéœ€è¦ä¸€èµ·inputè¿›å»ï¼Œnn.RNNè¿­ä»£ä¸€æ¬¡å°±è‡ªåŠ¨æ›´æ–°äº†æ‰€æœ‰ï¼Œè€Œnn.RNNCellæˆ‘ä»¬è¦æŒ‰é¡ºåºä¸€ä¸ªå•è¯ä¸€ä¸ªå•è¯æ‰”è¿›å»è®­ç»ƒã€‚ç›¸æ¯”ä¹‹ä¸‹nn.RNNCellè™½ç„¶æ›´åŠ éº»çƒ¦ï¼Œä½†æ˜¯æ¯”nn.RNNæ›´åŠ çµæ´»ã€‚ åˆå§‹åŒ– 1rnncell=nn.RNNCell(100,20) ä¸¤ä¸ªå‚æ•°è¡¨ç¤ºè¾“å…¥å’Œè¾“å‡ºçš„ç»´åº¦ï¼Œæ„Ÿè§‰å’Œnn.Linearæœ‰ç‚¹åƒ ä½¿ç”¨æ–¹æ³• 1ht=rnncell(xt,ht_1) xtï¼šå½“å‰ç½‘ç»œè¾“å…¥ï¼Œtensorå¤§å°ä¸º[batchsz,word_vec][batchsz,word\\_vec][batchsz,word_vec] ht_1ï¼šä¸Šä¸€æ¬¡RNNè¾“å‡ºï¼Œtensorå¤§å°ä¸º[num_layers,batchsz,h_dim][num\\_layers,batchsz,h\\_dim][num_layers,batchsz,h_dim]ï¼Œå’Œä¹‹å‰é‚£ä¸€æ · htï¼šæœ¬æ¬¡RNNè¾“å‡ºï¼Œtensorå¤§å°ä¸º[num_layers,batchsz,h_dim][num\\_layers,batchsz,h\\_dim][num_layers,batchsz,h_dim] è¿­ä»£æ“ä½œ å•å±‚RNN 1234567In [3]: from torch import nnIn [4]: cell1=nn.RNNCell(100,20)In [5]: h1=torch.zeros(3,20)In [6]: for xt in x: ...: h1=cell1(xt,h1)In [7]: print(h1.shape)torch.Size([3,20]) åŒå±‚RNN 12345678910In [3]: from torch import nnIn [4]: cell1=nn.RNNCell(100,30)In [5]: h1=torch.zeros(3,30)In [6]: cell2=nn.RNNCell(30,20)In [7]: h2=torch.zeros(3,20)In [8]: for xt in x: ...: h1=cell1(xt,h1) ...: h2=cell2(h1,h2)In [9]: print(h2.shape)torch.Size([3,20]) å®æˆ˜RNNæ³¢å½¢é¢„æµ‹ è¿™é‡Œæƒ³å®ç°çš„ä¸€ä¸ªç›®çš„å°±æ˜¯æ ¹æ®æ­£å¼¦æ³¢å½¢çš„å‰æ®µéƒ¨åˆ†ï¼Œé¢„æµ‹åé¢çš„æ­£å¼¦æ›²çº¿èµ°åŠ¿ã€‚ æˆ‘ä»¬è¿™é‡Œå®ç°çš„åŠŸèƒ½æ˜¯æ ¹æ®å‰1ä¸ªå€¼é¢„æµ‹å1ä¸ªå€¼æ˜¯å¤šå°‘ã€‚ è®­ç»ƒæ˜¯æ¯æ¬¡æ‰”å…¥è¿ç»­çš„50ä¸ªå€¼ï¼Œç„¶åé¢„æµ‹å‘åé¢„æµ‹ä»…å¾€åç§»åŠ¨ä¸€ä¸ªå•ä½çš„50ä¸ªå€¼ï¼ˆæœ‰49ä¸ªå€¼æ˜¯é‡å¤çš„ï¼‰ ç½‘ç»œè®¾è®¡ 12345678910111213141516171819202122232425class Net(nn.Module): def __init__(self, ): super(Net, self).__init__() self.rnn = nn.RNN( input_size=input_size, hidden_size=hidden_size, num_layers=1, batch_first=True, #input:[b,seq_len,word_vec] ) # åˆå§‹åŒ–å‚æ•° for p in self.rnn.parameters(): nn.init.normal_(p, mean=0.0, std=0.001) self.linear = nn.Linear(hidden_size, output_size) def forward(self, x, hidden_prev): out, hidden_prev = self.rnn(x, hidden_prev) # [b, seq, h] out = out.view(-1, hidden_size) out = self.linear(out) out = out.unsqueeze(dim=0) return out, hidden_prev è®­ç»ƒéƒ¨åˆ† 123456789101112131415161718192021for iter in range(6000): start = np.random.randint(3, size=1)[0] time_steps = np.linspace(start, start + 10, num_time_steps) data = np.sin(time_steps) data = data.reshape(num_time_steps, 1) x = torch.tensor(data[:-1]).float().view(1, num_time_steps - 1, 1) y = torch.tensor(data[1:]).float().view(1, num_time_steps - 1, 1) output, hidden_prev = model(x, hidden_prev) hidden_prev = hidden_prev.detach() loss = criterion(output, y) model.zero_grad() loss.backward() # for p in model.parameters(): # print(p.grad.norm()) # torch.nn.utils.clip_grad_norm_(p, 10) optimizer.step() if iter % 100 == 0: print(&quot;Iteration: &#123;&#125; loss &#123;&#125;&quot;.format(iter, loss.item())) ä»£ç ä¸­çš„detachæ˜¯æˆ‘ä»¬ä¹‹å‰ä»æœªè§è¿‡çš„å‡½æ•°ã€‚å®ƒè¿”å›ä¸€ä¸ªæ–°çš„tensorï¼Œä»å½“å‰è®¡ç®—å›¾ä¸­åˆ†ç¦»ä¸‹æ¥ã€‚ä½†æ˜¯ä»æŒ‡å‘åŸå˜é‡çš„å­˜æ”¾ä½ç½®ï¼Œ**ä¸åŒä¹‹å¤„åªæ˜¯requirse_gradä¸ºfalse.**å¾—åˆ°çš„è¿™ä¸ªtensiræ°¸è¿œä¸éœ€è¦è®¡ç®—å™¨æ¢¯åº¦ï¼Œä¸å…·æœ‰grad. æµ‹è¯•éƒ¨åˆ† 12345678910111213141516171819202122start = np.random.randint(3, size=1)[0]time_steps = np.linspace(start, start + 10, num_time_steps)data = np.sin(time_steps)data = data.reshape(num_time_steps, 1)x = torch.tensor(data[:-1]).float().view(1, num_time_steps - 1, 1)y = torch.tensor(data[1:]).float().view(1, num_time_steps - 1, 1)predictions = []input = x[:, 0, :]for _ in range(x.shape[1]): input = input.view(1, 1, 1) (pred, hidden_prev) = model(input, hidden_prev) input = pred predictions.append(pred.detach().numpy().ravel()[0])x = x.data.numpy().ravel()y = y.data.numpy()plt.scatter(time_steps[:-1], x.ravel(), s=90)plt.plot(time_steps[:-1], x.ravel())plt.scatter(time_steps[1:], predictions)plt.show() ä»£ç æ±‡æ€» 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import numpy as npimport torchimport torch.nn as nnimport torch.optim as optimfrom matplotlib import pyplot as pltnum_time_steps = 50input_size = 1hidden_size = 16output_size = 1lr=0.01class Net(nn.Module): def __init__(self, ): super(Net, self).__init__() self.rnn = nn.RNN( input_size=input_size, hidden_size=hidden_size, num_layers=1, batch_first=True, ) for p in self.rnn.parameters(): nn.init.normal_(p, mean=0.0, std=0.001) self.linear = nn.Linear(hidden_size, output_size) def forward(self, x, hidden_prev): out, hidden_prev = self.rnn(x, hidden_prev) # [b, seq, h] out = out.view(-1, hidden_size) out = self.linear(out) out = out.unsqueeze(dim=0) return out, hidden_prevmodel = Net()criterion = nn.MSELoss()optimizer = optim.Adam(model.parameters(), lr)hidden_prev = torch.zeros(1, 1, hidden_size)for iter in range(6000): start = np.random.randint(3, size=1)[0] time_steps = np.linspace(start, start + 10, num_time_steps) data = np.sin(time_steps) data = data.reshape(num_time_steps, 1) x = torch.tensor(data[:-1]).float().view(1, num_time_steps - 1, 1) y = torch.tensor(data[1:]).float().view(1, num_time_steps - 1, 1) output, hidden_prev = model(x, hidden_prev) hidden_prev = hidden_prev.detach() loss = criterion(output, y) model.zero_grad() loss.backward() # for p in model.parameters(): # print(p.grad.norm()) # torch.nn.utils.clip_grad_norm_(p, 10) optimizer.step() if iter % 100 == 0: print(&quot;Iteration: &#123;&#125; loss &#123;&#125;&quot;.format(iter, loss.item()))start = np.random.randint(3, size=1)[0]time_steps = np.linspace(start, start + 10, num_time_steps)data = np.sin(time_steps)data = data.reshape(num_time_steps, 1)x = torch.tensor(data[:-1]).float().view(1, num_time_steps - 1, 1)y = torch.tensor(data[1:]).float().view(1, num_time_steps - 1, 1)predictions = []input = x[:, 0, :]for _ in range(x.shape[1]): input = input.view(1, 1, 1) (pred, hidden_prev) = model(input, hidden_prev) input = pred predictions.append(pred.detach().numpy().ravel()[0])x = x.data.numpy().ravel()y = y.data.numpy()plt.scatter(time_steps[:-1], x.ravel(), s=90)plt.plot(time_steps[:-1], x.ravel())plt.scatter(time_steps[1:], predictions)plt.show() ravel()åœ¨numpyä¸­æ˜¯å°†numpyæ•°ç»„æ‹å¹³ï¼Œå˜æˆä¸€ç»´çš„æ“ä½œï¼Œç±»ä¼¼å‰é¢è®²çš„Flatten ç»“æœ RNNè®­ç»ƒé—®é¢˜ æ¢¯åº¦çˆ†ç‚¸ æ¢¯åº¦å¼¥æ•£ æ¢¯åº¦çˆ†ç‚¸ è§£å†³æ–¹æ³• å…¶å®å¹¶ä¸æ˜¯å¾ˆéš¾ï¼Œæˆ‘ä»¬é‡‡ç”¨clippingçš„æ–¹æ³•ï¼Œå°±æ˜¯æˆ‘ä»¬æ¯æ¬¡ä½¿ç”¨backward()æ›´æ–°äº†æ¢¯åº¦ä¿¡æ¯åï¼Œå¯¹æ‰€å¾—åˆ°çš„æ¢¯åº¦å¤§å°è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœæ¨¡é•¿å¤§äºäº†é˜ˆå€¼ï¼Œåˆ™æˆ‘ä»¬å¯¹è¯¥æ¢¯åº¦(gradâƒ—\\vec{grad}gradâ€‹)è¿›è¡Œå¦‚ä¸‹æ“ä½œ: gradâƒ—=thresholdÃ—gradâƒ—âˆ£âˆ£gradâˆ£âˆ£\\vec{grad}=threshold\\times \\frac{\\vec{grad}}{||grad||} gradâ€‹=thresholdÃ—âˆ£âˆ£gradâˆ£âˆ£gradâ€‹â€‹ è™½ç„¶æ²¡æœ‰ä»æ ¹æœ¬è§£å†³æ¢¯åº¦çˆ†ç‚¸çš„é—®é¢˜ï¼Œä½†æ˜¯æˆ‘ä»¬æœ‰æ•ˆéåˆ¶äº†å®ƒå¸¦æ¥çš„ç³Ÿç³•çš„æƒ…å†µã€‚ æ³¨æ„æ˜¯å¯¹å‚æ•°çš„æ¢¯åº¦è¿›è¡Œclippingä¸æ˜¯å¯¹ç½‘ç»œä¸­çš„å‚æ•°æœ¬ä½“ï¼ï¼ï¼ PyTorchå®ç° æ‰€ä½¿ç”¨çš„å‡½æ•°æ˜¯torch.nn.utils.clip_grad_norm_ 1234567loss = criterion(output,y)model.zero_grad()loss.backward()for p in model.parameters():\tprint(p.grad.norm())\ttorch.nn.utils.clip_grad_norm_(p,10) # &lt;10optimizer.step() æ¢¯åº¦åœ¨10å·¦å³æ¯”è¾ƒåˆé€‚ æ¢¯åº¦å¼¥æ•£ RNNæ¢¯åº¦å¼¥æ•£çš„è§£å†³æ–¹æ³•ï¼Œè¯·è§ä¸‹èŠ‚è¯¾æ‰€è®²çš„LSTM LSTM å¤§ä½“ç»“æ„å’ŒRNNç›¸åŒåªæ˜¯å¤šäº†ä¸‰ä¸ªÏƒ\\sigmaÏƒ(sigmoid)å‡½æ•°æ¥ä½œä¸ºé—¨ï¼Œè¿™ä¸‰é“é—¨åˆ†åˆ«å«åšForget gate,Input gate,Output gate ä¸åŒäºRNNï¼ŒLSTMçš„CtC_tCtâ€‹çš„ä½œç”¨æ‰æ˜¯memoryï¼ˆRNNä¸­æ˜¯hth_thtâ€‹ï¼‰ ä¸‰ä¸ªSigmoid Forget gate ft=Ïƒ(Wfâ‹…[htâˆ’1,xt]+bf)f_t=\\sigma (W_f \\cdot [h_{t-1},x_t] + b_f) ftâ€‹=Ïƒ(Wfâ€‹â‹…[htâˆ’1â€‹,xtâ€‹]+bfâ€‹) Input gate it=Ïƒ(Wiâ‹…[htâˆ’1,xt]+bi)i_t=\\sigma(W_i\\cdot [h_{t-1},x_t]+b_i) itâ€‹=Ïƒ(Wiâ€‹â‹…[htâˆ’1â€‹,xtâ€‹]+biâ€‹) C~t=tanh(WCâ‹…[htâˆ’1,xt]+bC)\\tilde{C}_t=tanh(W_C\\cdot [h_{t-1},x_t]+b_C) C~tâ€‹=tanh(WCâ€‹â‹…[htâˆ’1â€‹,xtâ€‹]+bCâ€‹) æ›´æ–°C Ct=ftâˆ—Ctâˆ’1+itâˆ—C~tC_t=f_t*C_{t-1}+i_t*\\tilde{C}_t Ctâ€‹=ftâ€‹âˆ—Ctâˆ’1â€‹+itâ€‹âˆ—C~tâ€‹ Output gate ot=Ïƒ(Wo[htâˆ’1,xt]+bo)o_t=\\sigma (W_o[h_{t-1},x_t]+b_o) otâ€‹=Ïƒ(Woâ€‹[htâˆ’1â€‹,xtâ€‹]+boâ€‹) ht=otâˆ—tanh(Ct)h_t=o_t*tanh(C_t) htâ€‹=otâ€‹âˆ—tanh(Ctâ€‹) LSTMè¡Œä¸º input gate forget gate behavior 0 1 è®°ä½è¿‡å»çš„å€¼ 1 1 å°†ç°åœ¨çš„å€¼åŠ å…¥è®°å¿† 0 0 æŠ¹é™¤æ‰€æœ‰çš„è®°å¿† 1 0 å¿˜æ‰è¿‡å»çš„ï¼ŒåŠ å…¥ç°åœ¨çš„ Forgeté—¨å«Rememberæ›´åŠ åˆç†ä¸€äº› LSTMè§£å†³æ¢¯åº¦å¼¥æ•£ å› ä¸ºæ•°å­¦åŸç†ç¨å¾®å¤æ‚ï¼Œæ‰€ä»¥è¿™é‡Œåªæ”¾å‡ºä¸€å¼ å›¾ä¾›å¤§å®¶å‚è€ƒï¼Œæœ‰å…´è¶£å¯ä»¥ä¸‹æ¥è‡ªè¡Œç™¾åº¦ã€‚ç®€å•ç›´è§‚ç†è§£å°±æ˜¯ï¼ŒLSTMå› ä¸ºåŠ å…¥äº†input gate forget gateç­‰ç»“æ„ï¼ŒåŸç†ä¸Šç±»ä¼¼ResNetï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä¸€ä¸ªRNNå•å…ƒå¯èƒ½é€€åŒ–æˆç›´è¿ï¼ˆç±»ä¼¼äºResNetä¸­é€€åŒ–æˆåªæœ‰shortcutï¼‰ã€‚å› æ­¤ä¸€å®šç¨‹åº¦ä¸Šè§£å†³äº†æ¢¯åº¦å¼¥æ•£é—®é¢˜ã€‚ LSTM Layer nn.LSTM __init()__ å’Œnn.RNNåˆå§‹åŒ–æ“ä½œä¸€æ ·: nn.LSTM(input_size,hidden_size,num_layers) æ³¨æ„ï¼šnn.LSTMä¸­çš„CCCå’Œhhhçš„ç»´åº¦å¤§å°æ˜¯ä¸€æ ·çš„ï¼Œéƒ½ç”¨hidden_sizeè¿›è¡Œè¡¨ç¤º LSTM.forward() 1out,(ht,ct)=lstm(x,[ht_1,ct_1]) xï¼štensorå¤§å°ä¸º[seq,b,vec][seq,b,vec][seq,b,vec] h/cï¼štensorå¤§å°ä¸º[numlayer,b,h][num_layer,b,h][numlâ€‹ayer,b,h] outï¼štensorå¤§å°ä¸º[seq,b,h][seq,b,h][seq,b,h] æ³¨æ„ï¼šoutè¾“å‡ºçš„æ˜¯hä¸æ˜¯c ä¸‹é¢è¿˜æ˜¯ç®€å•ç»™å‡ºä¸€ä¸ªä¾‹å­ï¼Œå¸®åŠ©ç†è§£ï¼š 123456789In [3]: from torch import nnIn [4]: lstm=nn.LSTM(input_size=100, hidden_size=20, num_layers=4)In [5]: lstmOut[5]: LSTM(100, 20, num_layers=4)In [6]: x=torch.randn(10,3,100)In [7]: out,(h,c)=lstm(x)In [8]: out.shape,h.shape,c.shapeOut[8]: (torch.Size([10, 3, 20]), torch.Size([4, 3, 20]), torch.Size([4, 3, 20])) å…¶å®å’ŒåŸæ¥çš„RNNä½¿ç”¨å·®åˆ«ä¸æ˜¯éå¸¸å¤§ nn.LSTMCell __init()__ å’Œnn.LSTMåˆå§‹åŒ–æ“ä½œä¸€æ ·: nn.LSTM(input_size,hidden_size,num_layers) LSTMCell.forward() 1ht,ct=lstmcell(xt,[ht_1,ct_1]) å¯¹äºä¸€ä¸ªè¾“å…¥æ˜¯[10,3,100]çš„æ•°æ®ï¼Œä½¿ç”¨ä¸Šè¿°æ–¹æ³•éœ€è¦é€å…¥10æ¬¡ï¼Œæ¯æ¬¡é€å…¥å¤§å°æ˜¯[3,100] åŒç†ï¼Œç›¸æ¯”LSTMï¼ŒLSTMCellæ›´åŠ çš„çµæ´»ï¼Œæˆ‘ä»¬æ›´æ¨èè¿™æ ·çš„æ–¹å¼ åŒä¸Šï¼Œä¸‹é¢è¿˜æ˜¯ç®€å•ç»™å‡ºä¸€ä¸ªä¾‹å­ï¼Œå¸®åŠ©ç†è§£ï¼š 123456789101112131415In [3]: from torch import nnIn [4]: xt=torch.randn(10,3,100)In [5]: cell1=nn.LSTMCell(input_size=100,hidden_size=30)In [6]: cell2=nn.LSTMCell(input_size=30,hidden_size=20)In [7]: h1=torch.zeros(3,30)In [8]: c1=torch.zeros(3,30)In [9]: h2=torch.zeros(3,20)In [10]: c2=torch.zeros(3,20)In [11]: for x in xt: ...: h1,c1=cell1(x,[h1,c1]) ...: h2,c2=cell2(h1,[h2,c2]) In [12]: h2.shape,c2.shapeOut[12]: (torch.Size([3, 20]), torch.Size([3, 20])) LSTMæƒ…æ„Ÿåˆ†ç±»å®æˆ˜ å®‰åˆ©ï¼šGoogle CoLab å…è´¹12Hè®­ç»ƒ å…è´¹K80GPU ç•Œé¢ç±»ä¼¼Jupyterï¼Œæˆ‘ä»¬åªéœ€è¦æŠŠæˆ‘ä»¬çš„ä»£ç æ‰”ä¸Šå»å°±å¯ä»¥è·‘å•¦ã€‚ æ•°æ®å¯¼å…¥ 12345TEXT = data.Field(tokenize=&#x27;spacy&#x27;)LABEL = data.LabelField(dtype=torch.float)train_data, test_data = datasets.IMDB.splits(TEXT, LABEL)print(&#x27;len of train data:&#x27;, len(train_data))print(&#x27;len of test data:&#x27;, len(test_data)) è¿è¡Œç»“æœ 12len of train data: 25000len of test data: 25000 æ‰“å‡ºæ•°æ®ä¸­çš„ä¸€ä¸ªexampleè¿›è¡Œè§‚å¯Ÿ 12print(train_data.examples[15].text)print(train_data.examples[15].label) 12[&#x27;Well&#x27;, &#x27;when&#x27;, &#x27;watching&#x27;, &#x27;this&#x27;, &#x27;film&#x27;, &#x27;late&#x27;, &#x27;one&#x27;, &#x27;night&#x27;, &#x27;I&#x27;, &#x27;was&#x27;, &#x27;simple&#x27;, &#x27;amazed&#x27;, &#x27;by&#x27;, &#x27;it&#x27;, &quot;&#x27;s&quot;, &#x27;greatness&#x27;, &#x27;.&#x27;, &#x27;Fantastic&#x27;, &#x27;script&#x27;, &#x27;,&#x27;, &#x27;great&#x27;, &#x27;acting&#x27;, &#x27;,&#x27;, &#x27;costumes&#x27;, &#x27;and&#x27;, &#x27;special&#x27;, &#x27;effects&#x27;, &#x27;,&#x27;, &#x27;and&#x27;, &#x27;the&#x27;, &#x27;plot&#x27;, &#x27;twists&#x27;, &#x27;,&#x27;, &#x27;wow&#x27;, &#x27;!&#x27;, &#x27;!&#x27;, &#x27;In&#x27;, &#x27;fact&#x27;, &#x27;if&#x27;, &#x27;you&#x27;, &#x27;can&#x27;, &#x27;see&#x27;, &#x27;the&#x27;, &#x27;ending&#x27;, &#x27;coming&#x27;, &#x27;you&#x27;, &#x27;should&#x27;, &#x27;become&#x27;, &#x27;a&#x27;, &#x27;writer&#x27;, &#x27;yourself.&lt;br&#x27;, &#x27;/&gt;&lt;br&#x27;, &#x27;/&gt;Great&#x27;, &#x27;,&#x27;, &#x27;I&#x27;, &#x27;would&#x27;, &#x27;recommend&#x27;, &#x27;this&#x27;, &#x27;film&#x27;, &#x27;to&#x27;, &#x27;anyone&#x27;, &#x27;,&#x27;, &#x27;especially&#x27;, &#x27;if&#x27;, &#x27;I&#x27;, &#x27;don;t&#x27;, &#x27;like&#x27;, &#x27;them&#x27;, &#x27;much.&lt;br&#x27;, &#x27;/&gt;&lt;br&#x27;, &#x27;/&gt;Terrific&#x27;]pos ä½¿ç”¨GloVeå¯¹æ•°æ®ç¼–ç  123456789101112# word2vec, gloveTEXT.build_vocab(train_data, max_size=10000, vectors=&#x27;glove.6B.100d&#x27;)LABEL.build_vocab(train_data)batchsz = 30device = torch.device(&#x27;cuda&#x27;)train_iterator, test_iterator = data.BucketIterator.splits( (train_data, test_data), batch_size = batchsz, device=device) ç½‘ç»œè®¾è®¡â€» 12345678910111213141516171819202122232425262728293031323334353637class RNN(nn.Module): def __init__(self, vocab_size, embedding_dim, hidden_dim): &quot;&quot;&quot; &quot;&quot;&quot; super(RNN, self).__init__() # [0-10001] =&gt; [100] self.embedding = nn.Embedding(vocab_size, embedding_dim) # [100] =&gt; [256] self.rnn = nn.LSTM(embedding_dim, hidden_dim, num_layers=2, bidirectional=True, dropout=0.5) # [256*2] =&gt; [1] self.fc = nn.Linear(hidden_dim*2, 1) self.dropout = nn.Dropout(0.5) def forward(self, x): &quot;&quot;&quot; x: [seq_len, b] vs [b, 3, 28, 28] &quot;&quot;&quot; # [seq, b, 1] =&gt; [seq, b, 100] embedding = self.dropout(self.embedding(x)) # output: [seq, b, hid_dim*2] # hidden/h: [num_layers*2, b, hid_dim] # cell/c: [num_layers*2, b, hid_di] output, (hidden, cell) = self.rnn(embedding) # [num_layers*2, b, hid_dim] =&gt; 2 of [b, hid_dim] =&gt; [b, hid_dim*2] hidden = torch.cat([hidden[-2], hidden[-1]], dim=1) # [b, hid_dim*2] =&gt; [b, 1] hidden = self.dropout(hidden) out = self.fc(hidden) return out å› ä¸ºnn.LSTMé‡‡ç”¨çš„æ˜¯åŒå‘bidirectional=True,å› æ­¤åé¢å…¨è¿æ¥å±‚çš„hidden_sizeè¦ä¹˜2ã€‚æœ€åLSTMç®—å‡ºæ¥çš„hiddenéƒ¨åˆ†ï¼Œæœ€åä¸¤å±‚å°±æ˜¯å®é™…ç½‘ç»œçš„æœ€åä¸€å±‚ï¼Œåªä¸è¿‡æ˜¯ä¸¤ä¸ªæ–¹å‘ï¼Œæ‰€ä»¥ç»´åº¦ä¸Šå äº†ä¸¤å±‚ã€‚ `vocab_size`è¡¨ç¤ºçš„æ˜¯æœ‰å¤šå°‘ä¸ªå•è¯ï¼Œ`embedding_dim`è¡¨ç¤ºçš„æ˜¯è¡¨ç¤ºä¸€ä¸ªå•è¯éœ€è¦å¤šé•¿ç»´åº¦çš„å‘é‡ã€‚æœ€åä¸€ä¸ªdropoutçš„å¼•å…¥æ˜¯ä¸ºäº†åŠ å¼ºç½‘ç»œçš„é²æ£’æ€§è€Œå¼•å…¥çš„ã€‚ è®­ç»ƒéƒ¨åˆ† 123456789101112131415161718192021222324252627282930313233343536optimizer = optim.Adam(rnn.parameters(), lr=1e-3)criteon = nn.BCEWithLogitsLoss().to(device)rnn.to(device)def binary_acc(preds, y): &quot;&quot;&quot; get accuracy &quot;&quot;&quot; preds = torch.round(torch.sigmoid(preds)) correct = torch.eq(preds, y).float() acc = correct.sum() / len(correct) return accdef train(rnn, iterator, optimizer, criteon): avg_acc = [] rnn.train() for i, batch in enumerate(iterator): # [seq, b] =&gt; [b, 1] =&gt; [b] pred = rnn(batch.text).squeeze(1) # å°†ç¬¬ä¸€ä¸ªç»´åº¦çš„ä¿¡æ¯å‹ç¼©æ‰ # loss = criteon(pred, batch.label) acc = binary_acc(pred, batch.label).item() avg_acc.append(acc) optimizer.zero_grad() loss.backward() optimizer.step() if i%10 == 0: print(i, acc) # ä¸€è½®è®­ç»ƒç»“æŸåæ‰“å‡ºè®­ç»ƒè¿‡ç¨‹ä¸­çš„å¹³å‡å‡†ç¡®ç‡ avg_acc = np.array(avg_acc).mean() print(&#x27;avg acc:&#x27;, avg_acc) evaléƒ¨åˆ† 123456789101112131415161718192021def eval(rnn, iterator, criteon): avg_acc = [] rnn.eval() # åˆ‡æ¢çŠ¶æ€ with torch.no_grad(): for batch in iterator: # [b, 1] =&gt; [b] pred = rnn(batch.text).squeeze(1) # loss = criteon(pred, batch.label) acc = binary_acc(pred, batch.label).item() avg_acc.append(acc) avg_acc = np.array(avg_acc).mean() print(&#x27;&gt;&gt;test:&#x27;, avg_acc) mainéƒ¨åˆ† 1234for epoch in range(10): eval(rnn, test_iterator, criteon) train(rnn, train_iterator, optimizer, criteon) è¿è¡Œç»“æœï¼š 123456789101112131415161718192021222324252627282930&gt;&gt;test: 0.49976021360507690 0.4666666984558105510 0.4000000357627868720 0.530 0.540 0.433333367109298750 0.533333361148834260 0.600000023841857970 0.566666722297668580 0.4000000357627868790 0.36666667461395264100 0.5333333611488342110 0.6666666865348816120 0.7333333492279053130 0.4333333671092987140 0.6000000238418579150 0.5333333611488342160 0.5170 0.46666669845581055180 0.6333333849906921190 0.6666666865348816200 0.40000003576278687210 0.46666669845581055220 0.5666667222976685230 0.5...810 0.9666666984558105820 0.9666666984558105830 0.9666666984558105avg acc: 0.9673461499545786 æ±‡æ€» 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157# -*- coding: utf-8 -*-&quot;&quot;&quot;lstmAutomatically generated by Colaboratory.Original file is located at https://colab.research.google.com/drive/1GX0Rqur8T45MSYhLU9MYWAbycfLH4-Fu&quot;&quot;&quot;!pip install torch!pip install torchtext!python -m spacy download en# K80 gpu for 12 hoursimport torchfrom torch import nn, optimfrom torchtext import data, datasetsprint(&#x27;GPU:&#x27;, torch.cuda.is_available())torch.manual_seed(123)TEXT = data.Field(tokenize=&#x27;spacy&#x27;)LABEL = data.LabelField(dtype=torch.float)train_data, test_data = datasets.IMDB.splits(TEXT, LABEL)print(&#x27;len of train data:&#x27;, len(train_data))print(&#x27;len of test data:&#x27;, len(test_data))print(train_data.examples[15].text)print(train_data.examples[15].label)# word2vec, gloveTEXT.build_vocab(train_data, max_size=10000, vectors=&#x27;glove.6B.100d&#x27;)LABEL.build_vocab(train_data)batchsz = 30device = torch.device(&#x27;cuda&#x27;)train_iterator, test_iterator = data.BucketIterator.splits( (train_data, test_data), batch_size = batchsz, device=device)class RNN(nn.Module): def __init__(self, vocab_size, embedding_dim, hidden_dim): &quot;&quot;&quot; &quot;&quot;&quot; super(RNN, self).__init__() # [0-10001] =&gt; [100] self.embedding = nn.Embedding(vocab_size, embedding_dim) # [100] =&gt; [256] self.rnn = nn.LSTM(embedding_dim, hidden_dim, num_layers=2, bidirectional=True, dropout=0.5) # [256*2] =&gt; [1] self.fc = nn.Linear(hidden_dim*2, 1) self.dropout = nn.Dropout(0.5) def forward(self, x): &quot;&quot;&quot; x: [seq_len, b] vs [b, 3, 28, 28] &quot;&quot;&quot; # [seq, b, 1] =&gt; [seq, b, 100] embedding = self.dropout(self.embedding(x)) # output: [seq, b, hid_dim*2] # hidden/h: [num_layers*2, b, hid_dim] # cell/c: [num_layers*2, b, hid_di] output, (hidden, cell) = self.rnn(embedding) # [num_layers*2, b, hid_dim] =&gt; 2 of [b, hid_dim] =&gt; [b, hid_dim*2] hidden = torch.cat([hidden[-2], hidden[-1]], dim=1) # [b, hid_dim*2] =&gt; [b, 1] hidden = self.dropout(hidden) out = self.fc(hidden) return outrnn = RNN(len(TEXT.vocab), 100, 256)pretrained_embedding = TEXT.vocab.vectorsprint(&#x27;pretrained_embedding:&#x27;, pretrained_embedding.shape)rnn.embedding.weight.data.copy_(pretrained_embedding)print(&#x27;embedding layer inited.&#x27;)optimizer = optim.Adam(rnn.parameters(), lr=1e-3)criteon = nn.BCEWithLogitsLoss().to(device)rnn.to(device)import numpy as npdef binary_acc(preds, y): &quot;&quot;&quot; get accuracy &quot;&quot;&quot; preds = torch.round(torch.sigmoid(preds)) correct = torch.eq(preds, y).float() acc = correct.sum() / len(correct) return accdef train(rnn, iterator, optimizer, criteon): avg_acc = [] rnn.train() for i, batch in enumerate(iterator): # [seq, b] =&gt; [b, 1] =&gt; [b] pred = rnn(batch.text).squeeze(1) # loss = criteon(pred, batch.label) acc = binary_acc(pred, batch.label).item() avg_acc.append(acc) optimizer.zero_grad() loss.backward() optimizer.step() if i%10 == 0: print(i, acc) avg_acc = np.array(avg_acc).mean() print(&#x27;avg acc:&#x27;, avg_acc) def eval(rnn, iterator, criteon): avg_acc = [] rnn.eval() with torch.no_grad(): for batch in iterator: # [b, 1] =&gt; [b] pred = rnn(batch.text).squeeze(1) # loss = criteon(pred, batch.label) acc = binary_acc(pred, batch.label).item() avg_acc.append(acc) avg_acc = np.array(avg_acc).mean() print(&#x27;&gt;&gt;test:&#x27;, avg_acc)for epoch in range(10): eval(rnn, test_iterator, criteon) train(rnn, train_iterator, optimizer, criteon)"},{"title":"PyTorch è‡ªå®šä¹‰æ•°æ®é›†å®æˆ˜","path":"/wiki/PyTorch/PyTorch è‡ªå®šä¹‰æ•°æ®é›†å®æˆ˜.html","content":"åœ¨å‰é¢çš„å­¦ä¹ ä¸­ï¼Œæˆ‘ä»¬å·²ç»è¾ƒä¸ºç†Ÿç»ƒçš„æŒæ¡äº†ä¸åŒç§ç±»ç¥ç»ç½‘ç»œçš„åŸç†å’ŒåŸºæœ¬PyTorchå®ç°ï¼Œä½†æ˜¯ä¹‹å‰æˆ‘ä»¬æ‰€ä½¿ç”¨çš„æ•°æ®é›†å¤šä¸ºPyTorchä¸­ç°æˆçš„ï¼Œå¹¶æ²¡æœ‰è‡ªå·±æå–æ•°æ®çš„è¿™ä¸€è¿‡ç¨‹ï¼Œæ‰€ä»¥æœ¬ç¯‡åšå®¢æ—¨åœ¨é‡‡ç”¨è‡ªå®šä¹‰æ•°æ®é›†ï¼Œå¸®åŠ©å¤§å®¶ä½“éªŒä¸€æ¬¡åŒ…å«æ•°æ®æå–ï¼Œæ•°æ®è®­ç»ƒï¼Œæ•°æ®æµ‹è¯•çš„å®Œæ•´çš„ç¥ç»ç½‘ç»œæ•°æ®å¤„ç†è¿‡ç¨‹ã€‚ Pokemon æ•°æ®é›† æ•°æ®é›†åŸºæœ¬ä¿¡æ¯ æœ¬æ¬¡å®æˆ˜ï¼Œé‡‡ç”¨Pokemonè‡ªå®šä¹‰æ•°æ®é›†ï¼Œæ•°æ®é›†ä¸­åŒ…å«5ç§ç±»å‹çš„ç²¾çµ æ•°æ®é›†ä¸­æ‰€åŒ…å«çš„å›¾ç‰‡çš„æ•°é‡åˆ†åˆ«æ˜¯ï¼š çš®å¡ä¸˜ ï¼š234 è¶…æ¢¦ï¼š 239 æ°å°¼é¾Ÿï¼š 223 å°ç«é¾™ï¼š 238 å¦™è›™ç§å­ï¼š 234 æ•°æ®é›†åˆ’åˆ† å®æˆ˜æ­¥éª¤ æ•°æ®é›†åŠ è½½ï¼ˆLoad dataï¼‰â€» åˆ›å»ºæ¨¡å‹ï¼ˆBuild modelï¼‰ è®­ç»ƒå’Œæµ‹è¯•ï¼ˆTrain and Testï¼‰ è¿ç§»å­¦ä¹ ï¼ˆTransfer Learningï¼‰â€» æ•°æ®é›†åŠ è½½ è¿™ä¸€éƒ¨åˆ†çš„å·¥ä½œä¸»è¦å°±æ˜¯è¦ç»§æ‰¿çˆ¶ç±»ï¼ˆtorch.utils.data.Datasetï¼‰å¹¶ä¸”å®ç°è¯¥ç±»ä¸‹çš„ä¸¤ä¸ªå‡½æ•° __len__:è¿”å›æ ·æœ¬é•¿åº¦ __getitem__:å–å‡ºæ ·æœ¬ ä¸¾ä¸ªä¾‹å­ï¼š 12345678910class NumberDataset(Dataset): def __init__(self,training=True): if training: self.samples = list(range(1,1001)) else: self.samples = list(range(1001,1501)) def __len__(self): return len(self.samples) def __getitem__(self, idx): return self.samples[idx] äº†è§£äº†æ•°æ®é›†PyTorchä¸­çš„åŠ è½½æ–¹æ³•ï¼Œä¸‹é¢æ¥ä»‹ç»ä¸€ä¸‹æœ¬æ¬¡é¡¹ç›®éœ€è¦å®Œæˆçš„æ•°æ®é¢„å¤„ç†ç›¸å…³æ“ä½œã€‚ æ•°æ®é¢„å¤„ç†æ­¥éª¤ï¼ˆPreprocessingï¼‰ Image Resize 224*224 for ResNet 18 Data Argumentation Rotate Crop Normalize Mean,std ToTensor æ•°æ®é›†å­˜æ”¾æ–‡ä»¶ç»“æ„ 123456pokemanâ”œâ”€bulbasaurâ”œâ”€charmanderâ”œâ”€mewtwoâ”œâ”€pikachuâ””â”€squirtle å¯ä»¥å‘ç°æ˜¯5ç§ç²¾çµæ˜¯åˆ†äº†5ä¸ªæ–‡ä»¶å¤¹ï¼Œæˆ‘ä»¬æ‰“å¼€pikachuæ–‡ä»¶å¤¹ï¼Œå¯ä»¥çœ‹åˆ°é‡Œé¢çš„å›¾ç‰‡æ•°æ®æ˜¯è¿™æ ·çš„ã€‚ è¿™æ ·å­˜æ”¾çš„å¥½å¤„æ˜¯ï¼Œä½¿ç”¨PyTorchå¯ä»¥ç›´æ¥ä¸€è¡Œä»£ç å¯¼å…¥æ‰€æœ‰çš„æ•°æ®ã€‚åé¢æˆ‘ä»¬ä¼šè¿›è¡Œè®²è§£ã€‚ PyTorchå®ç° é¦–å…ˆæ˜¯åå­—ç±»åˆ«çš„æ˜ å°„ name2label 12345678910111213def __init__(self, root, resize, mode): super(Pokemon, self).__init__() # è°ƒç”¨çˆ¶ç±»åˆå§‹åŒ–å‡½æ•° self.root = root self.resize = resize # åˆ›å»ºç±»åˆ«å’Œæ ‡ç­¾æ˜ å°„è¡¨ self.name2label=&#123;&#125; for name in sorted(os.listdir((os.path.join(root)))): if not os.path.isdir(os.path.join(root,name)): continue self.name2label[name] = len(self.name2label.keys()) # è°ƒè¯•ä»£ç  print(self.name2label) è¿™é‡Œå› ä¸ºlistdirè¿”å›çš„é¡ºåºä¸ç¨³å®šï¼Œæ‰€ä»¥è¿”å›åå¢åŠ ä¸€ä¸ªsortedå‡½æ•°å¯¹åå­—æ’åºï¼Œè¿™æ ·å°±ä¿è¯äº†è¿”å›çš„é¡ºåºç¨³å®šçš„é—®é¢˜ã€‚ ç»“æœå¦‚ä¸‹ï¼š 1&#123;&#x27;bulbasaur&#x27;: 0, &#x27;charmander&#x27;: 1, &#x27;mewtwo&#x27;: 2, &#x27;pikachu&#x27;: 3, &#x27;squirtle&#x27;: 4&#125; æ³¨æ„__getitem__é‡å†™çš„æ—¶å€™è¦å°†å›¾ç‰‡é‡Œé¢çš„ä¿¡æ¯æå–å‡ºæ¥ï¼Œè€Œä¸æ˜¯å›¾ç‰‡çš„è·¯å¾„ï¼ï¼ï¼ load_csvåŠ è½½æ–‡ä»¶ä¿¡æ¯ è¿™ä¸ªå‡½æ•°ä¹Ÿæ˜¯å†™åœ¨æˆ‘ä»¬è‡ªå·±çš„Classä¸­çš„ï¼Œç›®çš„æ˜¯æ ¹æ®ä¸€ä¸ªæ•°æ®é›†åŠ è½½ä¸€ä¸ªæ•°æ®é›†ä¿¡æ¯çš„csvæ–‡ä»¶(å¦‚æœæ²¡æœ‰å°±å…ˆåˆ›å»ºä¸€ä¸ªç„¶åå†åŠ è½½)ï¼Œæ–‡ä»¶ä¸­å­˜å‚¨æ¯ä¸€ä¸ªæ•°æ®çš„å­˜æ”¾ä½ç½®ä»¥åŠæ ‡ç­¾ä¿¡æ¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839def load_csv(self, filename):\t# æ²¡æœ‰csvæ•°æ®é›†ä¿¡æ¯æ–‡ä»¶ï¼Œç”Ÿæˆä¸€ä¸ª if not os.path.exists(os.path.join(self.root, filename)): images = [] for name in self.name2label.keys(): # &#x27;pokemon\\\\mewtwo\\\\00001.png images += glob.glob(os.path.join(self.root, name, &#x27;*.png&#x27;)) images += glob.glob(os.path.join(self.root, name, &#x27;*.jpg&#x27;)) images += glob.glob(os.path.join(self.root, name, &#x27;*.jpeg&#x27;)) # 1167, &#x27;pokemon\\\\bulbasaur\\\\00000000.png&#x27; print(len(images), images) random.shuffle(images) with open(os.path.join(self.root, filename), mode=&#x27;w&#x27;, newline=&#x27;&#x27;) as f: writer = csv.writer(f) for img in images: # &#x27;pokemon\\\\bulbasaur\\\\00000000.png&#x27; name = img.split(os.sep)[-2] label = self.name2label[name] # &#x27;pokemon\\\\bulbasaur\\\\00000000.png&#x27;, 0 writer.writerow([img, label]) print(&#x27;writen into csv file:&#x27;, filename) # å¦‚æœå­˜åœ¨csvæ•°æ®é›†ä¿¡æ¯æ–‡ä»¶ï¼Œåˆ™è¯»å– # read from csv file images, labels = [], [] with open(os.path.join(self.root, filename)) as f: reader = csv.reader(f) for row in reader: # &#x27;pokemon\\\\bulbasaur\\\\00000000.png&#x27;, 0 img, label = row label = int(label) images.append(img) labels.append(label) assert len(images) == len(labels) return images, labels globæ˜¯pythonè‡ªå·±å¸¦çš„ä¸€ä¸ªæ–‡ä»¶æ“ä½œç›¸å…³æ¨¡å—ï¼Œç”¨å®ƒå¯ä»¥æŸ¥æ‰¾ç¬¦åˆè‡ªå·±ç›®çš„çš„æ–‡ä»¶.è¯¥æ–¹æ³•è¿”å›æ‰€æœ‰åŒ¹é…çš„æ–‡ä»¶è·¯å¾„åˆ—è¡¨ï¼ˆlistï¼‰ï¼›è¯¥æ–¹æ³•éœ€è¦ä¸€ä¸ªå‚æ•°ç”¨æ¥æŒ‡å®šåŒ¹é…çš„è·¯å¾„å­—ç¬¦ä¸²ï¼ˆå­—ç¬¦ä¸²å¯ä»¥ä¸ºç»å¯¹è·¯å¾„ä¹Ÿå¯ä»¥ä¸ºç›¸å¯¹è·¯å¾„ï¼‰ï¼Œå…¶è¿”å›çš„æ–‡ä»¶ååªåŒ…æ‹¬å½“å‰ç›®å½•é‡Œçš„æ–‡ä»¶åï¼Œä¸åŒ…æ‹¬å­æ–‡ä»¶å¤¹é‡Œçš„æ–‡ä»¶ã€‚ åˆ’åˆ†æ•°æ®é›† åœ¨__init__ä¸­load_csvåï¼Œæˆ‘ä»¬å°±å¯ä»¥è¿›è¡Œæ•°æ®é›†è£å‰ªäº†ã€‚ 123456789101112# image, labelself.images, self.labels = self.load_csv(&#x27;images.csv&#x27;)if mode==&#x27;train&#x27;: # 60% self.images = self.images[:int(0.6*len(self.images))] self.labels = self.labels[:int(0.6*len(self.labels))]elif mode==&#x27;val&#x27;: # 20% = 60%-&gt;80% self.images = self.images[int(0.6*len(self.images)):int(0.8*len(self.images))] self.labels = self.labels[int(0.6*len(self.labels)):int(0.8*len(self.labels))]else: # 20% = 80%-&gt;100% self.images = self.images[int(0.8*len(self.images)):] self.labels = self.labels[int(0.8*len(self.labels)):] å…¶å®æˆ‘æ›´æ¨èçš„æ–¹æ³•æ˜¯å…ˆå°†æ•°æ®é›†å…¨éƒ¨è¯»å‡ºæ¥ï¼Œç„¶åå†å¦å†™ä¸€ä¸ªå‡½æ•°ï¼Œä½¿ç”¨PyTorchæä¾›çš„subsetæ–¹æ³•å¯¹æ•°æ®é›†è¿›è¡Œåˆ’åˆ†ã€‚è¯¦æƒ…å¯ä»¥è§PyTorchæŠ€å·§ä¸­Kfoldè¿™ä¸€ä¸ªæ¨¡å—ã€‚ æ•°æ®å¢å¼º æˆ‘ä»¬æ˜¯åœ¨å–æ•°æ®çš„æ—¶å€™å¯¹æ•°æ®è¿›è¡Œæ•°æ®å¢å¼ºæ“ä½œ 12345678910111213141516171819202122def __getitem__(self, idx): # idx~[0~len(images)] # self.images, self.labels # img: &#x27;pokemon\\\\bulbasaur\\\\00000000.png&#x27; # label: 0 img, label = self.images[idx], self.labels[idx] tf = transforms.Compose([ lambda x:Image.open(x).convert(&#x27;RGB&#x27;), # string path= &gt; image data transforms.Resize((int(self.resize*1.25), int(self.resize*1.25))), transforms.RandomRotation(15), transforms.CenterCrop(self.resize), transforms.ToTensor(), transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]) ]) img = tf(img) label = torch.tensor(label) return img, label Classéƒ¨åˆ†ä»£ç æ±‡æ€» 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119class Pokemon(Dataset): def __init__(self, root, resize, mode): super(Pokemon, self).__init__() self.root = root self.resize = resize self.name2label = &#123;&#125; # &quot;sq...&quot;:0 for name in sorted(os.listdir(os.path.join(root))): if not os.path.isdir(os.path.join(root, name)): continue self.name2label[name] = len(self.name2label.keys()) # print(self.name2label) # image, label self.images, self.labels = self.load_csv(&#x27;images.csv&#x27;) if mode==&#x27;train&#x27;: # 60% self.images = self.images[:int(0.6*len(self.images))] self.labels = self.labels[:int(0.6*len(self.labels))] elif mode==&#x27;val&#x27;: # 20% = 60%-&gt;80% self.images = self.images[int(0.6*len(self.images)):int(0.8*len(self.images))] self.labels = self.labels[int(0.6*len(self.labels)):int(0.8*len(self.labels))] else: # 20% = 80%-&gt;100% self.images = self.images[int(0.8*len(self.images)):] self.labels = self.labels[int(0.8*len(self.labels)):] def load_csv(self, filename): if not os.path.exists(os.path.join(self.root, filename)): images = [] for name in self.name2label.keys(): # &#x27;pokemon\\\\mewtwo\\\\00001.png images += glob.glob(os.path.join(self.root, name, &#x27;*.png&#x27;)) images += glob.glob(os.path.join(self.root, name, &#x27;*.jpg&#x27;)) images += glob.glob(os.path.join(self.root, name, &#x27;*.jpeg&#x27;)) # 1167, &#x27;pokemon\\\\bulbasaur\\\\00000000.png&#x27; print(len(images), images) random.shuffle(images) with open(os.path.join(self.root, filename), mode=&#x27;w&#x27;, newline=&#x27;&#x27;) as f: writer = csv.writer(f) for img in images: # &#x27;pokemon\\\\bulbasaur\\\\00000000.png&#x27; name = img.split(os.sep)[-2] label = self.name2label[name] # &#x27;pokemon\\\\bulbasaur\\\\00000000.png&#x27;, 0 writer.writerow([img, label]) print(&#x27;writen into csv file:&#x27;, filename) # read from csv file images, labels = [], [] with open(os.path.join(self.root, filename)) as f: reader = csv.reader(f) for row in reader: # &#x27;pokemon\\\\bulbasaur\\\\00000000.png&#x27;, 0 img, label = row label = int(label) images.append(img) labels.append(label) assert len(images) == len(labels) return images, labels def __len__(self): return len(self.images) def denormalize(self, x_hat): mean = [0.485, 0.456, 0.406] std = [0.229, 0.224, 0.225] # x_hat = (x-mean)/std # x = x_hat*std = mean # x: [c, h, w] # mean: [3] =&gt; [3, 1, 1] mean = torch.tensor(mean).unsqueeze(1).unsqueeze(1) std = torch.tensor(std).unsqueeze(1).unsqueeze(1) # print(mean.shape, std.shape) x = x_hat * std + mean return x def __getitem__(self, idx): # idx~[0~len(images)] # self.images, self.labels # img: &#x27;pokemon\\\\bulbasaur\\\\00000000.png&#x27; # label: 0 img, label = self.images[idx], self.labels[idx] tf = transforms.Compose([ lambda x:Image.open(x).convert(&#x27;RGB&#x27;), # string path= &gt; image data transforms.Resize((int(self.resize*1.25), int(self.resize*1.25))), transforms.RandomRotation(15), transforms.CenterCrop(self.resize), transforms.ToTensor(), transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]) ]) img = tf(img) label = torch.tensor(label) return img, label å…¶ä¸­denormalizeå‡½æ•°åšçš„å·¥ä½œæ˜¯åæ­£åˆ™åŒ– VisdoméªŒè¯è‡ªå®šä¹‰æ•°æ®é›†åŠ è½½æ­£ç¡®æ€§ æˆ‘ä»¬åœ¨ä¸»å‡½æ•°ä¸­å†™ä¸‹å¦‚ä¸‹çš„ä»£ç ï¼š 12345678910111213141516171819import visdomimport timeimport torchvisionviz = visdom.Visdom()db = Pokemon(&#x27;pokemon&#x27;, 64, &#x27;train&#x27;)x,y = next(iter(db))print(&#x27;sample:&#x27;, x.shape, y.shape, y)viz.image(db.denormalize(x), win=&#x27;sample_x&#x27;, opts=dict(title=&#x27;sample_x&#x27;))loader = DataLoader(db, batch_size=32, shuffle=True, num_workers=8)for x,y in loader: viz.images(db.denormalize(x), nrow=8, win=&#x27;batch&#x27;, opts=dict(title=&#x27;batch&#x27;)) viz.text(str(y.numpy()), win=&#x27;label&#x27;, opts=dict(title=&#x27;batch-y&#x27;))time.sleep(10) ä½¿ç”¨Visdomä¹‹å‰ä¸€å®šè¦åœ¨å‘½ä»¤è¡Œå¯åŠ¨Visdomæœ¬åœ°æœåŠ¡å™¨ï¼Œè¾“å…¥ä»¥ä¸‹å‘½ä»¤ 1python -m visdom.server è¿è¡Œæ•ˆæœæ˜¯æ¯è¿‡10sload32å¼ å›¾å‡ºæ¥ï¼Œä¸€æ’8ä¸ªï¼Œä¸€å…±4æ’ã€‚ è‡ªå®šä¹‰æ•°æ®é›†çš„éƒ¨åˆ†å°±å®Œæˆäº†ï¼Œä¸‹é¢å°±è¿›å…¥åˆ°å»ºç«‹æ¨¡å‹çš„é˜¶æ®µäº†ã€‚ å»ºç«‹æ¨¡å‹ è¿™ä¸€é˜¶æ®µåœ¨ä¹‹å‰çš„PyTorch CNNå®æˆ˜éƒ¨åˆ†å·²ç»æœ‰è¿‡è¯¦ç»†çš„è®²è§£äº†ï¼Œè¿™é‡Œå°±ä¸èµ˜è¿°äº†ã€‚ æœ¬å®éªŒä½¿ç”¨çš„ResNet18æ¨¡å‹ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041class ResNet18(nn.Module): def __init__(self, num_class): super(ResNet18, self).__init__() self.conv1 = nn.Sequential( nn.Conv2d(3, 16, kernel_size=3, stride=3, padding=0), nn.BatchNorm2d(16) ) # followed 4 blocks # [b, 16, h, w] =&gt; [b, 32, h ,w] self.blk1 = ResBlk(16, 32, stride=3) # [b, 32, h, w] =&gt; [b, 64, h, w] self.blk2 = ResBlk(32, 64, stride=3) # # [b, 64, h, w] =&gt; [b, 128, h, w] self.blk3 = ResBlk(64, 128, stride=2) # # [b, 128, h, w] =&gt; [b, 256, h, w] self.blk4 = ResBlk(128, 256, stride=2) # [b, 256, 7, 7] self.outlayer = nn.Linear(256*3*3, num_class) def forward(self, x): &quot;&quot;&quot; :param x: :return: &quot;&quot;&quot; x = F.relu(self.conv1(x)) # [b, 64, h, w] =&gt; [b, 1024, h, w] x = self.blk1(x) x = self.blk2(x) x = self.blk3(x) x = self.blk4(x) # print(x.shape) x = x.view(x.size(0), -1) x = self.outlayer(x) return x è®­ç»ƒï¼ŒéªŒè¯ï¼Œæµ‹è¯• ä¸¥æ ¼Trainï¼ŒValï¼ŒTestæ¨¡æ¿â€» 12345678910111213for epoch in range(epochs): train(train_db) if epoch%10==0: # Val val_acc = evaluate(val_db) if val_acc is the best: save_ckpt() # ä¿å­˜å½“å‰ç½‘ç»œå‚æ•° if out_of_patience(): breakload_ckpt # åŠ è½½ç½‘ç»œå‚æ•°test_acc = evaluate(test_db) # test ä»¥åè®­ç»ƒæŒ‰ç…§ä»¥ä¸Šæ¨¡æ¿è¿›è¡Œä¹¦å†™å³å¯ã€‚ æœ¬å®éªŒä¸­æ‰€ä½¿ç”¨çš„ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š evaluateéƒ¨åˆ† 1234567891011121314def evalute(model, loader): model.eval() correct = 0 total = len(loader.dataset) for x,y in loader: x,y = x.to(device), y.to(device) with torch.no_grad(): logits = model(x) pred = logits.argmax(dim=1) correct += torch.eq(pred, y).sum().float().item() return correct / total mainéƒ¨åˆ† 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def main(): model = ResNet18(5).to(device) optimizer = optim.Adam(model.parameters(), lr=lr) criteon = nn.CrossEntropyLoss() best_acc, best_epoch = 0, 0 # ä¿å­˜æœ€ä¼˜æ¨¡å‹å‚æ•° global_step = 0 viz.line([0], [-1], win=&#x27;loss&#x27;, opts=dict(title=&#x27;loss&#x27;)) viz.line([0], [-1], win=&#x27;val_acc&#x27;, opts=dict(title=&#x27;val_acc&#x27;)) for epoch in range(epochs): for step, (x,y) in enumerate(train_loader): # x: [b, 3, 224, 224], y: [b] x, y = x.to(device), y.to(device) model.train() logits = model(x) loss = criteon(logits, y) optimizer.zero_grad() loss.backward() optimizer.step() viz.line([loss.item()], [global_step], win=&#x27;loss&#x27;, update=&#x27;append&#x27;) global_step += 1 if epoch % 1 == 0: val_acc = evalute(model, val_loader) if val_acc&gt; best_acc: best_epoch = epoch best_acc = val_acc torch.save(model.state_dict(), &#x27;best.mdl&#x27;) # ä¿å­˜æœ€ä¼˜æ¨¡å‹å‚æ•° viz.line([val_acc], [global_step], win=&#x27;val_acc&#x27;, update=&#x27;append&#x27;)\t# ç»“æŸtrainå print(&#x27;best acc:&#x27;, best_acc, &#x27;best epoch:&#x27;, best_epoch)\t# åŠ è½½æœ€ä¼˜æ¨¡å‹ model.load_state_dict(torch.load(&#x27;best.mdl&#x27;)) print(&#x27;loaded from ckpt!&#x27;)\t# è¿›è¡Œtest test_acc = evalute(model, test_loader) print(&#x27;test acc:&#x27;, test_acc) å¦‚æœæƒ³è¦å®æ—¶æ£€æµ‹è®­ç»ƒæƒ…å†µï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ä½¿ç”¨visdomå·¥å…·ï¼Œè€Œä¸æ˜¯æœ€åè¿›è¡Œmatplotlibï¼Œå®æ—¶ç›‘æ§å¯ä»¥åœ¨æ¨¡å‹å‡ºç°é—®é¢˜æ—¶åŠæ—¶åœä¸‹æ¥ï¼Œè¿›è¡Œè°ƒæ•´ã€‚(å¦‚ä¸Šé¢çš„ä»£ç æ‰€ç¤º) ç›®å‰ç»“æœ æŒ‰ç…§ä»¥ä¸Šæ­¥éª¤ä¸‹æ¥ï¼Œæˆ‘ä»¬çš„æ¨¡å‹trainä¸‹æ¥çš„lossæ˜¯éå¸¸å°çš„ï¼Œä½†æ˜¯æµ‹è¯•é›†ï¼Œå‡†ç¡®ç‡å¹¶æ²¡æœ‰è¾¾åˆ°ç†æƒ³çš„å‡†ç¡®ç‡ï¼Œè¿™è¯´æ˜æˆ‘ä»¬çš„æ¨¡å‹å‘ç”Ÿäº†è¿‡æ‹Ÿåˆ,å‘ç”Ÿè¿™æ ·çš„äº‹æƒ…éå¸¸çš„æ­£å¸¸ï¼Œå› ä¸ºæˆ‘ä»¬æ•°æ®é›†çš„è§„æ¨¡éå¸¸çš„å°ï¼Œè€Œä¸”ç§ç±»ä¹Ÿä¸å¤šï¼Œå¯¹äºResNet18è¿™ç§è¾ƒä¸ºå¤æ‚çš„ç¥ç»ç½‘ç»œæ˜¯ä¸å¤Ÿçš„ï¼Œå¾ˆå®¹æ˜“å‡ºç°è¿™æ ·çš„é—®é¢˜ï¼Œå› æ­¤ï¼Œè¿™ä¸ªæ—¶å€™å°±æœ‰å¿…è¦ä½¿ç”¨è¿ç§»å­¦ä¹ è§£å†³è¿‡æ‹Ÿåˆçš„é—®é¢˜äº†ã€‚ è¿ç§»å­¦ä¹ ï¼ˆTransfer Learningï¼‰ ç®€è€Œè¨€ä¹‹ï¼Œè¿ç§»å­¦ä¹ æ˜¯ä¸€ç§æœºå™¨å­¦ä¹ æ–¹æ³•ï¼Œå°±æ˜¯æŠŠä¸ºä»»åŠ¡ A å¼€å‘çš„æ¨¡å‹ä½œä¸ºåˆå§‹ç‚¹ï¼Œé‡æ–°ä½¿ç”¨åœ¨ä¸ºä»»åŠ¡ B å¼€å‘æ¨¡å‹çš„è¿‡ç¨‹ä¸­ã€‚ åœ¨æˆ‘ä»¬è¿™é‡Œï¼Œå°±æ˜¯åœ¨è®­ç»ƒå¥½ImageNetæ•°æ®é›†çš„ç¥ç»ç½‘ç»œçš„åŸºç¡€ä¸Šï¼Œæå–å…¶ä¸­è®­ç»ƒå¥½çš„ç½‘ç»œå‚æ•°ï¼ŒåŠ è½½åˆ°è¦è®­ç»ƒå®å¯æ¢¦æ•°æ®é›†çš„ç½‘ç»œä¸­ï¼Œç„¶åå†å¯¹å®å¯æ¢¦æ•°æ®é›†è¿›è¡Œè®­ç»ƒã€‚ è¿™é‡Œæˆ‘ä»¬ç›´æ¥ä½¿ç”¨çš„æ˜¯torchvisionä¸­æä¾›å¥½çš„resnet18æ¨¡å‹ 1from torchvision.models import resnet18 æ­¤ResNet18æ˜¯å·²ç»è®­ç»ƒå¥½çš„æ¨¡å‹ï¼ æˆ‘ä»¬è¦åšçš„å°±æ˜¯å°†å…¶å‰17å±‚æ‹†ä¸‹æ¥ï¼Œç„¶åæœ€åä¸€å±‚æ¥ä¸€å±‚æˆ‘ä»¬è‡ªå·±çš„å…¨è¿æ¥å±‚è¿›è¡Œåˆ†ç±»ã€‚ ä½¿ç”¨children()æ–¹æ³•æ‹†ä¸‹ç½‘ç»œçš„å‰17å±‚ç„¶åä¼ å…¥åˆ°æˆ‘ä»¬è‡ªå·±çš„modelä¸­å»ï¼Œç„¶åå†æ¥Flattenæ“ä½œï¼Œç„¶åæ¥å…¨è¿æ¥å±‚ã€‚ ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼šï¼ˆåªéœ€è¦åœ¨åˆå§‹åŒ–æ¨¡å‹é‚£é‡Œæ”¹å˜ä¸€ç‚¹å³å¯ï¼Œè¿™é‡Œå°±ä¸è´´ä»£ç æ±‡æ€»äº†ï¼‰ 12345trained_model = resnet18(pretrained=True)model = nn.Sequential(*list(trained_model.children())[:-1], #[b, 512, 1, 1] Flatten(), # [b, 512, 1, 1] =&gt; [b, 512] nn.Linear(512, 5) ).to(device) Flattenå±‚ä»£ç ï¼š 12345678class Flatten(nn.Module): def __init__(self): super(Flatten, self).__init__() def forward(self, x): shape = torch.prod(torch.tensor(x.shape[1:])).item() return x.view(-1, shape) ç»“æœ æœ€ç»ˆï¼Œtrain lossåœ¨åŒä¸€æ°´å¹³ä¸‹ï¼ŒéªŒè¯é›†çš„å‡†ç¡®ç‡æé«˜äº†10%å·¦å³ï¼Œä½¿ç”¨è¿ç§»å­¦ä¹ çš„æ•ˆæœæå‡è¿˜æ˜¯éå¸¸æ˜æ˜¾çš„ã€‚"},{"title":"PyTorch è‡ªç¼–ç å™¨","path":"/wiki/PyTorch/PyTorch è‡ªç¼–ç å™¨.html","content":"æˆ‘ä»¬ä¹‹å‰æ‰€å­¦ä¹ çš„çŸ¥è¯†éƒ½æ˜¯ç›‘ç£å­¦ä¹ ï¼Œç›‘ç£å­¦ä¹ å¾ˆå¤šæ˜¯åŸºäºäººçš„ç»éªŒæ¥å¯¹åˆ†ç±»å›å½’é—®é¢˜è¿›è¡Œåˆ¤æ–­ï¼Œç°åœ¨æˆ‘ä»¬æ¥ç ”ç©¶ä¸€äº›å…³äºéç›‘ç£å­¦ä¹ çš„å†…å®¹ã€‚ é¦–å…ˆä¾¿æ˜¯ä¸€ä¸ªé—®é¢˜ï¼Œä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦ç ”ç©¶éç›‘ç£å­¦ä¹ ã€‚ éç›‘ç£å­¦ä¹ çš„æ„ä¹‰ æ•°æ®ç»´åº¦å‡å°‘ï¼ˆDimension reductionï¼‰ é¢„å¤„ç†ï¼ˆPreprocessingï¼‰ å¯è§†åŒ–ï¼ˆVisualizationï¼‰ æ›´å¥½çš„åˆ©ç”¨çœ‹ä¸Šå»ä¸é‡è¦çš„æ•°æ®(Taking advantage of unsupervised data) å‹ç¼©ï¼Œé™å™ªï¼Œè¶…åˆ†è¾¨ç‡(Compression,denoising,super-resolution) ä¸€ä¸ªå¯ä»¥å¯è§†åŒ–æ•°æ®çš„ç½‘ç«™ï¼šhttps://projector.tensorflow.org æ€»è€Œè¨€ä¹‹å°±æ˜¯æ›´å¥½çš„åˆ©ç”¨æ•°æ®ï¼Œå¹¶ä»æ•°æ®ä¸­å‘ç°ä¸€äº›æœ‰ç”¨çš„ä¸œè¥¿ã€‚ Auto-Encoders è‡ªç¼–ç å™¨ï¼ˆautoencoder, AEï¼‰æ˜¯ä¸€ç±»åœ¨åŠç›‘ç£å­¦ä¹ å’Œéç›‘ç£å­¦ä¹ ä¸­ä½¿ç”¨çš„ç¥ç»ç½‘ç»œï¼ˆArtificial Neural Networks, ANNsï¼‰ï¼Œå…¶åŠŸèƒ½æ˜¯é€šè¿‡å°†è¾“å…¥ä¿¡æ¯ä½œä¸ºå­¦ä¹ ç›®æ ‡ï¼Œå¯¹è¾“å…¥ä¿¡æ¯è¿›è¡Œè¡¨å¾å­¦ä¹ ï¼ˆrepresentation learningï¼‰ è‡ªç¼–ç å™¨å…·æœ‰ä¸€èˆ¬æ„ä¹‰ä¸Šè¡¨å¾å­¦ä¹ ç®—æ³•çš„åŠŸèƒ½ï¼Œè¢«åº”ç”¨äº**é™ç»´ï¼ˆdimensionality reductionï¼‰**å’Œå¼‚å¸¸å€¼æ£€æµ‹ï¼ˆanomaly detectionï¼‰ è¾“å…¥è¾“å‡ºä¸€æ ·ï¼Œé‡å»ºè¾“å…¥æ•°æ® ä¸­é—´é‚£ä¸ªå¾ˆå°‘ç¥ç»å…ƒçš„å±‚å«åšneckï¼ˆä¸€èˆ¬æ˜¯å¯¹æ•°æ®è¿›è¡Œé™ç»´ï¼‰ Auto Encoderå°±æ˜¯ä¸€ä¸ªéå¸¸æ™®é€šçš„ç¥ç»ç½‘ç»œ å¦‚ä½•è®­ç»ƒ Loss Function Lose function for real-valued inputs l(f(x))=12âˆ‘k(x^kâˆ’xk)2l(f(x))=\\frac{1}{2}\\sum_k(\\hat{x}_k-x_k)^2 l(f(x))=21â€‹kâˆ‘â€‹(x^kâ€‹âˆ’xkâ€‹)2 x^k\\hat{x}_kx^kâ€‹æ˜¯é‡å»ºåæ•°æ®kä½ç½®çš„å€¼ xkx_kxkâ€‹æ˜¯è¾“å…¥æ•°æ®kä½ç½®çš„å€¼ Loss function for binary inputs l(f(x))=âˆ’âˆ‘k(xkÂ log(x^k)+(1âˆ’xk)log(1âˆ’x^k))l(f(x))=-\\sum_k(x_k\\ log(\\hat{x}_k)+(1-x_k)log(1-\\hat{x}_k)) l(f(x))=âˆ’kâˆ‘â€‹(xkâ€‹Â log(x^kâ€‹)+(1âˆ’xkâ€‹)log(1âˆ’x^kâ€‹)) Cross-entropy error function ä¸€èˆ¬ç”¨äºåˆ†ç±»é—®é¢˜ï¼Œç±»ä¼¼one-hotç¼–ç  å…¶å®è¿˜æ˜¯å’Œæ™®é€šç¥ç»ç½‘ç»œå·®ä¸å¤š AE vs PCA ä½¿ç”¨MNISTæ•°æ®é›†ä½œä¸ºè¾“å…¥ï¼Œç„¶ååˆ†åˆ«ä½¿ç”¨PCAæˆ–AEå¯¹æ•°æ®è¿›è¡Œé™ç»´ï¼Œç„¶åå†é‡æ„ï¼Œæ•ˆæœå›¾å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ äººè„¸æ•°æ®é›†ç¬¬äºŒè¡Œæ˜¯AEï¼Œç¬¬ä¸‰è¡Œæ˜¯PCAï¼Œç»¼ä¸Šï¼Œå¯ä»¥çœ‹å‡ºAEçš„æ•ˆæœè¿˜æ˜¯è¦å¥½ä¸€äº›çš„ã€‚ Denoising Auto-Encoders å°±æ˜¯å¯¹è¾“å…¥æ•°æ®åŠ å™ªå£°ï¼Œä»¥æ­¤è®©æ¨¡å‹ä¸è¦è®°ä½æŸäº›ç‰¹å¾ï¼Œè€Œæ˜¯ç†è§£æŸäº›ç‰¹å¾ï¼Œè®©æ¨¡å‹å‘æ˜ä¸€äº›æ•°æ®é«˜å±‚æ¬¡çš„ç‰¹å¾ã€‚è¿™ç§ç±»å‹çš„AEå¯ä»¥å¯¹å›¾ç‰‡è¿›è¡Œé™å™ªæ“ä½œã€‚ Dropout Auto-Encoders æ­£å¦‚å…¶åï¼Œå’Œæˆ‘ä»¬å‰é¢è®²çš„Dropoutæ˜¯ä¸€ä¸ªæ„æ€ã€‚ Adversarial Auto-Encoders Discriminatorè¿™ä¸€éƒ¨åˆ†çŸ¥è¯†æ¶‰åŠåˆ°GANï¼Œä¼šåœ¨GANéƒ¨åˆ†è®²è§£æ¸…æ¥š æˆ‘ä»¬ç›®å‰åªéœ€è¦çŸ¥é“ï¼Œéšç€è®­ç»ƒæ¬¡æ•°çš„å¢åŠ ï¼Œä¸­é—´çš„éšè—å±‚hæ‰€å¾—çš„æ•°æ®ä¼šå‘ˆç°å‡ºä¸€ç§åˆ†å¸ƒçš„çŠ¶æ€ã€‚ Variational Auto-Encodersï¼ˆVAEï¼‰â€» VAEéå¸¸çš„é‡è¦ï¼Œå…·ä½“åŸç†å¯ä»¥çœ‹è¿™ä¸ªè§†é¢‘æˆ–è¿™ç¯‡åšå®¢ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ã€‚ï¼ˆå› ä¸ºæœ¬äººè¡¨è¾¾èƒ½åŠ›é—®é¢˜å’Œæ¯”è¾ƒèœï¼Œå¯èƒ½è¯´ä¸å¤ªæ¸…æ¥šï¼‰ é“¾æ¥ï¼šæå®æ¯…è€å¸ˆVAEåŸç† ç›´è§‚ç†è§£ æ³¨æ„ï¼šè¿˜æ˜¯å’ŒAEä¸å¤ªä¸€æ ·ï¼Œå› ä¸ºä¸­é—´æœ‰ä¸€ä¸ªé‡‡æ ·çš„æ“ä½œï¼Œé‡‡æ ·çš„å€¼ä½œä¸ºæå–å‡ºæ¥çš„ç‰¹å¾ã€‚å› æ­¤è¿™ä¸¤å±‚çš„è¿æ¥ä¹Ÿå’Œå…¶ä»–å±‚ä¹‹é—´çš„è¿æ¥ä¹Ÿä¸ä¸€æ ·ï¼Œå¹¶ä¸æ˜¯å…¨è¿æ¥ï¼ï¼ï¼ è¿˜è¦æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬çš„Losså‡½æ•°ä¸ä»…è¦æœ€å°AEä¸­çš„å‡æ–¹å·®ï¼Œè¿˜è¦æœ€å°åŒ–KLdivï¼ˆä¸Šå›¾æ ‡æœ‰Minimizeçš„é»„æ¡†ï¼‰ï¼Œæ‰€ä»¥è¦å°†ä»–ä»¬ä¸¤ä¸ªåŠ èµ·æ¥ä½œä¸ºæœ€ç»ˆçš„lossè¿›è¡Œåå‘ä¼ æ’­ï¼ï¼ï¼ï¼ˆè¿™ä¸ªä¸œè¥¿å¯ä»¥åœ¨ä¸Šé¢çš„é“¾æ¥ä¸­äº†è§£åˆ°è¿™æ˜¯ä»€ä¹ˆï¼‰ VAEä¸åŒäºAEï¼Œå­¦ä¹ çš„ä¸æ˜¯å•ä¸ªå‘é‡ï¼Œè€Œæ˜¯åˆ†å¸ƒï¼ï¼ï¼å› æ­¤å…·æœ‰ä¸€å®šçš„æ¨ç†èƒ½åŠ›ï¼Œç›´è§‚ç†è§£è§ä¸‹å›¾çš„ä¾‹å­ ç»¼ä¸Šï¼ŒVAEè™½ç„¶æ•ˆæœæ¯”AEå¥½ï¼Œä½†æ˜¯æ ¹æ®ä»–çš„åŸç†ï¼Œä»–æœ¬è´¨ä¸Šåªæ˜¯è®°ä½äº†ç°æœ‰æ•°æ®çš„ç‰¹å¾ï¼Œå¹¶æ²¡æœ‰å­¦ä¹ å¦‚ä½•ç”Ÿæˆæ•°æ®ï¼ˆåªæ˜¯å†ä¸€ä¸ªç¡®å®šåˆ†å¸ƒå†…éšæœºï¼‰ï¼Œè¿™æ˜¯VAEæœ€å¤§çš„ä¸€ä¸ªé—®é¢˜ï¼Œè§£å†³è¿™ä¸ªé—®é¢˜éœ€è¦ä½¿ç”¨æˆ‘ä»¬åé¢é©¬ä¸Šä¼šè®²è§£çš„GANã€‚ Pytochå®æˆ˜ Auto-Encoderå®éªŒ ç›®æ ‡ æœ¬æ¬¡å®éªŒçš„ç›®æ ‡æ˜¯æ„å»ºä¸€ä¸ªAuto-Encoderé‡æ„MNISTæ•°æ®é›†ã€‚ ä»£ç å®ç° å…¶å®ä»£ç éƒ½å’Œæœ€ç®€å•çš„å…¨è¿æ¥ç¥ç»ç½‘ç»œéå¸¸çš„ç›¸ä¼¼ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ï¼Œç›´æ¥è´´ä»£ç ã€‚ é¦–å…ˆæ˜¯ç½‘ç»œç»“æ„çš„ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041class AE(nn.Module): def __init__(self) -&gt; None: super(AE,self).__init__() # Encoder # [b,784] =&gt; [b,20] self.encoder = nn.Sequential( nn.Linear(784,256), nn.ReLU(), nn.Linear(256,64), nn.ReLU(), nn.Linear(64, 20), nn.ReLU() ) # Decoder # [b,20] =&gt; [b,784] self.decoder = nn.Sequential( nn.Linear(20,64), nn.ReLU(), nn.Linear(64,256), nn.ReLU(), nn.Linear(256,784), nn.Sigmoid() ) def forward(self, x): batchsz = x.size(0) # flatten x = x.view(batchsz,784) # encoder x = self.encoder(x) # decoder x = self.decoder(x) # reshape x = x.view(batchsz,1,28,28) return x æ³¨æ„è¿™é‡Œæˆ‘ä»¬ç½‘ç»œç»“æ„æ˜¯æ‹†æˆäº†encoderå’Œdecoderçš„ï¼Œè¿™æ ·ä½¿å¾—ç½‘ç»œç»“æ„æ›´åŠ çš„æ¸…æ™°ï¼ è®­ç»ƒæµ‹è¯•éƒ¨åˆ†ä¸»ä»£ç ï¼ˆæ²¡æœ‰åŒºåˆ«ï¼Œ åªæ˜¯å¤šåšäº†ä¸€ä¸ªå¯è§†åŒ– ï¼‰ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142def main(): mnist_train = datasets.MNIST(&#x27;mnist&#x27;, True, transform=transforms.Compose([ transforms.ToTensor() ]), download=True) mnist_train = DataLoader(mnist_train,batch_size=32,shuffle=True) mnist_test = datasets.MNIST(&#x27;mnist&#x27;, False, transform=transforms.Compose([ transforms.ToTensor() ]), download=True) mnist_test = DataLoader(mnist_test,batch_size=32,shuffle=True) x,_ = iter(mnist_train).next() print(&#x27;x:&#x27;, x.shape) device = torch.device(&#x27;cuda&#x27;) model = AE().to(device) print(model) criteon = nn.MSELoss() optimizer = optim.Adam(model.parameters(),lr=1e-3) viz =visdom.Visdom() for epoch in range(1000): for batchidx, (x,_) in enumerate(mnist_train): x = x.to(device) x_hat = model(x) loss = criteon(x_hat,x) # backprop optimizer.zero_grad() loss.backward() optimizer.step() print(epoch , &quot;loss:&quot;, loss.item()) x,_ = iter(mnist_test).next() x = x.to(device) with torch.no_grad(): x_hat = model(x) viz.images(x,nrow=8,win=&#x27;x&#x27;,opts=dict(title=&#x27;x&#x27;)) viz.images(x_hat,nrow=8,win=&#x27;x_hat&#x27;,opts=dict(title=&#x27;x_hat&#x27;)) ç»“æœ é‡å»ºç»“æœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œå°½ç®¡è¿™ä¸ªæ•°æ®é›†éå¸¸çš„ç®€å•ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯å¯ä»¥çœ‹å‡ºï¼Œè¿˜æ˜¯æœ‰ä¸€äº›æ•°æ®é‡å»ºçš„å¹¶ä¸æ˜¯éå¸¸çš„ç†æƒ³ã€‚ VAEå®éªŒ ç›®æ ‡ æœ¬æ¬¡å®éªŒçš„ç›®æ ‡æ˜¯æ„å»ºä¸€ä¸ªVAEé‡æ„MNISTæ•°æ®é›†ã€‚ å› ä¸ºVAEä¸­é—´æœ‰ä¸€ä¸ªæ“ä½œæ˜¯é‡‡æ ·ï¼Œè€Œé‡‡æ ·è¿™ä¸ªæ“ä½œæ˜¯ä¸å¯å¯¼çš„ï¼Œå› æ­¤åœ¨å®é™…ä»£ç å®ç°ä¸­è¿™é‡Œæœ‰ä¸€ä¸ªå°trickã€‚ ä»£ç å®ç° ç½‘ç»œç»“æ„ä»£ç å’ŒAEä»£ç æ˜¯ä¸€æ ·çš„ï¼ˆè¿˜æ˜¯æœ‰ä¸€ç‚¹ä¸ä¸€æ · decoderèµ·å§‹ç¥ç»å…ƒæ•°é‡å˜ä¸º10ï¼Œæ³¨æ„æ”¹ä¸€ä¸‹ï¼ ï¼‰ï¼Œä¸ä¸€æ ·çš„éƒ¨åˆ†ä½“ç°åœ¨forwardéƒ¨åˆ†ï¼ˆåœ¨encoderå’Œdecoderä¸­é—´å¢åŠ äº†é‡‡æ ·ï¼‰ï¼Œè¿™é‡Œå°±ä½¿ç”¨åˆ°äº†æˆ‘ä»¬çš„trickï¼Œåˆ©ç”¨pytorchè‡ªå¸¦çš„åˆ†å¸ƒç”Ÿæˆå™¨ï¼Œå¯ä»¥ç”Ÿæˆå¯å¯¼çš„é‡‡æ ·æ“ä½œã€‚æ³¨æ„forwardæœ€åè¿”å›äº†kldå“¦ï¼ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class VAE(nn.Module): def __init__(self): super(VAE, self).__init__() # [b, 784] =&gt; [b, 20] # u: [b, 10] # sigma: [b, 10] self.encoder = nn.Sequential( nn.Linear(784, 256), nn.ReLU(), nn.Linear(256, 64), nn.ReLU(), nn.Linear(64, 20), nn.ReLU() ) # [b, 20] =&gt; [b, 784] self.decoder = nn.Sequential( nn.Linear(10, 64), nn.ReLU(), nn.Linear(64, 256), nn.ReLU(), nn.Linear(256, 784), nn.Sigmoid() ) self.criteon = nn.MSELoss() def forward(self, x): &quot;&quot;&quot; :param x: [b, 1, 28, 28] :return: &quot;&quot;&quot; batchsz = x.size(0) # flatten x = x.view(batchsz, 784) # encoder # [b, 20], including mean and sigma h_ = self.encoder(x) # [b, 20] =&gt; [b, 10] and [b, 10] mu, sigma = h_.chunk(2, dim=1) # reparametrize trick, epison~N(0, 1) h = mu + sigma * torch.randn_like(sigma) # decoder x_hat = self.decoder(h) # reshape x_hat = x_hat.view(batchsz, 1, 28, 28) kld = 0.5 * torch.sum( torch.pow(mu, 2) + torch.pow(sigma, 2) - torch.log(1e-8 + torch.pow(sigma, 2)) - 1 ) / (batchsz*28*28) return x_hat, kld ç„¶åå°±æ˜¯è®­ç»ƒéƒ¨åˆ†çš„ä»£ç äº†ï¼Œè¿™é‡Œä¹Ÿå°±åªæœ‰losså‡½æ•°æ”¹äº†ä¸€ä¸‹ã€‚ 12345x_hat, kld = model(x)loss = criteon(x_hat, x)if kld is not None: elbo = - loss - 1.0 * kld loss = - elbo å®Œæ•´ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def main(): mnist_train = datasets.MNIST(&#x27;mnist&#x27;, True, transform=transforms.Compose([ transforms.ToTensor() ]), download=True) mnist_train = DataLoader(mnist_train, batch_size=32, shuffle=True) mnist_test = datasets.MNIST(&#x27;mnist&#x27;, False, transform=transforms.Compose([ transforms.ToTensor() ]), download=True) mnist_test = DataLoader(mnist_test, batch_size=32, shuffle=True) x, _ = iter(mnist_train).next() print(&#x27;x:&#x27;, x.shape) device = torch.device(&#x27;cuda&#x27;) # model = AE().to(device) model = VAE().to(device) criteon = nn.MSELoss() optimizer = optim.Adam(model.parameters(), lr=1e-3) print(model) viz = visdom.Visdom() for epoch in range(1000): for batchidx, (x, _) in enumerate(mnist_train): # [b, 1, 28, 28] x = x.to(device) x_hat, kld = model(x) loss = criteon(x_hat, x) if kld is not None: elbo = - loss - 1.0 * kld loss = - elbo # backprop optimizer.zero_grad() loss.backward() optimizer.step() print(epoch, &#x27;loss:&#x27;, loss.item(), &#x27;kld:&#x27;, kld.item()) x, _ = iter(mnist_test).next() x = x.to(device) with torch.no_grad(): x_hat, kld = model(x) viz.images(x, nrow=8, win=&#x27;x&#x27;, opts=dict(title=&#x27;x&#x27;)) viz.images(x_hat, nrow=8, win=&#x27;x_hat&#x27;, opts=dict(title=&#x27;x_hat&#x27;)) ç»“æœ é‡å»ºç»“æœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼ŒVAEé‡å»ºçš„æ‰€æœ‰æ•°å­—åŸºæœ¬ä¸Šæ˜¯å¯ä»¥çœ‹æ¸…æ¥šçš„ï¼Œä½†æ˜¯å› ä¸ºæ­¤æ•°æ®é›†æ¯”è¾ƒç®€å•çš„ç¼˜æ•…ï¼ŒVAEç›¸æ¯”äºAEçš„ä¼˜åŠ¿å¹¶æ²¡æœ‰å¾ˆå¥½çš„ä½“ç°å‡ºæ¥ã€‚"},{"title":"PyTorchå…¥é—¨-ç®€å•BPå…¨è¿æ¥ç¥ç»ç½‘ç»œ","path":"/wiki/PyTorch/PyTorchå…¥é—¨-ç®€å•BPç¥ç»ç½‘ç»œ.html","content":"ç®€ä»‹ å› ä¸ºè¯¾ç¨‹éœ€è¦å­¦ä¹ PyTorchï¼Œæ‰€ä»¥è¿™é‡Œå°±å…ˆç®€å•çš„å…¥ä¸ªé—¨ï¼Œä½¿ç”¨PyTorchå®ç°ä¸€ä¸ªç®€å•çš„3å±‚BPå…¨è¿æ¥ç¥ç»ç½‘ç»œå®éªŒã€‚å®éªŒä½¿ç”¨çš„æ•°æ®é›†æ˜¯MNISTæ‰‹å†™æ•°å­—è¯†åˆ«æ•°æ®é›†ã€‚ æˆ‘ä»¬è®¾è®¡çš„ç½‘ç»œç»“æ„æ˜¯4å±‚å…¨è¿æ¥ç¥ç»ç½‘ç»œï¼Œå› ä¸ºä¸€ä¸ªæ•°å­—æ‰€å­˜å‚¨çš„åƒç´ ä¿¡æ¯æ˜¯28Ã—28Ã—128\\times 28\\times 128Ã—28Ã—1å› æ­¤ï¼Œç½‘ç»œçš„ç¬¬ä¸€å±‚æœ‰28Ã—28Ã—1=78428\\times 28 \\times 1=78428Ã—28Ã—1=784ä¸ªç¥ç»å…ƒï¼Œç¬¬äºŒå±‚è®¾è®¡çš„æœ‰ 256ä¸ªç¥ç»å…ƒï¼Œç¬¬ä¸‰å±‚æœ‰64ä¸ªç¥ç»å…ƒï¼Œç¬¬å››å±‚æœ‰10ä¸ªç¥ç»å…ƒã€‚å…¶ä¸­ç¬¬ä¸€å±‚å’Œç¬¬äºŒå±‚ï¼Œç¬¬äºŒå±‚å’Œç¬¬ä¸‰å±‚ï¼Œç¬¬ä¸‰å±‚å’Œç¬¬å››å±‚ä¹‹é—´ï¼Œéƒ½æœ‰ä¸€ä¸ªreluæ¿€æ´»å‡½æ•°ã€‚æœ€åç¬¬å››å±‚çš„1Ã—101\\times 101Ã—10è¾“å‡ºå‘é‡ç›¸å½“äºæ˜¯å¯¹10ä¸ªæ•°å­—çš„è¯†åˆ«ç›¸ä¼¼åº¦ï¼Œæœ€å¤§çš„æ•°çš„indexä»£è¡¨è¯†åˆ«å‡ºæ¥ç›¸ä¼¼åº¦æœ€é«˜çš„æ•°å­—ã€‚ ç½‘ç»œæ„å»ºéƒ¨åˆ†çš„ä»£ç å®ç°å¦‚ä¸‹ï¼š 1234567891011121314151617181920class Net(nn.Module): def __init__(self): super(Net, self).__init__() # xw+b self.fc1 = nn.Linear(28*28, 256) self.fc2 = nn.Linear(256, 64) self.fc3 = nn.Linear(64, 10) def forward(self, x): # x: [b, 1, 28, 28] # h1 = relu(xw1+b1) x = F.relu(self.fc1(x)) # h2 = relu(h1w2+b2) x = F.relu(self.fc2(x)) # h3 = h2w3+b3 x = self.fc3(x) return x å®šä¹‰æŸå¤±å‡½æ•°æ˜¯ï¼š cost=âˆ‘(predâˆ’Y)2cost=\\sum(pred-Y)^2 cost=âˆ‘(predâˆ’Y)2 ä»£ç å®ç°ä¸è®²è§£ æ•°æ®è½½å…¥ 123456789101112131415161718192021222324252627282930313233343536import torchfrom torch import nnfrom torch.nn import functional as Ffrom torch import optimimport torchvisionfrom matplotlib import pyplot as pltfrom utils import plot_image, plot_curve, one_hotbatch_size = 512 #æ‰¹# step1. load datasettrain_loader = torch.utils.data.DataLoader( torchvision.datasets.MNIST(&#x27;mnist_data&#x27;, train=True, download=True, transform=torchvision.transforms.Compose([ torchvision.transforms.ToTensor(), torchvision.transforms.Normalize( (0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=True)test_loader = torch.utils.data.DataLoader( torchvision.datasets.MNIST(&#x27;mnist_data/&#x27;, train=False, download=True, transform=torchvision.transforms.Compose([ torchvision.transforms.ToTensor(), torchvision.transforms.Normalize( (0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=False)x, y = next(iter(train_loader))print(x.shape, y.shape, x.min(), x.max())plot_image(x, y, &#x27;image sample&#x27;) è¿™é‡Œå°±æ˜¯è½½å…¥äº†è®­ç»ƒé›†train_loaderå’Œtest_loader ç„¶åå€’æ•°ç¬¬ä¸‰è¡Œçš„nextè¿”å›çš„æ˜¯è®­ç»ƒé›†ä¸­ä¸‹ä¸€ä¸ªå…ƒç´ ï¼ˆä¸‹ä¸€ä¸ªbatchï¼‰ï¼Œå› ä¸ºæ˜¯batchå¤§å°æ˜¯512ï¼Œæ‰€ä»¥printå‡ºæ¥çš„xå’Œyçš„ç»´åº¦å¦‚ä¸‹æ‰€ç¤ºã€‚ 1torch.Size([512, 1, 28, 28]) torch.Size([512]) tensor(-0.4242) tensor(2.8215) å»ºç«‹ç½‘ç»œ ä¸Šé¢å·²ç»è¿›è¡Œè¿‡è®²è§£äº†ï¼Œè¿™é‡Œä¸å†èµ˜è¿° 1234567891011121314151617181920class Net(nn.Module): def __init__(self): super(Net, self).__init__() # xw+b self.fc1 = nn.Linear(28*28, 256) self.fc2 = nn.Linear(256, 64) self.fc3 = nn.Linear(64, 10) def forward(self, x): # x: [b, 1, 28, 28] # h1 = relu(xw1+b1) x = F.relu(self.fc1(x)) # h2 = relu(h1w2+b2) x = F.relu(self.fc2(x)) # h3 = h2w3+b3 x = self.fc3(x) return x åˆå§‹åŒ–å‚æ•° 123net = Net() # å®ä¾‹åŒ–å¯¹è±¡ï¼Œè¿™é‡Œå°±æ˜¯æˆ‘ä»¬å»ºç«‹çš„ç½‘ç»œ# [w1, b1, w2, b2, w3, b3]optimizer = optim.SGD(net.parameters(), lr=0.01, momentum=0.9) # åˆå§‹åŒ–å‚æ•°ï¼ˆè®¾ç½®è¶…å‚æ•°å’Œéšæœºåˆå§‹åŒ–å‚æ•°ï¼‰ å¼€å§‹è®­ç»ƒ 1234567891011121314151617181920212223for epoch in range(3): for batch_idx, (x, y) in enumerate(train_loader): # x: [b, 1, 28, 28], y: [512] # [b, 1, 28, 28] =&gt; [b, 784] x = x.view(x.size(0), 28*28) # =&gt; [b, 10] out = net(x) # [b, 10] y_onehot = one_hot(y) # loss = mse(out, y_onehot) loss = F.mse_loss(out, y_onehot) optimizer.zero_grad() loss.backward() # w&#x27; = w - lr*grad optimizer.step() train_loss.append(loss.item()) if batch_idx % 10==0: print(epoch, batch_idx, loss.item()) epochä»£è¡¨è®­ç»ƒçš„è½®æ•°ï¼Œè¿™é‡Œä¸€å…±è®­ç»ƒä¸‰è½®ã€‚ç„¶åæ¯ä¸€è½®ä¸­æ¯æ¬¡è®­ç»ƒå–å‡ºåŒä¸€batchä¸‹çš„æ‰€æœ‰è®­ç»ƒæ•°æ®ï¼ˆä¸€å…±512ç»„ï¼‰ï¼Œæ³¨é‡Šä¸­çš„b=512 ç„¶åå…ˆè¿›è¡Œreshapeã€‚ä»£ç ä¸­çš„viewå®ç°çš„åŠŸèƒ½ç±»ä¼¼numpyä¸­reshapeã€‚è¿™é‡Œå°±å°†Xä»ä¸€ä¸ªå››ç»´æ•°ç»„512Ã—1Ã—28Ã—28512\\times 1 \\times 28\\times 28512Ã—1Ã—28Ã—28è½¬åŒ–ä¸ºäº†512Ã—784512 \\times 784512Ã—784çš„äºŒç»´æ•°ç»„ã€‚ç„¶åæ‰”å…¥ç½‘ç»œè¿›è¡Œè®­ç»ƒï¼Œå°†yæ ‡ç­¾å…ˆè½¬åŒ–ä¸ºç‹¬çƒ­ç¼–ç å’Œç½‘ç»œæ‰”å‡ºçš„å€¼ç»“åˆè®¡ç®—lossã€‚è®¡ç®—ç»“æŸåå°±è¿›è¡Œä»¥ä¸‹ä¸‰æ­¥ï¼š 1234optimizer.zero_grad() # å°†æ¨¡å‹çš„å‚æ•°æ¢¯åº¦åˆå§‹åŒ–ä¸º0 loss.backward() # åå‘ä¼ æ’­è®¡ç®—æ¢¯åº¦ # w&#x27; = w - lr*grad optimizer.step() # æ›´æ–°æ‰€æœ‰å‚æ•° æ€»ç»“ä¸€ä¸‹ï¼Œè®­ç»ƒè¿‡ç¨‹çš„ä»£ç ä¸€èˆ¬å°±ä»¥ä¸‹å‡ å—ï¼š 12345678910optimizer.zero_grad() # å°†æ¨¡å‹çš„å‚æ•°æ¢¯åº¦åˆå§‹åŒ–ä¸º0outputs=modelï¼ˆinputsï¼‰ # å‰å‘ä¼ æ’­è®¡ç®—é¢„æµ‹å€¼loss = cost(outputs, y_train) # è®¡ç®—å½“å‰æŸå¤±loss.backward() # åå‘ä¼ æ’­è®¡ç®—æ¢¯åº¦optimizer.step() # æ›´æ–°æ‰€æœ‰å‚æ•° ç„¶åè®­ç»ƒè¿‡ç¨‹å°±ç»“æŸäº†ï¼Œä¸‹é¢å°±æ˜¯æµ‹è¯•ç¯èŠ‚äº†ã€‚ è¿›è¡Œæµ‹è¯• 1234567891011121314151617total_correct = 0for x,y in test_loader: x = x.view(x.size(0), 28*28) out = net(x) # out: [b, 10] =&gt; pred: [b] pred = out.argmax(dim=1) correct = pred.eq(y).sum().float().item() total_correct += correcttotal_num = len(test_loader.dataset)acc = total_correct / total_numprint(&#x27;test acc:&#x27;, acc)x, y = next(iter(test_loader))out = net(x.view(x.size(0), 28*28))pred = out.argmax(dim=1)plot_image(x, pred, &#x27;test&#x27;) åŒç†ï¼Œå’Œè®­ç»ƒè¿‡ç¨‹å¾ˆåƒï¼Œä¹Ÿæ˜¯å…ˆä½¿ç”¨viewï¼Œreshapeä¸€ä¸‹åï¼Œæ‰”å…¥ç½‘ç»œï¼Œå¾—åˆ°outåï¼Œå¯»æ‰¾æ•°å€¼æœ€å¤§çš„ä¸‹æ ‡è®°å½•åœ¨predä¸­ï¼Œpredå°±æ˜¯æµ‹è¯•é¢„æµ‹çš„æ•°å€¼ï¼Œç„¶åå°±å¯ä»¥è®¡ç®—æ­£ç¡®ç‡ç­‰è¯„ä»·æŒ‡æ ‡äº†ã€‚ æ€»ç»“ ä¸åŒäºtensorflowçš„place_holder,pytorchç½‘ç»œå®šä¹‰æ›´åŠ ç®€å•ä¾¿æ·ï¼Œåªéœ€è¦ä½¿ç”¨ç±»ä¼¼nn.Linear(a,b)çš„å‡½æ•°å®šä¹‰è¿æ¥æ–¹å¼ï¼Œç„¶åæœ€åå®ä¾‹åŒ–ç½‘ç»œçš„æ—¶å€™ä¼ å…¥ä¸€ä¸ªparameter()å°±å¯ä»¥äº†ï¼Œç›¸æ¯”äºtensorflowç¡®å®æ›´åŠ ç®€å•ã€‚ æœ€ç»ˆä»£ç  mnist_train.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import torchfrom torch import nnfrom torch.nn import functional as Ffrom torch import optimimport torchvisionfrom matplotlib import pyplot as pltfrom utils import plot_image, plot_curve, one_hotbatch_size = 512 #æ‰¹# step1. load datasettrain_loader = torch.utils.data.DataLoader( torchvision.datasets.MNIST(&#x27;mnist_data&#x27;, train=True, download=True, transform=torchvision.transforms.Compose([ torchvision.transforms.ToTensor(), torchvision.transforms.Normalize( (0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=True)test_loader = torch.utils.data.DataLoader( torchvision.datasets.MNIST(&#x27;mnist_data/&#x27;, train=False, download=True, transform=torchvision.transforms.Compose([ torchvision.transforms.ToTensor(), torchvision.transforms.Normalize( (0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=False)x, y = next(iter(train_loader))print(x.shape, y.shape, x.min(), x.max())plot_image(x, y, &#x27;image sample&#x27;)class Net(nn.Module): def __init__(self): super(Net, self).__init__() # xw+b self.fc1 = nn.Linear(28*28, 256) self.fc2 = nn.Linear(256, 64) self.fc3 = nn.Linear(64, 10) def forward(self, x): # x: [b, 1, 28, 28] # h1 = relu(xw1+b1) x = F.relu(self.fc1(x)) # h2 = relu(h1w2+b2) x = F.relu(self.fc2(x)) # h3 = h2w3+b3 x = self.fc3(x) return xnet = Net()# [w1, b1, w2, b2, w3, b3]optimizer = optim.SGD(net.parameters(), lr=0.01, momentum=0.9)train_loss = []for epoch in range(3): for batch_idx, (x, y) in enumerate(train_loader): # x: [b, 1, 28, 28], y: [512] # [b, 1, 28, 28] =&gt; [b, 784] x = x.view(x.size(0), 28*28) # =&gt; [b, 10] out = net(x) # [b, 10] y_onehot = one_hot(y) # loss = mse(out, y_onehot) loss = F.mse_loss(out, y_onehot) optimizer.zero_grad() loss.backward() # w&#x27; = w - lr*grad optimizer.step() train_loss.append(loss.item()) if batch_idx % 10==0: print(epoch, batch_idx, loss.item())plot_curve(train_loss) # ç”»å‡ºæŸå¤±å‡½æ•°# we get optimal [w1, b1, w2, b2, w3, b3]total_correct = 0for x,y in test_loader: x = x.view(x.size(0), 28*28) out = net(x) # out: [b, 10] =&gt; pred: [b] pred = out.argmax(dim=1) correct = pred.eq(y).sum().float().item() total_correct += correcttotal_num = len(test_loader.dataset)acc = total_correct / total_numprint(&#x27;test acc:&#x27;, acc)x, y = next(iter(test_loader))out = net(x.view(x.size(0), 28*28))pred = out.argmax(dim=1)plot_image(x, pred, &#x27;test&#x27;) utils.py 1234567891011121314151617181920212223242526272829303132import torchfrom matplotlib import pyplot as pltdef plot_curve(data): fig = plt.figure() plt.plot(range(len(data)), data, color=&#x27;blue&#x27;) plt.legend([&#x27;value&#x27;], loc=&#x27;upper right&#x27;) plt.xlabel(&#x27;step&#x27;) plt.ylabel(&#x27;value&#x27;) plt.show()def plot_image(img, label, name): fig = plt.figure() for i in range(6): plt.subplot(2, 3, i + 1) plt.tight_layout() plt.imshow(img[i][0]*0.3081+0.1307, cmap=&#x27;gray&#x27;, interpolation=&#x27;none&#x27;) plt.title(&quot;&#123;&#125;: &#123;&#125;&quot;.format(name, label[i].item())) plt.xticks([]) plt.yticks([]) plt.show()def one_hot(label, depth=10): out = torch.zeros(label.size(0), depth) idx = torch.LongTensor(label).view(-1, 1) out.scatter_(dim=1, index=idx, value=1) return out ç»“æœ æœ€ç»ˆå¯ä»¥å‘ç°æ‰“å°å‡ºæ¥çš„å‡é¢„æµ‹æ­£ç¡®ã€‚accä¸º0.8794ï¼Œæ˜¯å¯ä»¥æ¥å—çš„æ­£ç¡®ç‡ã€‚"},{"title":"PyTorchåŸºç¡€","path":"/wiki/PyTorch/PyTorchåŸºç¡€.html","content":"Tensoræ•°æ®ç±»å‹ å¯¹æ¯” Python PyTorch Int IntTensor of size() float FloatTensor of size() Int array IntTensor of size [d1,d2,â€¦] Float array FloatTensor of size[d1,d2,â€¦] string â€“ å¯ä»¥å‘ç°PyTorchå¹¶ä¸æ”¯æŒstringè¡¨ç¤ºï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¦‚ä¸‹ä¸¤ç§æ–¹æ³•åœ¨PyTorch ä¸­è¡¨ç¤ºstringã€‚ One-hot Embedding Word2vec glove è¿™é‡Œä¸å¯¹ä»¥ä¸Šä¸¤ç§æ–¹æ³•å±•å¼€è¿›è¡Œè®²è§£ï¼Œå¤§å®¶æ„Ÿå…´è¶£å¯ä»¥è‡ªè¡Œç™¾åº¦ã€‚ æ•°æ®ç±»å‹ æœ€å¸¸ç”¨çš„ä¸€èˆ¬æ˜¯ä»¥ä¸‹å‡ ç§ FloatTensor DoubleTensor IntTensor LongTensor ByteTensor æ•°æ®ç±»å‹æ¨æ–­ 123456In [3]: a=torch.randn(2,3)In [4]: a.type()Out[4]: &#x27;torch.FloatTensor&#x27;In [5]: type(a)Out[5]: torch.Tensor type()ï¼šæ‰“å‡ºå½“å‰tensorçš„æ•°æ®ç±»å‹ isinstance()ï¼šæ£€éªŒå½“å‰æ•°æ®æ˜¯å¦ä¸ºæ­¤ç±»å‹ type(xxx)ï¼šPythonè‡ªå¸¦çš„ç±»å‹æ£€æµ‹ï¼Œåªèƒ½æ£€æµ‹æœ€åŸºæœ¬æ•°æ®ç±»å‹ ä»¥ä¸‹ä»£ç æµ‹è¯•è¯´æ˜äº†ï¼ŒåŒä¸€æ•°æ®éƒ¨ç½²åœ¨CPUå’ŒGPUä¸Šæ•°æ®ç±»å‹æ˜¯ä¸ä¸€æ ·çš„ 12345In [7]: isinstance(a,torch.cuda.FloatTensor)Out[7]: FalseIn [8]: a=a.cuda()In [9]: isinstance(a,torch.cuda.FloatTensor)Out[9]: True æ ‡é‡çš„è¡¨ç¤º: Dim0 1234In [10]: torch.tensor(1.0)Out[10]: tensor(1.)In [11]: torch.tensor(1.3)Out[11]: tensor(1.3000) ä»¥ä¸‹ä»£ç å±•ç¤ºäº†shape,size(),dim()çš„ä½¿ç”¨æ–¹æ³•ã€‚ å…¶ä¸­è¾“å…¥19å’Œ21æ˜¯å¸¸è§çš„ç¡®å®štensorç»´åº¦çš„æ–¹æ³• 123456789In [17]: a=torch.tensor(1.3)In [18]: a.shapeOut[18]: torch.Size([])In [19]: len(a.shape)Out[19]: 0In [20]: a.size()Out[20]: torch.Size([])In [21]: a.dim()Out[21]: 0 å‘é‡Vectorï¼šDim1 ä¸€ä¸ªå…ƒç´ çš„ä¸€ç»´å‘é‡ï¼Œå…¶å®å°±æ˜¯å¤šåŠ äº†ä¸€ä¸ªä¸­æ‹¬å·ï¼Œè¯¦æƒ…è§ä¸‹é¢çš„ä»£ç ã€‚ FloatTensoræ¥æ”¶çš„å‚æ•°æ˜¯shapeï¼Œç„¶åéšæœºåˆå§‹åŒ–å‘é‡ã€‚ ç„¶åIn [9]ä»¥åä»‹ç»äº†ä¸€ç§numpyè½¬tensorçš„æ–¹æ³• 123456789101112131415161718In [3]: torch.tensor([1.1])Out[3]: tensor([1.1000])In [4]: a=torch.tensor([1.1])In [5]: a.dim()Out[5]: 1In [6]: torch.tensor([1.1,2.2])Out[6]: tensor([1.1000, 2.2000])In [7]: torch.FloatTensor(1)Out[7]: tensor([0.])In [8]: torch.FloatTensor(2)Out[8]: tensor([0., 0.])In [9]: import numpy as npIn [10]: data=np.ones(2)In [11]: dataOut[11]: array([1., 1.])In [12]: torch.from_numpy(data)Out[12]: tensor([1., 1.], dtype=torch.float64) çŸ©é˜µMatrixï¼šDim2 1234567891011121314In [3]: a=torch.randn(2,3)In [4]: aOut[4]: tensor([[-0.6969, 1.8345, -0.4894], [-0.0066, -0.0398, -0.6140]])In [5]: a.shapeOut[5]: torch.Size([2, 3])In [6]: a.size(0)Out[6]: 2In [7]: a.size(1)Out[7]: 3In [8]: a.shape[1]Out[8]: 3 åœ¨PyTorchä¸­ï¼Œrandnæ˜¯éšæœºæ­£æ€åˆ†å¸ƒï¼Œè€Œrandæ˜¯éšæœºå‡åŒ€åˆ†å¸ƒã€‚ Dim3 12345678910111213141516171819In [3]: a=torch.rand(1,2,3)In [4]: aOut[4]: tensor([[[0.7603, 0.4443, 0.4788], [0.0602, 0.6325, 0.8426]]])In [5]: a.shapeOut[5]: torch.Size([1, 2, 3])In [6]: a[0]Out[6]: tensor([[0.7603, 0.4443, 0.4788], [0.0602, 0.6325, 0.8426]])In [7]: a[0,1]Out[7]: tensor([0.0602, 0.6325, 0.8426])In [8]: a[0,1,0]Out[8]: tensor(0.0602)In [9]: list(a.shape)Out[9]: [1, 2, 3] ä¸‰ç»´çš„tensorä¸€èˆ¬ç”¨äºRNNä¸­ Dim4 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253In [3]: a=torch.rand(2,3,28,28)In [4]: a.dim()Out[4]: 4In [5]: aOut[5]: tensor([[[[0.5255, 0.9019, 0.9471, ..., 0.7050, 0.4455, 0.8681], [0.7229, 0.9215, 0.4863, ..., 0.4863, 0.5061, 0.3511], [0.0015, 0.3703, 0.0695, ..., 0.7927, 0.0028, 0.5953], ..., [0.3896, 0.5274, 0.7822, ..., 0.7864, 0.5558, 0.2190], [0.8072, 0.7983, 0.8963, ..., 0.8586, 0.2881, 0.1836], [0.7002, 0.4452, 0.8168, ..., 0.6467, 0.2885, 0.4928]], [[0.5885, 0.6984, 0.6732, ..., 0.3300, 0.3039, 0.1747], [0.2004, 0.1730, 0.4867, ..., 0.5207, 0.3391, 0.6586], [0.0279, 0.1897, 0.5924, ..., 0.7152, 0.6622, 0.1943], ..., [0.6697, 0.9150, 0.1786, ..., 0.6098, 0.8226, 0.2826], [0.2074, 0.6030, 0.0912, ..., 0.9088, 0.1924, 0.6403], [0.0557, 0.0836, 0.2382, ..., 0.4082, 0.0600, 0.5102]], [[0.3708, 0.5273, 0.0810, ..., 0.8926, 0.5854, 0.7139], [0.6355, 0.3067, 0.9933, ..., 0.7173, 0.0793, 0.3067], [0.9277, 0.6752, 0.7401, ..., 0.6875, 0.4112, 0.9575], ..., [0.2762, 0.6146, 0.9833, ..., 0.2625, 0.9879, 0.1417], [0.1789, 0.9695, 0.6872, ..., 0.2485, 0.0840, 0.4170], [0.5604, 0.1260, 0.8523, ..., 0.6334, 0.1975, 0.5056]]], [[[0.9585, 0.5642, 0.2652, ..., 0.7171, 0.5738, 0.7511], [0.0737, 0.4149, 0.1017, ..., 0.4772, 0.4125, 0.4467], [0.6502, 0.9494, 0.1355, ..., 0.0834, 0.4446, 0.5004], ..., [0.2966, 0.6502, 0.6373, ..., 0.6158, 0.9067, 0.0245], [0.1544, 0.6203, 0.7105, ..., 0.5898, 0.9481, 0.7846], [0.0048, 0.8663, 0.5166, ..., 0.7284, 0.1925, 0.2311]], [[0.0852, 0.0139, 0.8834, ..., 0.6738, 0.1022, 0.8247], [0.0161, 0.2121, 0.9729, ..., 0.2736, 0.3918, 0.5949], [0.1229, 0.8208, 0.6334, ..., 0.0238, 0.5333, 0.0843], ..., [0.9250, 0.3495, 0.2272, ..., 0.2272, 0.7861, 0.1189], [0.7124, 0.8442, 0.6705, ..., 0.7530, 0.0809, 0.4165], [0.5223, 0.0803, 0.3681, ..., 0.3973, 0.7163, 0.1920]], [[0.1807, 0.7834, 0.5945, ..., 0.5394, 0.7165, 0.4785], [0.8470, 0.0618, 0.2278, ..., 0.5901, 0.4242, 0.0087], [0.9244, 0.1387, 0.8042, ..., 0.4879, 0.6511, 0.4556], ..., [0.2453, 0.7729, 0.5773, ..., 0.7876, 0.7998, 0.5125], [0.3097, 0.0141, 0.5490, ..., 0.2160, 0.4402, 0.9370], [0.5274, 0.9141, 0.0378, ..., 0.9517, 0.8165, 0.6193]]]])In [6]: a.shapeOut[6]: torch.Size([2, 3, 28, 28])In [7]: a.numel()Out[7]: 4704 numelå‡½æ•°çš„å«ä¹‰æ˜¯numberof element,è¿”å›å¯¹åº”tensorä¸­å…ƒç´ çš„ä¸ªæ•° å››ç»´çš„tensorä¸€èˆ¬ç”¨äºCNNä¸­ åˆ›å»ºTensor ä»numpyä¸­å¯¼å…¥æ•°æ® 123456789In [4]: a=np.array([2,3.3])In [5]: torch.from_numpy(a)Out[5]: tensor([2.0000, 3.3000], dtype=torch.float64)In [6]: a=np.ones([2,3])In [7]: torch.from_numpy(a)Out[7]: tensor([[1., 1., 1.], [1., 1., 1.]], dtype=torch.float64) ä»Liståˆ—è¡¨ä¸­å¯¼å…¥æ•°æ® 1234567891011121314151617In [3]: torch.tensor([2.,3.2])Out[3]: tensor([2.0000, 3.2000])In [4]: torch.FloatTensor([2.,3.2])Out[4]: tensor([2.0000, 3.2000])In [5]: torch.FloatTensor(2,3)Out[5]: tensor([[0., 0., 0.], [0., 0., 0.]])In [6]: torch.tensor([[2.,3.2],[1.,22.3]])Out[6]: tensor([[ 2.0000, 3.2000], [ 1.0000, 22.3000]])In [7]: torch.Tensor(2,3)Out[7]: tensor([[0., 0., 0.], [0., 0., 0.]]) æ³¨æ„åŒºåˆ†å¤§å†™Tensorå’Œå°å†™tensorï¼Œè§In[3]å’ŒIn [7]çš„åŒºåˆ«ï¼Œç„¶åIn [4]å’ŒIn [5]ä¹Ÿè¦è¿›è¡ŒåŒºåˆ†ã€‚ ç”Ÿæˆæœªç»è¿‡åˆå§‹åŒ–çš„æ•°æ®uninitalized torch.empty() torch.FloatTensor() torch.IntTensor(d1,d2,d3l) 1234567891011121314151617181920212223In [3]: torch.empty(1)Out[3]: tensor([0.])In [4]: torch.empty([2,3])Out[4]: tensor([[0., 0., 0.], [0., 0., 0.]])In [5]: torch.empty(2,3)Out[5]: tensor([[0., 0., 0.], [0., 0., 0.]])In [6]: torch.Tensor(2,3)Out[6]: tensor([[0., 0., 0.], [0., 0., 0.]])In [7]: torch.IntTensor(2,3)Out[7]: tensor([[0, 0, 0], [0, 0, 0]], dtype=torch.int32)In [8]: torch.FloatTensor(2,3)Out[8]: tensor([[0., 0., 0.], [0., 0., 0.]]) éå¸¸ä¸å»ºè®®ç›´æ¥å°†æœªåˆå§‹åŒ–çš„Tensorå¸¦å…¥è®¡ç®—ï¼Œæœ‰æå¤§æ¦‚ç‡å‡ºç°å¥‡æ€ªçš„é—®é¢˜ã€‚è¿™æ˜¯å› ä¸ºæœªç»åˆå§‹åŒ–çš„Tensorï¼Œéšæœºç”Ÿæˆçš„æ•°æ®æœ‰å¯èƒ½ä¼šç›¸å·®è¾ƒå¤§ï¼ˆæ¯”å¦‚æå¤§æˆ–è€…æå°ï¼‰ï¼Œä¸Šé¢çš„ä»£ç å¹¶æ²¡æœ‰å‡ºç°è¿™æ ·çš„é—®é¢˜ï¼Œå¯èƒ½æ˜¯å› ä¸ºè¿æ°”æ¯”è¾ƒå¥½ã€‚ empty()åŠ ä¸åŠ æ‹¬å·éƒ½å¯ä»¥ è®¾ç½®é»˜è®¤æ•°æ®ç±»å‹ PyTorché»˜è®¤çš„Tensorç±»å‹æ˜¯FloatTensorï¼Œå› æ­¤åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½¿ç”¨Tensoræˆ–tensorç”Ÿæˆçš„tensorçš„æ•°æ®ç±»å‹éƒ½æ˜¯FloatTensorç±»å‹çš„ã€‚ è®¾ç½®Tensoré»˜è®¤çš„æ•°æ®ç±»å‹é‡‡ç”¨çš„å‡½æ•°æ˜¯set_default_tensor_type 123456In [3]: torch.tensor([1.2,3]).type()Out[3]: &#x27;torch.FloatTensor&#x27;In [4]: torch.set_default_tensor_type(torch.DoubleTensor)In [5]: torch.tensor([1.2,3]).type()Out[5]: &#x27;torch.DoubleTensor&#x27; éšæœºåˆå§‹åŒ– rand():éšæœºç”Ÿæˆ(0,1)ä¹‹é—´çš„æ•°ï¼ˆå‡åŒ€åˆ†å¸ƒï¼‰ rand_likeï¼šä¼ å…¥å‚æ•°æ˜¯ä¸€ä¸ªTensorï¼Œå°±randä¸€ä¸ªå’Œä¼ å…¥tensorå½¢çŠ¶ä¸€æ ·çš„tensor randintï¼šæŒ‡å®šæœ€å°å€¼å’Œæœ€å¤§å€¼ä»¥åŠTensorçš„ç»´åº¦ä¿¡æ¯ï¼Œç„¶åè¿›è¡Œéšæœºã€‚ randint_likeï¼šåŒrandlike,è¿™é‡Œä¸å†èµ˜è¿°ï¼Œè¯¦æƒ…è§ä¸Šé¢çš„rand_likeå‡½æ•° randnï¼šéšæœºç”Ÿæˆ(0,1)ä¹‹é—´çš„æ•°ï¼ˆæ­£æ€åˆ†å¸ƒï¼‰ fullï¼šç»™å®šç»´åº¦ä¿¡æ¯å’Œå¯¹åº”çš„æ•°ï¼Œä½¿ç”¨è¯¥æ•°åˆå§‹åŒ–ç»™å®šç»´åº¦çš„tensorã€‚ 1234567891011121314151617181920212223242526272829303132333435363738In [3]: torch.rand(3,3)Out[3]: tensor([[0.2722, 0.3876, 0.2607], [0.2612, 0.5041, 0.4084], [0.2007, 0.0119, 0.1834]])In [4]: a=torch.rand(3,3)In [5]: torch.rand_like(a)Out[5]: tensor([[0.1392, 0.9533, 0.5443], [0.9043, 0.4646, 0.0362], [0.7572, 0.5375, 0.8975]])In [6]: b=torch.randint(1,10,[2,3])In [7]: bOut[7]: tensor([[5, 6, 9], [5, 1, 1]])In [8]: c=torch.randint_like(b,1,100)In [9]: cOut[9]: tensor([[42, 20, 59], [15, 51, 1]])In [10]: torch.randn(3,3)Out[10]: tensor([[ 0.6524, -1.4728, 0.0623], [-0.6681, 0.7447, 0.9798], [ 0.0814, 1.3355, -0.7414]])In [11]: torch.full([5,2],0.1213)Out[11]: tensor([[0.1213, 0.1213], [0.1213, 0.1213], [0.1213, 0.1213], [0.1213, 0.1213], [0.1213, 0.1213]])In [12]: torch.full([],7)#ç”Ÿæˆæ ‡é‡Out[12]: tensor(7)In [13]: torch.full([1],7)#ç”Ÿæˆä¸€ç»´å‘é‡Out[13]: tensor([7]) arange ä¼ å…¥ä¸¤ä¸ªæˆ–ä¸‰ä¸ªå‚æ•°ï¼Œåˆ†åˆ«è¡¨ç¤ºèµ·å§‹å’Œç»ˆæ­¢ä½ç½®ï¼ˆå·¦é—­å³å¼€ï¼‰ï¼Œç„¶åç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯æ­¥é•¿ï¼Œä¸å†™å°±é»˜è®¤æ˜¯1ã€‚ 12345In [3]: torch.arange(0,10)Out[3]: tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])In [4]: torch.arange(0,10,2)Out[4]: tensor([0, 2, 4, 6, 8]) linspace/logspace linspaceå’Œarangeéå¸¸çš„åƒï¼Œä½†æ˜¯ç¬¬ä¸‰ä¸ªå‚æ•°ä¸è¡¨ç¤ºæ­¥é•¿äº†ï¼Œè€Œæ˜¯è¡¨ç¤ºçš„æ˜¯æ•°é‡ï¼Œè¿˜æœ‰ä¸€ä¸ªéå¸¸é‡è¦çš„ä¸åŒæ˜¯ï¼Œè¿™é‡Œçš„ç»ˆæ­¢ç‚¹æ˜¯åŒ…å«åœ¨äº†åˆ†å‰²çš„åºåˆ—ä¸­çš„ã€‚ï¼ˆè§ä¸‹é¢çš„ä¾‹å­ï¼‰ logspaceå…ˆæ˜¯åŒlinspaceä¸€æ ·ï¼Œå°†èµ·å§‹ç‚¹å’Œç»ˆæ­¢ç‚¹ä¹‹é—´çš„æ•°æ®åˆ’åˆ†æˆç»™å®šæ•°é‡çš„ç­‰å·®æ•°åˆ—ï¼Œç„¶åå°†è¿™äº›å€¼ä½œä¸ºæŒ‡æ•°ï¼Œ10ä½œä¸ºåº•æ•°ï¼ˆå½“ç„¶åº•æ•°ä¹Ÿå¯ä»¥è‡ªå·±é€šè¿‡æ”¹å˜baseå‚æ•°è¿›è¡Œè®¾ç½®ï¼‰ï¼Œè®¡ç®—å‡ºæ¥çš„åºåˆ—ä½œä¸ºæœ€åå‘ˆç°çš„ç­”æ¡ˆã€‚ 1234567891011121314151617In [3]: torch.linspace(0,10,steps=5)Out[3]: tensor([ 0.0000, 2.5000, 5.0000, 7.5000, 10.0000])In [4]: torch.linspace(0,10,steps=10)Out[4]: tensor([ 0.0000, 1.1111, 2.2222, 3.3333, 4.4444, 5.5556, 6.6667, 7.7778, 8.8889, 10.0000])In [5]: torch.linspace(0,10,steps=11)Out[5]: tensor([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.])In [6]: torch.logspace(0,-1,steps=10)Out[6]: tensor([1.0000, 0.7743, 0.5995, 0.4642, 0.3594, 0.2783, 0.2154, 0.1668, 0.1292, 0.1000])In [7]: torch.logspace(0,10,steps=11,base=2)Out[7]: tensor([1.0000e+00, 2.0000e+00, 4.0000e+00, 8.0000e+00, 1.6000e+01, 3.2000e+01, 6.4000e+01, 1.2800e+02, 2.5600e+02, 5.1200e+02, 1.0240e+03]) ones/zeros/eye è¿™ä¸ªéå¸¸ç®€å•ï¼Œå¤§å®¶ç›´æ¥çœ‹ä¸‹é¢çš„ä¾‹å­å°±å¯ä»¥æ˜ç™½ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°ã€‚ 12345678910111213141516171819202122232425In [3]: torch.ones(3,3)Out[3]: tensor([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]])In [4]: torch.zeros(3,3)Out[4]: tensor([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]])In [5]: torch.eye(3,3)Out[5]: tensor([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]])In [6]: torch.eye(3,5)Out[6]: tensor([[1., 0., 0., 0., 0.], [0., 1., 0., 0., 0.], [0., 0., 1., 0., 0.]])In [7]: torch.eye(3)Out[7]: tensor([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) likeæ–¹æ³•åœ¨è¿™é‡Œä¹Ÿå¯ä»¥ä½¿ç”¨å“¦ã€‚æ¯”å¦‚ones_like randperm éšæœºæ‰“ä¹±å‡½æ•°ï¼Œä¸€èˆ¬ç”¨äºæ‰“ä¹±ç´¢å¼•ç¼–å·ã€‚ 123In [3]: idx=torch.randperm(10)In [4]: idxOut[4]: tensor([8, 6, 9, 5, 1, 2, 4, 7, 3, 0]) Tensor åˆ‡ç‰‡ ç®€å•åˆ‡ç‰‡ 123456789In [3]: a=torch.rand(4,3,28,28)In [4]: a[0].shapeOut[4]: torch.Size([3, 28, 28])In [5]: a[0,1].shapeOut[5]: torch.Size([28, 28])In [6]: a[0,1,2,3]Out[6]: tensor(0.4744)In [7]: a[:2].shapeOut[7]: torch.Size([2, 3, 28, 28]) é€‰åŒºé—´ 123456789In [9]: a[:2,:1,:,:].shapeOut[9]: torch.Size([2, 1, 28, 28])In [10]: a[:2,1:,:,:].shapeOut[10]: torch.Size([2, 2, 28, 28])In [11]: a[:2,-1,:,:].shapeOut[11]: torch.Size([2, 28, 28])In [12]: a[:2,-1:,:,:].shapeOut[12]: torch.Size([2, 1, 28, 28]) æœ‰æ­¥é•¿çš„åˆ‡ç‰‡ 1234In [14]: a[:,:,0:28:2,0:28:2].shapeOut[14]: torch.Size([4, 3, 14, 14])In [15]: a[:,:,::2,::2].shapeOut[15]: torch.Size([4, 3, 14, 14]) ç‰¹å®šç´¢å¼•åˆ‡ç‰‡ ä½¿ç”¨index_selectè¿™ä¸ªå‡½æ•° ä¼ å…¥ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªæ ‡é‡è¡¨ç¤ºå¯¹ç¬¬å‡ ä¸ªç»´åº¦è¿›è¡Œç´¢å¼•æ“ä½œï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ªtensoræ•°ç»„ï¼Œè¡¨ç¤ºæˆ‘ä»¬æƒ³å–å‡ºæ¥çš„ç´¢å¼•å·ã€‚ 123456789101112131415In [21]: a=torch.eye(3)In [22]: aOut[22]: tensor([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]])In [23]: a.index_select(0,torch.tensor([0,2]))Out[23]: tensor([[1., 0., 0.], [0., 0., 1.]])In [24]: a.index_select(0,torch.arange(2))Out[24]: tensor([[1., 0., 0.], [0., 1., 0.]]) â€¦ 12345678910111213In [3]: a=torch.rand(4,3,28,28)In [4]: a.shapeOut[4]: torch.Size([4, 3, 28, 28])In [5]: a[...].shapeOut[5]: torch.Size([4, 3, 28, 28])In [6]: a[0,...].shapeOut[6]: torch.Size([3, 28, 28])In [7]: a[:,1,...].shapeOut[7]: torch.Size([4, 28, 28])In [8]: a[...,:2].shapeOut[8]: torch.Size([4, 3, 28, 2]) é€šè¿‡é®ç½©å–æ•° ä½¿ç”¨åˆ°çš„å‡½æ•°æ˜¯masked_selectedï¼Œè¿™ä¸ªå‡½æ•°å¹¶ä¸æ˜¯éå¸¸çš„å¸¸ç”¨ã€‚ 123456789101112131415In [3]: z=torch.randn(3,4)In [4]: zOut[4]: tensor([[-0.9371, 1.0520, 0.2948, 0.3691], [ 0.9820, 0.9555, -0.9335, -1.5135], [-0.2594, -0.7860, -0.5336, 0.2682]])In [5]: mask=z.ge(0.5)In [6]: maskOut[6]: tensor([[False, True, False, False], [ True, True, False, False], [False, False, False, False]])In [7]: torch.masked_select(z,mask)Out[7]: tensor([1.0520, 0.9820, 0.9555]) é€šè¿‡takeæ¥è¿›è¡Œå–æ•° takeå–æ•°ä¼šå°†tensoræ‰“å¹³ç„¶åå†æ ¹æ®æ–°çš„ç´¢å¼•è¿›è¡Œå–æ•°æ“ä½œï¼Œè¯¦æƒ…è§ä¸‹é¢çš„ä¾‹å­ã€‚ 123In [3]: src=torch.tensor([[4,3,5],[6,7,8]])In [4]: torch.take(src,torch.tensor([0,2,5]))Out[4]: tensor([4, 5, 8]) Tensor ç»´åº¦å˜æ¢ view/reshape squeeze/unsqueeze transpose/t/permute expand/repeat reshape/view reshapeå’Œviewæ˜¯å®Œå…¨ç­‰ä»·çš„ï¼Œè¯¦æƒ…è§ä¸‹é¢çš„ä¾‹å­ã€‚ 12345678In [3]: a=torch.rand(4,1,28,28)In [4]: a.shapeOut[4]: torch.Size([4, 1, 28, 28])In [5]: a.view(4,28*28).shapeOut[5]: torch.Size([4, 784])In [6]: a.reshape(4,28*28).shapeOut[6]: torch.Size([4, 784]) squeeze/unsqueeze unsqueeze å¯¹äºä¸€ä¸ªç»´åº¦ä¸ºnçš„tensorï¼Œæƒ³è¦æ‰©å±•ç»´åº¦æ‰€èƒ½å¤Ÿä¼ å…¥å‚æ•°çš„èŒƒå›´æ˜¯**$[-n-1,n+1)$**å¦‚æœè¾“å…¥çš„æ˜¯æ­£çš„ç´¢å¼•ï¼ˆæˆ–0ï¼‰åˆ™æ˜¯åœ¨ä¹‹å‰æ’å…¥ï¼Œè´Ÿçš„ç´¢å¼•åˆ™æ˜¯åœ¨ä¹‹åæ’å…¥ 123456789101112131415In [3]: a=torch.randn(4,1,28,28)In [4]: a.shapeOut[4]: torch.Size([4, 1, 28, 28])In [5]: a.unsqueeze(0).shapeOut[5]: torch.Size([1, 4, 1, 28, 28])In [6]: a.unsqueeze(-1).shapeOut[6]: torch.Size([4, 1, 28, 28, 1])In [7]: a.unsqueeze(4).shapeOut[7]: torch.Size([4, 1, 28, 28, 1])In [8]: a.unsqueeze(-4).shapeOut[8]: torch.Size([4, 1, 1, 28, 28])In [9]: a.unsqueeze(-5).shapeOut[9]: torch.Size([1, 4, 1, 28, 28])In [10]: a.unsqueeze(5).shapeOut[10]: RuntimeError: Dimension out of range squeeze 1234567891011121314In [3]: b=torch.rand(1,32,1,1)In [4]: b.shapeOut[4]: torch.Size([1, 32, 1, 1])In [5]: b.squeeze().shapeOut[5]: torch.Size([32])In [6]: b.squeeze(0).shapeOut[6]: torch.Size([32, 1, 1])In [7]: b.squeeze(-1).shapeOut[7]: torch.Size([1, 32, 1])In [8]: b.squeeze(1).shape # can&#x27;t squeeze this dimensionOut[8]: torch.Size([1, 32, 1, 1])In [9]: b.squeeze(-4).shapeOut[9]: torch.Size([32, 1, 1]) expand/repeat expand è¿™æ˜¯ç»´åº¦æ‰©å±•å‡½æ•°å’Œç»´åº¦å¢åŠ å‡½æ•°è¿˜æ˜¯æœ‰è¾ƒå¤§ä¸åŒçš„ï¼Œæ³¨æ„åŒºåˆ†ï¼ç»´åº¦å¢åŠ æ˜¯å¢åŠ äº†ä¸€ä¸ªæ–°çš„ç»´åº¦ï¼Œè€Œç»´åº¦æ‰©å±•æ˜¯å°†å½“å‰å·²æœ‰ç»´åº¦æ”¹å˜å…¶shapeçš„å¤§å°ã€‚ ä¸¤ä¸ªAPIæ‰€å®ç°çš„åŠŸèƒ½æ˜¯å®Œå…¨ä¸€æ ·çš„ï¼Œä½†æ˜¯æˆ‘ä»¬æ›´åŠ æ¨èä½¿ç”¨ç¬¬ä¸€ä¸ªAPIï¼Œå› ä¸ºç¬¬ä¸€ä¸ªAPIæ˜¯åœ¨æ•°æ®éœ€è¦ä½¿ç”¨æ—¶æ‰è¿›è¡Œå¤åˆ¶ï¼Œå› æ­¤expandçš„æ‰§è¡Œé€Ÿåº¦æ›´å¿«ï¼Œå¹¶ä¸”æ›´åŠ èŠ‚çº¦å†…å­˜ã€‚ åªæœ‰åŸæ¥ç»´åº¦ä¸º1ï¼Œæ‰èƒ½å¤Ÿè¢«æ‰©å±•ï¼ï¼ï¼ å¦‚æœexpandä¸­å¡«å†™çš„å‚æ•°ä¸º-1ï¼Œè¡¨ç¤ºçš„æ˜¯ç»´åº¦å¤§å°ä¿æŒä¸å˜ã€‚ 123456789101112131415161718In [3]: a=torch.rand(1,3)In [4]: aOut[4]: tensor([[0.2768, 0.6714, 0.6259]])In [5]: a.shapeOut[5]: torch.Size([1, 3])In [6]: a.expand(4,3)Out[6]: tensor([[0.2768, 0.6714, 0.6259], [0.2768, 0.6714, 0.6259], [0.2768, 0.6714, 0.6259], [0.2768, 0.6714, 0.6259]])In [7]: a.expand(4,-1)Out[7]: tensor([[0.2768, 0.6714, 0.6259], [0.2768, 0.6714, 0.6259], [0.2768, 0.6714, 0.6259], [0.2768, 0.6714, 0.6259]]) repeat ä¼ å…¥çš„å‚æ•°å’Œexpandå‡½æ•°æœ‰ä¸€äº›ä¸åŒï¼Œè¿™é‡Œæ‰€ä¼ å…¥çš„å‚æ•°ä»£è¡¨æ‹·è´çš„æ¬¡æ•°ï¼Œæ¯”å¦‚å¦‚æœåŸæ¥ç»´åº¦å¤§å°æ˜¯32ï¼Œä¸‹é¢å¯¹åº”å‚æ•°å¡«å†™ä¸º2ï¼Œæœ€åç”Ÿæˆçš„å¤§å°å°±æ˜¯64ã€‚ 12345678910In [3]: a=torch.rand(1,32,1,1)In [4]: a.repeat(4,32,1,1).shapeOut[4]: torch.Size([4, 1024, 1, 1])In [5]: a.repeat(4,1,1,1).shapeOut[5]: torch.Size([4, 32, 1, 1])In [6]: a.repeat(4,1,32,32).shapeOut[6]: torch.Size([4, 32, 32, 32])In [7]: a.repeat(4,1,32,0).shapeOut[7]: torch.Size([4, 32, 32, 0]) transpose/t/permute t çŸ©é˜µè½¬ç½®æ“ä½œ è¿™ä¸ªå‡½æ•°åªé€‚ç”¨äºäºŒç»´tensorï¼Œå…¶ä»–ç»´åº¦çš„tensorä½¿ç”¨ä¼šæŠ¥é”™ 12345678910111213In [3]: a=torch.rand(3,4)In [4]: aOut[4]: tensor([[0.0723, 0.9169, 0.2574, 0.9654], [0.5009, 0.9152, 0.6344, 0.7596], [0.5432, 0.3906, 0.9426, 0.9421]])In [5]: a.t()Out[5]: tensor([[0.0723, 0.5009, 0.5432], [0.9169, 0.9152, 0.3906], [0.2574, 0.6344, 0.9426], [0.9654, 0.7596, 0.9421]]) transpose çŸ©é˜µç»´åº¦äº¤æ¢å‡½æ•°ï¼Œç›´æ¥è¾“å…¥ä¸¤ä¸ªéœ€è¦è¿›è¡Œäº¤æ¢çš„ç»´åº¦ï¼Œå°±å¯ä»¥ç›´æ¥å°†è¿™ä¸¤ä¸ªç»´åº¦è¿›è¡Œäº¤æ¢ï¼ŒåŒæ—¶è¿™ä¸¤ä¸ªç»´åº¦å­˜å‚¨çš„ä¿¡æ¯ä¹Ÿä¼šè¿›è¡Œäº¤æ¢ã€‚ 12345678910In [3]: a=torch.rand(4,3,32,32)In [4]: a1=a.transpose(1,3).contiguous().view(4,3*32*32).view(4,3,32,32)In [5]: a2=a.transpose(1,3).contiguous().view(4,3*32*32).view(4,32,32,3).transpose(1,3)In [6]: a1.shape,a2.shapeOut[6]: (torch.Size([4, 3, 32, 32]), torch.Size([4, 3, 32, 32]))In [7]: torch.all(torch.eq(a,a1))Out[7]: tensor(False)In [8]: torch.all(torch.eq(a,a2))Out[8]: tensor(True) contiguouså‡½æ•°æ˜¯ä½¿å†…å­˜é¡ºåºå˜å¾—è¿ç»­ï¼Œä¸ç„¶ä¼šå¦‚æœæœ‰ä»¥ä¸‹å†™æ³•ä¼šå‡ºç°æŠ¥é”™ã€‚ï¼ˆå› ä¸ºviewä¼šå¿½è§†ç»´åº¦ä¿¡æ¯ï¼‰ permute å’Œtransposeæ¯”è¾ƒç±»ä¼¼ï¼Œä½†æ˜¯å¾ˆå¥½çš„è§£å†³äº†transposeæ¯æ¬¡åªèƒ½äº¤æ¢ä¸¤ä¸ªç»´åº¦çš„é—®é¢˜ï¼Œæˆ‘ä»¬è¾“å…¥çš„å‚æ•°ï¼Œæ˜¯ç»´åº¦çš„æ’åˆ—é¡ºåºï¼Œè¿™æ ·å°±å¯ä»¥åŒæ—¶äº¤æ¢å¤šä¸ªç»´åº¦ã€‚ 12345In [3]: a=torch.rand(1,2,3,4)In [4]: a.shapeOut[4]: torch.Size([1, 2, 3, 4])In [5]: a.permute(3,0,2,1).shapeOut[5]: torch.Size([4, 1, 3, 2])"},{"title":"PyTorchæ¢¯åº¦","path":"/wiki/PyTorch/PyTorchæ¢¯åº¦.html","content":"æ¢¯åº¦ æ¢¯åº¦çš„æ–¹å‘ä»£è¡¨çš„æ˜¯ä»å°åˆ°å¤§çš„æ–¹å‘ Î¸t+1=Î¸tâˆ’Î±tâˆ‡f(Î¸t)\\theta_{t+1}=\\theta_t-\\alpha_t abla f(\\theta_t) Î¸t+1â€‹=Î¸tâ€‹âˆ’Î±tâ€‹âˆ‡f(Î¸tâ€‹) An overview of gradient descent optimization algorithms (ruder.io) æœä¸åˆ°å…¨å±€æœ€å°å€¼çš„åŸå›  å±€éƒ¨æœ€å°å€¼ éç‚¹ å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œéç‚¹æ¯”å±€éƒ¨æœ€å°å€¼å¸¦æ¥çš„å½±å“æ›´ä¸ºä¸¥é‡ å¸¸è§å‡½æ•°çš„æ¢¯åº¦ æ¿€æ´»å‡½æ•°å’Œæ¢¯åº¦ sigmoid sigmoid(x)=11+eâˆ’xsigmoid(x)=\\frac{1}{1+e^{-x}} sigmoid(x)=1+eâˆ’x1â€‹ ä¼˜ç‚¹ è¿ç»­ å…‰æ»‘ èŒƒå›´01ï¼Œé€‚åˆäºä¸€äº›è¾“å‡ºéœ€è¦æ§åˆ¶åœ¨01çš„åœºæ™¯ï¼ˆeg:æ¦‚ç‡ï¼Œrgbå€¼ï¼‰ ç¼ºç‚¹ å½“èŒƒå›´è¶‹äº+âˆ+\\infty+âˆæˆ–âˆ’âˆ-\\inftyâˆ’âˆæ—¶ï¼Œå› ä¸ºå¯¼æ•°è¾ƒå°ï¼Œæ‰€ä»¥å‚æ•°æ›´æ–°ä¼šéå¸¸çš„ç¼“æ…¢ï¼Œæ”¶æ•›é€Ÿåº¦æ…¢ PyTorchå®ç° 1234567891011121314151617In [3]: a=torch.linspace(-100,100,10)In [4]: aOut[4]: tensor([-100.0000, -77.7778, -55.5556, -33.3333, -11.1111, 11.1111, 33.3333, 55.5556, 77.7778, 100.0000])In [5]: torch.sigmoid(a)Out[5]: tensor([0.0000e+00, 1.6655e-34, 7.4564e-25, 3.3382e-15, 1.4945e-05, 9.9999e-01, 1.0000e+00, 1.0000e+00, 1.0000e+00, 1.0000e+00])In [6]: from torch.nn import functional as FIn [7]: F.sigmoid(a)D:\\App\\Anaconda\\envs\\pytorch\\lib\\site-packages\\torch n\\functional.py:1806: UserWarning: nn.functional.sigmoid is deprecated. Use torch.sigmoid instead. warnings.warn(&quot;nn.functional.sigmoid is deprecated. Use torch.sigmoid instead.&quot;)Out[7]: tensor([0.0000e+00, 1.6655e-34, 7.4564e-25, 3.3382e-15, 1.4945e-05, 9.9999e-01, 1.0000e+00, 1.0000e+00, 1.0000e+00, 1.0000e+00]) tanh tanh(x)=exâˆ’eâˆ’xex+eâˆ’x=2sigmoid(2x)âˆ’1tanh(x)=\\frac{e^x-e^{-x}}{e^x+e^{-x}}=2sigmoid(2x)-1 tanh(x)=ex+eâˆ’xexâˆ’eâˆ’xâ€‹=2sigmoid(2x)âˆ’1 ddxtanh(x)=1âˆ’tanh2(x)\\frac{d}{dx}tanh(x)=1-tanh^2(x) dxdâ€‹tanh(x)=1âˆ’tanh2(x) åœ¨RNNä¸­ä½¿ç”¨è¾ƒå¤šã€‚ PyTorchå®ç° 12345In [3]: a=torch.linspace(-1,1,10)In [4]: torch.tanh(a)Out[4]: tensor([-0.7616, -0.6514, -0.5047, -0.3215, -0.1107, 0.1107, 0.3215, 0.5047, 0.6514, 0.7616]) Rectified Linear Unit(ReLU) f(x)={0forÂ x&lt;0xforÂ xâ‰¥0f(x)=\\begin{cases} 0\\quad for\\ x&lt;0\\\\ x\\quad for\\ x\\ge0 \\end{cases} f(x)={0forÂ x&lt;0xforÂ xâ‰¥0â€‹ ç»è¿‡å¤§é‡å®éªŒéªŒè¯ï¼ŒReLUå‡½æ•°è¢«è¯æ˜éå¸¸é€‚ç”¨äºæ·±åº¦å­¦ä¹ ã€‚ Pytochå®ç° 12345678910In [3]: a=torch.linspace(-1,1,10)In [4]: torch.relu(a)Out[4]: tensor([0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.1111, 0.3333, 0.5556, 0.7778, 1.0000])In [5]: aOut[5]: tensor([-1.0000, -0.7778, -0.5556, -0.3333, -0.1111, 0.1111, 0.3333, 0.5556, 0.7778, 1.0000]) Losså‡½æ•°å’Œæ¢¯åº¦ å¸¸è§çš„Losså‡½æ•° å‡æ–¹å·®Losså‡½æ•°ï¼ˆMean Square Errorï¼‰ Cross Entropy Loss äºŒåˆ†ç±»ï¼ˆbinaryï¼‰ å¤šåˆ†ç±»ï¼ˆmulti-classï¼‰ softmax MSE loss=âˆ‘[yâˆ’(xw+b)2]loss=\\sum[y-(xw+b)^2] loss=âˆ‘[yâˆ’(xw+b)2] æ³¨æ„å’Œ2èŒƒæ•°è¿›è¡ŒåŒºåˆ†ï¼ˆL2_normï¼‰ L2_norm=âˆ£âˆ£yâˆ’(xw+b)âˆ£âˆ£2L2\\_norm=||y-(xw+b)||_2 L2_norm=âˆ£âˆ£yâˆ’(xw+b)âˆ£âˆ£2â€‹ loss=norm(yâˆ’(xw+b))2loss=norm(y-(xw+b))^2 loss=norm(yâˆ’(xw+b))2 PyTorchä¸­è¿›è¡Œè¡¨ç¤ºç»“æœå¦‚ä¸‹ï¼š 1torch.norm(y-pred,2).pow(2) å¯¹mseå‡½æ•°æ±‚å¯¼è¡¨è¾¾å¼å¦‚ä¸‹ï¼š loss=âˆ‘[yâˆ’fÎ¸(x)]2loss=\\sum[y-f_\\theta(x)]^2 loss=âˆ‘[yâˆ’fÎ¸â€‹(x)]2 âˆ‡lossâˆ‡Î¸=2âˆ‘[yâˆ’fÎ¸(x)]âˆ—âˆ‡fÎ¸(x)âˆ‡Î¸\\frac{ abla loss}{ abla \\theta}=2\\sum[y-f_\\theta(x)]*\\frac{ abla f_\\theta(x)}{ abla\\theta} âˆ‡Î¸âˆ‡lossâ€‹=2âˆ‘[yâˆ’fÎ¸â€‹(x)]âˆ—âˆ‡Î¸âˆ‡fÎ¸â€‹(x)â€‹ è¡¥å……ï¼šåœ¨PyTorchä¸­å®ç°è‡ªåŠ¨æ±‚å¯¼â€» autograd.grad 123456789In [3]: x=torch.ones(1)In [4]: w=torch.tensor([2.],requires_grad=True)# importantIn [5]: from torch.nn import functional as FIn [6]: mse=F.mse_loss(torch.ones(1),x*w)#label,predIn [7]: mseOut[7]: tensor(1., grad_fn=&lt;MseLossBackward0&gt;)In [8]: torch.autograd.grad(mse,[w])Out[8]: (tensor([2.]),) loss.backwardâ€» æ¥ä¸Šé¢ 1234In [9]: mse=F.mse_loss(torch.ones(1),x*w)In [10]: mse.backward()In [11]: w.gradOut[11]: tensor([2.]) ä¸€èˆ¬ä½¿ç”¨ä¸‹é¢è¿™ç§ è¡¥å……ï¼šsoftmax soft version of max æˆ‘ä»¬å‡è®¾ï¼Œå·¦è¾¹æ²¡æœ‰è¿›å…¥softmaxå±‚çš„ç‰¹å¾å‘é‡ä¸ºaaaå³è¾¹ç»è¿‡äº†softmaxå±‚çš„ç‰¹å¾å‘é‡ä¸ºppp,é‚£ä¹ˆæœ‰ã€‚ âˆ‚piâˆ‚aj={pi(1âˆ’pj)ifÂ i=jâˆ’pjpiifÂ iâ‰ j\\frac{\\partial p_i}{\\partial a_j}=\\begin{cases} p_i(1-p_j)\\quad if \\ i=j\\\\ -p_jp_i\\quad if\\ i e j \\end{cases} âˆ‚ajâ€‹âˆ‚piâ€‹â€‹={piâ€‹(1âˆ’pjâ€‹)ifÂ i=jâˆ’pjâ€‹piâ€‹ifÂ iî€ =jâ€‹ pytorch ä»£ç éªŒè¯å¦‚ä¸‹ï¼š 12345678910In [3]: a=torch.rand(3)In [4]: a.requires_grad_()Out[4]: tensor([0.1714, 0.4650, 0.7201], requires_grad=True)In [5]: from torch.nn import functional as FIn [6]: p=F.softmax(a,dim=0)In [7]: p.sum().backward()# å¦‚æœè¿™é‡Œä¸æ±‚å’Œï¼Œå°±è¦åœ¨backwardä¸­ æŒ‡å®šä¸€ä¸ªå’Œpä¸€æ ·å¤§çš„tensorï¼Œè¯¦æƒ…è§ï¼šä¸‹é¢çš„çº¢è‰²æ¡†ä¸­çš„blogIn [8]: a.gradOut[8]: tensor([0., 0., 0.])In [9]: p.gradOut[9]: UserWarning: The .grad attribute of a Tensor that is not a leaf Tensor is being accessed. Its .grad attribute won&#x27;t be populated during autograd.backward(). If you indeed want the .grad field to be populated for a non-leaf Tensor, use .retain_grad() on the non-leaf Tensor. If you access the non-leaf Tensor by mistake, make sure you access the leaf Tensor instead. See github.com/pytorch/pytorch/pull/30531 for more informations. (Triggered internally at aten\\src\\ATen/core/TensorBody.h:417.) [gradcan be implicitly created only for scalar outputs_](https://blog.csdn.net/qq_39208832/article/details/117415229#:~:text=1.1 grad can be implicitly created only for,æ˜¯ä¸€ä¸ª æ ‡é‡ (å³å®ƒåŒ…å«ä¸€ä¸ªå…ƒç´ çš„æ•°æ®ï¼‰ï¼Œåˆ™ä¸éœ€è¦ä¸º backward () æŒ‡å®šä»»ä½•å‚æ•°ï¼Œä½†æ˜¯å¦‚æœå®ƒæœ‰æ›´å¤šçš„å…ƒç´ ï¼Œåˆ™éœ€è¦æŒ‡å®šä¸€ä¸ª gradient å‚æ•°ï¼Œè¯¥å‚æ•°æ˜¯å½¢çŠ¶åŒ¹é…çš„å¼ é‡ã€‚) Psï¼šè¿™é‡Œå°†pæ±‚å’Œï¼Œå’Œä¸å°†pæ±‚å’Œå¯¹aæ±‚å¯¼çš„æœ€ç»ˆç»“æœæ˜¯ä¸€æ ·çš„ï¼Œå› ä¸ºæ ¹æ®é“¾å¼æ³•åˆ™ï¼Œæœ€åæ±‚å’Œæ¯ä¸ªpçš„éƒ¨åˆ†å‰é¢çš„ç³»æ•°éƒ½æ˜¯1ï¼Œæ‰€ä»¥ä¹˜ä¸Š1ä¸å½±å“æœ€ç»ˆçš„ç»“æœã€‚ å¯ä»¥å‘ç°æœ€åæˆ‘ä»¬æ˜¯**æ— æ³•æŸ¥çœ‹**æœ€ç»ˆçš„p.sum()å¯¹ä¸­é—´å˜é‡pçš„æ±‚å¯¼å‚æ•°çš„(**ä¸ä¿å­˜ä¸­é—´å˜é‡çš„æ¢¯åº¦ä¿¡æ¯**)ã€‚è¯¦æƒ…è§ä¸‹é¢è¿™ç¯‡åšå®¢ï¼š é€šä¿—è®²è§£PyTorchæ¢¯åº¦çš„ç›¸å…³é—®é¢˜ï¼šè®¡ç®—å›¾ã€torch.no_gradã€zero_gradã€detachå’Œbackwardï¼›Variableã€Parameterå’Œtorch.tensor è¿™å…¶ä¸­ä¹Ÿæœ‰è®²é‡å¤backwardæŠ¥é”™çš„é—®é¢˜ï¼è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæ¯æ¬¡backwardå°†retain_graphè®¾ä¸ºTrueå°±å¥½äº†ã€‚ backward(retain_graph=True) è®°å¾—å†æ¬¡è¿›è¡Œbackwardå‰ï¼Œè¦æ ¹æ®è‡ªå·±éœ€æ±‚ç¡®å®šæ˜¯å¦ä½¿ç”¨a.grad.zero_()å°†æ¢¯åº¦æ¸…é›¶ã€‚ä¸ç„¶æ¢¯åº¦ä¼šåœ¨ä¸Šä¸€æ¬¡æ±‚å‡ºæ¥çš„åŸºç¡€ä¸Šè¿›è¡Œå åŠ ã€‚ Cross Entropy Lossï¼ˆäº¤å‰ç†µï¼‰ ç†µï¼ˆEntropyï¼‰ ä¸ç¡®å®šæ€§ ç”¨äºè¡¡é‡æƒŠå–œç¨‹åº¦ ç†µå€¼è¶Šé«˜ï¼šè¶Šé«˜çš„ä¸ç¡®å®šæ€§ Entropy=âˆ’âˆ‘iP(i)logP(i)Entropy=-\\sum_iP(i)logP(i) Entropy=âˆ’iâˆ‘â€‹P(i)logP(i) äº¤å‰ç†µï¼ˆCross Entropyï¼‰ æ•°å­¦å®šä¹‰ H(p,q)=âˆ’âˆ‘p(x)logÂ q(x)H(p,q)=-\\sum p(x)log \\ q(x) H(p,q)=âˆ’âˆ‘p(x)logÂ q(x) H(p,q)=H(p)+DKL(pâˆ£q)H(p,q)=H(p)+D_{KL}(p|q) H(p,q)=H(p)+DKLâ€‹(pâˆ£q) DKLD_{KL}DKLâ€‹æ˜¯æ•£åº¦ï¼Œç”¨äºè¡¡é‡ä¸¤ä¸ªåˆ†å¸ƒçš„æ¥è¿‘ç¨‹åº¦çš„ï¼Œæ•£åº¦è¶Šå°ï¼Œåˆ†å¸ƒè¶Šæ¥è¿‘ã€‚ è¿™é‡Œpæ˜¯æˆ‘ä»¬å°†på®šä¸ºç½‘ç»œå­¦ä¹ å‡ºæ¥çš„åˆ†å¸ƒï¼Œqä¸ºå®é™…æ•°æ®çš„åˆ†å¸ƒï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´è§‚ç†è§£ä¼˜åŒ–ç›®æ ‡å°±æ˜¯ï¼Œç½‘ç»œå­¦ä¹ å‡ºæ¥çš„åˆ†å¸ƒè¦æœ‰è¾ƒé«˜çš„ç¡®å®šæ€§ï¼ˆä¸èƒ½è§‰å¾—åŒæ—¶å½’å±äºå‡ ä¸ªç§ç±»çš„æ¦‚ç‡æ˜¯ä¸€æ ·çš„ï¼‰ã€‚ä¹Ÿè¦å’Œå®é™…åˆ†å¸ƒæ¥è¿‘ï¼ˆæ•£åº¦å°ï¼‰ã€‚ å› æ­¤å¯¹äºäºŒåˆ†ç±»ï¼Œæˆ‘ä»¬çš„ Cross Ebtropy Losså‡½æ•°å¯ä»¥å†™ä¸ºï¼š H(P,Q)=âˆ’(ylog(p)+(1âˆ’y)log(1âˆ’p))H(P,Q)=-(ylog(p)+(1-y)log(1-p)) H(P,Q)=âˆ’(ylog(p)+(1âˆ’y)log(1âˆ’p)) ä¸ºä»€ä¹ˆä½¿ç”¨äº¤å‰ç†µ å¯¹äºåˆ†ç±»é—®é¢˜ åŸºäºsigmoidçš„mseå®¹æ˜“å‘ç”Ÿæ¢¯åº¦æ¶ˆå¤±çš„é—®é¢˜ æ”¶æ•›ç¼“æ…¢ PyTorchå®ä¾‹ æ³¨æ„:cross_entropyå‡½æ•°åŒ…å«äº†æ±‚softmaxï¼Œlogè¿™äº›æ­¥éª¤ã€‚ PyTorchå•å±‚å•è¾“å‡ºæ„ŸçŸ¥æœºå®æˆ˜ ä¸Šæ ‡ä»£è¡¨ç¬¬å‡ å±‚ï¼Œä¸‹æ ‡ä»£è¡¨ç‰¹å¾å‘é‡çš„ç¬¬å‡ ä¸ªå…ƒç´ ã€‚ æ±‚å¯¼è¿‡ç¨‹å¦‚ä¸‹ï¼š è¿™æ ·å¾—çŸ¥äº†âˆ‚Eâˆ‚wj0\\frac{\\partial E}{\\partial w_{j0}}âˆ‚wj0â€‹âˆ‚Eâ€‹åï¼Œæˆ‘ä»¬ä¾¿å¯ä»¥æ›´æ–°wäº†ã€‚ ä¸‹é¢ä½¿ç”¨PyTorchç®€å•çš„å®ç°ä¸Šè¿°å•å±‚å•è¾“å‡ºæ„ŸçŸ¥æœºã€‚ 123456789101112131415In [3]: x=torch.randn(1,10)In [4]: w=torch.randn(1,10,requires_grad=True)In [5]: o=torch.sigmoid(x@w.t())In [6]: o.shapeOut[6]: torch.Size([1, 1])In [7]: from torch.nn import functional as FIn [8]: loss=F.mse_loss(torch.ones(1,1),o)In [9]: loss.shapeOut[9]: torch.Size([])In [10]: loss.backward()In [11]: w.gradOut[11]: tensor([[-0.1147, -0.2456, -0.2645, 0.1144, -0.0162, 0.1094, -0.3674, -0.0048, -0.1127, -0.1605]]) ç„¶åï¼Œæˆ‘ä»¬ä¾¿å¯ä»¥ä½¿ç”¨w.gradå¯¹wè¿›è¡Œæ›´æ–°å•¦ï¼ PyTorchå¤šè¾“å‡ºæ„ŸçŸ¥æœºå®æˆ˜ æ±‚å¯¼æ¨å¯¼è¿‡ç¨‹å¦‚ä¸‹ï¼š ä¸‹é¢ä½¿ç”¨PyTorchç®€å•çš„å®ç°ä¸Šè¿°å•å±‚å¤šè¾“å‡ºæ„ŸçŸ¥æœºã€‚ 1234567891011121314151617In [3]: x=torch.randn(1,10)In [4]: w=torch.randn(2,10,requires_grad=True)In [5]: o=torch.sigmoid(x@w.t())In [6]: o.shapeOut[6]: torch.Size([1, 2])In [7]: from torch.nn import functional as FIn [8]: loss=F.mse_loss(torch.ones(1,2),o)In [9]: lossOut[9]: tensor(0.6030, grad_fn=&lt;MseLossBackward0&gt;)In [10]: loss.backward(retain_graph=True)In [11]: w.gradOut[11]: tensor([[-0.1720, -0.1305, -0.0129, 0.0506, -0.0449, 0.1076, 0.0133, 0.0291, 0.0757, 0.0186], [-0.0033, -0.0025, -0.0002, 0.0010, -0.0009, 0.0021, 0.0003, 0.0006, 0.0015, 0.0004]]) é“¾å¼æ³•åˆ™â€» é€šè¿‡ä½¿ç”¨é“¾å¼æ³•åˆ™ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæœ€åä¸€å±‚çš„è¯¯å·®ï¼Œä¸€å±‚ä¸€å±‚çš„è¾“å‡ºåˆ°ä¸­é—´å±‚çš„æƒå€¼ä¸Šé¢å»ï¼Œä»è€Œå¾—åˆ°ä¸­é—´å±‚çš„æ¢¯åº¦ä¿¡æ¯ï¼Œè¿›è€Œå¾ˆå¥½çš„æ›´æ–°æƒå€¼ï¼Œè¾¾åˆ°åå‘ä¼ æ’­ä¼˜åŒ–æ¨¡å‹çš„æ•ˆæœ PyTorchå®éªŒ 12345678910111213141516In [3]: from torch import autogradIn [4]: x=torch.tensor(1.)In [5]: w1=torch.tensor(2.,requires_grad=True)In [6]: b1=torch.tensor(1.)In [7]: w2=torch.tensor(2.,requires_grad=True)In [8]: b2=torch.tensor(1.)In [9]: y1=x*w1+b1In [10]: y2=y1*w2+b2In [11]: dy2_dy1=autograd.grad(y2,[y1],retain_graph=True)[0]In [12]: dy1_dw1=autograd.grad(y1,[w1],retain_graph=True)[0]In [13]: dy2_dw1=autograd.grad(y2,[w1],retain_graph=True)[0]In [14]: dy2_dy1*dy1_dw1Out[14]: tensor(2.)In [15]: dy2_dw1Out[15]: tensor(2.) ç”±ä¸Šè¯æ˜äº†é“¾å¼æ³•åˆ™çš„æ­£ç¡®æ€§ï¼ MLPåå‘ä¼ æ’­ å¤šå±‚æ„ŸçŸ¥æœº å…¶å®åŸç†éå¸¸çš„ç®€å•ï¼Œå°±æ˜¯æ­£å‘ä¼ æ’­å®Œæˆåï¼Œå€’ç€ä¸€å±‚ä¸€å±‚è®¡ç®—å¯¼æ•°ï¼Œæ¯ä¸€å±‚çš„å€’æ•°è®¡ç®—åŒä¸Šé¢çš„å•å±‚å•è¾“å‡ºæ„ŸçŸ¥æœºå’Œå•å±‚å¤šè¾“å‡ºæ„ŸçŸ¥æœºã€‚æ‰€ä»¥æ•´ä¸ªåå‘ä¼ æ’­çš„è¿‡ç¨‹ç›¸å½“äºæ˜¯å¾ˆå¤šä¸ªå•å±‚nè¾“å‡ºæ„ŸçŸ¥æœºæ¥åœ¨ä¸€èµ·ã€‚ï¼ˆæ„ŸçŸ¥æœºçš„æ¨åˆ°æ­¥éª¤è§ä¸Šé¢ï¼‰ 2Då‡½æ•°ä¼˜åŒ–å®ä¾‹ Himmelblau function è¿™é‡Œæˆ‘ä»¬é‡‡ç”¨çš„å‡½æ•°è¡¨è¾¾å¼å¦‚ä¸‹ï¼š f(x,y)=(x2+yâˆ’11)2+(x+y2âˆ’7)2f(x,y)=(x^2+y-11)^2+(x+y^2-7)^2 f(x,y)=(x2+yâˆ’11)2+(x+y2âˆ’7)2 å¦‚ä¸‹å›¾æ‰€ç¤º è¯¥å‡½æ•°åœ¨ä»¥ä¸‹å››ç‚¹å–å¾—å…¨å±€æœ€å°å€¼ï¼š f(3.0,2.0)=0.0f(3.0,2.0)=0.0f(3.0,2.0)=0.0 f(âˆ’2.805118,3.131312)=0.0f(-2.805118,3.131312)=0.0f(âˆ’2.805118,3.131312)=0.0 f(âˆ’3.779310,âˆ’3.283186)=0.0f(-3.779310,-3.283186)=0.0f(âˆ’3.779310,âˆ’3.283186)=0.0 f(3.584428,âˆ’1.848126)=0.0f(3.584428,-1.848126)=0.0f(3.584428,âˆ’1.848126)=0.0 é¦–å…ˆæ˜¯ç”»å›¾ä»£ç ï¼š 1234567891011121314151617181920import numpy as npimport matplotlib.pyplot as pltimport torchdef himmelblau(x): return (x[0]**2+x[1]-11)**2+(x[0]+x[1]**2-7)**2x=np.arange(-6,6,0.1)y=np.arange(-6,6,0.1)print(&#x27;x,y range:&#x27;,x.shape,y.shape)X,Y=np.meshgrid(x,y)print(&#x27;X,Y maps:&#x27;,X.shape,Y.shape)Z=himmelblau([X,Y])fig=plt.figure(&#x27;himmelblau&#x27;)ax=fig.gca(projection=&#x27;3d&#x27;)ax.plot_surface(X,Y,Z)ax.view_init(60,-30)ax.set_xlabel(&#x27;x&#x27;)ax.set_ylabel(&#x27;y&#x27;)plt.show() ç”»å›¾ç»“æœå¦‚ä¸‹ï¼š ç„¶åå°±æ˜¯æ±‚å¯¼æ‰¾å‡ºæœ€ä¼˜è§£äº†ï¼Œä»£ç å¦‚ä¸‹ï¼š å…·ä½“ç»†èŠ‚è§ä»£ç ä¸­çš„æ³¨é‡Š 12345678910111213141516# ä¸‹é¢ä½¿ç”¨éšæœºæ¢¯åº¦ä¸‹é™çš„æ–¹å¼è¿›è¡Œæ±‚è§£å…¨å±€æœ€å°å€¼x=torch.tensor([0.,0.],requires_grad=True)# ä½¿ç”¨ä¼˜åŒ–å™¨ï¼Œä¼˜åŒ–å™¨ä¼šè‡ªåŠ¨æ ¹æ®æ¢¯åº¦ä¿¡æ¯å’Œå­¦ä¹ ç‡æ¥æ›´æ–°ç›®æ ‡ï¼ˆè¿™é‡Œæ˜¯xï¼‰çš„å€¼optimizer=torch.optim.Adam([x],lr=1e-3)# åˆå§‹åŒ–ä¼˜åŒ–å™¨for step in range(20000): pred=himmelblau(x) optimizer.zero_grad()# æ¸…é›¶æ¢¯åº¦ï¼ˆä¸ç„¶ä¼šå‡ºç°æ¢¯åº¦ç´¯åŠ ï¼‰ pred.backward() # è‡ªåŠ¨æ±‚å¯¼è·å–æ¢¯åº¦ä¿¡æ¯ optimizer.step()# ä¼˜åŒ–å™¨æ‰§è¡Œä¸€æ¬¡æ›´æ–° if step%2000==0: print(&#x27;step &#123;&#125;: x = &#123;&#125;, f(x) = &#123;&#125;&#x27; .format(step,x.tolist(),pred.item())) æœ€ç»ˆè¿è¡Œç»“æœå¦‚ä¸‹æ‰€ç¤ºï¼Œå¯ä»¥å‘ç°æœ€ç»ˆæ˜¯æ‰¾åˆ°äº†ä¸€ä¸ªå…¨å±€æœ€ä¼˜è§£ï¼š äº†è§£äº†PyTorchæœ€åŸºæœ¬çš„æ¢¯åº¦çŸ¥è¯†åï¼Œä¸‹é¢æˆ‘ä»¬å°†ç»§ç»­å­¦ä¹ å¦‚ä½•ä½¿ç”¨PyTorchæ„é€ ç®€å•çš„ç¥ç»ç½‘ç»œäº†ã€‚"},{"title":"PyTorchç¥ç»ç½‘ç»œ","path":"/wiki/PyTorch/PyTorchç¥ç»ç½‘ç»œ.html","content":"Logistic Regression è¯¥æ¦‚å¿µç°ç›®å‰å·²ç»å®Œå…¨è¢«Classificationæ›¿æ¢æ‰ å°±æ˜¯é€šè¿‡è¾“å‡ºåŠ sigmoidå‡½æ•°ï¼Œè®©è¾“å‡ºæ¥è¿‘0æˆ–1ï¼Œè¾¾åˆ°åˆ†ç±»çš„æ•ˆæœã€‚ ç›®æ ‡ï¼šæœ€å°åŒ–dist(pred,y) Logistic Regression ä¸€èˆ¬ä½¿ç”¨äº¤å‰ç†µä½œä¸ºLosså‡½æ•°ï¼Œåœ¨Pytochæ¢¯åº¦ä¸­çš„äº¤å‰ç†µä¸€èŠ‚æœ‰å¯¹äº¤å‰ç†µlosså‡½æ•°è¯¦ç»†çš„è®²è§£ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°ã€‚ å¤šåˆ†ç±»é—®é¢˜å®æˆ˜â€”â€”å‡½æ•°APIå®ç° å‰é¢å¯¹è¿™ä¸€éƒ¨åˆ†çš„ä»‹ç»å·²ç»éå¸¸è¯¦ç»†äº†ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°ã€‚ ç½‘ç»œç»“æ„ 123456789101112131415161718192021w1, b1 = torch.randn(200, 784, requires_grad=True),\\ torch.zeros(200, requires_grad=True)w2, b2 = torch.randn(200, 200, requires_grad=True),\\ torch.zeros(200, requires_grad=True)w3, b3 = torch.randn(10, 200, requires_grad=True),\\ torch.zeros(10, requires_grad=True)# ä»¥ä¸‹ä¸‰è¡Œæ˜¯kaimingåˆå§‹åŒ–torch.nn.init.kaiming_normal_(w1)torch.nn.init.kaiming_normal_(w2)torch.nn.init.kaiming_normal_(w3)def forward(x): x = x@w1.t() + b1 x = F.relu(x) x = x@w2.t() + b2 x = F.relu(x) x = x@w3.t() + b3 x = F.relu(x) # logits return x æ³¨æ„ï¼šåˆå§‹åŒ–ä¸­tensorç¬¬ä¸€ä¸ªç»´åº¦æ˜¯outï¼ˆä¸‹ä¸€å±‚å‘é‡é•¿åº¦ï¼‰ï¼Œç¬¬äºŒä¸ªç»´åº¦æ˜¯inï¼ˆè¿™ä¸€å±‚å‘é‡é•¿åº¦ï¼‰ è®­ç»ƒè¿‡ç¨‹ è®­ç»ƒè¿‡ç¨‹çš„åŸç†å’Œåšå®¢PyTorchæ¢¯åº¦æœ€åè®²çš„ä¸€æ ·ï¼Œè¿™é‡Œä¸å†èµ˜è¿° 123456789101112131415161718192021optimizer = optim.SGD([w1, b1, w2, b2, w3, b3], lr=learning_rate)criteon = nn.CrossEntropyLoss()for epoch in range(epochs): for batch_idx, (data, target) in enumerate(train_loader): data = data.view(-1, 28*28) logits = forward(data) loss = criteon(logits, target) # åŒ…å«äº†softmaxå’Œlogæ±‚å¯¼éƒ¨åˆ† optimizer.zero_grad() loss.backward() # print(w1.grad.norm(), w2.grad.norm()) optimizer.step() if batch_idx % 100 == 0: print(&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\\tLoss: &#123;:.6f&#125;&#x27;.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100. * batch_idx / len(train_loader), loss.item())) æ±‡æ€» é‡‡ç”¨çš„æ˜¯MINISTæ•°æ®é›†,ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimfrom torchvision import datasets, transformsbatch_size=200learning_rate=0.01epochs=10train_loader = torch.utils.data.DataLoader( datasets.MNIST(&#x27;../data&#x27;, train=True, download=True, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=True)test_loader = torch.utils.data.DataLoader( datasets.MNIST(&#x27;../data&#x27;, train=False, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=True)w1, b1 = torch.randn(200, 784, requires_grad=True),\\ torch.zeros(200, requires_grad=True)w2, b2 = torch.randn(200, 200, requires_grad=True),\\ torch.zeros(200, requires_grad=True)w3, b3 = torch.randn(10, 200, requires_grad=True),\\ torch.zeros(10, requires_grad=True)# ä»¥ä¸‹ä¸‰è¡Œæ˜¯kaimingåˆå§‹åŒ–torch.nn.init.kaiming_normal_(w1)torch.nn.init.kaiming_normal_(w2)torch.nn.init.kaiming_normal_(w3)def forward(x): x = x@w1.t() + b1 x = F.relu(x) x = x@w2.t() + b2 x = F.relu(x) x = x@w3.t() + b3 x = F.relu(x) return xoptimizer = optim.SGD([w1, b1, w2, b2, w3, b3], lr=learning_rate)criteon = nn.CrossEntropyLoss()for epoch in range(epochs): for batch_idx, (data, target) in enumerate(train_loader): data = data.view(-1, 28*28) logits = forward(data) loss = criteon(logits, target) # åŒ…å«äº†softmaxå’Œlogæ±‚å¯¼éƒ¨åˆ† optimizer.zero_grad() loss.backward() # print(w1.grad.norm(), w2.grad.norm()) optimizer.step() if batch_idx % 100 == 0: print(&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\\tLoss: &#123;:.6f&#125;&#x27;.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100. * batch_idx / len(train_loader), loss.item())) test_loss = 0 correct = 0 for data, target in test_loader: data = data.view(-1, 28 * 28) logits = forward(data) test_loss += criteon(logits, target).item() pred = logits.data.max(1)[1] correct += pred.eq(target.data).sum() test_loss /= len(test_loader.dataset) print(&#x27; Test set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%) &#x27;.format( test_loss, correct, len(test_loader.dataset), 100. * correct / len(test_loader.dataset))) å…¨è¿æ¥å±‚â€”â€”ç±»APIå®ç° ç½‘ç»œç»“æ„ åœ¨ä¸Šä¸€æ¬¡çš„å®è·µä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨åˆ†æ•£çš„wï¼Œb tensorå®ç°äº†ä¸€ä¸ªéå¸¸ç®€å•çš„ä¸‰å±‚å…¨è¿æ¥å±‚ï¼ˆå‡½æ•°APIå®ç°ï¼‰ã€‚ä½†æ˜¯è¿™æ ·è™½ç„¶ç®€å•ï¼Œä½†æ˜¯ä¸å¤Ÿç›´è§‚ï¼Œå˜é‡ç¨å¾®æœ‰ç‚¹å¤šï¼Œè¿™æ¬¡æˆ‘ä»¬ä»‹ç»ä½¿ç”¨PyTorchè‡ªå¸¦çš„APIå®ç°ä¸€ä¸ªå’Œä¸Šé¢ä¸€æ ·çš„ä¸‰å±‚å…¨è¿æ¥å±‚ã€‚ 1234567891011121314151617In [3]: x=torch.randn(1,784)In [4]: x.shapeOut[4]: torch.Size([1, 784])In [5]: from torch import nnIn [6]: layer1=nn.Linear(784,200)In [7]: layer2=nn.Linear(200,200)In [8]: layer3=nn.Linear(200,10)In [9]: x=layer1(x)In [10]: x.shapeOut[10]: torch.Size([1, 200])In [11]: x=layer2(x)In [12]: x.shapeOut[12]: torch.Size([1, 200])In [13]: x=layer3(x)In [14]: x.shapeOut[14]: torch.Size([1, 10]) è¿™ä¸ªåªæ˜¯æ¯”è¾ƒåƒï¼Œä½†æ˜¯è¿˜æ˜¯æœ‰äº›åŒºåˆ«ï¼Œå› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰åŠ å±‚ä¹‹é—´çš„æ¿€æ´»å‡½æ•°ã€‚ ä¸‹é¢æˆ‘ä»¬åœ¨å±‚ä¹‹é—´æ·»åŠ æ¿€æ´»å‡½æ•°ï¼š 12345678910111213141516171819In [3]: from torch import nnIn [4]: import torch.nn.functional as FIn [5]: x=torch.randn(1,784)In [6]: layer1=nn.Linear(784,200)In [7]: layer2=nn.Linear(200,200)In [8]: layer3=nn.Linear(200,10)In [9]: x=layer1(x)In [10]: x=F.relu(x,inplace=True)In [11]: x.shapeOut[11]: torch.Size([1, 200])In [12]: x=layer2(x)In [13]: x=F.relu(x,inplace=True)In [14]: x.shapeOut[14]: torch.Size([1, 200])In [15]: x=layer3(x)In [16]: x=F.relu(x,inplace=True)In [17]: x.shapeOut[17]: torch.Size([1, 10]) reluä¸­çš„inplaceå‚æ•°å¦‚æœè®¾ç½®ä¸ºtrueçš„è¯ï¼ŒèŠ‚çœäº†å†…å­˜ï¼Œç›¸å½“äºè¾“å‡ºå’Œè¾“å…¥ç”¨åŒä¸€ä»½å†…å­˜ã€‚ å­¦ä¼šäº†å¦‚ä¸ŠAPIå®šä¹‰ç½‘ç»œï¼Œå› ä¸ºä¸€èˆ¬æƒ…å†µä¸‹çš„å·¥ç¨‹ï¼Œç½‘ç»œéƒ½ä¼šå®šä¹‰æˆä¸ºä¸€ä¸ªç±»ï¼Œæ‰€ä»¥è¿™é‡Œï¼Œæˆ‘ä»¬å­¦ä¹ å¦‚ä½•å°†ç½‘ç»œå®šä¹‰ä¸ºä¸€ä¸ªç±»ã€‚ 12345678910111213141516class MPL(nn.Module): def __init__(self): super(MLP,self).__init__() self.model=nn.Sequential( #çº¿æ€§å®¹å™¨ï¼Œå¯ä»¥å®¹çº³æ‰€æœ‰nn.Moduleç±» nn.Linear(784,200), nn.ReLU(inplace=True), nn.Linear(200,200), nn.ReLU(inplace=True), nn.Linear(200,10), nn.ReLU(inplace=True), ) def forward(self,x): x=self.model(x) return x æ³¨æ„åŒºåˆ†F.relu(x,inplace=True)å’Œä¸Šé¢nn.ReLU(inplace=True)è¿™ä¸¤ç§ç±»å‹çš„APIï¼Œå‰è€…æ˜¯å‡½æ•°ç±»å‹APIï¼Œå…¶ä¸­çš„tensoræ”¯æŒè‡ªå·±ç®¡ç†ï¼Œåè€…æ˜¯ç±»-ç±»å‹APIï¼Œtensorä¸ºç±»å†…éƒ¨å˜é‡ä¸èƒ½éšæ„è®¿é—®ï¼Œä½¿ç”¨ä¹Ÿå¿…é¡»å°†ç±»å®ä¾‹åŒ–åæ‰å¯ä»¥ä½¿ç”¨ã€‚ è®­ç»ƒè¿‡ç¨‹ ä»£ç å¦‚ä¸‹ï¼Œè¯¦æƒ…è§æ³¨é‡Šï¼š 123456789101112131415net=MLP()# å®ä¾‹åŒ–ç½‘ç»œoptimizer=optim.SGD(net.parameters(),lr=learning_rate) # è¿™é‡Œä½¿ç”¨parameters()è‡ªåŠ¨åŠ è½½ç›®æ ‡å˜é‡criteon = nn.CrossEntropyLoss()for epoch in range(epochs): for batch_idx, (data,target) in enumerate(train_loader): data=data.view(-1,28*28) logits=net(data) # é‡è½½forwardåï¼Œç›´æ¥ä¼ å…¥å‚æ•°é»˜è®¤forward loss=criteon(logits,target) optimizer.zero_grad() loss.backward() optimizer.step() æ±‡æ€» é‡‡ç”¨ç±»APIä¹¦å†™ï¼Œä½¿ç”¨çš„æ˜¯MINISTæ•°æ®é›†,ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimfrom torchvision import datasets, transformsbatch_size=200learning_rate=0.01epochs=10train_loader = torch.utils.data.DataLoader( datasets.MNIST(&#x27;../data&#x27;, train=True, download=True, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=True)test_loader = torch.utils.data.DataLoader( datasets.MNIST(&#x27;../data&#x27;, train=False, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=True)class MLP(nn.Module): def __init__(self): super(MLP, self).__init__() self.model = nn.Sequential( nn.Linear(784, 200), nn.ReLU(inplace=True), nn.Linear(200, 200), nn.ReLU(inplace=True), nn.Linear(200, 10), nn.ReLU(inplace=True), ) def forward(self, x): x = self.model(x) return xnet = MLP()optimizer = optim.SGD(net.parameters(), lr=learning_rate)criteon = nn.CrossEntropyLoss()for epoch in range(epochs): for batch_idx, (data, target) in enumerate(train_loader): data = data.view(-1, 28*28) logits = net(data) loss = criteon(logits, target) optimizer.zero_grad() loss.backward() # print(w1.grad.norm(), w2.grad.norm()) optimizer.step() if batch_idx % 100 == 0: print(&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\\tLoss: &#123;:.6f&#125;&#x27;.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100. * batch_idx / len(train_loader), loss.item())) test_loss = 0 correct = 0 for data, target in test_loader: data = data.view(-1, 28 * 28) logits = net(data) test_loss += criteon(logits, target).item() pred = logits.data.max(1)[1] correct += pred.eq(target.data).sum() test_loss /= len(test_loader.dataset) print(&#x27; Test set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%) &#x27;.format( test_loss, correct, len(test_loader.dataset), 100. * correct / len(test_loader.dataset))) ä»¥ä¸Šä¸ºç›®å‰çš„ä¸»æµç‰ˆæœ¬ï¼Œå€¼å¾—å­¦ä¹ ä¸å‚è€ƒï¼ æ¿€æ´»å‡½æ•°ä¸GPUåŠ é€Ÿ æ¿€æ´»å‡½æ•° tanhâ€”â€”RNN sigmoidâ€”â€”probability ReLUâ€”â€”DL LeakyReLUâ€”â€”DL SELUâ€”â€”ä¼˜åŒ–äº†ReLUåœ¨0ç‚¹å¯¼æ•°ä¸è¿ç»­çš„æƒ…å†µ softplusâ€”â€”åŒSELUï¼Œå…‰æ»‘äº†ReLUåœ¨0ç‚¹å¤„çš„è¿æ¥ GPUåŠ é€Ÿ ç°ç›®å‰è¾ƒé«˜ç‰ˆæœ¬çš„PyTorchå·²ç»å¯ä»¥ä½¿ç”¨toæ–¹æ³•æŒ‡å®šä½¿ç”¨ç‰¹å®šè®¾å¤‡è¿›è¡Œè¿ç®—ï¼Œè€Œä¸å¿…åƒåŸæ¥ä½¿ç”¨ä¸åŒè®¾å¤‡è¿›è¡Œç›¸åŒçš„è¿ç®—éœ€è¦è°ƒç”¨ä¸åŒçš„APIã€‚ ä½¿ç”¨GPU cudaåŠ é€Ÿè¿ç®—çš„ä»£ç å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š 12345678910device = torch.device(&#x27;cuda:0&#x27;)net = MLP().to(device)optimizer = optim.SGD(net.parameters(), lr=learning_rate)criteon = nn.CrossEntropyLoss().to(device)for epoch in range(epochs): for batch_idx, (data, target) in enumerate(train_loader): data = data.view(-1, 28*28) data, target = data.to(device), target.cuda()# å»ºè®®ç»Ÿä¸€ç”¨toï¼Œè¿™é‡Œåªæ˜¯æƒ³è¯´æ˜ç”¨.cuda()ä¹Ÿæ˜¯å¯ä»¥çš„ ä¸Šè¿°ä»£ç ç›¸å½“äºæ˜¯å°†ç½‘ç»œï¼Œlosså‡½æ•°å’Œæ‰€æœ‰çš„æ•°æ®éƒ½æ¬è¿åˆ°äº†GPUä¸Šå»ã€‚ æ±‡æ€» é‡‡ç”¨çš„æ˜¯MINISTæ•°æ®é›†, ä¼˜åŒ–æ¿€æ´»å‡½æ•°å˜ä¸ºLeakyReLU ä½¿ç”¨äº†GPU cudaåŠ é€Ÿ ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimfrom torchvision import datasets, transformsbatch_size=200learning_rate=0.01epochs=10train_loader = torch.utils.data.DataLoader( datasets.MNIST(&#x27;../data&#x27;, train=True, download=True, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=True)test_loader = torch.utils.data.DataLoader( datasets.MNIST(&#x27;../data&#x27;, train=False, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ])), batch_size=batch_size, shuffle=True)class MLP(nn.Module): def __init__(self): super(MLP, self).__init__() self.model = nn.Sequential( nn.Linear(784, 200), nn.LeakyReLU(inplace=True), nn.Linear(200, 200), nn.LeakyReLU(inplace=True), nn.Linear(200, 10), nn.LeakyReLU(inplace=True), ) def forward(self, x): x = self.model(x) return xdevice = torch.device(&#x27;cuda:0&#x27;)net = MLP().to(device)optimizer = optim.SGD(net.parameters(), lr=learning_rate)criteon = nn.CrossEntropyLoss().to(device)for epoch in range(epochs): for batch_idx, (data, target) in enumerate(train_loader): data = data.view(-1, 28*28) data, target = data.to(device), target.cuda() logits = net(data) loss = criteon(logits, target) optimizer.zero_grad() loss.backward() # print(w1.grad.norm(), w2.grad.norm()) optimizer.step() if batch_idx % 100 == 0: print(&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\\tLoss: &#123;:.6f&#125;&#x27;.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100. * batch_idx / len(train_loader), loss.item())) test_loss = 0 correct = 0 for data, target in test_loader: data = data.view(-1, 28 * 28) data, target = data.to(device), target.cuda() logits = net(data) test_loss += criteon(logits, target).item() pred = logits.data.max(1)[1] correct += pred.eq(target.data).sum() test_loss /= len(test_loader.dataset) print(&#x27; Test set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%) &#x27;.format( test_loss, correct, len(test_loader.dataset), 100. * correct / len(test_loader.dataset))) æµ‹è¯•ç¯èŠ‚ å¯ä»¥å‘ç°å‰é¢æ‰€è®²çš„å†…å®¹åªæ˜¯è¦†ç›–äº†ç½‘ç»œç»“æ„çš„åˆå§‹åŒ–ä»¥åŠè®­ç»ƒè¿‡ç¨‹ï¼Œå¹¶æ²¡æœ‰è®²è§£æµ‹è¯•è¿‡ç¨‹ï¼Œä¸‹é¢æˆ‘ä»¬å°±æ¥å­¦ä¹ ä¸€ä¸‹å½“PyTorchè®­ç»ƒå®Œæˆåï¼Œå¦‚ä½•è¿›è¡Œæµ‹è¯•ã€‚ å¯¹äºMINISTæ•°æ®é›†å…¶å®å°±æ˜¯å°†æœ€åçš„ç®—losså’Œloss.backward()å»æ‰ï¼Œç›´æ¥å°†logitsæ¥ä¸€ä¸ªsoftmaxå±‚ï¼ˆå…¶å®ä¹Ÿå¯ä»¥ä¸åŠ ï¼‰ç„¶åæ‰¾åˆ°æœ€å¤§å€¼çš„indexå³å¯ï¼ˆä½¿ç”¨argmaxå‡½æ•°ï¼‰ã€‚ è®¡ç®—å‡†ç¡®ç‡å°±æ˜¯ç”¨é¢„æµ‹æ­£ç¡®çš„æ•°é‡é™¤ä»¥æ€»æ•°é‡ã€‚ ä»£ç å®ç° ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„æµ‹è¯•ç¯èŠ‚çš„æ¨¡æ‹Ÿä»£ç ï¼Œå…¶ä¸­è®¡ç®—å‡†ç¡®ç‡è¿™ä¸€éƒ¨åˆ†è¿˜æ˜¯æœ‰ä¸€äº›æŠ€æœ¯æ€§çš„ã€‚ 1234567891011121314151617In [3]: logits=torch.rand(4,10)In [4]: import torch.nn.functional as FIn [5]: pred=F.softmax(logits,dim=1)In [6]: pred.shapeOut[6]: torch.Size([4, 10])In [7]: pred_label=pred.argmax(dim=1)In [8]: pred_labelOut[8]: tensor([8, 0, 0, 0])In [9]: logits.argmax(dim=1)Out[9]: tensor([8, 0, 0, 0])In [10]: label=torch.tensor([8,0,1,2])In [11]: correct=torch.eq(pred_label,label)In [12]: correctOut[12]: tensor([ True, True, False, False])In [13]: correct.sum().float().item()/4Out[13]: 0.5 è¿˜æœ‰ä¸€äº›å…¶ä»–çš„è¯„ä»·å‚æ•°ï¼Œæ¯”å¦‚precisionæˆ–recallï¼Œè¿™äº›åé¢ä¼šå•ç‹¬å†™ä¸€ç¯‡åšå®¢è¿›è¡Œè®²è§£ã€‚ ä»€ä¹ˆæ—¶å€™æµ‹è¯•ï¼Ÿ åœ¨è¿è¡Œå®Œå‡ ä¸ªBatchåè¿›è¡Œä¸€æ¬¡test è¿è¡Œå®Œä¸€ä¸ªepochåè¿›è¡Œä¸€æ¬¡æµ‹è¯• æ±‡æ€» ä»£ç æ±‡æ€»è§ä¸Šé¢çš„æ±‡æ€»æ¨¡å— Visdomå¯è§†åŒ– step1ï¼šå®‰è£…visdom 1pip install visdom step2ï¼šå¼€å¯visdom WebæœåŠ¡å™¨ å‘½ä»¤è¡Œä¸­è¾“å…¥ï¼š 1python -m visdom.server step3ï¼šç„¶åå°±å¯ä»¥å°†æ•°æ®ä¸¢å…¥visdomè¿›è¡Œå¯è§†åŒ–æŸ¥çœ‹äº† 1234from visdom import Visdomviz=Visdom()viz.line([0.],[0.],win=&#x27;train_loss&#x27;,opts=dict(title=&#x27;train_loss_title&#x27;))# åˆ›å»ºä¸€æ¡ç›´çº¿ï¼Œå‰ä¸¤ä¸ªå‚æ•°ç¬¬ä¸€ä¸ªæ˜¯yï¼Œç¬¬äºŒä¸ªæ˜¯xviz.line([loss.item()],[global_step],win=&#x27;train_loss&#x27;,update=&#x27;append&#x27;)# ä¼ å…¥ä»æ˜¯numpyæ•°æ®ï¼ˆimageå¯ä»¥æ¥æ”¶tensorï¼‰ `win`ï¼šå°çª—å£IDenv:å¤§çª—å£IDï¼Œå¤§çª—å£ä¸­å¯ä»¥æœ‰å¾ˆå¤šä¸ªå°çª—å£ï¼Œé»˜è®¤æ˜¯mainå¤§çª—å£ update:è‹¥ä¸ºappendè¡¨ç¤ºæ·»åŠ åœ¨å½“å‰ç›´çº¿çš„åé¢ï¼Œè‹¥ä¸æŒ‡å®šä¼šè¢«è¦†ç›–æ‰ å¤šæ¡æ›²çº¿ä¸€ä¸ªçª—å£ ä¸Šé¢çš„ä»£ç å®ç°çš„æ˜¯ä¸€æ¡æ›²çº¿ä¸€ä¸ªçª—å£ï¼Œä¸‹é¢æˆ‘ä»¬æ¥è®²ä¸€ä¸‹å¦‚ä½•å®ç°å¤šæ¡æ›²çº¿ç”»åœ¨ä¸€ä¸ªçª—å£ã€‚ 12345from matplotlib.pyplot import legendfrom visdom import Visdomviz=Visdom()viz.line([0.,0.],[0.],win=&#x27;test&#x27;,opts=dict(title=&#x27;train_loss&amp;acc&#x27;,legend=[&#x27;loss&#x27;,&#x27;acc&#x27;]))viz.line([test_loss,correct/len(test_loader.dataset)],[global_step],win=&#x27;train_loss&#x27;,update=&#x27;append&#x27;) å…¶å®å°±æ˜¯å°†yå‚æ•°çš„listå¢åŠ äº†ä¸€ä¸ªé•¿åº¦ï¼Œå°±å¯ä»¥ä¸€ä¸ªå°çª—å£ç”»ä¸¤æ¡æ›²çº¿ã€‚ visual x è¿™æ˜¯visdomæä¾›çš„ä¸€ä¸ªå¯è§†åŒ–çš„åŠŸèƒ½ 123456from matplotlib.pyplot import legendfrom visdom import Visdomviz=Visdom()#MINSTä¸ºä¾‹viz.images(data.view(-1,1,28,28)ï¼Œwin=&#x27;x&#x27;) # å¯¹äºå›¾ç‰‡ï¼Œè¿™é‡Œå¯ä»¥ç›´æ¥æ¥æ”¶tensorï¼ï¼ï¼viz.text(str(pred.detach().cpu().numpy()),win=&#x27;pred&#x27;,opts=dict(title=&#x27;pred&#x27;)) # å¯¹äºStringç±»å‹è¿˜æ˜¯è¦å…ˆè½¬åˆ°cpuç„¶å¹´è½¬numpyç„¶åè½¬string"},{"title":"PyTorchç»ˆç« ï¼šå¼€GANï¼","path":"/wiki/PyTorch/PyTorchç»ˆç« ï¼šå¼€GANï¼.html","content":"GANç®€ä»‹ GANçš„ç»ˆæç›®çš„å°±æ˜¯å­¦ä¹ p(x)p(x)p(x),p(x)p(x)p(x)æ˜¯ä¸€ä¸ªåˆ†å¸ƒï¼Œæ¯”å¦‚å®ƒå¯ä»¥æ˜¯äºŒæ¬¡å…ƒå¤´åƒå›¾ç‰‡ç‰¹å¾çš„åˆ†å¸ƒï¼Œå¯ä»¥æ˜¯ä¸€ç§ç±»å‹çš„ç”»ä½œçš„ç‰¹å¾é›†åˆï¼Œæˆ‘ä»¬å­¦ä¼šäº†p(x)p(x)p(x)åï¼Œæˆ‘ä»¬ä¾¿å¯ä»¥åœ¨å…¶ä¸­è¿›è¡Œsampleç„¶åå°±å¯ä»¥è¿›è¡Œåˆ›ä½œäº†ã€‚è¿™ä¾¿æ˜¯GANçš„åŸç†è§£é‡Šã€‚ GAN ç»“æ„ ç”Ÿæˆå™¨ï¼ˆPainter or Generatorï¼‰ é‰´åˆ«å™¨ï¼ˆCritic or Discriminatorï¼‰ å¤§è‡´ç»“æ„å¦‚ä¸Šï¼Œç”Ÿæˆå™¨æ ¹æ®éšæœºç”Ÿæˆçš„ä¿¡å·ï¼Œäº§ç”Ÿä¸€å¹…â€œç”»â€ã€‚é‰´åˆ«å™¨ä½¿ç”¨å¾ˆå¤šçœŸçš„å’Œå‡çš„â€œç”»â€è¿›è¡Œè®­ç»ƒï¼Œæ¥åˆ†è¾¨ç”»çš„çœŸå‡ï¼Œä»è€Œäº§ç”Ÿä¸€ä¸ªæ‰“åˆ†å€¼ã€‚åˆ†å€¼è¶Šé«˜è¡¨æ˜ç”»è¶ŠçœŸå®ï¼ˆé‰´åˆ«å™¨çœ‹æ¥ï¼‰ã€‚é‰´åˆ«å™¨çš„ç›®æ ‡æ˜¯å°½å¯èƒ½çš„åˆ†è¾¨å‡ºçœŸâ€œç”»â€å’Œå‡â€œç”»â€ã€‚ç”Ÿæˆå™¨çš„ç›®æ ‡æ˜¯å°½å¯èƒ½çš„æœ€å¤§åŒ–é‰´åˆ«å™¨çš„æ‰“åˆ†ï¼ˆç›¸å½“äºå°½å¯èƒ½çš„æ¬ºéª—é‰´åˆ«å™¨ï¼‰ GANçš„å‡ºç°è®©ç¥ç»ç½‘ç»œå…·æœ‰äº†åˆ›é€ æ€§ï¼Œå½“æˆ‘ä»¬éœ€è¦ä½¿ç”¨ç¥ç»ç½‘ç»œå®Œæˆä¸€äº›å…·æœ‰åˆ›é€ åŠ›çš„ä»»åŠ¡æ—¶ï¼ŒGANæ˜¯ä¸€ä¸ªéå¸¸ä¸é”™çš„é€‰æ‹©ã€‚ è¿™é‡Œæ¨èä¸€ä¸ªéå¸¸ä¸é”™çš„å…³äºGANåœ¨çº¿è®­ç»ƒçš„ç½‘é¡µé“¾æ¥ [GANplayground: Experiment with Generative Adversarial Networks in your browser ](https://reiinakano.com/gan-playground/) ä¸‹å›¾æ˜¯GANç½‘ç»œçš„å½¢è±¡è§£é‡Šï¼Œç»¿çº¿æ˜¯æˆ‘ä»¬è¦å­¦ä¹ çš„ç‰©ä½“çš„ç‰¹å¾ï¼ˆæ¯”å¦‚äºŒæ¬¡å…ƒå¤´åƒçš„ç‰¹å¾ï¼‰çš„åˆ†å¸ƒï¼Œé»‘çº¿æ˜¯æˆ‘ä»¬å­¦ä¹ åˆ°çš„ç‰¹å¾çš„åˆ†å¸ƒï¼Œè“çº¿æ˜¯é‰´åˆ«å™¨çš„è¾“å‡ºï¼Œä¸€å¼€å§‹ç”Ÿæˆå™¨å’Œé‰´åˆ«å™¨éƒ½æ²¡æœ‰è¿›è¡Œè®­ç»ƒï¼Œæ‰€ä»¥ç”Ÿæˆå™¨ç”Ÿæˆçš„åˆ†å¸ƒéå¸¸çš„çƒ‚ï¼Œé‰´åˆ«å™¨ä¹Ÿæ— æ³•å¾ˆå¥½çš„é‰´åˆ«å›¾ç‰‡æ˜¯å¦æ˜¯ç”Ÿæˆå™¨ç”Ÿæˆçš„ï¼ˆå¦‚å›¾(a)æ‰€ç¤ºï¼‰ï¼Œç´§æ¥ç€æˆ‘ä»¬è®­ç»ƒé‰´åˆ«å™¨ï¼Œç„¶åå¯ä»¥å‘ç°åœ¨è®­ç»ƒä¸€æ®µæ—¶é—´åé‰´åˆ«å™¨å·²ç»å¯ä»¥å¾ˆå¥½çš„é‰´åˆ«å›¾ç‰‡çš„çœŸä¼ªäº†ï¼ˆå›¾bï¼‰ã€‚æ¥ç€æˆ‘ä»¬è®­ç»ƒç”Ÿæˆå™¨ï¼Œç”Ÿæˆå™¨çš„ç›®æ ‡æ˜¯å°½é‡è®©é‰´åˆ«å™¨è®¤ä¸ºå›¾ç‰‡æ˜¯çœŸçš„ï¼Œä»è€Œç»™å‡ºé«˜åˆ†ï¼Œéšç€è®­ç»ƒæ¬¡æ•°çš„å¢åŠ ï¼Œç”Ÿæˆå™¨ç”Ÿæˆçš„åˆ†å¸ƒä¼šè¶Šæ¥è¶Šæ¥è¿‘çœŸå®çš„åˆ†å¸ƒï¼ˆå¦‚å›¾Â©æ‰€ç¤ºï¼‰ï¼Œåœ¨æœ€åçš„æ—¶å€™è¿é‰´åˆ«å™¨ä¹Ÿæ— æ³•è¯†åˆ«ç”Ÿæˆå™¨ç”Ÿæˆå›¾ç‰‡çš„çœŸä¼ªæ—¶ï¼Œè®­ç»ƒç»“æŸã€‚ï¼ˆå›¾dï¼‰ GANåŸç† GANçš„è®­ç»ƒåˆ†ä¸ºä¸¤æ­¥ã€‚ å›ºå®šç”Ÿæˆå™¨ï¼ˆGï¼‰è®­ç»ƒé‰´åˆ«å™¨ï¼ˆDï¼‰ä½¿å…¶æ”¶æ•› å›ºå®šé‰´åˆ«å™¨ï¼ˆDï¼‰è®­ç»ƒç”Ÿæˆå™¨ï¼ˆGï¼‰ä½¿å…¶æ”¶æ•› ä¸‹é¢æˆ‘ä»¬å°±åˆ†åˆ«æ¥è¯¦ç»†è¯´æ˜ä¸€ä¸‹è¿™ä¸¤æ­¥ä¸­çš„æ•°å­¦åŸç†ã€‚ é¦–å…ˆæˆ‘ä»¬è¦æ˜ç™½æˆ‘ä»¬çš„æœ€ç»ˆç›®æ ‡ minâ¡Gmaxâ¡DL(D,G)=Exâˆ¼pr(x)[logâ¡D(x)]+Ezâˆ¼pz(z)[logâ¡(1âˆ’D(G(z)))]\\min\\limits_{G}\\max\\limits_{D} L(D,G)=\\mathbb{E}_{x\\sim p_r(x)}[\\log D(x)] + \\mathbb{E}_{z\\sim p_z(z)}[\\log(1- D(G(z)))] Gminâ€‹Dmaxâ€‹L(D,G)=Exâˆ¼prâ€‹(x)â€‹[logD(x)]+Ezâˆ¼pzâ€‹(z)â€‹[log(1âˆ’D(G(z)))] minâ¡Gmaxâ¡DL(D,G)=Exâˆ¼pr(x)[logâ¡D(x)]+Exâˆ¼pg(x)[logâ¡(1âˆ’D(x))]\\min\\limits_{G}\\max\\limits_{D} L(D,G)=\\mathbb{E}_{x\\sim p_r(x)}[\\log D(x)] + \\mathbb{E}_{x\\sim p_g(x)}[\\log(1- D(x))] Gminâ€‹Dmaxâ€‹L(D,G)=Exâˆ¼prâ€‹(x)â€‹[logD(x)]+Exâˆ¼pgâ€‹(x)â€‹[log(1âˆ’D(x))] çº³ä»€å‡è¡¡â€”â€”D å¯¹äºå›ºå®šçš„Gï¼Œæœ€å¥½çš„Dæ˜¯ï¼š DGâˆ—(x)=pdata(x)pdata(x)+pg(x)D^*_G(x)=\\frac{p_{data}(x)}{p_{data}(x)+p_g(x)} DGâˆ—â€‹(x)=pdataâ€‹(x)+pgâ€‹(x)pdataâ€‹(x)â€‹ è®­ç»ƒDçš„å‡†åˆ™ï¼ˆcriterionï¼‰æ˜¯å¯¹äºç»™å®šçš„Gæœ€å¤§åŒ–V(G,D)V(G,D)V(G,D) V(G,D)=âˆ«xpdata(x)logâ¡(D(x))dx+âˆ«zp(z)logâ¡(1âˆ’D(g(z)))dz=âˆ«xpdata(x)logâ¡(D(x))+pg(x)logâ¡(1âˆ’D(x))dx\\begin{aligned} V(G,D) &amp;= \\int_x p_{data}(x)\\log(D(x))dx + \\int_z p(z)\\log(1-D(g(z)))dz\\\\ &amp;= \\int_xp_{data}(x)\\log(D(x))+p_g(x)\\log(1-D(x))dx \\end{aligned} V(G,D)â€‹=âˆ«xâ€‹pdataâ€‹(x)log(D(x))dx+âˆ«zâ€‹p(z)log(1âˆ’D(g(z)))dz=âˆ«xâ€‹pdataâ€‹(x)log(D(x))+pgâ€‹(x)log(1âˆ’D(x))dxâ€‹ è¿™ä¸ªå…¶å®å°±æ˜¯æ±‚æœŸæœ›ï¼Œåªæ˜¯æŠŠå®ƒå†™æˆäº†ç§¯åˆ†å½¢å¼ã€‚ æˆ‘ä»¬å¯¹ä¸Šé¢è¿™ä¸ªå¼å­æ±‚å¯¼ï¼Œå°±å¯ä»¥çŸ¥é“æœ€å¥½çš„DDDæ˜¯ä¸Šé¢çš„Dâˆ—D^*Dâˆ— çº³ä»€å‡è¡¡â€”â€”G å½“æˆ‘ä»¬è®­ç»ƒå®ŒDåï¼Œä¸‹é¢å°±è½®åˆ°Gè¿›è¡Œè®­ç»ƒäº†ã€‚ L(G,Dâˆ—)=2DJS(prâˆ£âˆ£pg)âˆ’2logâ¡2L(G,D^*)=2D_{JS}(p_r||p_g)-2\\log2 L(G,Dâˆ—)=2DJSâ€‹(prâ€‹âˆ£âˆ£pgâ€‹)âˆ’2log2 è¿™ä¾¿æ˜¯æ¬ºéª—é‰´åˆ«å™¨è¿™ä¸€ç›´è§‚ç†è§£çš„ç›®æ ‡å‡½æ•°è¡¨è¾¾å½¢å¼ï¼Œæˆ‘ä»¬çš„ç›®çš„æ˜¯æœ€å°åŒ–è¿™ä¸ªå‡½æ•°ã€‚ GANçš„é—®é¢˜ è®­ç»ƒç¨³å®šæ€§å·® å¯¼è‡´è¿™ä¸ªæƒ…å†µä¸»è¦æ˜¯æœ‰ä¸¤ä¸ªåŸå› ï¼š æ•°æ®æœ¬èº«çš„ç‰¹å¾ å› ä¸ºåœ¨å¾ˆå¤šæƒ…å†µä¸‹PGP_GPGâ€‹å’ŒPdataP_{data}Pdataâ€‹æ˜¯å‡ ä¹ä¸å¯èƒ½é‡åˆçš„ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªåˆ†å¸ƒçš„ç‰¹å¾æ˜¯åœ¨é«˜ç»´ç‰¹å¾ç©ºé—´ä¸­å°±å‡ ä¹æ˜¯ä¸¤æ¡çº¿ï¼ˆä»…ç”¨äºè¯´æ˜ï¼‰ï¼Œä»–ä»¬é‡åˆçš„éƒ¨åˆ†å‡ ä¹å¯ä»¥å¿½ç•¥ã€‚ é‡‡æ · å°±ç®—PGP_GPGâ€‹å’ŒPdataP_{data}Pdataâ€‹è¿˜æ˜¯æœ‰ä¸€éƒ¨åˆ†é‡åˆçš„ï¼Œä½†æ˜¯å¦‚æœæˆ‘ä»¬é‡‡æ ·æ²¡æœ‰é‡‡å¤Ÿçš„è¯ï¼Œè¿˜æ˜¯æœ‰å¯èƒ½å‡ºç°ä¸‹å›¾çš„æƒ…å†µï¼Œè®©æˆ‘ä»¬è®¤ä¸ºä¸¤ä¸ªåˆ†å¸ƒæ²¡æœ‰é‡åˆã€‚ï¼ˆç‚¹ä¸ºå®é™…çš„é‡‡æ ·ç‚¹ï¼Œä¸¤ä¸ªæ¤­åœ†è¡¨ç¤ºçš„æ˜¯å®é™…çš„ä¸¤ä¸ªåˆ†å¸ƒæƒ…å†µã€‚ï¼‰ JS ç»è¿‡æ•°å­¦æ¨å¯¼ï¼Œåªè¦ä¸¤ä¸ªåˆ†å¸ƒä¸é‡å ï¼ŒJS Divergenceçš„å–å€¼æ°¸è¿œéƒ½æ˜¯logâ¡2\\log 2log2ã€‚è¿™ä¸ªå°±æ²¡æœ‰å¾ˆå¥½çš„é‡åŒ–åˆ†å¸ƒä¹‹é—´è·ç¦»çš„è¿™ç§å…³ç³»ã€‚è€Œä¸”æ ¹æ®æ•°æ®çš„è‡ªç„¶ç‰¹æ€§æˆ‘ä»¬ä¹ŸçŸ¥é“è¿™ä¸¤ä¸ªåˆ†å¸ƒæ˜¯ä¸å¥½é‡å çš„ï¼Œæˆ–è€…è¯´å¤§æ¦‚ç‡æ˜¯ä¸ä¼šé‡å çš„ï¼ŒJS Divergenceä¸€ç›´ä¸å˜ä¼šç»™æ¢¯åº¦ä¸‹é™å¸¦æ¥å¾ˆå¤§çš„é—®é¢˜ï¼Œå¯¼è‡´æ¨¡å‹ä¸€ç›´ä¸æ”¶æ•›ã€‚è¿™ä¾¿æ˜¯JS Divergenceåœ¨GANä¸­ä½¿ç”¨çš„ä¸€ä¸ªéå¸¸ä¸¥é‡çš„é—®é¢˜ã€‚ è§£å†³JSçš„é—®é¢˜ æˆ‘ä»¬é‡‡ç”¨äº†Wasserstein Distanceæ¥ä»£æ›¿JSã€‚å…¶æ ¹æœ¬æ€æƒ³å°±æ˜¯è¡¡é‡å°†ä¸€ä¸ªåˆ†å¸ƒå˜æˆå¦ä¸€ä¸ªåˆ†å¸ƒæ‰€éœ€è¦çš„æœ€å°ä»£ä»·ã€‚ï¼ˆç›´è§‚ç†è§£å°±æ˜¯æ¬ç –ï¼ŒæŠŠä¸€ä¸ªç –å †å˜æˆå¦å¤–ä¸€ç§ç –å †æ‰€éœ€çš„æœ€å°ä»£ä»·ï¼‰ã€‚ é‡‡ç”¨Wasserstein Distanceæ¥ä»£æ›¿JSçš„GANè¢«ç§°ä¸ºWGAN ç®€è¦è®¡ç®—æ­¥éª¤å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ WGANçš„æå‡ºä»æ ¹æœ¬ä¸Šè§£å†³äº†éƒ¨åˆ†GANæ— æ³•æ”¶æ•›(è®­ç»ƒä¸ç¨³å®š)çš„é—®é¢˜ã€‚ å®æˆ˜GAN ç½‘ç»œç»“æ„ é¦–å…ˆæ˜¯å»ºç«‹ç½‘ç»œç»“æ„ï¼ŒGANçš„ç½‘ç»œç»“æ„åŒ…å«ä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸€ä¸ªæ˜¯ç”Ÿæˆå™¨ï¼ˆGeneratorï¼‰ï¼Œè¿˜æœ‰ä¸€ä¸ªæ˜¯é‰´åˆ«å™¨ï¼ˆDiscriminatorï¼‰ã€‚ä»£ç éå¸¸ç®€ç­”ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041h_dim = 400batchsz = 512class Generator(nn.Module): def __init__(self): super(Generator, self).__init__() self.net = nn.Sequential( nn.Linear(2, h_dim), nn.ReLU(True), nn.Linear(h_dim, h_dim), nn.ReLU(True), nn.Linear(h_dim, h_dim), nn.ReLU(True), nn.Linear(h_dim, 2), ) def forward(self, z): output = self.net(z) return output class Discriminator(nn.Module): def __init__(self): super(Discriminator, self).__init__() self.net = nn.Sequential( nn.Linear(2, h_dim), nn.ReLU(True), nn.Linear(h_dim, h_dim), nn.ReLU(True), nn.Linear(h_dim, h_dim), nn.ReLU(True), nn.Linear(h_dim, 1), nn.Sigmoid() ) def forward(self, x): output = self.net(x) return output.view(-1) ç”Ÿæˆæ•°æ®é›† æˆ‘ä»¬æœ¬æ¬¡å®éªŒé‡‡ç”¨çš„æ•°æ®é›†æ˜¯ç»Ÿè®¡å­¦ä¸­ç»å¸¸ä½¿ç”¨çš„æ··åˆé«˜æ–¯æ¨¡å‹ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼ŒäºŒç»´å¹³é¢ä¸Šä¸€å…±æ˜¯æœ‰8ä¸ªé«˜æ–¯åˆ†å¸ƒç»„åˆè€Œæˆçš„ä¸€ä¸ªæ··åˆåˆ†å¸ƒå›¾å½¢ã€‚ ç›¸ä¿¡å¤§å®¶ä¹Ÿæ˜ç™½äº†ä¸ºä»€ä¹ˆè¾“å‡ºæ˜¯ä¸¤ä¸ªç¥ç»å…ƒâ€”â€”å› ä¸ºè¦åœ¨å¹³é¢åæ ‡ç³»ä¸Šè¿›è¡Œå¯è§†åŒ–è¾“å‡ºå˜›ğŸ˜‚ æ•°æ®é›†ç”Ÿæˆä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728def data_generator(): &#x27;&#x27;&#x27; 8-gaussian mixture models :return: &#x27;&#x27;&#x27; scale = 2. centers = [ (1, 0), (-1, 0), (0, 1), (0, -1), (1. / np.sqrt(2), 1. / np.sqrt(2)), (1. / np.sqrt(2), -1. / np.sqrt(2)), (-1. / np.sqrt(2), 1. / np.sqrt(2)), (-1. / np.sqrt(2), -1. / np.sqrt(2)) ] centers = [(scale * x, scale * y) for x, y in centers] while True: dataset = [] for i in range(batchsz): point = np.random.randn(2) * .02 center = random.choice(centers) point[0] += center[0] point[1] += center[1] dataset.append(point) dataset = np.array(dataset, dtype=&#x27;float32&#x27;) dataset /= 1.414 # stdev yield dataset yield è¿™é‡Œå¤§å®¶å¯èƒ½å¥½å¥‡yieldæ˜¯å¹²ä»€ä¹ˆçš„ï¼Œä¸‹é¢æˆ‘ä¸¾ä¸¤ä¸ªä¾‹å­å¸®åŠ©å¤§å®¶ç†è§£ã€‚ ä»¥ä¸‹å…³äºyieldçš„éƒ¨åˆ†è®²è§£è½¬è½½è‡ª:https://blog.csdn.net/mieleizhi0522/article/details/82142856 ä¾‹ä¸€ 123456789101112def dataset_generator(): i=0 while True: i=i+1 yield iif __name__ == &#x27;__main__&#x27;: g = dataset_generator() for ii in range (10): print(next(g)) print(&quot;*&quot;*20) ä»£ç è¿è¡Œç»“æœæ˜¯ï¼š 12345678910111213141516171819201********************2********************3********************4********************5********************6********************7********************8********************9********************10******************** ä¾‹äºŒ 1234567891011def foo(): print(&quot;starting...&quot;) while True: res = yield 4 print(&quot;res:&quot;,res)if __name__ == &#x27;__main__&#x27;: g = foo() print(&#x27;ok&#x27;) print(next(g)) print(&quot;*&quot;*20) print(next(g)) ä»£ç è¿è¡Œç»“æœæ˜¯ï¼š 123456okstarting...4********************res: None4 åˆ°è¿™é‡Œä½ å¯èƒ½å°±æ˜ç™½yieldå’Œreturnçš„å…³ç³»å’ŒåŒºåˆ«äº†ï¼Œå¸¦yieldçš„å‡½æ•°æ˜¯ä¸€ä¸ªç”Ÿæˆå™¨ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå‡½æ•°äº†ï¼Œè¿™ä¸ªç”Ÿæˆå™¨æœ‰ä¸€ä¸ªå‡½æ•°å°±æ˜¯nextå‡½æ•°ï¼Œnextå°±ç›¸å½“äºâ€œä¸‹ä¸€æ­¥â€ç”Ÿæˆå“ªä¸ªæ•°ï¼Œè¿™ä¸€æ¬¡çš„nextå¼€å§‹çš„åœ°æ–¹æ˜¯æ¥ç€ä¸Šä¸€æ¬¡çš„nextåœæ­¢çš„åœ°æ–¹æ‰§è¡Œçš„ï¼Œæ‰€ä»¥è°ƒç”¨nextçš„æ—¶å€™ï¼Œç”Ÿæˆå™¨å¹¶ä¸ä¼šä»fooå‡½æ•°çš„å¼€å§‹æ‰§è¡Œï¼Œåªæ˜¯æ¥ç€ä¸Šä¸€æ­¥åœæ­¢çš„åœ°æ–¹å¼€å§‹ï¼Œç„¶åé‡åˆ°yieldåï¼Œreturnå‡ºè¦ç”Ÿæˆçš„æ•°ï¼Œæ­¤æ­¥å°±ç»“æŸã€‚ è®­ç»ƒéƒ¨åˆ† GANçš„è®­ç»ƒå’Œå…¶ä»–ç¥ç»ç½‘ç»œçš„è®­ç»ƒè¿˜æœ‰ä¸€ç‚¹ä¸å¤ªä¸€æ ·ï¼ŒGANçš„è®­ç»ƒæ˜¯Då’ŒGåˆ†å¼€è®­ç»ƒï¼ŒDå…ˆè®­ç»ƒå‡ è½®åï¼Œå®šä½Dè®­ç»ƒGï¼Œç„¶åä¾æ¬¡å¾€å¤ã€‚æœ‰ç‚¹åƒå·¦è„šè¸©å³è„šï¼ŒåŸåœ°å‡å¤©é‚£ç§æ„Ÿè§‰ã€‚ è®­ç»ƒD è®­ç»ƒé‰´åˆ«å™¨åˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†ï¼Œè®­ç»ƒçœŸå®æ•°æ®ï¼Œè®­ç»ƒå‡æ•°æ®ï¼ˆGç”Ÿæˆçš„ï¼‰ï¼Œåå‘ä¼ æ’­ï¼Œé¦–å…ˆæ˜¯æˆ‘ä»¬å…ˆç»™é‰´åˆ«å™¨è¾“å…¥çœŸå®çš„æ•°æ®ï¼ˆä»£ç ä¸­æ˜¯xrï¼Œä½¿ç”¨åˆšæ‰æˆ‘ä»¬å†™çš„data_generatorç”Ÿæˆï¼‰,é‰´åˆ«å™¨çš„è¾“å‡ºæ˜¯predrã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æœ€å¤§åŒ–è¿™ä¸€éƒ¨åˆ†çš„è¾“å‡ºï¼ˆç›¸å½“äºæœ€å°åŒ–predrçš„ç›¸åæ•°ï¼‰ã€‚å› æ­¤lossr = - (predr.mean())ã€‚ç„¶åæˆ‘ä»¬å†ç»™é‰´åˆ«å™¨è¾“å…¥Gç”Ÿæˆçš„æ•°æ®ï¼ˆä»£ç ä¸­æ˜¯xfï¼‰,é‰´åˆ«å™¨çš„è¾“å‡ºæ˜¯predfã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æœ€å°åŒ–è¿™ä¸€éƒ¨åˆ†çš„è¾“å‡ºï¼ˆç›¸å½“äºæœ€å°åŒ–predrçš„ç›¸åæ•°ï¼‰ã€‚å› æ­¤lossf = (predr.mean())ã€‚ 1234567891011121314151617181920212223242526272829# 1. train discriminator for k stepsfor _ in range(5): x = next(data_iter) xr = torch.from_numpy(x).cuda() # [b] predr = (D(xr)) # max log(lossr) lossr = - (predr.mean()) # [b, 2] z = torch.randn(batchsz, 2).cuda() # stop gradient on G # [b, 2] xf = G(z).detach() # [b] predf = (D(xf)) # min predf lossf = (predf.mean()) # gradient penalty gp = gradient_penalty(D, xr, xf) loss_D = lossr + lossf + gp optim_D.zero_grad() loss_D.backward() # for p in D.parameters(): # print(p.grad.norm()) optim_D.step() æ³¨æ„ï¼šä»£ç ä¸­æœ‰ä¸€å¥`xf= G(z).detach()ã€‚è¿™å¥è¯çš„ä½œç”¨æ˜¯æ–­å¼€Gå’ŒDä¹‹é—´ç›¸è¿çš„åå‘ä¼ æ’­é“¾ï¼Œè¿™æ ·å°±ä¸ä¼šå†æˆ‘ä»¬æ›´æ–°Dçš„æ—¶å€™åŒæ—¶æ›´æ–°å‰é¢Dçš„å‚æ•°ã€‚ è¯¦ç»†è§£é‡Šï¼š tensor.detach()è¿”å›ä¸€ä¸ªæ–°çš„tensorï¼Œä»å½“å‰è®¡ç®—å›¾ä¸­åˆ†ç¦»ä¸‹æ¥ã€‚ä½†æ˜¯ä»æŒ‡å‘åŸå˜é‡çš„å­˜æ”¾ä½ç½®ï¼Œä¸åŒä¹‹å¤„åªæ˜¯requirse_gradä¸ºfalse.å¾—åˆ°çš„è¿™ä¸ªtensiræ°¸è¿œä¸éœ€è¦è®¡ç®—å™¨æ¢¯åº¦ï¼Œä¸å…·æœ‰grad. å³ä½¿ä¹‹åé‡æ–°å°†å®ƒçš„requires_gradç½®ä¸ºtrue,å®ƒä¹Ÿä¸ä¼šå…·æœ‰æ¢¯åº¦grad.è¿™æ ·æˆ‘ä»¬å°±ä¼šç»§ç»­ä½¿ç”¨è¿™ä¸ªæ–°çš„tensorè¿›è¡Œè®¡ç®—ï¼Œåé¢å½“æˆ‘ä»¬è¿›è¡Œåå‘ä¼ æ’­æ—¶åˆ°è¯¥è°ƒç”¨detach()çš„tensorå°±ä¼šåœæ­¢ï¼Œä¸èƒ½å†ç»§ç»­å‘å‰è¿›è¡Œä¼ æ’­. æ³¨æ„ï¼šæ˜¯ç»§ç»­ä½¿ç”¨è¿™ä¸ªæ–°çš„tensor`è¿›è¡Œè®¡ç®—ï¼ è®­ç»ƒG ç„¶åæ¥ä¸‹æ¥å°±æ˜¯è®­ç»ƒç”Ÿæˆå™¨Gäº†ï¼Œç”Ÿæˆå™¨çš„è®­ç»ƒæ˜¯æ ¹æ®éšæœºæ­£æ€åˆ†å¸ƒä¸­çš„é‡‡æ ·æ¥å­¦ä¹ æˆ‘ä»¬è¦å­¦ä¹ çš„åˆ†å¸ƒçš„ç‰¹å¾ã€‚ 12345678910# 2. train Generatoroptim_D.zero_grad()z = torch.randn(batchsz, 2).cuda()xf = G(z)predf = (D(xf))# max predfloss_G = - (predf.mean())optim_G.zero_grad()loss_G.backward()optim_G.step() æ³¨æ„ï¼šDè®­ç»ƒå®Œäº†ä»¥åä¸€å®šè¦æ¸…é›¶ï¼Œé˜²æ­¢Gæ›´æ–°çš„æ—¶å€™åå‘ä¼ æ’­æ›´æ–°Dçš„ç½‘ç»œå‚æ•°ã€‚ ç»“æœ è¿è¡Œä¸Šé¢çš„ä»£ç ï¼Œæˆ‘ä»¬å¤§æ¦‚ç‡å¾—åˆ°çš„GANçš„è®­ç»ƒç»“æœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæˆ‘ä»¬ä¼šå‘ç°Dçš„é‰´åˆ«å¾ˆå‡†ç¡®ï¼Œè¯¯å·®æ˜¯0ï¼Œè€ŒGå› ä¸ºç”Ÿæˆçš„å¾ˆçƒ‚æ‰€ä»¥æ˜¯-1ï¼Œä½†æ˜¯åˆå› ä¸ºJSçš„ç‰¹æ€§ï¼Œå¯¼è‡´æ¨¡å‹æ— æ³•æ›´æ–°ï¼ˆåˆ†å¸ƒä¸é‡åˆï¼ŒJSæ’å®šï¼Œæ¢¯åº¦ä¸º0ï¼‰ã€‚å› æ­¤ä¸ºäº†è§£å†³è¿™ç§é—®é¢˜æˆ‘ä»¬éœ€è¦å¼•å…¥ä¸Šæ–‡æ‰€è¯´çš„WGANã€‚ å®æˆ˜WGAN ç•¥å¾®ä¸åŒäºGANï¼Œä¸»è¦æ˜¯è®­ç»ƒé‰´åˆ«å™¨éƒ¨åˆ†æœ‰ä¸€äº›å·®åˆ«ã€‚è®­ç»ƒé‰´åˆ«å™¨åœ¨WGANä¸­åˆ†ä¸ºå››ä¸ªéƒ¨åˆ†ï¼Œè®­ç»ƒçœŸå®æ•°æ®ï¼Œè®­ç»ƒå‡æ•°æ®ï¼ˆGç”Ÿæˆçš„ï¼‰ï¼Œæ¢¯åº¦æƒ©ç½šï¼ˆgradient penaltyï¼‰ï¼Œåå‘ä¼ æ’­ï¼Œé¦–å…ˆæ˜¯æˆ‘ä»¬å…ˆç»™é‰´åˆ«å™¨è¾“å…¥çœŸå®çš„æ•°æ®ï¼ˆä»£ç ä¸­æ˜¯xrï¼Œä½¿ç”¨åˆšæ‰æˆ‘ä»¬å†™çš„data_generatorç”Ÿæˆï¼‰,é‰´åˆ«å™¨çš„è¾“å‡ºæ˜¯predrã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æœ€å¤§åŒ–è¿™ä¸€éƒ¨åˆ†çš„è¾“å‡ºï¼ˆç›¸å½“äºæœ€å°åŒ–predrçš„ç›¸åæ•°ï¼‰ã€‚å› æ­¤lossr = - (predr.mean())ã€‚ç„¶åæˆ‘ä»¬å†ç»™é‰´åˆ«å™¨è¾“å…¥Gç”Ÿæˆçš„æ•°æ®ï¼ˆä»£ç ä¸­æ˜¯xfï¼‰,é‰´åˆ«å™¨çš„è¾“å‡ºæ˜¯predfã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æœ€å°åŒ–è¿™ä¸€éƒ¨åˆ†çš„è¾“å‡ºï¼ˆç›¸å½“äºæœ€å°åŒ–predrçš„ç›¸åæ•°ï¼‰ã€‚å› æ­¤lossf = (predr.mean())ã€‚ ç„¶åæ¥ç€æ˜¯æ¢¯åº¦æƒ©ç½šæ“ä½œï¼Œè¿™ä¸€æ­¥éå¸¸é‡è¦åé¢æˆ‘ä»¬å•ç‹¬è®²ï¼Œç®—å‡ºéœ€è¦æˆ‘ä»¬æœ€å°åŒ–çš„gpã€‚ç„¶åæˆ‘ä»¬å°±å¯ä»¥å†™å‡ºæˆ‘ä»¬æœ€åéœ€è¦æœ€å°åŒ–çš„å‡½æ•°loss_D = lossr + lossf + gpã€‚ç„¶åè¿›è¡Œæœ€åä¸€æ­¥åå‘ä¼ æ’­ã€‚ ç½‘ç»œç»“æ„ å’ŒGANåŸºæœ¬ä¸€æ ·ï¼Œä¸å†èµ˜è¿°ã€‚ ç›¸æ¯”äºGANåªæ˜¯å¤šäº†ä¸€ä¸ª**æ¢¯åº¦æƒ©ç½š(gradient_penalty)**éƒ¨åˆ†ã€‚ æ¢¯åº¦æƒ©ç½š(gradient_penalty) ç¨å¾®ç†è§£ä¸€ä¸‹å³å¯ï¼Œæˆ‘ä»¬æœ€åæ˜¯è¦æœ€å°åŒ–è¯¥å‡½æ•°è¿”å›çš„gpçš„ï¼Œå…·ä½“ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 123456789101112131415161718192021222324252627282930def gradient_penalty(D, xr, xf): &quot;&quot;&quot; :param D: :param xr: :param xf: :return: &quot;&quot;&quot; LAMBDA = 0.3 # only constrait for Discriminator xf = xf.detach() xr = xr.detach() # [b, 1] =&gt; [b, 2] alpha = torch.rand(batchsz, 1).cuda() alpha = alpha.expand_as(xr) interpolates = alpha * xr + ((1 - alpha) * xf) interpolates.requires_grad_() disc_interpolates = D(interpolates) gradients = autograd.grad(outputs=disc_interpolates, inputs=interpolates, grad_outputs=torch.ones_like(disc_interpolates), create_graph=True, retain_graph=True, only_inputs=True)[0] # å¯¹ä¸­é—´ç‚¹é‰´åˆ«ç»“æœå…³äºä¸­é—´ç‚¹ä¿¡æ¯æ±‚å¯¼ gp = ((gradients.norm(2, dim=1) - 1) ** 2).mean() * LAMBDA return gp å¤–é¢è°ƒç”¨å¦‚ä¸‹ä»£ç æ‰€ç¤ºï¼š 12# gradient penaltygp = gradient_penalty(D, xr, xf) æ³¨æ„ï¼šè¿™é‡Œçš„xfåœ¨å‰é¢æ˜¯ç»è¿‡äº†detach()æ“ä½œçš„ã€‚ ä»£ç æ±‡æ€» æœ€ååœ¨åŠ ä¸Šä¸€äº›ç»†èŠ‚ï¼Œæœ€ç»ˆçš„WGANä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249import torch from torch import nn, optim, autogradimport numpy as npimport visdomfrom torch.nn import functional as Ffrom matplotlib import pyplot as pltimport randomh_dim = 400batchsz = 512viz = visdom.Visdom()class Generator(nn.Module): def __init__(self): super(Generator, self).__init__() self.net = nn.Sequential( nn.Linear(2, h_dim), nn.ReLU(True), nn.Linear(h_dim, h_dim), nn.ReLU(True), nn.Linear(h_dim, h_dim), nn.ReLU(True), nn.Linear(h_dim, 2), ) def forward(self, z): output = self.net(z) return outputclass Discriminator(nn.Module): def __init__(self): super(Discriminator, self).__init__() self.net = nn.Sequential( nn.Linear(2, h_dim), nn.ReLU(True), nn.Linear(h_dim, h_dim), nn.ReLU(True), nn.Linear(h_dim, h_dim), nn.ReLU(True), nn.Linear(h_dim, 1), nn.Sigmoid() ) def forward(self, x): output = self.net(x) return output.view(-1)def data_generator(): scale = 2. centers = [ (1, 0), (-1, 0), (0, 1), (0, -1), (1. / np.sqrt(2), 1. / np.sqrt(2)), (1. / np.sqrt(2), -1. / np.sqrt(2)), (-1. / np.sqrt(2), 1. / np.sqrt(2)), (-1. / np.sqrt(2), -1. / np.sqrt(2)) ] centers = [(scale * x, scale * y) for x, y in centers] while True: dataset = [] for i in range(batchsz): point = np.random.randn(2) * .02 center = random.choice(centers) point[0] += center[0] point[1] += center[1] dataset.append(point) dataset = np.array(dataset, dtype=&#x27;float32&#x27;) dataset /= 1.414 # stdev yield dataset # for i in range(100000//25): # for x in range(-2, 3): # for y in range(-2, 3): # point = np.random.randn(2).astype(np.float32) * 0.05 # point[0] += 2 * x # point[1] += 2 * y # dataset.append(point) # # dataset = np.array(dataset) # print(&#x27;dataset:&#x27;, dataset.shape) # viz.scatter(dataset, win=&#x27;dataset&#x27;, opts=dict(title=&#x27;dataset&#x27;, webgl=True)) # # while True: # np.random.shuffle(dataset) # # for i in range(len(dataset)//batchsz): # yield dataset[i*batchsz : (i+1)*batchsz]def generate_image(D, G, xr, epoch): &quot;&quot;&quot; Generates and saves a plot of the true distribution, the generator, and the critic. &quot;&quot;&quot; N_POINTS = 128 RANGE = 3 plt.clf() points = np.zeros((N_POINTS, N_POINTS, 2), dtype=&#x27;float32&#x27;) points[:, :, 0] = np.linspace(-RANGE, RANGE, N_POINTS)[:, None] points[:, :, 1] = np.linspace(-RANGE, RANGE, N_POINTS)[None, :] points = points.reshape((-1, 2)) # (16384, 2) # print(&#x27;p:&#x27;, points.shape) # draw contour with torch.no_grad(): points = torch.Tensor(points).cuda() # [16384, 2] disc_map = D(points).cpu().numpy() # [16384] x = y = np.linspace(-RANGE, RANGE, N_POINTS) cs = plt.contour(x, y, disc_map.reshape((len(x), len(y))).transpose()) plt.clabel(cs, inline=1, fontsize=10) # plt.colorbar() # draw samples with torch.no_grad(): z = torch.randn(batchsz, 2).cuda() # [b, 2] samples = G(z).cpu().numpy() # [b, 2] plt.scatter(xr[:, 0], xr[:, 1], c=&#x27;orange&#x27;, marker=&#x27;.&#x27;) plt.scatter(samples[:, 0], samples[:, 1], c=&#x27;green&#x27;, marker=&#x27;+&#x27;) viz.matplot(plt, win=&#x27;contour&#x27;, opts=dict(title=&#x27;p(x):%d&#x27;%epoch))def weights_init(m): if isinstance(m, nn.Linear): # m.weight.data.normal_(0.0, 0.02) nn.init.kaiming_normal_(m.weight) m.bias.data.fill_(0)def gradient_penalty(D, xr, xf): &quot;&quot;&quot; :param D: :param xr: :param xf: :return: &quot;&quot;&quot; LAMBDA = 0.3 # only constrait for Discriminator xf = xf.detach() xr = xr.detach() # [b, 1] =&gt; [b, 2] alpha = torch.rand(batchsz, 1).cuda() alpha = alpha.expand_as(xr) interpolates = alpha * xr + ((1 - alpha) * xf) interpolates.requires_grad_() disc_interpolates = D(interpolates) gradients = autograd.grad(outputs=disc_interpolates, inputs=interpolates, grad_outputs=torch.ones_like(disc_interpolates), create_graph=True, retain_graph=True, only_inputs=True)[0] gp = ((gradients.norm(2, dim=1) - 1) ** 2).mean() * LAMBDA return gpdef main(): torch.manual_seed(23) np.random.seed(23) G = Generator().cuda() D = Discriminator().cuda() G.apply(weights_init) D.apply(weights_init) optim_G = optim.Adam(G.parameters(), lr=1e-3, betas=(0.5, 0.9)) optim_D = optim.Adam(D.parameters(), lr=1e-3, betas=(0.5, 0.9)) data_iter = data_generator() print(&#x27;batch:&#x27;, next(data_iter).shape) viz.line([[0,0]], [0], win=&#x27;loss&#x27;, opts=dict(title=&#x27;loss&#x27;, legend=[&#x27;D&#x27;, &#x27;G&#x27;])) for epoch in range(50000): # 1. train discriminator for k steps for _ in range(5): x = next(data_iter) xr = torch.from_numpy(x).cuda() # [b] predr = (D(xr)) # max log(lossr) lossr = - (predr.mean()) # [b, 2] z = torch.randn(batchsz, 2).cuda() # stop gradient on G # [b, 2] xf = G(z).detach() # [b] predf = (D(xf)) # min predf lossf = (predf.mean()) # gradient penalty gp = gradient_penalty(D, xr, xf) loss_D = lossr + lossf + gp optim_D.zero_grad() loss_D.backward() # for p in D.parameters(): # print(p.grad.norm()) optim_D.step() # 2. train Generator optim_D.zero_grad() z = torch.randn(batchsz, 2).cuda() xf = G(z) predf = (D(xf)) # max predf loss_G = - (predf.mean()) optim_G.zero_grad() loss_G.backward() optim_G.step() if epoch % 100 == 0: viz.line([[loss_D.item(), loss_G.item()]], [epoch], win=&#x27;loss&#x27;, update=&#x27;append&#x27;) generate_image(D, G, xr, epoch) print(loss_D.item(), loss_G.item())if __name__ == &#x27;__main__&#x27;: main()"},{"title":"PyTorchè¿‡æ‹Ÿåˆ","path":"/wiki/PyTorch/PyTorchè¿‡æ‹Ÿåˆ.html","content":"è¿‡æ‹Ÿåˆä¸æ¬ æ‹Ÿåˆ æ¬ æ‹Ÿåˆ è®­ç»ƒæ—¶çš„å‡†ç¡®ç‡ä½ï¼ˆtrain acc. is badï¼‰ æµ‹è¯•æ—¶çš„å‡†ç¡®ç‡ä¹Ÿå¾ˆä½ï¼ˆtest acc. is bad as wellï¼‰ è¿‡æ‹Ÿåˆ ç›¸æ¯”äºæ¬ æ‹Ÿåˆçš„çŠ¶æ€ï¼Œè®­ç»ƒæ—¶çš„æŸå¤±å‡½æ•°å’Œå‡†ç¡®ç‡è¦å¥½å¾—å¤šï¼ˆtrain loss and acc. is much betterï¼‰ æµ‹è¯•æ—¶çš„å‡†ç¡®ç‡è¦ä½ä¸€äº›(test acc. is worse) æ³›åŒ–èƒ½åŠ›è¾ƒå·®ï¼ˆgeneralization performance is worseï¼‰ Train-Val-Teståˆ’åˆ† ä½¿ç”¨å¦‚Train-Val-Teståˆ’åˆ†æ¥æ£€æµ‹æ˜¯å¦å­˜åœ¨è¿‡æ‹Ÿåˆæˆ–è€…æ¬ æ‹Ÿåˆçš„æƒ…å†µã€‚ Trainï¼šç”¨æ¥è®­ç»ƒç½‘ç»œValï¼šç”¨æ¥æŒ‘é€‰æ¨¡å‹å‚æ•°ï¼Œç”¨äºç›‘è§†è®­ç»ƒï¼ˆå‡ è½®è®­ç»ƒåè·‘ä¸€è½®Valï¼‰ï¼Œå‘ç°è¿‡æ‹Ÿåˆæ—¶å¯ä»¥æå‰åœæ­¢è®­ç»ƒæ¨¡å‹ Testï¼šéªŒè¯æ¨¡å‹æœ€ç»ˆçš„æ€§èƒ½ï¼ˆç»™å®¢æˆ·çœ‹ï¼‰ï¼Œä¸€èˆ¬å®é™…æƒ…å†µä¸‹è¿™ä¸€éƒ¨åˆ†çš„æ•°æ®å®¢æˆ·ä¸ä¼šæä¾› PyTorchåˆ’åˆ†Train-Valæ•°æ®é›†ä»£ç å¦‚ä¸‹ï¼š 1234567891011print(&#x27;train:&#x27;,len(train_db),&#x27;test:&#x27;,len(test_db))train_db,val_db=torch.utils.data.random_split(train_db,[50000,10000])print(&#x27;db1:&#x27;,len(train_db),&#x27;db2:&#x27;,len(val_db))train_loader=torch.utils.data.DataLoader( train_db, batch_size=batch_size,shuffle=True)val_loader=torch.utils.data.DataLoader( val_db, batch_size=batch_size,shuffle=True) kæŠ˜äº¤å‰éªŒè¯ï¼ˆk-fold cross validationï¼‰ K-foldäº¤å‰éªŒè¯æ˜¯ä¸€ç§æ•°æ®æ‹†åˆ†æŠ€æœ¯ï¼Œè¢«å®šä¹‰ä¸ºä¸€ç§ç”¨äºåœ¨æœªè§è¿‡çš„æ•°æ®ä¸Šä¼°è®¡æ¨¡å‹æ€§èƒ½çš„æ–¹æ³•ã€‚ä½ å¯ä»¥ä½¿ç”¨k&gt;1æŠ˜æ¥å®ç°ç”¨äºä¸åŒç›®çš„çš„æ ·æœ¬åˆ’åˆ†ï¼Œä¹Ÿæ˜¯ä¸€ç§ç”¨äºè¶…å‚æ•°ä¼˜åŒ–çš„æŠ€æœ¯ï¼Œä»¥ä¾¿å¯ä»¥è®­ç»ƒå…·æœ‰æœ€ä¼˜è¶…å‚æ•°å€¼çš„æ¨¡å‹ã€‚è¿™æ˜¯ä¸€ç§æ— éœ€å¢æ·»æˆ–è€…ä¿®æ”¹æ ·æœ¬çš„é‡é‡‡æ ·æŠ€æœ¯ã€‚è¿™ç§æ–¹æ³•çš„ä¼˜ç‚¹æ˜¯ï¼Œæ¯ä¸ªæ ·æœ¬æ¡ˆä¾‹ä»…ç”¨äºè®­ç»ƒå’ŒéªŒè¯ï¼ˆä½œä¸ºæµ‹è¯•æŠ˜çš„ä¸€éƒ¨åˆ†ï¼‰ä¸€æ¬¡ã€‚ä¸ä¼ ç»Ÿæ–¹æ³•ç›¸æ¯”ï¼Œè¿™ç§æ–¹æ³•å¯ä»¥å¾ˆå¥½é™ä½æ¨¡å‹æ€§èƒ½çš„æ–¹å·®ã€‚ K-foldäº¤å‰éªŒè¯çš„è¿‡ç¨‹åˆ†ä¸ºä¸‹é¢å‡ æ­¥ï¼š æŠŠæ•°æ®é›†åˆ†ä¸ºè®­ç»ƒæ•°æ®é›†å’Œæµ‹è¯•æ•°æ®é›†ã€‚ ç„¶åå°†è®­ç»ƒæ•°æ®é›†æ‹†åˆ†ä¸ºKä»½ï¼›åœ¨K-foldsæ ·æœ¬ä¸­ï¼Œï¼ˆK-1ï¼‰ä»½ç”¨äºè®­ç»ƒï¼Œ1ä»½ç”¨äºéªŒè¯ï¼ŒæŠŠæ¯æ¬¡æ¨¡å‹çš„æ€§èƒ½è®°å½•ä¸‹æ¥ã€‚ é‡å¤ç¬¬2æ­¥ï¼Œç›´åˆ°æ¯ä¸ªk-fold éƒ½ç”¨åˆ°äº†éªŒè¯ï¼ˆè¿™å°±æ˜¯ä¸ºä»€ä¹ˆå®ƒè¢«ç§°ä¸ºk-foldäº¤å‰éªŒè¯ï¼‰ã€‚ é€šè¿‡è·å–æ­¥éª¤2ä¸­ä¸ºæ‰€æœ‰Kä¸ªæ¨¡å‹è®¡ç®—çš„æ¨¡å‹åˆ†æ•°æ¥è®¡ç®—æ¨¡å‹æ€§èƒ½çš„å‡å€¼å’Œæ ‡å‡†å·®ã€‚ å¯¹ä¸åŒçš„è¶…å‚æ•°å€¼é‡å¤æ­¥éª¤2åˆ°æ­¥éª¤5ã€‚ æœ€åé€‰æ‹©äº§ç”Ÿæœ€ä¼˜åˆ†æ•°å‡å€¼å’Œæ ‡å‡†å€¼çš„æ¨¡å‹è¶…å‚æ•°ã€‚ åœ¨æµ‹è¯•æ•°æ®é›†ä¸Šè®¡ç®—è¯„ä¼°æ¨¡å‹æ€§èƒ½ã€‚ æ±‡æ€» ä»ç„¶æ˜¯é’ˆå¯¹MINSTæ•°æ®é›†ï¼ŒåŸºäºå‰é¢ä¼˜åŒ–çš„åŸºç¡€ä¸Šä½†æ˜¯åˆ’åˆ†æˆä¸ºäº†ä¸‰ä¸ªæ•°æ®é›†çš„ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimfrom torchvision import datasets, transformsbatch_size=200learning_rate=0.01epochs=10train_db = datasets.MNIST(&#x27;../data&#x27;, train=True, download=True, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) ]))train_loader = torch.utils.data.DataLoader( train_db, batch_size=batch_size, shuffle=True)test_db = datasets.MNIST(&#x27;../data&#x27;, train=False, transform=transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,))]))test_loader = torch.utils.data.DataLoader(test_db, batch_size=batch_size, shuffle=True)print(&#x27;train:&#x27;, len(train_db), &#x27;test:&#x27;, len(test_db))train_db, val_db = torch.utils.data.random_split(train_db, [50000, 10000])print(&#x27;db1:&#x27;, len(train_db), &#x27;db2:&#x27;, len(val_db))train_loader = torch.utils.data.DataLoader( train_db, batch_size=batch_size, shuffle=True)val_loader = torch.utils.data.DataLoader( val_db, batch_size=batch_size, shuffle=True)class MLP(nn.Module): def __init__(self): super(MLP, self).__init__() self.model = nn.Sequential( nn.Linear(784, 200), nn.LeakyReLU(inplace=True), nn.Linear(200, 200), nn.LeakyReLU(inplace=True), nn.Linear(200, 10), nn.LeakyReLU(inplace=True), ) def forward(self, x): x = self.model(x) return xdevice = torch.device(&#x27;cuda:0&#x27;)net = MLP().to(device)optimizer = optim.SGD(net.parameters(), lr=learning_rate)criteon = nn.CrossEntropyLoss().to(device)# Trainéƒ¨åˆ†for epoch in range(epochs): for batch_idx, (data, target) in enumerate(train_loader): data = data.view(-1, 28*28) data, target = data.to(device), target.cuda() logits = net(data) loss = criteon(logits, target) optimizer.zero_grad() loss.backward() # print(w1.grad.norm(), w2.grad.norm()) optimizer.step() if batch_idx % 100 == 0: print(&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\\tLoss: &#123;:.6f&#125;&#x27;.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100. * batch_idx / len(train_loader), loss.item()))\t# ValéªŒè¯éƒ¨åˆ† test_loss = 0 correct = 0 for data, target in val_loader: data = data.view(-1, 28 * 28) data, target = data.to(device), target.cuda() logits = net(data) test_loss += criteon(logits, target).item() pred = logits.data.max(1)[1] correct += pred.eq(target.data).sum() test_loss /= len(val_loader.dataset) print(&#x27; VAL set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%) &#x27;.format( test_loss, correct, len(val_loader.dataset), 100. * correct / len(val_loader.dataset)))# testæµ‹è¯•éƒ¨åˆ†test_loss = 0correct = 0for data, target in test_loader: data = data.view(-1, 28 * 28) data, target = data.to(device), target.cuda() logits = net(data) test_loss += criteon(logits, target).item() pred = logits.data.max(1)[1] correct += pred.eq(target.data).sum()test_loss /= len(test_loader.dataset)print(&#x27; Test set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%) &#x27;.format( test_loss, correct, len(test_loader.dataset), 100. * correct / len(test_loader.dataset))) å‡å°‘è¿‡æ‹Ÿåˆçš„æ–¹æ³• æ›´å¤šçš„æ•°æ®ï¼ˆMore Dataï¼‰ å‡å°‘æ¨¡å‹çš„å¤æ‚ç¨‹åº¦ï¼ˆConstraint model complexityï¼‰ æ›´æµ…çš„ç½‘ç»œ æ­£åˆ™åŒ– Dropout æ•°æ®å¢å¼ºï¼ˆData aargumentationï¼‰ Early stoppingï¼ˆå‰é¢è¿›è¡Œè®²è§£è¿‡ï¼‰ æ­£åˆ™åŒ–ï¼ˆRegularizationï¼‰ ä½ å¯èƒ½ç†Ÿæ‚‰å¥¥å¡å§†å‰ƒåˆ€åŸåˆ™ï¼šç»™å‡ºä¸¤ä¸ªè§£é‡Šï¼Œæœ€å¯èƒ½æ­£ç¡®çš„è§£é‡Šæ˜¯æ›´ç®€å•çš„ä¸€ä¸ª â€“ å‡è®¾è¾ƒå°‘çš„è§£é‡Šã€‚ è¿™ä¸ªåŸåˆ™ä¹Ÿé€‚ç”¨äºç¥ç»ç½‘ç»œçš„æ¨¡å‹ï¼š ç®€å•çš„æ¨¡å‹æ¯”å¤æ‚çš„æ³›åŒ–èƒ½åŠ›å¥½ã€‚ æ­£åˆ™åŒ–ï¼Œå³åœ¨æˆæœ¬å‡½æ•°ä¸­åŠ å…¥ä¸€ä¸ªæ­£åˆ™åŒ–é¡¹(æƒ©ç½šé¡¹)ï¼Œæƒ©ç½šæ¨¡å‹çš„å¤æ‚åº¦ï¼Œé˜²æ­¢ç½‘ç»œè¿‡æ‹Ÿåˆã€‚ ä»¥Logistic Regressionçš„äº¤å‰ç†µæŸå¤±å‡½æ•°ä¸ºä¾‹ã€‚ J(Î¸)=âˆ’1mâˆ‘i=1m[yilny^i+(1âˆ’yi)ln(1âˆ’y^i)]J(\\theta)=-\\frac{1}{m}\\sum_{i=1}^{m}[y_i ln\\hat{y}_i+(1-y_i)ln(1-\\hat{y}_i)] J(Î¸)=âˆ’m1â€‹i=1âˆ‘mâ€‹[yiâ€‹lny^â€‹iâ€‹+(1âˆ’yiâ€‹)ln(1âˆ’y^â€‹iâ€‹)] æˆ‘ä»¬åŠ å…¥å¯¹å‚æ•°çš„æƒ©ç½šé¡¹ J(Î¸)=âˆ’1mâˆ‘i=1m[yilny^i+(1âˆ’yi)ln(1âˆ’y^i)]+Î»âˆ‘i=1nâˆ£Î¸iâˆ£J(\\theta)=-\\frac{1}{m}\\sum_{i=1}^{m}[y_i ln\\hat{y}_i+(1-y_i)ln(1-\\hat{y}_i)]+\\lambda\\sum_{i=1}^n|\\theta_i| J(Î¸)=âˆ’m1â€‹i=1âˆ‘mâ€‹[yiâ€‹lny^â€‹iâ€‹+(1âˆ’yiâ€‹)ln(1âˆ’y^â€‹iâ€‹)]+Î»i=1âˆ‘nâ€‹âˆ£Î¸iâ€‹âˆ£ å½“ç„¶ä¹Ÿå¯ä»¥åŠ L2èŒƒæ•°çš„æƒ©ç½šé¡¹(åœ¨PyTorchä¸­æœ€å¸¸ç”¨) J(Î¸)=âˆ’1mâˆ‘i=1m[yilny^i+(1âˆ’yi)ln(1âˆ’y^i)]+12Î»âˆ‘i=1nâˆ£âˆ£Î¸iâˆ£âˆ£2J(\\theta)=-\\frac{1}{m}\\sum_{i=1}^{m}[y_i ln\\hat{y}_i+(1-y_i)ln(1-\\hat{y}_i)]+\\frac{1}{2}\\lambda\\sum_{i=1}^n||\\theta_i||^2 J(Î¸)=âˆ’m1â€‹i=1âˆ‘mâ€‹[yiâ€‹lny^â€‹iâ€‹+(1âˆ’yiâ€‹)ln(1âˆ’y^â€‹iâ€‹)]+21â€‹Î»i=1âˆ‘nâ€‹âˆ£âˆ£Î¸iâ€‹âˆ£âˆ£2 è¿™æ ·é€šè¿‡è°ƒæ•´åˆé€‚çš„Î»\\lambdaÎ»å‚æ•°å°±å¯ä»¥æœ‰æ•ˆçš„æŠ‘åˆ¶æ¨¡å‹é«˜é˜¶å‚æ•°ã€‚ æ­£åˆ™åŒ–åœ¨PyTorchä¸­åˆå«åš`WeightDecay` åœ¨PyTorchä¸­åšL2-regularization 1234device=torch.device(&#x27;cuda:0&#x27;)net=MLP().to(device)optimizer=optim.SGD(net.parameters(),lr=learning_rate,weight_decay=0.01)#è¿™é‡ŒåŠ ä¸€ä¸ªweight_decayå‚æ•°å°±å¥½äº†criteon=nn.CrossEntropyLoss().to(device) åœ¨PyTorchä¸­åšL1-regularization å› ä¸ºPyTorchä¸æä¾›ç›¸åº”çš„APIï¼Œæ‰€ä»¥L1-regularizationéœ€è¦è‡ªå·±å®ç°. 12345678910regularization_loss=0for param in model.parameters(): regularization_loss+=torch.sum(torch.abs(param))classify_loss=criteon(logits,target)loss=classify_loss+0.01*regularization_lossoptimizer.zero_grad()loss.backward()optimizer.step() ä¸€èˆ¬æ˜¯å‡ºç°äº†overfittingçš„æƒ…å†µåæ‰ä¼šè®¾ç½®weight_decay åŠ¨é‡ä¸å­¦ä¹ ç‡è¡°å‡ åŠ¨é‡ï¼ˆmomentumï¼‰ å­¦ä¹ ç‡è¡°å‡ï¼ˆlearningrate decayï¼‰ åŠ¨é‡ï¼ˆmomentumï¼‰ åŸæ¥çš„æ›´æ–°å‡½æ•° wk+1=wkâˆ’Î±âˆ‡f(wk)w^{k+1}=w^k-\\alpha abla f(w^k) wk+1=wkâˆ’Î±âˆ‡f(wk) åŠ äº†åŠ¨é‡ä»¥åçš„æ›´æ–°å‡½æ•° wk+1=wkâˆ’Î±zk+1w^{k+1}=w^k-\\alpha z^{k+1} wk+1=wkâˆ’Î±zk+1 zk+1=Î²zk+âˆ‡f(wk)z^{k+1}=\\beta z^k+ abla f(w^k) zk+1=Î²zk+âˆ‡f(wk) zkz^kzkåœ¨è¿™é‡Œä»£è¡¨ä¸Šä¸€æ¬¡æ¢¯åº¦çš„æ–¹å‘ï¼Œæ‰€ä»¥æ¯æ¬¡çš„æ›´æ–°ä¸ä»…å–å†³äºè¿™ä¸€æ¬¡æ¢¯åº¦çš„æ–¹å‘è¿˜è¦å–å†³äºä¸Šä¸€æ¬¡æ¢¯åº¦çš„æ–¹å‘ã€‚å¯ä»¥å‘ç°åŠ¨é‡å…¶å®å°±æ˜¯æŒ‡æ•°åŠ æƒå¹³å‡ã€‚ å¯ä»¥å‘ç°ç›¸æ¯”æœªæ·»åŠ åŠ¨é‡ï¼Œæœ‰åŠ¨é‡çš„è®­ç»ƒæ›´æ–°çš„æ—¶å€™æ–¹å‘å˜åŒ–æ²¡æœ‰é‚£ä¹ˆå°–é”å’Œå‰§çƒˆäº†ï¼Œæœªæ·»åŠ åŠ¨é‡çš„è®­ç»ƒæœ€ç»ˆæ— æ³•æ”¶æ•›åˆ°æœ€ä¼˜è§£ï¼Œä½†æ˜¯æ·»åŠ äº†åŠ¨é‡çš„è®­ç»ƒï¼Œæœ€ç»ˆå¯ä»¥å‡­å€Ÿæƒ¯æ€§å¾—åˆ°å…¨å±€æœ€ä¼˜è§£ã€‚ PyTorchå¯¹momentumçš„æ”¯æŒ 123456789optimizer=torch.optim.SGD(model.parameters(),args.lr, momentum=args.momentum,# è¿™é‡Œæ·»åŠ ä¸€ä¸ªåŠ¨é‡å‚æ•°å°±å¯ä»¥äº† weight_decay=args.weight_decay)scheduler=ReduceLROnPlateau(optimizer,&#x27;min&#x27;)for epoch in xrange(args.start_epoch,args.epochs): train(train_loader,model,criterion,optimizer,epoch) reult_avg,loss_val=validate(val_loader,model,criterion,epoch) scheduler.step(loss_val) å­¦ä¹ ç‡è¡°å‡ï¼ˆlearningrate decayï¼‰ å­¦ä¹ ç‡è¡°å‡ä¸€èˆ¬æœ‰ä¸¤ç§è¡°å‡ç­–ç•¥ ä¸€ç§æ˜¯å½“æŸå¤±å‡½æ•°ç¢°åˆ°å¹³åŸçš„æ—¶å€™è¿›è¡Œå­¦ä¹ ç‡è¡°å‡ï¼Œä½¿ç”¨PyTorchä¸­çš„å‡½æ•°æ˜¯ReduceLROnPlateau 123456789optimizer=torch.optim.SGD(model.parameters(),args.lr, momentum=args.momentum,# è¿™é‡Œæ·»åŠ ä¸€ä¸ªåŠ¨é‡å‚æ•°å°±å¯ä»¥äº† weight_decay=args.weight_decay)scheduler=ReduceLROnPlateau(optimizer,&#x27;min&#x27;)for epoch in xrange(args.start_epoch,args.epochs): train(train_loader,model,criterion,optimizer,epoch) reult_avg,loss_val=validate(val_loader,model,criterion,epoch) scheduler.step(loss_val) è¿˜æœ‰ä¸€ç§æ¯”è¾ƒç®€å•ç²—æš´ï¼Œå°±æ˜¯æ¯è¿‡å¤šå°‘æ­¥ç„¶åæŠŠlearning_rateè¿›è¡Œè¡°å‡ã€‚PyTorchä¸­ä½¿ç”¨çš„å‡½æ•°æ˜¯StepLR 123456789# Assuming optimizer uses lr = 0.05 for all groups# lr = 0.05 if epoch &lt; 30# lr = 0.005 if 30 &lt;= epoch &lt; 60# lr = 0.0005 if 60 &lt;= epoch &lt; 90schedular =StepLR(optimizer,steo_size=30,gamma=0.1)for epoch in range(100): scheduler.step() train(...) validate(...) StepLRä¸­çš„å‚æ•°è¡¨ç¤ºçš„å°±æ˜¯æ¯æ­¥è¿›30æ­¥ï¼Œlrå‡å°‘ä¸ºåŸæ¥çš„0.1ï¼Œè¯¦æƒ…å¯ä»¥è§ä¸Šé¢çš„ä»£ç æ³¨é‡Šã€‚ Early Stop&amp;Dropout Early Stop å› ä¸ºæœ‰æ—¶è®­ç»ƒè½®æ•°è¿‡å¤šä¼šå‡ºç°è¿‡æ‹Ÿåˆçš„æƒ…å†µä»è€Œè®©æ¨¡å‹æ€§èƒ½å˜åï¼Œæ‰€ä»¥åœ¨å¿…è¦çš„æ—¶å€™æˆ‘ä»¬è¦å…ˆåœæ­¢è®­ç»ƒæ¨¡å‹ï¼ˆvalå–æœ€å¤§å€¼æ—¶ï¼‰ï¼Œä¿å­˜å‚æ•°ï¼Œé¿å…ç»§ç»­è®­ç»ƒå‡ºç°è¿‡æ‹Ÿåˆçš„æƒ…å†µã€‚è¿™å°±æ˜¯æˆ‘ä»¬æ‰€è¯´çš„Early Stop æ­¥éª¤ Valæ•°æ®é›†ç”¨æ¥é€‰æ‹©å‚æ•°ï¼ˆè¶…å‚æ•°ï¼‰ è§‚å¯ŸéªŒè¯é›†çš„è¡¨ç° åœ¨ValéªŒè¯é›†Accæœ€é«˜ï¼ˆæˆ–Lossæœ€ä½ï¼‰å¤„åœæ­¢è®­ç»ƒï¼ˆæ ¹æ®ç»éªŒï¼Œè¿ç»­ä¸‹æ»‘ä¸€æ®µæ—¶é—´åæˆ‘ä»¬å°±è®¤ä¸ºå‰é¢çš„æœ€é«˜ç‚¹å°±æ˜¯æœ€å¥½çš„ï¼‰ Dropout æ€æƒ³ å­¦çš„æ›´å°‘æ¥å­¦çš„æ›´å¥½ æ¯ä¸ªè¿æ¥éƒ½æœ‰pçš„æ¦‚ç‡è¢«æ–­å¼€ ä»£ç å®ç° PyTorchä¸­æ·»åŠ Dropoutè¿˜æ˜¯æ¯”è¾ƒæ–¹ä¾¿çš„ 123456789net_dropped=torch.nn.Sequential( torch.nn.Linear(784,200), torch.nn.Dropout(0.5), torch.nn.ReLU(), torch.nn.Linear(200,200), torch.nn.Dropout(0.5), torch.nn.ReLU(), torch.nn.Linear(200,10),) å±‚ä¹‹é—´æ˜¯ç›´è¿çš„ï¼Œè¿™é‡Œçš„æ„æ€æ˜¯åœ¨å±‚ä¹‹é—´æœ‰50%çš„æ¦‚ç‡å‡ºç°è¿æ¥æ–­æ‰ã€‚å’Œä¸Šé¢ç”»çš„ç¤ºæ„å›¾æœ‰ä¸€ç‚¹ä¸ä¸€æ ·ã€‚ æ³¨æ„ï¼šdropoutåªåœ¨è®­ç»ƒçš„æ—¶å€™æ‰æœ‰ï¼Œæµ‹è¯•çš„æ—¶å€™æ˜¯ä¸ä¼šdropoutçš„ã€‚ æ•°æ®å¢å¼º è§PyTorch CNN,å› ä¸ºè®²è§£äº†å·ç§¯ç¥ç»ç½‘ç»œåœ¨å›¾åƒè¯†åˆ«æ–¹é¢çš„åº”ç”¨åï¼Œå¯èƒ½ä¼šå¯¹è¿™ä¸€æ–¹é¢å°è±¡æ›´åŠ æ·±åˆ»ä¸€äº›ã€‚ SGD SGDå…¨ç§°Stochastic Gradient Descentï¼Œä¸­æ–‡å…¨ç§°å«éšæœºæ¢¯åº¦ä¸‹é™ã€‚ä¸ºäº†è§£å†³æ•°æ®é›†è¿‡å¤§æ— æ³•å°†æ‰€æœ‰æ ·æœ¬æ”¾å…¥è¿›è¡Œæ¢¯åº¦ä¸‹é™ï¼Œæˆ‘ä»¬å°†æ•°æ®é›†åŒ–æˆè‹¥å¹²ä¸ªBatchï¼Œä¸€ä¸ªBatchä¸­åŒ…å«è‹¥å¹²ä¸ªæ ·æœ¬ï¼Œæ¯æ¬¡ä½¿ç”¨ä¸€ä¸ªBatchè¿›è¡Œä¸€æ¬¡æ¢¯åº¦ä¸‹é™ï¼ˆæ³¨æ„æ˜¯ä¸€ä¸ªBatchè€Œä¸æ˜¯æ¯æ¬¡å–ä¸€ä¸ªæ ·æœ¬å°±ä¸‹é™ä¸€æ¬¡ï¼‰ å…¶å®ä»¥ä¸Šè¿™ä¸ªåº”è¯¥å«åšå°æ‰¹é‡æ¢¯åº¦ä¸‹é™ï¼Œè€Œå¹¶éSGDï¼ŒSGDæ˜¯Batchsize=1çš„å°æ‰¹é‡æ¢¯åº¦ä¸‹é™ã€‚ è¿™é‡Œæ¨èä¸€ç¯‡è®²è§£ä¸åŒæ¢¯åº¦ä¸‹é™çš„åšå®¢ï¼šæœºå™¨å­¦ä¹ ï¼šé¢å¯¹æµ·é‡æ•°æ®å¦‚ä½•è¿›è¡Œæœºå™¨å­¦ä¹ "},{"title":"bitset åŸºç¡€","path":"/wiki/C++/bitset/bitset åŸºç¡€.html","content":"bitset æ˜¯ C++ æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªæ¨¡æ¿ç±»ï¼Œç”¨äºè¡¨ç¤ºå’Œæ“ä½œä¸€ç»„ä½ï¼ˆbitï¼‰ã€‚å®ƒæä¾›äº†ä¸€ç§é«˜æ•ˆçš„æ–¹å¼æ¥ç®¡ç†å’Œæ“ä½œå›ºå®šå¤§å°çš„ä½åºåˆ—ã€‚ åŸºæœ¬ç”¨æ³• bitset æ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»ï¼Œå®ƒéœ€è¦ä¸€ä¸ªæ•´æ•°å‚æ•°æ¥æŒ‡å®šä½çš„æ•°é‡ã€‚ä¾‹å¦‚ï¼š 12345678#include &lt;bitset&gt;#include &lt;iostream&gt;int main() &#123; std::bitset&lt;8&gt; bs; // å®šä¹‰ä¸€ä¸ªåŒ…å«8ä¸ªä½çš„bitsetï¼Œåˆå§‹åŒ–ä¸º00000000 std::cout &lt;&lt; bs &lt;&lt; std::endl; return 0;&#125; åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œstd::bitset&lt;8&gt; å®šä¹‰äº†ä¸€ä¸ªåŒ…å«8ä¸ªä½çš„ä½é›†ï¼Œé»˜è®¤æƒ…å†µä¸‹æ‰€æœ‰ä½éƒ½åˆå§‹åŒ–ä¸º0ã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ å›ºå®šå¤§å°ï¼šbitset çš„å¤§å°åœ¨ç¼–è¯‘æ—¶ç¡®å®šï¼Œä¸èƒ½åŠ¨æ€æ”¹å˜ã€‚è¿™æ„å‘³ç€ä¸€æ—¦åˆ›å»ºï¼Œä½çš„æ•°é‡æ˜¯å›ºå®šçš„ã€‚ ä½æ“ä½œï¼šbitset æä¾›äº†ä¸°å¯Œçš„ä½æ“ä½œå‡½æ•°ï¼Œå¦‚æŒ‰ä½ä¸ï¼ˆ&amp;ï¼‰ã€æŒ‰ä½æˆ–ï¼ˆ|ï¼‰ã€æŒ‰ä½å¼‚æˆ–ï¼ˆ^ï¼‰ã€å–åï¼ˆ~ï¼‰ç­‰ã€‚ é«˜æ•ˆï¼šç”±äºbitsetæ˜¯åŸºäºä½æ“ä½œçš„ï¼Œå› æ­¤å®ƒåœ¨å†…å­˜å’Œé€Ÿåº¦æ–¹é¢éƒ½éå¸¸é«˜æ•ˆï¼Œå°¤å…¶é€‚ç”¨äºéœ€è¦å¤§é‡å¸ƒå°”æ“ä½œçš„åœºæ™¯ã€‚ ä½è®¿é—®ï¼šå¯ä»¥é€šè¿‡ä¸‹æ ‡æ“ä½œç¬¦[]æ¥è®¿é—®å’Œä¿®æ”¹ç‰¹å®šä½ã€‚ åˆå§‹åŒ–ï¼šå¯ä»¥é€šè¿‡æ•´æ•°æˆ–å­—ç¬¦ä¸²æ¥åˆå§‹åŒ–bitsetï¼Œä½†è¦æ³¨æ„å­—ç¬¦ä¸²çš„é•¿åº¦å’Œæ ¼å¼ã€‚ ç¤ºä¾‹ä»£ç  ä»¥ä¸‹æ˜¯ä¸€äº›å…³äºbitsetçš„ç¤ºä¾‹ä»£ç ï¼Œä»¥å±•ç¤ºå…¶å¸¸è§ç”¨æ³•å’Œæ“ä½œï¼š 1234567891011121314151617181920212223242526272829#include &lt;bitset&gt;#include &lt;iostream&gt;int main() &#123; std::bitset&lt;8&gt; bs1; // é»˜è®¤åˆå§‹åŒ–ä¸º00000000 std::bitset&lt;8&gt; bs2(42); // ç”¨æ•´æ•°åˆå§‹åŒ–ï¼Œ42çš„äºŒè¿›åˆ¶è¡¨ç¤ºæ˜¯00101010 std::bitset&lt;8&gt; bs3(&quot;1100&quot;); // ç”¨å­—ç¬¦ä¸²åˆå§‹åŒ–ï¼Œå‰é¢å››ä½ä¼šè¢«è¡¥é›¶ï¼Œå¾—åˆ°00001100 // è¾“å‡ºbitset std::cout &lt;&lt; &quot;bs1: &quot; &lt;&lt; bs1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;bs2: &quot; &lt;&lt; bs2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;bs3: &quot; &lt;&lt; bs3 &lt;&lt; std::endl; // ä½æ“ä½œ bs1.set(1); // å°†ç¬¬1ä½ç½®ä¸º1ï¼Œç»“æœæ˜¯00000010 bs2.reset(1); // å°†ç¬¬1ä½æ¸…é›¶ï¼Œç»“æœæ˜¯00101000 bs3.flip(0); // ç¿»è½¬ç¬¬0ä½ï¼Œç»“æœæ˜¯00001101 std::cout &lt;&lt; &quot;After operations:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;bs1: &quot; &lt;&lt; bs1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;bs2: &quot; &lt;&lt; bs2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;bs3: &quot; &lt;&lt; bs3 &lt;&lt; std::endl; // è®¿é—®ä½ std::cout &lt;&lt; &quot;bs2[3]: &quot; &lt;&lt; bs2[3] &lt;&lt; std::endl; // è¾“å‡º1 std::cout &lt;&lt; &quot;bs3.count() : &quot; &lt;&lt; bs3.count() &lt;&lt; std::endl; // è®¡ç®—1çš„æ•°é‡ï¼Œè¾“å‡º3 return 0;&#125; é¢å¤–èµ„æº C++ Reference: bitset cppreference.com: std::bitset"},{"title":"test","path":"/wiki/C++/bitset/test.html","content":"bitset ä¸­çš„ test å‡½æ•°ç”¨äºæ£€æŸ¥ bitset ä¸­æŸä¸ªä½æ˜¯å¦è¢«è®¾ç½®ä¸º1ã€‚å®ƒæœ‰ä¸¤ç§ç”¨æ³•ï¼š æ£€æŸ¥æŒ‡å®šä½ç½®çš„ä½æ˜¯å¦ä¸º1ã€‚ æ£€æŸ¥bitsetæ˜¯å¦æœ‰ä»»ä½•ä½è¢«è®¾ç½®ä¸º1ã€‚ åŸºæœ¬ç”¨æ³• 1. æ£€æŸ¥æŒ‡å®šä½ç½®çš„ä½ test å‡½æ•°çš„å‚æ•°æ˜¯ä¸€ä¸ªä½çš„ä½ç½®ç´¢å¼•ï¼Œè¿”å›å€¼æ˜¯ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œå¦‚æœè¯¥ä½ç½®çš„ä½ä¸º1ï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›falseã€‚ 123456789101112#include &lt;bitset&gt;#include &lt;iostream&gt;int main() &#123; std::bitset&lt;8&gt; bs(&quot;11001010&quot;); // ç”¨å­—ç¬¦ä¸²åˆå§‹åŒ–ï¼Œå¾—åˆ° 11001010 // æ£€æŸ¥ç¬¬0ä½å’Œç¬¬1ä½ std::cout &lt;&lt; &quot;bs[0] is &quot; &lt;&lt; bs.test(0) &lt;&lt; std::endl; // è¾“å‡º 0ï¼Œå› ä¸ºç¬¬0ä½æ˜¯0 std::cout &lt;&lt; &quot;bs[1] is &quot; &lt;&lt; bs.test(1) &lt;&lt; std::endl; // è¾“å‡º 1ï¼Œå› ä¸ºç¬¬1ä½æ˜¯1 return 0;&#125; 2. æ£€æŸ¥bitsetæ˜¯å¦æœ‰ä»»ä½•ä½è¢«è®¾ç½®ä¸º1 æ— å‚æ•°çš„ test å‡½æ•°æ£€æŸ¥ bitset ä¸­æ˜¯å¦æœ‰ä»»ä½•ä½è¢«è®¾ç½®ä¸º1ã€‚ 123456789101112#include &lt;bitset&gt;#include &lt;iostream&gt;int main() &#123; std::bitset&lt;8&gt; bs1(&quot;00000000&quot;); // å…¨éƒ¨ä½éƒ½æ˜¯0 std::bitset&lt;8&gt; bs2(&quot;11001010&quot;); // æœ‰ä¸€äº›ä½æ˜¯1 std::cout &lt;&lt; &quot;bs1 has any bit set to 1: &quot; &lt;&lt; bs1.any() &lt;&lt; std::endl; // è¾“å‡º 0ï¼ˆfalseï¼‰ std::cout &lt;&lt; &quot;bs2 has any bit set to 1: &quot; &lt;&lt; bs2.any() &lt;&lt; std::endl; // è¾“å‡º 1ï¼ˆtrueï¼‰ return 0;&#125; ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ è¶Šç•Œæ£€æŸ¥ï¼štest å‡½æ•°ä¼šæ£€æŸ¥ç»™å®šçš„ä½ç½®ç´¢å¼•æ˜¯å¦æœ‰æ•ˆï¼Œå¦‚æœç´¢å¼•è¶…å‡ºèŒƒå›´ï¼Œä¼šæŠ›å‡º std::out_of_range å¼‚å¸¸ã€‚ å¸ƒå°”è¿”å›å€¼ï¼štest è¿”å›å¸ƒå°”å€¼ï¼Œå¯ä»¥ç›´æ¥ç”¨äºæ¡ä»¶è¯­å¥ä¸­ã€‚ ç¤ºä¾‹ä»£ç  ä»¥ä¸‹æ˜¯ä¸€ä¸ªå®Œæ•´çš„ç¤ºä¾‹ä»£ç ï¼Œæ¼”ç¤ºå¦‚ä½•ä½¿ç”¨ test å‡½æ•°æ¥æ£€æŸ¥ bitset ä¸­æŸä¸ªä½çš„çŠ¶æ€ä»¥åŠæ˜¯å¦æœ‰ä»»ä½•ä½è¢«è®¾ç½®ä¸º1ï¼š 123456789101112131415161718#include &lt;bitset&gt;#include &lt;iostream&gt;int main() &#123; std::bitset&lt;8&gt; bs(&quot;11001010&quot;); // ç”¨å­—ç¬¦ä¸²åˆå§‹åŒ–ï¼Œå¾—åˆ° 11001010 // æ£€æŸ¥ç¬¬3ä½å’Œç¬¬5ä½ std::cout &lt;&lt; &quot;bs[3] is &quot; &lt;&lt; (bs.test(3) ? &quot;set&quot; : &quot;not set&quot;) &lt;&lt; std::endl; // è¾“å‡º &quot;set&quot; std::cout &lt;&lt; &quot;bs[5] is &quot; &lt;&lt; (bs.test(5) ? &quot;set&quot; : &quot;not set&quot;) &lt;&lt; std::endl; // è¾“å‡º &quot;not set&quot; // æ£€æŸ¥æ•´ä¸ªbitsetæ˜¯å¦æœ‰ä»»ä½•ä½è¢«è®¾ç½®ä¸º1 std::cout &lt;&lt; &quot;bs has any bit set to 1: &quot; &lt;&lt; (bs.any() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl; // è¾“å‡º &quot;true&quot; // æ£€æŸ¥æ•´ä¸ªbitsetæ˜¯å¦å…¨éƒ¨ä½éƒ½æ˜¯0 std::cout &lt;&lt; &quot;bs has all bits set to 0: &quot; &lt;&lt; (bs.none() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl; // è¾“å‡º &quot;false&quot; return 0;&#125;"},{"title":"atoi","path":"/wiki/C++/cstdlib/atoi.html","content":"atoi æ˜¯ C æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºå°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°ã€‚å°½ç®¡ atoi å‡½æ•°ä¸»è¦å±äº C è¯­è¨€ï¼Œä½†åœ¨ C++ ä¸­ä¹Ÿå¹¿æ³›ä½¿ç”¨ã€‚ä¸‹é¢å°†è¯¦ç»†è§£é‡Š atoi çš„åŸºæœ¬ç”¨æ³•ã€ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ï¼Œä»¥åŠç¤ºä¾‹ä»£ç ã€‚ åŸºæœ¬ç”¨æ³• atoi å‡½æ•°ç”¨äºå°†ä»¥æ•°å­—å½¢å¼è¡¨ç¤ºçš„å­—ç¬¦ä¸²è½¬æ¢ä¸º int ç±»å‹çš„æ•´æ•°ã€‚ å‡½æ•°åŸå‹ï¼š 1int atoi(const char *str); å‚æ•°ï¼š strï¼šæŒ‡å‘ä»¥ null ç»“å°¾çš„å­—ç¬¦ä¸²ï¼Œè¯¥å­—ç¬¦ä¸²è¡¨ç¤ºä¸€ä¸ªæ•´æ•°ã€‚ è¿”å›å€¼ï¼š æˆåŠŸæ—¶ï¼šè¿”å›è½¬æ¢åçš„æ•´æ•°å€¼ã€‚ å¤±è´¥æ—¶ï¼šè¿”å› 0ï¼Œå¦‚æœå­—ç¬¦ä¸²ä¸åŒ…å«æœ‰æ•ˆçš„æ•°å­—ã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ è¾“å…¥å­—ç¬¦ä¸²è¦æ±‚ï¼š atoi åªèƒ½å¤„ç†çº¯æ•°å­—å­—ç¬¦ä¸²ï¼Œå¯ä»¥åŒ…å«å¯é€‰çš„æ­£è´Ÿå·ã€‚ è¾“å…¥å­—ç¬¦ä¸²ä¸­ä¸èƒ½åŒ…å«éæ•°å­—å­—ç¬¦ï¼Œå¦åˆ™ç»“æœå¯èƒ½ä¸å‡†ç¡®ã€‚ å¦‚æœå­—ç¬¦ä¸²ä¸ºç©ºæˆ–ä¸åŒ…å«æœ‰æ•ˆçš„æ•´æ•°ï¼Œatoi ä¼šè¿”å› 0ã€‚ å¼‚å¸¸å¤„ç†ï¼š atoi ä¸ä¼šæ£€æµ‹è½¬æ¢è¿‡ç¨‹ä¸­çš„æº¢å‡ºæƒ…å†µã€‚ä¾‹å¦‚ï¼Œå¦‚æœå­—ç¬¦ä¸²è¡¨ç¤ºçš„æ•°å­—è¶…å‡ºäº† int ç±»å‹çš„èŒƒå›´ï¼Œatoi ä¸ä¼šæŠ›å‡ºé”™è¯¯æˆ–è­¦å‘Šï¼Œåªä¼šè¿”å›æœªå®šä¹‰çš„è¡Œä¸ºã€‚ å®‰å…¨æ›¿ä»£ï¼š ç”±äº atoi ç¼ºä¹é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œå»ºè®®ä½¿ç”¨æ›´å®‰å…¨çš„æ›¿ä»£å‡½æ•°ï¼Œå¦‚ strtol æˆ– C++11 å¼•å…¥çš„ std::stoiï¼Œå®ƒä»¬æä¾›äº†æ›´å¥½çš„é”™è¯¯æ£€æµ‹å’Œå¤„ç†èƒ½åŠ›ã€‚ ç¤ºä¾‹ä»£ç  ä¸‹é¢æ˜¯ä¸€äº›ç¤ºä¾‹ä»£ç ï¼Œå±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ atoi å‡½æ•°å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°ï¼š 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdlib&gt; // åŒ…å« atoi å‡½æ•°çš„å¤´æ–‡ä»¶int main() &#123; const char *numStr1 = &quot;12345&quot;; const char *numStr2 = &quot;-6789&quot;; const char *numStr3 = &quot;42 is the answer&quot;; const char *numStr4 = &quot;abc123&quot;; // ä½¿ç”¨ atoi å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•° int num1 = atoi(numStr1); int num2 = atoi(numStr2); int num3 = atoi(numStr3); int num4 = atoi(numStr4); // è¾“å‡ºè½¬æ¢ç»“æœ std::cout &lt;&lt; &quot;String: &quot; &lt;&lt; numStr1 &lt;&lt; &quot; -&gt; Integer: &quot; &lt;&lt; num1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;String: &quot; &lt;&lt; numStr2 &lt;&lt; &quot; -&gt; Integer: &quot; &lt;&lt; num2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;String: &quot; &lt;&lt; numStr3 &lt;&lt; &quot; -&gt; Integer: &quot; &lt;&lt; num3 &lt;&lt; std::endl; // åªè½¬æ¢å‰é¢çš„æ•°å­—éƒ¨åˆ† std::cout &lt;&lt; &quot;String: &quot; &lt;&lt; numStr4 &lt;&lt; &quot; -&gt; Integer: &quot; &lt;&lt; num4 &lt;&lt; std::endl; // éæ•°å­—å¼€å¤´ï¼Œè¿”å› 0 return 0;&#125; è¾“å‡ºï¼š 1234String: 12345 -&gt; Integer: 12345String: -6789 -&gt; Integer: -6789String: 42 is the answer -&gt; Integer: 42String: abc123 -&gt; Integer: 0 æ€»ç»“ atoi æ˜¯ä¸€ä¸ªç®€å•ä½†ä¸å¤Ÿå¥å£®çš„å­—ç¬¦ä¸²åˆ°æ•´æ•°è½¬æ¢å‡½æ•°ï¼Œé€‚ç”¨äºå¤„ç†çº¯æ•°å­—å­—ç¬¦ä¸²ã€‚ç”±äºç¼ºä¹é”™è¯¯å¤„ç†æœºåˆ¶å’Œå®‰å…¨æ€§é—®é¢˜ï¼Œå»ºè®®åœ¨å®é™…å¼€å‘ä¸­ä½¿ç”¨æ›´å®‰å…¨çš„æ›¿ä»£å‡½æ•°ï¼Œå¦‚ strtol æˆ– std::stoiã€‚"},{"title":"multiset åŸºç¡€","path":"/wiki/C++/set/multiset åŸºç¡€.html","content":"åŸºæœ¬ç”¨æ³• multiset æ˜¯ C++ æ ‡å‡†æ¨¡æ¿åº“ï¼ˆSTLï¼‰ä¸­çš„ä¸€ä¸ªå…³è”å®¹å™¨ï¼Œå®ƒå…è®¸å­˜å‚¨å¤šä¸ªç›¸åŒå€¼çš„å…ƒç´ ï¼Œå¹¶ä¸”è‡ªåŠ¨æŒ‰é¡ºåºè¿›è¡Œæ’åºã€‚multiset çš„ä¸»è¦ç‰¹ç‚¹æ˜¯å¯ä»¥é«˜æ•ˆåœ°è¿›è¡Œæ’å…¥ã€åˆ é™¤å’ŒæŸ¥æ‰¾æ“ä½œã€‚ è¦ä½¿ç”¨ multisetï¼Œé¦–å…ˆéœ€è¦åŒ…å«å¤´æ–‡ä»¶ï¼š 1#include &lt;set&gt; ç„¶åï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ª multisetï¼š 1std::multiset&lt;int&gt; myMultiset; ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ è‡ªåŠ¨æ’åºï¼šmultiset ä¸­çš„å…ƒç´ æ€»æ˜¯æŒ‰å‡åºæ’åˆ—ï¼ˆé»˜è®¤æƒ…å†µä¸‹ï¼‰ï¼Œä¹Ÿå¯ä»¥é€šè¿‡è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°è¿›è¡Œæ’åºã€‚ å…è®¸é‡å¤ï¼šä¸ set ä¸åŒï¼Œmultiset å…è®¸å­˜å‚¨å¤šä¸ªç›¸åŒçš„å€¼ã€‚ åº•å±‚å®ç°ï¼šmultiset é€šå¸¸ä½¿ç”¨çº¢é»‘æ ‘ï¼ˆRed-Black Treeï¼‰æ¥å®ç°ï¼Œè¿™ä½¿å¾—æ’å…¥ã€åˆ é™¤å’ŒæŸ¥æ‰¾æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º O(log n)ã€‚ æŸ¥æ‰¾æ“ä½œï¼š count(key)ï¼šè¿”å›æŒ‡å®šé”®çš„æ•°é‡ã€‚ find(key)ï¼šè¿”å›ä¸€ä¸ªæŒ‡å‘é”®çš„è¿­ä»£å™¨ã€‚ equal_range(key)ï¼šè¿”å›ä¸€ä¸ªèŒƒå›´ï¼Œè¡¨ç¤ºé”®çš„æ‰€æœ‰ç­‰ä»·å…ƒç´ ã€‚ æ’å…¥å’Œåˆ é™¤æ“ä½œï¼š insert(value)ï¼šæ’å…¥å€¼ã€‚ erase(key)ï¼šåˆ é™¤æ‰€æœ‰ç­‰äºé”®çš„å…ƒç´ ã€‚ erase(iterator)ï¼šåˆ é™¤æŒ‡å®šè¿­ä»£å™¨å¤„çš„å…ƒç´ ã€‚ ç¤ºä¾‹ä»£ç  ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨ multiset çš„ç®€å•ç¤ºä¾‹ï¼Œå±•ç¤ºäº†åŸºæœ¬çš„æ’å…¥ã€æŸ¥æ‰¾å’Œåˆ é™¤æ“ä½œï¼š 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;set&gt;int main() &#123; // å®šä¹‰ä¸€ä¸ª multiset std::multiset&lt;int&gt; myMultiset; // æ’å…¥å…ƒç´  myMultiset.insert(10); myMultiset.insert(20); myMultiset.insert(10); myMultiset.insert(30); // è¾“å‡º multiset ä¸­çš„å…ƒç´  std::cout &lt;&lt; &quot;Multiset elements: &quot;; for (const int&amp; elem : myMultiset) &#123; std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // æŸ¥æ‰¾å…ƒç´  std::cout &lt;&lt; &quot;Count of 10: &quot; &lt;&lt; myMultiset.count(10) &lt;&lt; std::endl; // åˆ é™¤å…ƒç´  myMultiset.erase(10); // è¾“å‡ºåˆ é™¤åçš„ multiset ä¸­çš„å…ƒç´  std::cout &lt;&lt; &quot;Multiset elements after erasing 10: &quot;; for (const int&amp; elem : myMultiset) &#123; std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; è¿è¡Œç»“æœï¼š 123Multiset elements: 10 10 20 30 Count of 10: 2Multiset elements after erasing 10: 20 30 æ€»ç»“ multiset æ˜¯ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„å®¹å™¨ï¼Œç‰¹åˆ«æ˜¯åœ¨éœ€è¦å­˜å‚¨é‡å¤å…ƒç´ å¹¶ä¸”å¯¹å…ƒç´ è¿›è¡Œæ’åºçš„åœºæ™¯ä¸­ã€‚å®ƒæä¾›äº†é«˜æ•ˆçš„æ’å…¥ã€åˆ é™¤å’ŒæŸ¥æ‰¾æ“ä½œï¼Œä½†éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå®ƒå…è®¸é‡å¤çš„å…ƒç´ å­˜åœ¨ï¼Œå¹¶ä¸”è¿™äº›æ“ä½œçš„æ—¶é—´å¤æ‚åº¦é€šå¸¸ä¸º O(log n)ã€‚"},{"title":"PyTorchè¿›é˜¶","path":"/wiki/PyTorch/PyTorchè¿›é˜¶.html","content":"Broadcastè‡ªåŠ¨æ‰©å±• ç»´åº¦æ‰©å±• æ‰©å±•æ— éœ€å¤åˆ¶æ•°æ® å¯¹äºä¸€ä¸ªshapeä¸º`torch.size([x1,x2,x3,...,xn])`çš„`tensor`,é è¿‘x1é‚£ä¸€ç«¯ä¸ºå¤§ç»´åº¦ï¼Œé è¿‘xné‚£ä¸€ç«¯ä¸ºå°ç»´åº¦ã€‚é‚£ä¹ˆå¯¹äºbroadcastæœ‰ï¼š å°ç»´åº¦æŒ‡å®šï¼Œå¤§ç»´åº¦éšæ„è¿™ä¸€è§„å¾‹ï¼ˆå› ä¸ºåœ¨å¤§ç»´åº¦ä¸Šè¿›è¡Œå¹¿æ’­ï¼‰ æ‹¼æ¥ä¸æ‹†åˆ† cat stack split chunk cat ä¸»è¦çš„åŠŸèƒ½æ˜¯å°†tensoræ‹¼æ¥èµ·æ¥ 1234In [3]: a=torch.rand(4,32,8)In [4]: b=torch.rand(5,32,8)In [5]: torch.cat([a,b],dim=0).shapeOut[5]: torch.Size([9, 32, 8]) `dim`å‚æ•°è¡¨ç¤ºçš„æ˜¯åœ¨å“ªä¸ªç»´åº¦ä¸Šè¿›è¡Œåˆå¹¶ã€‚å¦‚æœæ˜¯`n`ç»´tensoråˆ™å–å€¼èŒƒå›´æ˜¯[0,n) stack stackçš„åŠŸèƒ½å’Œcatæœ‰äº›åƒï¼Œä½†æ˜¯ä»–è¦æ±‚çš„æ˜¯æ‰€æ‹¼æ¥çš„ä¸¤ä¸ªtensorçš„shapeå¿…é¡»å®Œå…¨ä¸€æ ·ã€‚å¹¶ä¸”æ‹¼æ¥åä¼šåœ¨æ‹¼æ¥ç»´åº¦ä¹‹å‰å¢åŠ ä¸€ä¸ªç»´åº¦ã€‚ æ³¨æ„ï¼šshapeå¿…é¡»å®Œå…¨ä¸€æ ·ï¼ ç„¶ååœ¨æ‰€æ‹¼æ¥ç»´åº¦ä¹‹å‰ä¼šæ–°å¢åŠ ä¸€ä¸ªç»´åº¦ï¼Œç”¨äºåŒºåˆ†æ˜¯æ‹¼æ¥çš„å“ªä¸€å—ï¼ˆå‰ä¸€å—æˆ–åä¸€å—ï¼‰ 1234In [3]: a1=torch.rand(5,3,16,32)In [4]: a2=torch.rand(5,3,16,32)In [5]: torch.stack([a1,a2],dim=1).shapeOut[5]: torch.Size([5, 2, 3, 16, 32]) split splitæ˜¯æŒ‰ç…§é•¿åº¦å¯¹tensorè¿›è¡Œæ‹†åˆ†çš„å‡½æ•°ï¼Œä¸€èˆ¬ä¼ å…¥ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä»£è¡¨çš„æ˜¯æ‰€æ‹†ç»´åº¦çš„é•¿åº¦ï¼ˆé•¿åº¦ä¸ä»…å¯ä»¥ç”¨æ ‡é‡è¡¨ç¤ºå›ºå®šçš„é•¿åº¦ï¼Œä¹Ÿå¯ä»¥ç”¨listæ¥è¡¨ç¤ºä¸å›ºå®šçš„é•¿åº¦ï¼Œè¯¦æƒ…è§ä¸‹é¢çš„ä¾‹å­ï¼‰ï¼Œç¬¬äºŒä¸ªå‚æ•°ä»£è¡¨çš„æ˜¯æ‰€æ‹†çš„ç»´åº¦æ˜¯ç¬¬å‡ ç»´åº¦ã€‚ 12345678In [3]: c=torch.rand(3,32,8)In [4]: aa,bb,cc=c.split(1,dim=0)In [5]: aa.shape,bb.shape,cc.shapeOut[5]: (torch.Size([1, 32, 8]), torch.Size([1, 32, 8]), torch.Size([1, 32, 8]))In [6]: aa,bb=c.split([2,1],dim=0)In [7]: aa.shape,bb.shapeOut[7]: (torch.Size([2, 32, 8]), torch.Size([1, 32, 8])) chunck chunckæ˜¯æŒ‰ç…§æ•°é‡å¯¹tensorè¿›è¡Œæ‹†åˆ†çš„å‡½æ•°ï¼Œä¸€èˆ¬ä¼ å…¥ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä»£è¡¨çš„æ˜¯æ‰€æ‹†ç»´åº¦è¦æ‹†å‡ºæ¥çš„æ•°é‡ï¼Œç¬¬äºŒä¸ªå‚æ•°ä»£è¡¨çš„æ˜¯æ‰€æ‹†çš„ç»´åº¦æ˜¯ç¬¬å‡ ç»´åº¦ã€‚ 12345In [3]: d=torch.rand(6,32,8)In [4]: c=torch.rand(3,32,8)In [5]: aa,bb,cc=d.chunk(3,dim=0)In [6]: aa.shape,bb.shape,cc.shapeOut[6]: (torch.Size([2, 32, 8]), torch.Size([2, 32, 8]), torch.Size([2, 32, 8])) æ•°å­¦è¿ç®— åŸºæœ¬å››åˆ™è¿ç®—(add/minus/multiply/divide) çŸ©é˜µä¹˜æ³•(Matmul) ä¹˜æ–¹è¿ç®—(Pow) å¼€æ–¹è¿ç®—(Sqrt/rsqrt) è¿‘ä¼¼è¿ç®—(Round) åŸºæœ¬å››åˆ™è¿ç®— 1234567891011121314151617181920212223In [3]: a=torch.tensor([[2,4,6],[8,10,12]])In [4]: b=torch.ones(2,3)*2In [5]: a+bOut[5]: tensor([[ 4., 6., 8.], [10., 12., 14.]])In [6]: a-bOut[6]: tensor([[ 0., 2., 4.], [ 6., 8., 10.]])In [7]: a*bOut[7]: tensor([[ 4., 8., 12.], [16., 20., 24.]])In [8]: a/bOut[8]: tensor([[1., 2., 3.], [4., 5., 6.]])In [9]: a/(a/b)Out[9]: tensor([[2., 2., 2.], [2., 2., 2.]]) pytorchä¸­è¿˜ä¸“é—¨æœ‰å®šä¹‰å¥½çš„å››åˆ™è¿ç®—çš„å‡½æ•°å’Œä»¥ä¸Šè¿™äº›è¿ç®—ç¬¦å·æ‰€è¿ç®—å‡ºæ¥çš„æ•ˆæœç›¸åŒï¼Œä»–ä»¬åˆ†åˆ«æ˜¯ã€‚ torch.add torch.minus torch.mul torch.div 123456789In [10]: torch.all(torch.eq(a+b,torch.add(a,b)))Out[10]: tensor(True)In [11]: torch.all(torch.eq(a-b,torch.sub(a,b)))Out[11]: tensor(True)In [12]: torch.all(torch.eq(a*b,torch.mul(a,b)))Out[12]: tensor(True)In [13]: torch.all(torch.eq(a/b,torch.div(a,b)))Out[13]: tensor(True) æ³¨æ„ï¼šè¿™é‡Œçš„ä¹˜æ³•å’Œé™¤æ³•ï¼Œä¸åŒäºçŸ©é˜µä¹˜æ³•å’Œé™¤æ³•ï¼Œåªæ˜¯å°†ä¸¤ä¸ªçŸ©é˜µå¯¹åº”ä½ç½®çš„æ•°è¿›è¡Œç›¸ä¹˜æˆ–ç›¸é™¤æ“ä½œã€‚ è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªæ•´é™¤è¿ç®—ç¬¦å·//æ²¡æœ‰è®²åˆ°ï¼Œå¥½åƒå¹¶æ²¡æœ‰æ‰¾åˆ°ä¸ä»–å¯¹åº”çš„å‡½æ•° çŸ©é˜µä¹˜æ³• torch.mm(åªé€‚ç”¨äºäºŒç»´tensor,ä¸æ¨è) torch.matmul(é€‚ç”¨äºä»»æ„ç»´åº¦çš„çŸ©é˜µ) @(åŒä¸Štorch.matmul) 123456789101112131415In [3]: a=torch.tensor([[2,4],[8,12]])In [4]: b=torch.tensor([[1,2],[3,4]])In [5]: torch.mm(a,b)Out[5]: tensor([[14, 20], [44, 64]])In [6]: torch.matmul(a,b)Out[6]: tensor([[14, 20], [44, 64]])In [7]: a@bOut[7]: tensor([[14, 20], [44, 64]]) BPå…¨è¿æ¥ç¥ç»ç½‘ç»œçš„ä¸€ä¸ªä¾‹å­ x@w.t()+bx@w.t()+b x@w.t()+b 1234In [4]: x=torch.rand(4,784)In [5]: w=torch.rand(512,784)In [6]: (x@w.t()).shapeOut[6]: torch.Size([4, 512]) é«˜äº2ç»´çŸ©é˜µä¹˜æ³•çš„åŸç† å–æœ€å°ä¸¤ä¸ªç»´åº¦çš„å†…å®¹è¿›è¡ŒçŸ©é˜µä¹˜æ³•ï¼Œä¿ç•™é«˜ç»´åº¦çš„çš„å¤§å°ã€‚å…¶å®ç›¸å½“äºæ˜¯æ”¯æŒäº†å¤šä¸ªçŸ©é˜µå¹¶è¡Œç›¸ä¹˜ã€‚ é«˜ç»´åº¦å¤§å°ä¸ä¸€å®šè¦å®Œå…¨ä¸€æ ·ï¼Œä½†æ˜¯è¦ç¬¦åˆbroadcastingåŸåˆ™ï¼Œå…·ä½“è§ä¸‹é¢çš„ä¾‹å­ 12345678910In [3]: a=torch.rand(4,3,28,64)In [4]: b=torch.rand(4,3,64,32)In [5]: torch.matmul(a,b).shapeOut[5]: torch.Size([4, 3, 28, 32])In [6]: b=torch.rand(4,1,64,32)In [7]: torch.matmul(a,b).shapeOut[7]: torch.Size([4, 3, 28, 32])In [8]: b=torch.rand(4,2,64,32)In [9]: torch.matmul(a,b).shapeTraceback ä¹˜æ–¹è¿ç®— .pow()ï¼šæ‹¬å·ä¸­å†™æ¬¡æ–¹æ•° **ï¼šåŒä¸Šé¢çš„powå‡½æ•°ï¼Œä¹˜æ–¹è¿ç®—ç¬¦ sqrt()ï¼šå¼€å¹³æ–¹è¿ç®— rsqrt()ï¼šå¼€å¹³æ–¹åæ±‚å€’æ•°ã€‚ 1234567891011121314151617181920212223242526272829In [3]: a=torch.full([2,2],3)In [4]: aOut[4]: tensor([[3, 3], [3, 3]])In [5]: a.pow(2)Out[5]: tensor([[9, 9], [9, 9]])In [6]: a**2Out[6]: tensor([[9, 9], [9, 9]])In [7]: torch.all(torch.eq(a**2,a.pow(2)))Out[7]: tensor(True)In [8]: aa=a**2In [9]: aa.sqrt()Out[9]: tensor([[3., 3.], [3., 3.]])In [10]: aa.rsqrt()Out[10]: tensor([[0.3333, 0.3333], [0.3333, 0.3333]])In [11]: aa**(0.5)Out[11]: tensor([[3., 3.], [3., 3.]]) expå’Œlogå’Œlog2å’Œlog10 çœ‹åå­—åº”è¯¥å°±å¤§æ¦‚æ˜ç™½åŠŸèƒ½äº†ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ï¼Œç›´æ¥ä¸Šä¸€ä¸ªä¾‹å­å§ 12345678910In [14]: a=torch.exp(torch.ones(2,2))In [15]: aOut[15]: tensor([[2.7183, 2.7183], [2.7183, 2.7183]])In [16]: torch.log(a)Out[16]: tensor([[1., 1.], [1., 1.]]) 1234567891011In [18]: a=torch.ones(2,2)*2In [19]: torch.log2(a)Out[19]: tensor([[1., 1.], [1., 1.]])In [20]: a=torch.ones(2,2)*100In [21]: torch.log10(a)Out[21]: tensor([[2., 2.], [2., 2.]]) è¿‘ä¼¼è¿ç®— .floor()ï¼šå‘ä¸‹å–æ•´ .ceil()ï¼šå‘ä¸Šå–æ•´ .round()ï¼šå››èˆäº”å…¥ .trunc()ï¼šè£å‰ªâ€”â€”åªä¿ç•™æ•´æ•°éƒ¨åˆ† /frac()ï¼šè£å‰ªâ€”â€”åªä¿ç•™å°æ•°éƒ¨åˆ† 12345678910In [3]: a=torch.tensor(3.14)In [4]: a.floor(),a.ceil(),a.trunc(),a.frac()Out[4]: (tensor(3.), tensor(4.), tensor(3.), tensor(0.1400))In [5]: a=torch.tensor(3.499999)In [6]: a.round()Out[6]: tensor(3.)In [7]: a=torch.tensor(3.5)In [8]: a.round()Out[8]: tensor(4.) æ¢¯åº¦è£å‰ªâ€» æˆ‘ä»¬åœ¨åšå’Œæœºå™¨å­¦ä¹ ç›¸å…³çš„é¡¹ç›®ä¸­æ—¶ï¼Œæœ‰å¯èƒ½ä¼šç¢°åˆ°è¿™ç§æƒ…å†µï¼Œå°±æ˜¯æ¢¯åº¦å¤ªå¤§æˆ–å¤ªå°ï¼ˆæ¥è¿‘0ï¼‰ä»è€Œå¯¼è‡´æˆ‘ä»¬çš„è®­ç»ƒç»“æœå¹¶ä¸æ˜¯éå¸¸çš„ç†æƒ³ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é‡‡ç”¨æ¢¯åº¦è£å‰ªçš„æ–¹æ³•ï¼Œå°†æ¢¯åº¦ç°æœ‰æ¢¯åº¦æ§åˆ¶åœ¨ä¸€ä¸ªèŒƒå›´å†…ï¼Œæœ‰æ•ˆé¿å…è¿™ç±»é—®é¢˜ã€‚ æ‰€ä½¿ç”¨çš„å‡½æ•°æ˜¯clampï¼Œä¸€èˆ¬ä¼ å…¥ä¸€ä¸ªæˆ–ä¸¤ä¸ªå‚æ•°ã€‚ å¦‚æœä¹‹ä¼ å…¥ä¸€ä¸ªå‚æ•°ï¼Œè¯¥å‚æ•°è¡¨ç¤ºæ¢¯åº¦çš„æœ€å°å€¼ï¼Œå› æ­¤æ¯”è¯¥å€¼å°çš„æ¢¯åº¦éƒ½ä¼šè¢«å¼ºè¡Œå¢å¤§åˆ°è¯¥å€¼ã€‚ å¦‚æœä¼ å…¥ä¸¤ä¸ªå‚æ•°ï¼Œåˆ™ä¸¤ä¸ªå‚æ•°åˆ†åˆ«è¡¨ç¤ºæœ€å°å€¼å’Œæœ€å¤§å€¼ï¼Œæ¯”æœ€å°å€¼å°çš„å€¼ä¼šå¼ºè¡Œå˜ä¸ºè®¾å®šçš„æœ€å°å€¼ï¼Œæ¯”æœ€å¤§å€¼å¤§çš„å€¼ä¼šå¼ºè¡Œå˜ä¸ºè®¾å®šçš„æœ€å¤§å€¼ã€‚ 123456789101112131415161718192021222324In [3]: grad=torch.rand(2,3)*30-15In [4]: grad.max()Out[4]: tensor(6.2306)In [5]: grad.min()Out[5]: tensor(-11.8838)In [6]: grad.median()Out[6]: tensor(-0.5767)In [7]: grad.clamp(5)Out[7]: tensor([[5.0000, 5.0000, 5.0000], [5.0000, 5.0000, 6.2306]])In [8]: gradOut[8]: tensor([[ 3.8570, -0.2229, -11.8838], [ -8.5261, -0.5767, 6.2306]])In [9]: grad.clamp(0)Out[9]: tensor([[3.8570, 0.0000, 0.0000], [0.0000, 0.0000, 6.2306]])In [10]: grad.clamp(0,5)Out[10]: tensor([[3.8570, 0.0000, 0.0000], [0.0000, 0.0000, 5.0000]]) ç»Ÿè®¡å±æ€§ normï¼šèŒƒæ•° mean,sumï¼šå¹³å‡å€¼ï¼Œå’Œ prodï¼šç´¯ä¹˜ max,min,argmin,argmaxï¼šæœ€å¤§å€¼ï¼Œæœ€å°å€¼ï¼Œæœ€å°å€¼æ‰€åœ¨ä½ç½®ï¼Œæœ€å¤§å€¼æ‰€åœ¨ä½ç½® kthvalue,topkï¼šæ±‚ç¬¬kä¸ªå€¼ï¼Œæ±‚å‰kä¸ªå€¼ norm ä¸€èˆ¬æ˜¯1èŒƒæ•°å’Œ2èŒƒæ•°ä½¿ç”¨çš„è¾ƒå¤šï¼Œä½†ä¸‹é¢è¿˜æ˜¯ä¼šå°†å„ä¸ªèŒƒæ•°çš„å«ä¹‰è¿›è¡Œç®€è¦çš„ä»‹ç»ã€‚ 0èŒƒæ•°ï¼šçŸ©é˜µä¸­éé›¶å…ƒç´ çš„ä¸ªæ•° 1èŒƒæ•°ï¼šçŸ©é˜µä¸­å„ä¸ªå…ƒç´ çš„ç»å¯¹å€¼ä¹‹å’Œ 2èŒƒæ•°ï¼šçŸ©é˜µä¸­å„ä¸ªå…ƒç´ å¹³æ–¹å’Œçš„1/2æ¬¡æ–¹ï¼Œåˆè¢«ç§°ä¸ºEuclideanèŒƒæ•°æˆ–è€…Frobenius èŒƒæ•°ã€‚ pèŒƒæ•°ï¼šä¸ºxå‘é‡ï¼ˆæˆ–çŸ©é˜µï¼‰å„ä¸ªå…ƒç´ ç»å¯¹å€¼pæ¬¡æ–¹å’Œçš„1/pæ¬¡æ–¹ã€‚ normå‡½æ•°ä¸€èˆ¬éœ€è¦ä¸€ä¸ªæˆ–è€…ä¸¤ä¸ªå‚æ•°ï¼Œå¦‚æœåªæ˜¯æä¾›ä¸€ä¸ªå‚æ•°ï¼Œåˆ™è¯¥å‚æ•°è¡¨ç¤ºçš„æ˜¯ç¬¬å‡ èŒƒæ•°ï¼Œå¦‚æœæä¾›2ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ„ä¹‰åŒä¸Šï¼Œç¬¬äºŒä¸ªå‚æ•°çš„æ„ä¹‰æ˜¯åœ¨å“ªä¸ªç»´åº¦ä¸Šè¿›è¡ŒèŒƒæ•°è¿ç®—ã€‚ 123456789101112131415161718192021222324252627282930313233343536In [3]: a=torch.tensor([1.,2.,3.,4.,5.,6.,7.,8.])In [4]: b=a.view(2,4)In [5]: c=a.view(2,2,2)In [6]: bOut[6]: tensor([[1., 2., 3., 4.], [5., 6., 7., 8.]])In [7]: cOut[7]: tensor([[[1., 2.], [3., 4.]], [[5., 6.], [7., 8.]]])In [8]: a.norm(1),b.norm(1),c.norm(1)Out[8]: (tensor(36.), tensor(36.), tensor(36.))In [9]: a.norm(2),b.norm(2),c.norm(2)Out[9]: (tensor(14.2829), tensor(14.2829), tensor(14.2829))In [10]: b.norm(1,dim=1)Out[10]: tensor([10., 26.])In [11]: b.norm(1,dim=0)Out[11]: tensor([ 6., 8., 10., 12.])In [12]: b.norm(2,dim=1)Out[12]: tensor([ 5.4772, 13.1909])In [13]: c.norm(1,dim=0)Out[13]: tensor([[ 6., 8.], [10., 12.]])In [14]: c.norm(1,dim=1)Out[14]: tensor([[ 4., 6.], [12., 14.]])In [15]: c.norm(1,dim=2)Out[15]: tensor([[ 3., 7.], [11., 15.]]) mean,max,min,sum,prod 123456789101112In [3]: a=torch.arange(8).view(2,4).float()In [4]: aOut[4]: tensor([[0., 1., 2., 3.], [4., 5., 6., 7.]])In [5]: a.min(),a.max(),a.mean(),a.prod()Out[5]: (tensor(0.), tensor(7.), tensor(3.5000), tensor(0.))In [6]: a.sum()Out[6]: tensor(28.)In [7]: a.argmax(),a.argmin()Out[7]: (tensor(7), tensor(0)) å¯ä»¥å‘ç°argmaxå’Œargminåœ¨å¯»æ‰¾æœ€å¤§æœ€å°å€¼çš„æ—¶å€™ï¼Œæ˜¯å°†æ•´ä¸ªtensorå˜ä¸ºäº†ä¸€ä¸ªä¸€ç»´å‘é‡çš„ï¼å¦‚æœæˆ‘ä»¬æƒ³æ±‚æ¯ä¸€è¡Œçš„ä¸€ä¸ªæœ€å¤§å€¼æˆ–æœ€å°å€¼çš„ä½ç½®ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨ä»¥ä¸‹çš„è¿™ç§åšæ³•ã€‚ 123In [3]: a=torch.randn(4,10)In [4]: a.argmax(dim=1)Out[4]: tensor([3, 0, 6, 9]) dim&amp;keepdim è¿™ä¸¤ä¸ªéƒ½æ˜¯å‡½æ•°ä¸­çš„å‚æ•°ï¼Œdimçš„ä½œç”¨åœ¨ä¸Šé¢æˆ‘ä»¬å·²ç»æ¼”ç¤ºè¿‡äº†ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°ã€‚keepdimè®¾ç½®çš„æ˜¯è¿”å›çš„ç­”æ¡ˆæ˜¯å¦è¦å’ŒåŸæ¥çš„çŸ©é˜µä¿æŒç›¸åŒçš„ç»´åº¦ä¿¡æ¯ã€‚ 12345678910111213141516171819202122232425262728In [3]: a=torch.randn(4,10)In [4]: a.argmax(dim=1)Out[4]: tensor([3, 0, 6, 9])In [5]: a.max(dim=1)Out[5]: torch.return_types.max(values=tensor([2.2597, 1.0554, 0.9288, 1.1149]),indices=tensor([3, 0, 6, 9]))In [6]: a.argmax(dim=1)Out[6]: tensor([3, 0, 6, 9])In [7]: a.max(dim=1,keepdim=True)Out[7]: torch.return_types.max(values=tensor([[2.2597], [1.0554], [0.9288], [1.1149]]),indices=tensor([[3], [0], [6], [9]]))In [8]: a.argmax(dim=1,keepdim=True)Out[8]: tensor([[3], [0], [6], [9]]) topk,kthvalue 123456789101112131415161718192021222324252627282930313233343536373839In [3]: a=torch.randn(4,10)In [4]: a.topk(3,dim=1)Out[4]: torch.return_types.topk(values=tensor([[2.0085, 0.5275, 0.4304], [1.5748, 0.8510, 0.6699], [1.1440, 0.8921, 0.7946], [0.9630, 0.8487, 0.8158]]),indices=tensor([[4, 0, 8], [9, 3, 5], [5, 9, 0], [6, 9, 4]]))In [5]: a.topk(3,dim=1,largest=False)Out[5]: torch.return_types.topk(values=tensor([[-1.8353, -1.5600, -0.7452], [-1.1623, -1.0671, -0.2221], [-1.1269, -0.3777, -0.2676], [-2.1377, -0.2639, -0.0832]]),indices=tensor([[2, 3, 9], [1, 8, 4], [7, 8, 6], [8, 1, 5]]))In [6]: a.kthvalue(1,dim=1)Out[6]: torch.return_types.kthvalue(values=tensor([-1.8353, -1.1623, -1.1269, -2.1377]),indices=tensor([2, 1, 7, 8]))In [7]: a.kthvalue(1)Out[7]: torch.return_types.kthvalue(values=tensor([-1.8353, -1.1623, -1.1269, -2.1377]),indices=tensor([2, 1, 7, 8]))In [8]: a.kthvalue(9)Out[8]: torch.return_types.kthvalue(values=tensor([0.5275, 0.8510, 0.8921, 0.8487]),indices=tensor([0, 3, 9, 9])) å¯¹äºtopkå‡½æ•°é»˜è®¤æ˜¯ä»å¤§åˆ°å°ï¼Œå¦‚æœæŠŠlargestæ”¹ä¸ºFalseåˆ™æ˜¯ä»å°åˆ°å¤§ã€‚kthvalueå‡½æ•°é»˜è®¤æ˜¯ä»å°åˆ°å¤§ æ¯”è¾ƒ &gt;,&gt;=,&lt;=,!=,== torch.eq(a,b) ä»¥ä¸Šä¸¤ç§éƒ½æ˜¯æ¯”è¾ƒçŸ©é˜µå¯¹åº”ä½ç½®çš„æ•°ï¼Œå› æ­¤è¿”å›çš„å€¼æ˜¯ä¸€ä¸ªåŒå¤§å°çš„çŸ©é˜µã€‚ torch.equal(a,b)ï¼šåˆ¤æ–­ä¸¤ä¸ªçŸ©é˜µæ˜¯å¦å®Œå…¨ç›¸ç­‰ 12345678910111213141516171819202122232425262728293031323334In [3]: a=torch.randn(4,10)In [4]: a&gt;0Out[4]: tensor([[ True, True, True, True, True, True, False, False, True, True], [ True, True, True, True, True, True, False, True, False, False], [False, True, False, True, False, True, False, True, True, False], [False, True, False, True, False, False, False, False, True, True]])In [5]: torch.gt(a,0)Out[5]: tensor([[ True, True, True, True, True, True, False, False, True, True], [ True, True, True, True, True, True, False, True, False, False], [False, True, False, True, False, True, False, True, True, False], [False, True, False, True, False, False, False, False, True, True]])In [6]: a!=0Out[6]: tensor([[True, True, True, True, True, True, True, True, True, True], [True, True, True, True, True, True, True, True, True, True], [True, True, True, True, True, True, True, True, True, True], [True, True, True, True, True, True, True, True, True, True]])In [7]: a=torch.ones(2,3)In [8]: b=torch.randn(2,3)In [9]: torch.eq(a,b)Out[9]: tensor([[False, False, False], [False, False, False]])In [10]: torch.eq(a,a)Out[10]: tensor([[True, True, True], [True, True, True]])In [11]: torch.equal(a,a)Out[11]: TrueIn [12]: torch.equal(a,b)Out[12]: False é«˜é˜¶æ“ä½œ where gather where torch.where(condition,x,y) whereå‡½æ•°è¿”å›ä¸€ä¸ªtensorï¼Œè¿™ä¸ªtensorä¸­çš„å…ƒç´ ä¸æ˜¯ä»xä¸­é€‰å‡ºæ¥çš„å°±æ˜¯ä»yä¸­é€‰å‡ºæ¥çš„ï¼Œé€‰æ‹©åˆ¤æ–­æ¡ä»¶å¦‚ä¸‹æ‰€ç¤ºï¼š outi={xiifÂ conditioniyiotherwiseout_i=\\begin{cases} x_i \\quad if\\ condition_i\\\\ y_i\\quad otherwise \\end{cases} outiâ€‹={xiâ€‹ifÂ conditioniâ€‹yiâ€‹otherwiseâ€‹ conditionä¹Ÿæ˜¯ä¸€ä¸ªtensorï¼Œå’Œx,yçš„å¤§å°ä¸€æ ·ã€‚å¦‚æœå¯¹åº”ä½ç½®çš„conditonå€¼ä¸º1ï¼Œåˆ™å–xå¯¹åº”ä½ç½®çš„æ•°æ®ï¼Œå¦åˆ™å–yå¯¹åº”ä½ç½®çš„æ•°æ® 1234567891011121314151617181920In [3]: cond=torch.rand(2,2)In [4]: a=torch.zeros(2,2)In [5]: b=torch.ones(2,2)In [6]: condOut[6]: tensor([[0.5486, 0.6658], [0.9244, 0.3691]])In [7]: aOut[7]: tensor([[0., 0.], [0., 0.]])In [8]: bOut[8]: tensor([[1., 1.], [1., 1.]])In [9]: torch.where(cond&gt;0.6,a,b)Out[9]: tensor([[1., 0.], [0., 1.]]) è™½ç„¶æˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨Pythonè‡ªå¸¦çš„forå¾ªç¯å’Œifè¯­å¥æ¥å®ç°åŒæ ·çš„åŠŸèƒ½ï¼Œä½†æ˜¯è¿™æ ·çš„è¯ç”±äºè¿™äº›è¯­å¥è¿è¡Œåœ¨CPUä¸Šï¼Œæˆ‘ä»¬ä¸èƒ½äº«å—åˆ°PyTorchåº“ä¸­å¸¦æ¥çš„GPUåŠ é€Ÿçš„ä¼˜åŠ¿ï¼Œå› æ­¤ä¼šè¿è¡Œçš„æ›´æ…¢ä¸€äº›ã€‚ gather torch.gather(input,dim,index,out=None) gatherå‡½æ•°å®ç°çš„åŠŸèƒ½ç±»ä¼¼äºæŸ¥è¡¨å‡½æ•°ï¼Œç»™å®šä¸€ä¸ªåˆå§‹è¡¨ï¼Œå†ç»™å®šä¸€ä¸ªç´¢å¼•è¡¨ï¼Œè‡ªåŠ¨ç”Ÿæˆä¸€å¼ æŒ‰ç…§ç´¢å¼•è¡¨æŸ¥å®Œåˆå§‹è¡¨çš„è¡¨ã€‚ 12345678910111213141516171819In [3]: prob=torch.randn(4,10)In [4]: idx=prob.topk(dim=1,k=3)In [5]: idx=idx[1]In [6]: idxOut[6]: tensor([[9, 6, 7], [0, 3, 2], [1, 4, 2], [1, 5, 6]])In [7]: label=torch.arange(10)+100In [8]: labelOut[8]: tensor([100, 101, 102, 103, 104, 105, 106, 107, 108, 109])In [9]: torch.gather(label.expand(4,10),dim=1,index=idx.long())Out[9]: tensor([[109, 106, 107], [100, 103, 102], [101, 104, 102], [101, 105, 106]]) æ€»ç»“ ä»¥ä¸Šä¾¿æ˜¯PyTorchä¸­å¸¸ç”¨çš„æ“ä½œäº†ï¼Œåç»­å°±æ˜¯å®æˆ˜ç¯èŠ‚äº†ã€‚"},{"title":"set åˆå§‹åŒ–","path":"/wiki/C++/set/set åˆå§‹åŒ–.html","content":"æœ¬æ–‡ä»‹ç»ä¸€ä¸‹setçš„ä¸åŒåˆå§‹åŒ–æ–¹æ³•ã€‚ åŸºæœ¬ç”¨æ³• åœ¨åˆå§‹åŒ– set ä¹‹å‰ï¼Œé¦–å…ˆéœ€è¦åŒ…å« &lt;set&gt; å¤´æ–‡ä»¶ï¼Œå¹¶ä½¿ç”¨ std::set å‘½åç©ºé—´ã€‚ 1#include &lt;set&gt; ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ åˆå§‹åŒ–æ–¹æ³•å¤šæ ·ï¼šå¯ä»¥ä½¿ç”¨é»˜è®¤æ„é€ å‡½æ•°ã€åˆå§‹åŒ–åˆ—è¡¨ã€èŒƒå›´åˆå§‹åŒ–ã€å¤åˆ¶æ„é€ å‡½æ•°ã€ç§»åŠ¨æ„é€ å‡½æ•°ç­‰æ–¹æ³•æ¥åˆå§‹åŒ– setã€‚ è‡ªåŠ¨æ’åºï¼šæ’å…¥å…ƒç´ æ—¶ä¼šè‡ªåŠ¨æ’åºã€‚ å”¯ä¸€æ€§ï¼šset ä¸å…è®¸æœ‰é‡å¤çš„å…ƒç´ ã€‚ é«˜æ•ˆæ€§ï¼šæŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å‡ä¸º O(log n)ã€‚ ç¤ºä¾‹ä»£ç  1. é»˜è®¤æ„é€ å‡½æ•° åˆ›å»ºä¸€ä¸ªç©ºçš„ setï¼Œå¹¶æ ¹æ®éœ€è¦æ’å…¥å…ƒç´ ã€‚ 1234567891011121314#include &lt;set&gt;#include &lt;iostream&gt;int main() &#123; std::set&lt;int&gt; s; // åˆ›å»ºä¸€ä¸ªç©ºçš„set s.insert(10); s.insert(5); s.insert(20); for (const auto&amp; elem : s) &#123; std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 2. ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨ ç›´æ¥åœ¨å£°æ˜æ—¶åˆå§‹åŒ– setã€‚ 12345678910#include &lt;set&gt;#include &lt;iostream&gt;int main() &#123; std::set&lt;int&gt; s = &#123;10, 5, 20, 5&#125;; // ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨ for (const auto&amp; elem : s) &#123; std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 3. ä½¿ç”¨èŒƒå›´ï¼ˆåŒºé—´ï¼‰åˆå§‹åŒ– å¯ä»¥ä½¿ç”¨å¦ä¸€ä¸ªå®¹å™¨çš„å…ƒç´ èŒƒå›´æ¥åˆå§‹åŒ– setã€‚ 12345678910111213141516#include &lt;set&gt;#include &lt;vector&gt;#include &lt;iostream&gt;int main() &#123; std::vector&lt;int&gt; vec = &#123;10, 5, 20, 15, 10&#125;; // åˆ›å»ºä¸€ä¸ªvectorï¼Œå…¶ä¸­åŒ…å«ä¸€äº›é‡å¤å…ƒç´  std::set&lt;int&gt; s(vec.begin(), vec.end()); // ä½¿ç”¨vectorçš„èŒƒå›´æ¥åˆå§‹åŒ–set std::cout &lt;&lt; &quot;Elements in set initialized from vector: &quot;; for (const auto&amp; elem : s) &#123; std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;; // æ‰“å°setä¸­çš„å…ƒç´  &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 4. å¤åˆ¶æ„é€ å‡½æ•° å¯ä»¥ä½¿ç”¨å·²æœ‰çš„ set æ¥åˆå§‹åŒ–æ–°çš„ setã€‚ 123456789101112#include &lt;set&gt;#include &lt;iostream&gt;int main() &#123; std::set&lt;int&gt; s1 = &#123;10, 5, 20&#125;; std::set&lt;int&gt; s2(s1); // ä½¿ç”¨å¦ä¸€ä¸ªsetæ¥åˆå§‹åŒ– for (const auto&amp; elem : s2) &#123; std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 5. ç§»åŠ¨æ„é€ å‡½æ•° å¯ä»¥ä½¿ç”¨å·²æœ‰çš„ set æ¥ç§»åŠ¨åˆå§‹åŒ–æ–°çš„ setã€‚ 123456789101112#include &lt;set&gt;#include &lt;iostream&gt;int main() &#123; std::set&lt;int&gt; s1 = &#123;10, 5, 20&#125;; std::set&lt;int&gt; s2(std::move(s1)); // ä½¿ç”¨å¦ä¸€ä¸ªsetæ¥ç§»åŠ¨åˆå§‹åŒ– for (const auto&amp; elem : s2) &#123; std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;; &#125; return 0;&#125; æ€»ç»“ C++ æä¾›äº†å¤šç§æ–¹æ³•æ¥åˆå§‹åŒ– setï¼Œä»é»˜è®¤æ„é€ å‡½æ•°åˆ°ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨ã€èŒƒå›´åˆå§‹åŒ–ã€å¤åˆ¶æ„é€ å‡½æ•°å’Œç§»åŠ¨æ„é€ å‡½æ•°ç­‰ã€‚é€‰æ‹©åˆé€‚çš„åˆå§‹åŒ–æ–¹æ³•å¯ä»¥ä½¿ä»£ç æ›´åŠ ç®€æ´å’Œé«˜æ•ˆã€‚äº†è§£è¿™äº›åˆå§‹åŒ–æ–¹æ³•æœ‰åŠ©äºåœ¨å®é™…ç¼–ç¨‹ä¸­æ ¹æ®å…·ä½“éœ€æ±‚çµæ´»åœ°åˆ›å»ºå’Œåˆå§‹åŒ– setã€‚ ä½¿ç”¨ vector åˆå§‹åŒ– set æ˜¯ä¸€ç§æ–¹ä¾¿çš„æ–¹æ³•ï¼Œå¯ä»¥å°† vector ä¸­çš„å…ƒç´ å¿«é€Ÿæ’å…¥åˆ° set ä¸­ï¼Œå¹¶è‡ªåŠ¨å»é‡å’Œæ’åºã€‚è¿™ç§æ–¹æ³•ç‰¹åˆ«é€‚ç”¨äºéœ€è¦ä»å…¶ä»–å®¹å™¨è½¬æ¢ä¸º set çš„æƒ…å†µã€‚ç†è§£è¿™äº›åˆå§‹åŒ–æ–¹æ³•å¯ä»¥å¸®åŠ©æ›´æœ‰æ•ˆåœ°åˆ©ç”¨ set å®¹å™¨ã€‚"},{"title":"set åŸºç¡€","path":"/wiki/C++/set/set åŸºç¡€.html","content":"set æ˜¯ C++ æ ‡å‡†åº“ä¸­çš„ä¸€ç§å…³è”å®¹å™¨ï¼Œæä¾›äº†ä¸€ç§é«˜æ•ˆçš„æ–¹å¼æ¥å­˜å‚¨å’Œæ“ä½œä¸é‡å¤çš„å…ƒç´ é›†åˆã€‚set ä½¿ç”¨å¹³è¡¡äºŒå‰æ ‘ï¼ˆé€šå¸¸æ˜¯çº¢é»‘æ ‘ï¼‰æ¥å®ç°ï¼Œå› æ­¤å®ƒçš„å…ƒç´ æ˜¯æœ‰åºçš„ï¼Œå¹¶ä¸”æ”¯æŒå¿«é€ŸæŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œã€‚ åŸºæœ¬ç”¨æ³• åœ¨ C++ ä¸­ä½¿ç”¨ set éœ€è¦åŒ…å« &lt;set&gt; å¤´æ–‡ä»¶ï¼Œå¹¶ä½¿ç”¨ std::set å‘½åç©ºé—´ã€‚set çš„å¸¸è§æ“ä½œåŒ…æ‹¬æ’å…¥å…ƒç´ ã€åˆ é™¤å…ƒç´ ã€æŸ¥æ‰¾å…ƒç´ ç­‰ã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ æœ‰åºæ€§ï¼šset ä¸­çš„å…ƒç´ æŒ‰ç…§ç‰¹å®šçš„é¡ºåºï¼ˆé»˜è®¤æ˜¯ä»å°åˆ°å¤§ï¼‰æ’åˆ—ã€‚ å”¯ä¸€æ€§ï¼šset ä¸å…è®¸æœ‰é‡å¤çš„å…ƒç´ ã€‚ é«˜æ•ˆæ€§ï¼šæŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å‡ä¸º O(log n)ã€‚ è‡ªåŠ¨æ’åºï¼šæ’å…¥å…ƒç´ æ—¶ä¼šè‡ªåŠ¨è¿›è¡Œæ’åºã€‚ è¿­ä»£å™¨ç¨³å®šæ€§ï¼šset çš„è¿­ä»£å™¨åœ¨æ’å…¥å’Œåˆ é™¤æ“ä½œåä»ç„¶æœ‰æ•ˆï¼ˆæŒ‡å‘è¢«åˆ é™¤å…ƒç´ çš„è¿­ä»£å™¨é™¤å¤–ï¼‰ã€‚ ç¤ºä¾‹ä»£ç  ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è§çš„ set æ“ä½œçš„ç¤ºä¾‹ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;set&gt;int main() &#123; // åˆ›å»ºä¸€ä¸ªsetå®¹å™¨ std::set&lt;int&gt; s; // æ’å…¥å…ƒç´  s.insert(10); s.insert(5); s.insert(20); s.insert(10); // é‡å¤å…ƒç´ ä¸ä¼šè¢«æ’å…¥ // æ˜¾ç¤ºsetä¸­çš„å…ƒç´  std::cout &lt;&lt; &quot;Elements in set: &quot;; for (const auto&amp; elem : s) &#123; std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // æŸ¥æ‰¾å…ƒç´  auto it = s.find(10); if (it != s.end()) &#123; std::cout &lt;&lt; &quot;Element 10 found in set.&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Element 10 not found in set.&quot; &lt;&lt; std::endl; &#125; // åˆ é™¤å…ƒç´  s.erase(5); // æ˜¾ç¤ºåˆ é™¤åçš„å…ƒç´  std::cout &lt;&lt; &quot;Elements in set after erasing 5: &quot;; for (const auto&amp; elem : s) &#123; std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; æ€»ç»“ set æ˜¯ C++ æ ‡å‡†åº“ä¸­ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„å…³è”å®¹å™¨ï¼Œé€‚ç”¨äºéœ€è¦å­˜å‚¨ä¸é‡å¤çš„æœ‰åºå…ƒç´ é›†åˆçš„åœºæ™¯ã€‚äº†è§£å…¶åŸºæœ¬ç”¨æ³•ã€ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹æœ‰åŠ©äºåœ¨å®é™…ç¼–ç¨‹ä¸­æœ‰æ•ˆåœ°åˆ©ç”¨ set æé«˜ä»£ç çš„æ•ˆç‡å’Œå¯è¯»æ€§ã€‚"},{"title":"set è½¬ vector","path":"/wiki/C++/set/set è½¬ vector.html","content":"å°† set è½¬æ¢ä¸º vector æ˜¯ä¸€ç§å¸¸è§çš„æ“ä½œï¼Œç‰¹åˆ«æ˜¯åœ¨éœ€è¦æŒ‰ç‰¹å®šé¡ºåºè®¿é—®æˆ–æ“ä½œé›†åˆä¸­çš„å…ƒç´ æ—¶ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›æ–¹æ³•å°† set è½¬æ¢ä¸º vectorï¼Œå¹¶åŒ…æ‹¬ç¤ºä¾‹ä»£ç ã€‚ åŸºæœ¬ç”¨æ³• åœ¨è½¬æ¢ set ä¸º vector æ—¶ï¼Œé¦–å…ˆéœ€è¦åŒ…å« &lt;set&gt; å’Œ &lt;vector&gt; å¤´æ–‡ä»¶ï¼Œå¹¶ä½¿ç”¨ç›¸åº”çš„å‘½åç©ºé—´ã€‚ 12#include &lt;set&gt;#include &lt;vector&gt; ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ è‡ªåŠ¨æ’åºï¼šset ä¸­çš„å…ƒç´ æ˜¯æœ‰åºçš„ï¼Œåœ¨è½¬æ¢ä¸º vector åä»ä¿æŒè¿™ç§é¡ºåºã€‚ å»é‡ï¼šset ä¸­çš„å…ƒç´ æ˜¯å”¯ä¸€çš„ï¼Œå› æ­¤è½¬æ¢åçš„ vector ä¹Ÿä¸ä¼šåŒ…å«é‡å¤çš„å…ƒç´ ã€‚ ç¤ºä¾‹ä»£ç  æ–¹æ³• 1ï¼šä½¿ç”¨æ„é€ å‡½æ•° å¯ä»¥ç›´æ¥ä½¿ç”¨ vector çš„æ„é€ å‡½æ•°ï¼Œå°† set çš„å…ƒç´ èŒƒå›´ä¼ é€’ç»™ vectorã€‚ 12345678910111213141516#include &lt;set&gt;#include &lt;vector&gt;#include &lt;iostream&gt;int main() &#123; std::set&lt;int&gt; s = &#123;10, 5, 20, 15&#125;; std::vector&lt;int&gt; v(s.begin(), s.end()); // ä½¿ç”¨setçš„èŒƒå›´åˆå§‹åŒ–vector std::cout &lt;&lt; &quot;Elements in vector: &quot;; for (const auto&amp; elem : v) &#123; std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; æ–¹æ³• 2ï¼šä½¿ç”¨ std::copy å¯ä»¥ä½¿ç”¨ std::copy ç®—æ³•å°† set ä¸­çš„å…ƒç´ å¤åˆ¶åˆ° vector ä¸­ã€‚ 12345678910111213141516171819#include &lt;set&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;int main() &#123; std::set&lt;int&gt; s = &#123;10, 5, 20, 15&#125;; std::vector&lt;int&gt; v; v.reserve(s.size()); // é¢„ç•™è¶³å¤Ÿçš„ç©ºé—´ä»¥é¿å…é‡æ–°åˆ†é…å†…å­˜ std::copy(s.begin(), s.end(), std::back_inserter(v)); std::cout &lt;&lt; &quot;Elements in vector: &quot;; for (const auto&amp; elem : v) &#123; std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; æ–¹æ³• 3ï¼šä½¿ç”¨èŒƒå›´ insert æ–¹æ³• ä½¿ç”¨ vector çš„ insert æ–¹æ³•å°† set ä¸­çš„å…ƒç´ èŒƒå›´æ’å…¥åˆ° vector ä¸­ã€‚ 1234567891011121314151617#include &lt;set&gt;#include &lt;vector&gt;#include &lt;iostream&gt;int main() &#123; std::set&lt;int&gt; s = &#123;10, 5, 20, 15&#125;; std::vector&lt;int&gt; v; v.insert(v.end(), s.begin(), s.end()); // ä½¿ç”¨insertæ–¹æ³•å°†setçš„å…ƒç´ æ’å…¥vector std::cout &lt;&lt; &quot;Elements in vector: &quot;; for (const auto&amp; elem : v) &#123; std::cout &lt;&lt; elem &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; æ€»ç»“ å°† set è½¬æ¢ä¸º vector æœ‰å¤šç§æ–¹æ³•ï¼ŒåŒ…æ‹¬ç›´æ¥ä½¿ç”¨æ„é€ å‡½æ•°ã€ä½¿ç”¨ std::copy ç®—æ³•å’Œä½¿ç”¨ vector çš„ insert æ–¹æ³•ã€‚è¿™äº›æ–¹æ³•éƒ½å¯ä»¥æœ‰æ•ˆåœ°å°†æœ‰åºä¸”ä¸é‡å¤çš„ set å…ƒç´ è½¬æ¢ä¸º vectorï¼Œä»¥ä¾¿åœ¨ vector ä¸­è¿›è¡Œè¿›ä¸€æ­¥çš„æ“ä½œã€‚ç†è§£å’ŒæŒæ¡è¿™äº›æ–¹æ³•æœ‰åŠ©äºåœ¨å®é™…ç¼–ç¨‹ä¸­çµæ´»åœ°è¿›è¡Œå®¹å™¨ä¹‹é—´çš„è½¬æ¢ã€‚"},{"title":"map åŸºç¡€","path":"/wiki/C++/map/map åŸºç¡€.html","content":"åŸºæœ¬ç”¨æ³• map æ˜¯ C++ æ ‡å‡†æ¨¡æ¿åº“ï¼ˆSTLï¼‰ä¸­çš„å…³è”å®¹å™¨ï¼Œç”¨äºå­˜å‚¨é”®å€¼å¯¹ï¼ˆkey-value pairsï¼‰ï¼Œå…¶ä¸­æ¯ä¸ªé”®æ˜¯å”¯ä¸€çš„ã€‚é”®å€¼å¯¹æŒ‰ç…§é”®çš„é¡ºåºè‡ªåŠ¨æ’åºã€‚ å£°æ˜ä¸åˆå§‹åŒ– 12345678910111213141516#include &lt;iostream&gt;#include &lt;map&gt;int main() &#123; std::map&lt;int, std::string&gt; myMap; // æ’å…¥é”®å€¼å¯¹ myMap.insert(std::make_pair(1, &quot;one&quot;)); myMap[2] = &quot;two&quot;; // è®¿é—®å…ƒç´  std::cout &lt;&lt; myMap[1] &lt;&lt; std::endl; // è¾“å‡º &quot;one&quot; std::cout &lt;&lt; myMap.at(2) &lt;&lt; std::endl; // è¾“å‡º &quot;two&quot; return 0;&#125; ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ æœ‰åºæ€§ï¼šmap ä¸­çš„å…ƒç´ æŒ‰ç…§é”®è‡ªåŠ¨æ’åºï¼Œé»˜è®¤æƒ…å†µä¸‹ä½¿ç”¨ &lt; è¿ç®—ç¬¦è¿›è¡Œæ¯”è¾ƒã€‚å¯ä»¥è‡ªå®šä¹‰æ¯”è¾ƒå™¨æ¥æ”¹å˜æ’åºè§„åˆ™ã€‚ å”¯ä¸€æ€§ï¼šmap ä¸­çš„æ¯ä¸ªé”®éƒ½æ˜¯å”¯ä¸€çš„ã€‚å¦‚æœæ’å…¥ä¸€ä¸ªå·²å­˜åœ¨çš„é”®ï¼Œåˆ™ä¼šè¦†ç›–åŸæœ‰çš„å€¼ã€‚ å¤æ‚åº¦ï¼šmap çš„æŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œçš„å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º O(log n)ï¼Œè¿™æ˜¯å› ä¸ºå®ƒé€šå¸¸æ˜¯ç”¨çº¢é»‘æ ‘ï¼ˆRed-Black Treeï¼‰å®ç°çš„ã€‚ å†…å­˜å ç”¨ï¼šç›¸æ¯”äº unordered_mapï¼Œmap ç”±äºç»´æŠ¤äº†å…ƒç´ çš„æœ‰åºæ€§ï¼Œé€šå¸¸å ç”¨æ›´å¤šçš„å†…å­˜å’Œæœ‰ç•¥ä½çš„æ€§èƒ½ã€‚ ç¤ºä¾‹ä»£ç  ä»¥ä¸‹æ˜¯ä¸€ä¸ªæ›´è¯¦ç»†çš„ map ä½¿ç”¨ç¤ºä¾‹ï¼ŒåŒ…æ‹¬éå†ã€æŸ¥æ‰¾å’Œåˆ é™¤æ“ä½œï¼š 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;map&gt;int main() &#123; std::map&lt;std::string, int&gt; ageMap; // æ’å…¥é”®å€¼å¯¹ ageMap[&quot;Alice&quot;] = 30; ageMap[&quot;Bob&quot;] = 25; ageMap[&quot;Charlie&quot;] = 35; // éå† map for (const auto&amp; pair : ageMap) &#123; std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl; &#125; // æŸ¥æ‰¾å…ƒç´  auto it = ageMap.find(&quot;Bob&quot;); if (it != ageMap.end()) &#123; std::cout &lt;&lt; &quot;Found Bob, age: &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Bob not found&quot; &lt;&lt; std::endl; &#125; // åˆ é™¤å…ƒç´  ageMap.erase(&quot;Alice&quot;); // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨ if (ageMap.count(&quot;Alice&quot;) == 0) &#123; std::cout &lt;&lt; &quot;Alice has been removed&quot; &lt;&lt; std::endl; &#125; return 0;&#125; æ€»ç»“ map æ˜¯ä¸€ä¸ªå¼ºå¤§ä¸”çµæ´»çš„å…³è”å®¹å™¨ï¼Œé€‚ç”¨äºéœ€è¦è‡ªåŠ¨æ’åºé”®å€¼å¯¹çš„åœºæ™¯ã€‚å…¶æœ‰åºæ€§å’Œé«˜æ•ˆçš„æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤æ“ä½œä½¿å…¶åœ¨è®¸å¤šåº”ç”¨ä¸­éå¸¸æœ‰ç”¨ã€‚ä½†åœ¨ä½¿ç”¨æ—¶éœ€è¦æ³¨æ„å…¶ç›¸å¯¹è¾ƒé«˜çš„å†…å­˜å ç”¨å’Œç•¥ä½çš„æ€§èƒ½ã€‚"},{"title":"stringstream","path":"/wiki/C++/sstream/stringstream.html","content":"stringstream æ˜¯ C++ æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„ç±»ï¼Œå®ƒå±äº &lt;sstream&gt; å¤´æ–‡ä»¶ã€‚è¿™ä¸ªç±»å…è®¸ä½ æŠŠå­—ç¬¦ä¸²å½“ä½œæµæ¥å¤„ç†ï¼Œè¿™æ„å‘³ç€ä½ å¯ä»¥ä½¿ç”¨ç±»ä¼¼äºå¤„ç†æ–‡ä»¶æµï¼ˆå¦‚ ifstream å’Œ ofstreamï¼‰çš„æ–¹å¼æ¥å¤„ç†å­—ç¬¦ä¸²ã€‚ åŸºæœ¬ç”¨æ³• å®šä¹‰ï¼šä½ å¯ä»¥é€šè¿‡åŒ…å«å¤´æ–‡ä»¶ &lt;sstream&gt; æ¥ä½¿ç”¨ stringstream ç±»ã€‚std::stringstream å¯ç”¨äºè¯»å†™å­—ç¬¦ä¸²ã€‚ åˆå§‹åŒ–ï¼šä½ å¯ä»¥ç›´æ¥åˆå§‹åŒ–ä¸€ä¸ª stringstream å¯¹è±¡ï¼Œä¹Ÿå¯ä»¥ç”¨ä¸€ä¸ªå­—ç¬¦ä¸²åˆå§‹åŒ–å®ƒã€‚ è¯»å†™æ“ä½œï¼šä½¿ç”¨ &lt;&lt; æ“ä½œç¬¦å‘ stringstream å†™å…¥æ•°æ®ï¼Œä½¿ç”¨ &gt;&gt; æ“ä½œç¬¦ä»ä¸­è¯»å–æ•°æ®ã€‚ è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼šä½¿ç”¨ str() æˆå‘˜å‡½æ•°å¯ä»¥è·å–æˆ–è®¾ç½® stringstream çš„å†…å®¹ã€‚ æ¸…ç©ºï¼šä½¿ç”¨ str(&quot;&quot;) å¯ä»¥æ¸…ç©º stringstream çš„å†…å®¹ï¼Œä½¿ç”¨ clear() å¯ä»¥é‡ç½®å®ƒçš„çŠ¶æ€ã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ çµæ´»æ€§ï¼šstringstream éå¸¸é€‚åˆåšç±»å‹è½¬æ¢å’Œå­—ç¬¦ä¸²æ‹¼æ¥ã€‚ æ€§èƒ½ï¼šä¸ç›´æ¥æ“ä½œå­—ç¬¦ä¸²ç›¸æ¯”ï¼Œä½¿ç”¨ stringstream å¯èƒ½ä¼šæœ‰ä¸€äº›æ€§èƒ½æŸå¤±ï¼Œå°¤å…¶æ˜¯åœ¨å¤§é‡æ•°æ®æ“ä½œæ—¶ã€‚ çŠ¶æ€ç®¡ç†ï¼šåœ¨ä» stringstream è¯»å–æ•°æ®åï¼Œåº”æ£€æŸ¥æµçš„çŠ¶æ€ï¼ˆå¦‚æ˜¯å¦åˆ°è¾¾æœ«å°¾ï¼‰ã€‚ å†…å­˜ç®¡ç†ï¼šstringstream è‡ªåŠ¨ç®¡ç†å†…éƒ¨çš„å­—ç¬¦ä¸²ç¼“å†²åŒºï¼Œæ— éœ€æ‰‹åŠ¨é‡Šæ”¾å†…å­˜ã€‚ ç¤ºä¾‹ä»£ç  12345678910111213141516171819#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;int main() &#123; std::stringstream ss; ss &lt;&lt; &quot;Example &quot;; // å†™å…¥å­—ç¬¦ä¸² ss &lt;&lt; 2024; // å†™å…¥æ•°å­— std::string str = ss.str(); // å°† stringstream è½¬æ¢ä¸º string std::cout &lt;&lt; str &lt;&lt; std::endl; // è¾“å‡º &quot;Example 2024&quot; int num; ss.str(&quot;1234&quot;); // è®¾ç½®æ–°çš„å­—ç¬¦ä¸²å†…å®¹ ss &gt;&gt; num; // ä» stringstream è¯»å–æ•°å­— std::cout &lt;&lt; num &lt;&lt; std::endl; // è¾“å‡º 1234 return 0;&#125; åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ stringstream æ¥è¿›è¡ŒåŸºæœ¬çš„å†™å…¥ã€è¯»å–å’Œç±»å‹è½¬æ¢æ“ä½œã€‚"},{"title":"map éå†","path":"/wiki/C++/map/map éå†.html","content":"åœ¨ C++ ä¸­ï¼Œæœ‰å¤šç§æ–¹æ³•å¯ä»¥éå† map å®¹å™¨ã€‚éå† map çš„è¿‡ç¨‹é€šå¸¸æ¶‰åŠè¿­ä»£å™¨ã€‚ä¸‹é¢æˆ‘ä»¬å°†ä»‹ç»ä¸‰ç§å¸¸è§çš„éå†æ–¹æ³•ï¼šä½¿ç”¨è¿­ä»£å™¨ã€ä½¿ç”¨èŒƒå›´ for å¾ªç¯å’Œä½¿ç”¨ for_each ç®—æ³•ã€‚ åŸºæœ¬ç”¨æ³• ä½¿ç”¨è¿­ä»£å™¨éå† è¿™æ˜¯æœ€åŸºæœ¬çš„æ–¹æ³•ï¼Œé€‚ç”¨äºæ‰€æœ‰ C++ æ ‡å‡†å®¹å™¨ã€‚è¿­ä»£å™¨å¯ä»¥è®©ä½ ç²¾ç¡®æ§åˆ¶éå†çš„è¿‡ç¨‹ã€‚ 12345678910111213141516#include &lt;iostream&gt;#include &lt;map&gt;int main() &#123; std::map&lt;int, std::string&gt; myMap = &#123; &#123;1, &quot;one&quot;&#125;, &#123;2, &quot;two&quot;&#125;, &#123;3, &quot;three&quot;&#125; &#125;; for (std::map&lt;int, std::string&gt;::iterator it = myMap.begin(); it != myMap.end(); ++it) &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl; &#125; return 0;&#125; ä½¿ç”¨èŒƒå›´ for å¾ªç¯éå† C++11 å¼•å…¥äº†èŒƒå›´ for å¾ªç¯ï¼Œç®€åŒ–äº†éå†å®¹å™¨çš„è¿‡ç¨‹ã€‚ 12345678910111213141516#include &lt;iostream&gt;#include &lt;map&gt;int main() &#123; std::map&lt;int, std::string&gt; myMap = &#123; &#123;1, &quot;one&quot;&#125;, &#123;2, &quot;two&quot;&#125;, &#123;3, &quot;three&quot;&#125; &#125;; for (const auto&amp; pair : myMap) &#123; std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl; &#125; return 0;&#125; ä½¿ç”¨ for_each ç®—æ³•éå† for_each ç®—æ³•éœ€è¦åŒ…å«å¤´æ–‡ä»¶ &lt;algorithm&gt; å’Œä¸€ä¸ªå›è°ƒå‡½æ•°ã€‚ 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;void printPair(const std::pair&lt;int, std::string&gt;&amp; p) &#123; std::cout &lt;&lt; p.first &lt;&lt; &quot;: &quot; &lt;&lt; p.second &lt;&lt; std::endl;&#125;int main() &#123; std::map&lt;int, std::string&gt; myMap = &#123; &#123;1, &quot;one&quot;&#125;, &#123;2, &quot;two&quot;&#125;, &#123;3, &quot;three&quot;&#125; &#125;; std::for_each(myMap.begin(), myMap.end(), printPair); return 0;&#125; ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ ä½¿ç”¨è¿­ä»£å™¨ï¼šè¿­ä»£å™¨æ–¹æ³•çµæ´»ä¸”åŠŸèƒ½å¼ºå¤§ï¼Œé€‚ç”¨äºéœ€è¦å¯¹å…ƒç´ è¿›è¡Œå¤æ‚æ“ä½œçš„æƒ…å†µã€‚ èŒƒå›´ for å¾ªç¯ï¼šç®€æ´ä¸”æ˜“äºé˜…è¯»ï¼Œé€‚ç”¨äºå¤§å¤šæ•°éå†éœ€æ±‚ã€‚ for_each ç®—æ³•ï¼šé€‚ç”¨äºéœ€è¦å°†æ“ä½œå°è£…æˆç‹¬ç«‹å‡½æ•°çš„æƒ…å†µï¼Œå¯ä»¥ä½¿ä»£ç æ›´åŠ æ¨¡å—åŒ–ã€‚ æ³¨æ„ï¼šå¦‚æœä½¿ç”¨è¿­ä»£å™¨å¯¹mapå®¹å™¨è¿›è¡Œéå†ï¼Œå¯ä»¥ä½¿ç”¨distanceæ–¹æ³•è·å¾—å½“å‰è¿­ä»£å™¨çš„ä¸‹æ ‡distance(mp.begin(), it); ç¤ºä¾‹ä»£ç  ä»¥ä¸‹æ˜¯ä¸€ä¸ªç»¼åˆç¤ºä¾‹ï¼Œå±•ç¤ºäº†ä¸‰ç§éå†æ–¹æ³•ï¼š 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;void printPair(const std::pair&lt;int, std::string&gt;&amp; p) &#123; std::cout &lt;&lt; p.first &lt;&lt; &quot;: &quot; &lt;&lt; p.second &lt;&lt; std::endl;&#125;int main() &#123; std::map&lt;int, std::string&gt; myMap = &#123; &#123;1, &quot;one&quot;&#125;, &#123;2, &quot;two&quot;&#125;, &#123;3, &quot;three&quot;&#125; &#125;; // ä½¿ç”¨è¿­ä»£å™¨éå† std::cout &lt;&lt; &quot;Using iterator:&quot; &lt;&lt; std::endl; for (std::map&lt;int, std::string&gt;::iterator it = myMap.begin(); it != myMap.end(); ++it) &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl; &#125; // ä½¿ç”¨èŒƒå›´ for å¾ªç¯éå† std::cout &lt;&lt; &quot;Using range-based for loop:&quot; &lt;&lt; std::endl; for (const auto&amp; pair : myMap) &#123; std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl; &#125; // ä½¿ç”¨ for_each ç®—æ³•éå† std::cout &lt;&lt; &quot;Using for_each algorithm:&quot; &lt;&lt; std::endl; std::for_each(myMap.begin(), myMap.end(), printPair); return 0;&#125; è¾“å‡ºç»“æœå¦‚ä¸‹ï¼š 123456789101112Using iterator:1: one2: two3: threeUsing range-based for loop:1: one2: two3: threeUsing for_each algorithm:1: one2: two3: three æ€»ç»“ éå† map å®¹å™¨æœ‰å¤šç§æ–¹æ³•ï¼Œæ¯ç§æ–¹æ³•éƒ½æœ‰å…¶é€‚ç”¨åœºæ™¯å’Œä¼˜ç¼ºç‚¹ã€‚ä½¿ç”¨è¿­ä»£å™¨æ–¹æ³•çµæ´»ä½†ä»£ç è¾ƒé•¿ï¼ŒèŒƒå›´ for å¾ªç¯ç®€æ´æ˜“è¯»ï¼Œfor_each ç®—æ³•é€‚ç”¨äºéœ€è¦æ¨¡å—åŒ–çš„åœºæ™¯ã€‚é€‰æ‹©åˆé€‚çš„æ–¹æ³•å¯ä»¥ä½¿ä»£ç æ›´åŠ æ¸…æ™°å’Œé«˜æ•ˆã€‚"},{"title":"accumulate","path":"/wiki/C++/numeric/accumulate.html","content":"accumulate å‡½æ•°æ˜¯ C++ æ ‡å‡†åº“ä¸­ &lt;numeric&gt; å¤´æ–‡ä»¶çš„ä¸€éƒ¨åˆ†ï¼Œä¸»è¦ç”¨äºè®¡ç®—ç»™å®šèŒƒå›´å†…å…ƒç´ çš„ç´¯ç§¯å’Œæˆ–å…¶ä»–ç´¯ç§¯æ“ä½œã€‚ åŸºæœ¬ç”¨æ³• accumulate å‡½æ•°çš„åŸå‹å¦‚ä¸‹ï¼š 12345template &lt;class InputIterator, class T&gt;T accumulate (InputIterator first, InputIterator last, T init);template &lt;class InputIterator, class T, class BinaryOperation&gt;T accumulate (InputIterator first, InputIterator last, T init, BinaryOperation binary_op); first å’Œ lastï¼šç¡®å®šè¦å¤„ç†çš„å…ƒç´ èŒƒå›´çš„è¿­ä»£å™¨ã€‚ initï¼šç´¯ç§¯çš„åˆå§‹å€¼ã€‚ binary_opï¼ˆå¯é€‰ï¼‰ï¼šä¸€ä¸ªäºŒå…ƒæ“ä½œï¼Œç”¨äºæ›¿ä»£é»˜è®¤çš„åŠ æ³•æ“ä½œã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ é»˜è®¤è¡Œä¸ºï¼šåœ¨ä¸æä¾› binary_op çš„æƒ…å†µä¸‹ï¼Œé»˜è®¤æ‰§è¡ŒåŠ æ³•æ“ä½œã€‚ è‡ªå®šä¹‰æ“ä½œï¼šé€šè¿‡æä¾› binary_opï¼Œå¯ä»¥æ‰§è¡Œä»»ä½•äºŒå…ƒæ“ä½œï¼Œå¦‚ä¹˜æ³•ã€æœ€å¤§å€¼ç­‰ã€‚ ç±»å‹åŒ¹é…ï¼šinit çš„ç±»å‹åº”ä¸å®¹å™¨å…ƒç´ ç±»å‹å…¼å®¹ï¼Œå¦åˆ™å¯èƒ½å¯¼è‡´æ„å¤–çš„ç»“æœæˆ–ç¼–è¯‘é”™è¯¯ã€‚ æ€§èƒ½ï¼šè¿™æ˜¯ä¸€ä¸ªçº¿æ€§æ—¶é—´å¤æ‚åº¦çš„æ“ä½œï¼Œå› ä¸ºå®ƒéå†æ•´ä¸ªèŒƒå›´ã€‚ ç¤ºä¾‹ä»£ç  ä»¥ä¸‹æ˜¯ä½¿ç”¨ accumulate çš„ä¸€ä¸ªç¤ºä¾‹ï¼Œå±•ç¤ºäº†åŸºæœ¬çš„ç´¯åŠ æ“ä½œå’Œè‡ªå®šä¹‰æ“ä½œï¼š 1234567891011121314151617#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;numeric&gt;int main() &#123; std::vector&lt;int&gt; nums = &#123;1, 2, 3, 4, 5&#125;; // é»˜è®¤ç´¯åŠ  int sum = std::accumulate(nums.begin(), nums.end(), 0); std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl; // ä½¿ç”¨è‡ªå®šä¹‰æ“ä½œï¼ˆä¹˜æ³•ï¼‰ int product = std::accumulate(nums.begin(), nums.end(), 1, std::multiplies&lt;int&gt;()); std::cout &lt;&lt; &quot;Product: &quot; &lt;&lt; product &lt;&lt; std::endl; return 0;&#125; åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œç¬¬ä¸€ä¸ª accumulate è°ƒç”¨è®¡ç®—äº† nums çš„æ€»å’Œï¼Œè€Œç¬¬äºŒä¸ªè°ƒç”¨ä½¿ç”¨äº†ä¹˜æ³•æ“ä½œæ¥è®¡ç®—æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯ã€‚"},{"title":"lower_bound","path":"/wiki/C++/algorithm/lower_bound.html","content":"åœ¨ C++ ä¸­ï¼Œ&lt;algorithm&gt; å¤´æ–‡ä»¶ä¸­çš„lower_bound å‡½æ•°æ˜¯ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„ç®—æ³•ï¼Œå®ƒç”¨äºåœ¨å·²æ’åºçš„èŒƒå›´å†…æŸ¥æ‰¾ç¬¬ä¸€ä¸ªä¸å°äºç»™å®šå€¼çš„å…ƒç´ ã€‚ä¸‹é¢æˆ‘å°†è¯¦ç»†è§£é‡Šè¿™ä¸ªå‡½æ•°çš„åŸºæœ¬ç”¨æ³•ã€ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ï¼Œä»¥åŠæä¾›ç¤ºä¾‹ä»£ç ã€‚ åŸºæœ¬ç”¨æ³• å‡½æ•°åŸå‹ï¼šlower_bound(ForwardIterator first, ForwardIterator last, const T&amp; val) å‚æ•°ï¼š first å’Œ last æ˜¯å®šä¹‰è¦æœç´¢çš„èŒƒå›´çš„è¿­ä»£å™¨ã€‚ val æ˜¯æˆ‘ä»¬è¦æŸ¥æ‰¾çš„å€¼ã€‚ è¿”å›å€¼ï¼šæŒ‡å‘èŒƒå›´ä¸­ç¬¬ä¸€ä¸ªä¸å°äº val çš„å…ƒç´ çš„è¿­ä»£å™¨ã€‚å¦‚æœæ‰€æœ‰å…ƒç´ éƒ½å°äº valï¼Œåˆ™è¿”å› lastã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ lower_bound éœ€è¦é¢„æ’åºçš„èŒƒå›´ã€‚å¦‚æœèŒƒå›´æ²¡æœ‰æ’åºï¼Œç»“æœæ˜¯æœªå®šä¹‰çš„ã€‚ å®ƒä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ç®—æ³•ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º O(log n)ï¼Œå…¶ä¸­ n æ˜¯èŒƒå›´å†…å…ƒç´ çš„æ•°é‡ã€‚ å¦‚æœèŒƒå›´ä¸­å­˜åœ¨å¤šä¸ªç­‰äº val çš„å…ƒç´ ï¼Œlower_bound ä¼šè¿”å›æŒ‡å‘è¿™äº›å…ƒç´ ä¸­ç¬¬ä¸€ä¸ªçš„è¿­ä»£å™¨ã€‚ å¯¹äºè‡ªå®šä¹‰ç±»å‹ï¼Œä½ å¯èƒ½éœ€è¦æä¾›æ¯”è¾ƒå‡½æ•°æˆ–é‡è½½æ¯”è¾ƒæ“ä½œç¬¦ã€‚ ç¤ºä¾‹ä»£ç  123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; std::vector&lt;int&gt; vec = &#123;1, 2, 4, 4, 5, 6, 7&#125;; // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªä¸å°äº4çš„å…ƒç´  auto it = std::lower_bound(vec.begin(), vec.end(), 4); if (it != vec.end()) &#123; std::cout &lt;&lt; &quot;ç¬¬ä¸€ä¸ªä¸å°äº4çš„å…ƒç´ æ˜¯: &quot; &lt;&lt; *it &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;æ²¡æœ‰æ‰¾åˆ°ä¸å°äº4çš„å…ƒç´ &quot; &lt;&lt; std::endl; &#125; return 0;&#125; åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åœ¨ä¸€ä¸ªå·²æ’åºçš„ vector ä¸­æŸ¥æ‰¾ç¬¬ä¸€ä¸ªä¸å°äº4çš„å…ƒç´ ã€‚ç”±äºé›†åˆä¸­æœ‰ä¸¤ä¸ª4ï¼Œlower_bound è¿”å›æŒ‡å‘ç¬¬ä¸€ä¸ª4çš„è¿­ä»£å™¨ã€‚"},{"title":"max_element","path":"/wiki/C++/algorithm/max_element.html","content":"åœ¨ C++ ä¸­ï¼Œmax_element æ˜¯ä¸€ä¸ªæ¥è‡ª &lt;algorithm&gt; å¤´æ–‡ä»¶çš„å‡½æ•°ï¼Œç”¨äºæŸ¥æ‰¾ç»™å®šèŒƒå›´å†…çš„æœ€å¤§å…ƒç´ ã€‚ä»¥ä¸‹æ˜¯å…³äº max_element çš„è¯¦ç»†è§£é‡Šï¼š åŸºæœ¬ç”¨æ³• å‡½æ•°åŸå‹: max_element å‡½æ•°çš„åŸºæœ¬åŸå‹ä¸º max_element(Iterator first, Iterator last)ï¼Œå…¶ä¸­ Iterator æ˜¯æŒ‡å‘å®¹å™¨å…ƒç´ çš„è¿­ä»£å™¨ã€‚ è¿”å›å€¼: å®ƒè¿”å›ä¸€ä¸ªæŒ‡å‘ç»™å®šèŒƒå›´ä¸­æœ€å¤§å…ƒç´ çš„è¿­ä»£å™¨ã€‚å¦‚æœæœ‰å¤šä¸ªç›¸åŒçš„æœ€å¤§å…ƒç´ ï¼Œè¿”å›ç¬¬ä¸€ä¸ªè¿™æ ·çš„å…ƒç´ çš„è¿­ä»£å™¨ã€‚ èŒƒå›´: ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯èŒƒå›´çš„å¼€å§‹ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯èŒƒå›´çš„ç»“æŸï¼ˆä¸åŒ…æ‹¬ï¼‰ã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ å®¹å™¨ç±»å‹: max_element å¯ä»¥ç”¨äºä»»ä½•æä¾›éšæœºè®¿é—®è¿­ä»£å™¨çš„å®¹å™¨ï¼Œå¦‚ vectorã€dequeã€æ•°ç»„ç­‰ã€‚ æ¯”è¾ƒå‡½æ•°: å¯ä»¥æä¾›è‡ªå®šä¹‰çš„æ¯”è¾ƒå‡½æ•°æ¥å®šä¹‰â€œæœ€å¤§â€å…ƒç´ çš„æ¡ä»¶ã€‚ ç©ºèŒƒå›´: å¦‚æœèŒƒå›´ä¸ºç©ºï¼ˆå³ first ç­‰äº lastï¼‰ï¼Œåˆ™è¿”å› lastã€‚ æ€§èƒ½: æ—¶é—´å¤æ‚åº¦é€šå¸¸æ˜¯çº¿æ€§çš„ï¼Œå³ O(n)ï¼Œå…¶ä¸­ n æ˜¯èŒƒå›´å†…å…ƒç´ çš„æ•°é‡ã€‚ ç¤ºä¾‹ä»£ç  123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; std::vector&lt;int&gt; v = &#123;1, 3, 2, 8, 5&#125;; auto max_it = std::max_element(v.begin(), v.end()); if (max_it != v.end()) &#123; std::cout &lt;&lt; &quot;æœ€å¤§å…ƒç´ : &quot; &lt;&lt; *max_it &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;å‘é‡ä¸ºç©º&quot; &lt;&lt; std::endl; &#125; return 0;&#125; åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œmax_element ç”¨äºæŸ¥æ‰¾ vector ä¸­çš„æœ€å¤§å…ƒç´ ã€‚å¦‚æœæ‰¾åˆ°ï¼Œå®ƒæ‰“å°å‡ºè¯¥å…ƒç´ çš„å€¼ã€‚"},{"title":"next_permutation","path":"/wiki/C++/algorithm/next_permutation.html","content":"next_permutation æ˜¯ C++ æ ‡å‡†åº“ &lt;algorithm&gt; ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºå¯¹åºåˆ—ç”Ÿæˆä¸‹ä¸€ä¸ªå­—å…¸åºæ’åˆ—ã€‚å¦‚æœå½“å‰åºåˆ—å·²ç»æ˜¯å­—å…¸åºçš„æœ€åä¸€ä¸ªæ’åˆ—ï¼Œåˆ™ç”Ÿæˆç¬¬ä¸€ä¸ªæ’åˆ—ï¼ˆå³æœ€å°çš„æ’åˆ—ï¼‰ã€‚ åŸºæœ¬ç”¨æ³• 123456789101112131415#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;int main() &#123; std::vector&lt;int&gt; vec = &#123;1, 2, 3&#125;; do &#123; for (int x : vec) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; std::cout &lt;&lt; &quot; &quot;; &#125; while (std::next_permutation(vec.begin(), vec.end())); return 0;&#125; ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ è¿”å›å€¼ï¼šnext_permutation è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ã€‚å¦‚æœæˆåŠŸç”Ÿæˆä¸‹ä¸€ä¸ªæ’åˆ—ï¼Œè¿”å› trueï¼›å¦‚æœå·²ç»æ˜¯æœ€åä¸€ä¸ªæ’åˆ—å¹¶ç”Ÿæˆäº†ç¬¬ä¸€ä¸ªæ’åˆ—ï¼Œè¿”å› falseã€‚ åŸåœ°æ“ä½œï¼šnext_permutation å¯¹ä¼ å…¥çš„åºåˆ—è¿›è¡ŒåŸåœ°é‡æ’ï¼Œä¸ä¼šåˆ†é…é¢å¤–çš„å†…å­˜ã€‚ åºåˆ—è¦æ±‚ï¼šé€‚ç”¨äºä»»ä½•æ”¯æŒéšæœºè®¿é—®è¿­ä»£å™¨çš„åºåˆ—ï¼Œå¦‚ std::vectorã€std::arrayã€åŸå§‹æ•°ç»„ç­‰ã€‚ ç®—æ³•å¤æ‚åº¦ï¼šåœ¨æœ€åæƒ…å†µä¸‹ï¼Œnext_permutation çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(N)ï¼Œå…¶ä¸­ N æ˜¯åºåˆ—çš„é•¿åº¦ã€‚ ç¤ºä¾‹ä»£ç  ä¸‹é¢æ˜¯ä¸€ä¸ªæ›´è¯¦ç»†çš„ç¤ºä¾‹ï¼Œæ¼”ç¤ºäº† next_permutation çš„ä½¿ç”¨ï¼Œå¹¶è¯´æ˜äº†å¦‚ä½•åœ¨ä¸åŒçš„æ•°æ®ç±»å‹ä¸Šåº”ç”¨ï¼š 12345678910111213141516171819202122232425#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;int main() &#123; // ç¤ºä¾‹ 1ï¼šä½¿ç”¨æ•´æ•°å‘é‡ std::vector&lt;int&gt; vec = &#123;1, 2, 3&#125;; std::cout &lt;&lt; &quot;æ•´æ•°å‘é‡çš„æ’åˆ—: &quot;; do &#123; for (int x : vec) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; std::cout &lt;&lt; &quot; &quot;; &#125; while (std::next_permutation(vec.begin(), vec.end())); // ç¤ºä¾‹ 2ï¼šä½¿ç”¨å­—ç¬¦æ•°ç»„ char arr[] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;; std::cout &lt;&lt; &quot; å­—ç¬¦æ•°ç»„çš„æ’åˆ—: &quot;; do &#123; for (char x : arr) std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; std::cout &lt;&lt; &quot; &quot;; &#125; while (std::next_permutation(arr, arr + 3)); return 0;&#125; åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬åˆ†åˆ«å¯¹æ•´æ•°å‘é‡å’Œå­—ç¬¦æ•°ç»„è¿›è¡Œäº†æ’åˆ—ã€‚ä½¿ç”¨ next_permutation å‡½æ•°å¯ä»¥æ–¹ä¾¿åœ°ç”Ÿæˆåºåˆ—çš„æ‰€æœ‰æ’åˆ—ï¼Œå¹¶è¿›è¡Œå¤„ç†æˆ–è¾“å‡ºã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœéœ€è¦ç”Ÿæˆæ’åˆ—çš„åºåˆ—æ˜¯å·²æ’åºçš„ï¼Œé‚£ä¹ˆç¬¬ä¸€æ¬¡è°ƒç”¨ next_permutation å°†ç”Ÿæˆå…¶ä¸‹ä¸€ä¸ªå­—å…¸åºæ’åˆ—ï¼Œå¦åˆ™å¯èƒ½éœ€è¦å¤šæ¬¡è°ƒç”¨æ‰èƒ½è¾¾åˆ°æ•ˆæœã€‚"},{"title":"sort","path":"/wiki/C++/algorithm/sort.html","content":"åŸºæœ¬ç”¨æ³• sort å‡½æ•°æ˜¯ C++ æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªå¼ºå¤§çš„æ’åºç®—æ³•ï¼Œé€šå¸¸å®ç°ä¸ºå¿«é€Ÿæ’åºã€‚è¿™ä¸ªå‡½æ•°å®šä¹‰åœ¨ &lt;algorithm&gt; å¤´æ–‡ä»¶ä¸­ã€‚sort å¯ä»¥å¯¹ä¸€ä¸ªåºåˆ—è¿›è¡Œæ’åºï¼Œä½¿ä¹‹æŒ‰ç…§å‡åºæ’åˆ—ã€‚åŸºæœ¬è¯­æ³•å¦‚ä¸‹ï¼š 12sort(RandomAccessIterator first, RandomAccessIterator last);sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp); first å’Œ last æ˜¯å®šä¹‰å¾…æ’åºåºåˆ—çš„éšæœºè®¿é—®è¿­ä»£å™¨ã€‚ comp æ˜¯ä¸€ä¸ªå¯é€‰çš„æ¯”è¾ƒå‡½æ•°æˆ–è€…å‡½æ•°å¯¹è±¡ï¼Œç”¨äºè‡ªå®šä¹‰æ’åºé¡ºåºã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ æ—¶é—´å¤æ‚åº¦: sort çš„å¹³å‡æ—¶é—´å¤æ‚åº¦æ˜¯ O(n log n)ï¼Œå…¶ä¸­ n æ˜¯[first, last)èŒƒå›´å†…å…ƒç´ çš„æ•°é‡ã€‚ éšæœºè®¿é—®è¿­ä»£å™¨: sort éœ€è¦éšæœºè®¿é—®è¿­ä»£å™¨ï¼Œå› æ­¤é€‚ç”¨äº std::vectorã€std::dequeã€æ•°ç»„ç­‰ï¼Œä½†ä¸é€‚ç”¨äº std::listã€‚ ç¨³å®šæ€§: æ ‡å‡†åº“ä¸­çš„ sort ä¸ä¿è¯æ’åºçš„ç¨³å®šæ€§ã€‚å¦‚æœéœ€è¦ç¨³å®šæ’åºï¼Œå¯ä»¥ä½¿ç”¨ stable_sortã€‚ è‡ªå®šä¹‰æ’åº: é€šè¿‡æä¾›æ¯”è¾ƒå‡½æ•°ï¼Œå¯ä»¥å®ç°è‡ªå®šä¹‰æ’åºé€»è¾‘ã€‚ ç¤ºä¾‹ä»£ç  1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; std::vector&lt;int&gt; v = &#123;4, 2, 5, 1, 3&#125;; // æŒ‰å‡åºæ’åº std::sort(v.begin(), v.end()); std::cout &lt;&lt; &quot;Sorted array: &quot;; for (int i : v) &#123; std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // ä½¿ç”¨è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°è¿›è¡Œé™åºæ’åº std::sort(v.begin(), v.end(), [](int a, int b) &#123; return a &gt; b; &#125;); std::cout &lt;&lt; &quot;Sorted in descending order: &quot;; for (int i : v) &#123; std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œé¦–å…ˆä½¿ç”¨ sort å°†å‘é‡ v æŒ‰å‡åºæ’åºï¼Œç„¶åä½¿ç”¨è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°å°†å…¶æŒ‰é™åºæ’åºã€‚ è¿™é‡Œå±•ç¤ºçš„å°±æ˜¯ä½¿ç”¨è‡ªå®šä¹‰åŒ¿åå‡½æ•°é‡æ–°è§„å®šæ’åºè§„åˆ™"},{"title":"upper_bound","path":"/wiki/C++/algorithm/upper_bound.html","content":"åŸºæœ¬ç”¨æ³• upper_bound å‡½æ•°åœ¨ C++ ä¸­ç”¨äºåœ¨æœ‰åºèŒƒå›´å†…æŸ¥æ‰¾å¤§äºç»™å®šå€¼çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚è¿™ä¸ªå‡½æ•°å±äº &lt;algorithm&gt; å¤´æ–‡ä»¶ã€‚å®ƒä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ç®—æ³•ï¼Œå› æ­¤æ•ˆç‡è¾ƒé«˜ã€‚åŸºæœ¬è¯­æ³•å¦‚ä¸‹ï¼š 1upper_bound(ForwardIterator first, ForwardIterator last, const T&amp; val); first å’Œ last æ˜¯å®šä¹‰å¾…æœç´¢åŒºé—´çš„è¿­ä»£å™¨ã€‚ val æ˜¯æˆ‘ä»¬è¦æŸ¥æ‰¾çš„å€¼ã€‚ å‡½æ•°è¿”å›ä¸€ä¸ªæŒ‡å‘æ‰¾åˆ°çš„å…ƒç´ çš„è¿­ä»£å™¨ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™è¿”å› lastã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ æ—¶é—´å¤æ‚åº¦: upper_bound çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(log n)ï¼Œå…¶ä¸­ n æ˜¯[first,last)[first, last)[first,last) èŒƒå›´å†…å…ƒç´ çš„æ•°é‡ã€‚ è¦æ±‚æœ‰åº: ä½¿ç”¨ upper_bound å‰ï¼Œç¡®ä¿èŒƒå›´ [first,last)[first, last)[first,last) å·²æ’åºã€‚ è¿”å›å€¼: å¦‚æœèŒƒå›´å†…æ‰€æœ‰å…ƒç´ éƒ½å°äºæˆ–ç­‰äº valï¼Œåˆ™è¿”å› lastã€‚ è‡ªå®šä¹‰æ¯”è¾ƒ: å¯ä»¥æä¾›è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°ã€‚ ç¤ºä¾‹ä»£ç  123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; std::vector&lt;int&gt; v = &#123;1, 2, 4, 4, 5, 6, 7&#125;; // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå¤§äº 4 çš„å…ƒç´  auto it = std::upper_bound(v.begin(), v.end(), 4); if (it != v.end()) &#123; std::cout &lt;&lt; &quot;The first element greater than 4 is: &quot; &lt;&lt; *it &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;No element greater than 4 found.&quot; &lt;&lt; std::endl; &#125; return 0;&#125; åœ¨æ­¤ä¾‹ä¸­ï¼Œupper_bound ä¼šè¿”å›æŒ‡å‘å€¼ 5 çš„è¿­ä»£å™¨ï¼Œå› ä¸º 5 æ˜¯æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå¤§äº 4 çš„å…ƒç´ ã€‚ å½“ç„¶upper_boundå’Œsortä¸€æ ·è¿˜å¯ä»¥è‡ªå®šä¹‰æ¯”è¾ƒçš„å†…å®¹ï¼Œä¸‹é¢æ˜¯å¦å¤–ä¸€ä¸ªä¾‹å­ï¼š å–è‡ª2023-12-08 Leetcode æ¯æ—¥ä¸€é¢˜è§£æ³• 123456789101112131415161718class Solution &#123;public: long long maxTaxiEarnings(int n, vector&lt;vector&lt;int&gt;&gt;&amp; rides) &#123; sort(rides.begin(),rides.end(), [](const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123; if(a[1]==b[1])return a[0] &lt; b[0]; return a[1] &lt; b[1]; &#125;); int p_num = rides.size(); vector&lt;long long&gt; dp(p_num+1); for(int i=0;i&lt;p_num;++i)&#123; int j = upper_bound(rides.begin(), rides.begin() + i, rides[i][0], [](int x, const vector&lt;int&gt; &amp;r)&#123; return x &lt; r[1]; &#125;) - rides.begin(); dp[i+1] = max(dp[i], dp[j]+rides[i][1]-rides[i][0]+rides[i][2]); &#125; return dp[p_num]; &#125;&#125;; è¯¥å†…åµŒè‡ªå®šä¹‰åŒ¿åå‡½æ•°ä¸»è¦å®ç°äº†å‘ŠçŸ¥upper_boundå‡½æ•°å¦‚ä½•å°†ä¼ å…¥çš„æ•´æ•°å’Œvectorä¸­çš„vectorç±»å‹æ¯”è¾ƒå¤§å°ã€‚"},{"title":"getline","path":"/wiki/C++/string/getline.html","content":"getline æ˜¯ C++ ä¸­ç”¨äºä»è¾“å…¥æµä¸­è¯»å–å­—ç¬¦ä¸²çš„å‡½æ•°ï¼Œé€šå¸¸ä¸æ–‡ä»¶æµï¼ˆå¦‚ ifstreamï¼‰æˆ–æ ‡å‡†è¾“å…¥ï¼ˆå¦‚ cinï¼‰ä¸€èµ·ä½¿ç”¨ã€‚å®ƒå±äº &lt;string&gt; å¤´æ–‡ä»¶ã€‚ åŸºæœ¬ç”¨æ³• å®šä¹‰ï¼šgetline å‡½æ•°å®šä¹‰åœ¨ &lt;string&gt; å¤´æ–‡ä»¶ä¸­ï¼Œé€šå¸¸ä¸ &lt;iostream&gt; ä¸€èµ·ä½¿ç”¨ã€‚ å‡½æ•°åŸå‹ï¼šstd::getline(std::istream&amp; stream, std::string&amp; str, char delim)ã€‚ streamï¼šè¦è¯»å–çš„è¾“å…¥æµï¼Œå¦‚ cin æˆ–æ–‡ä»¶æµå¯¹è±¡ã€‚ strï¼šç”¨äºå­˜å‚¨è¯»å–åˆ°çš„å­—ç¬¦ä¸²çš„ std::string å¯¹è±¡ã€‚ delimï¼ˆå¯é€‰ï¼‰ï¼šä½œä¸ºè¡Œç»“æŸç¬¦çš„åˆ†éš”ç¬¦ï¼Œé»˜è®¤ä¸ºæ¢è¡Œç¬¦ ã€‚ è¯»å–è¡Œï¼šgetline ä¼šè¯»å–è¾“å…¥ç›´åˆ°é‡åˆ°åˆ†éš”ç¬¦ï¼ˆé»˜è®¤ä¸ºæ¢è¡Œç¬¦ï¼‰ï¼Œå¹¶å°†è¯»å–çš„å†…å®¹ï¼ˆä¸åŒ…æ‹¬åˆ†éš”ç¬¦ï¼‰å­˜å‚¨åœ¨ str ä¸­ã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ å®‰å…¨æ€§ï¼šä¸ä½¿ç”¨ cin &gt;&gt; ç›´æ¥è¯»å–å­—ç¬¦ä¸²ç›¸æ¯”ï¼Œgetline å¯ä»¥é¿å…å› å­—ç¬¦ä¸²ä¸­çš„ç©ºæ ¼è€Œå¯¼è‡´çš„è¯»å–ä¸­æ–­ã€‚ çµæ´»æ€§ï¼šä½ å¯ä»¥è‡ªå®šä¹‰åˆ†éš”ç¬¦ï¼Œä¾¿äºå¤„ç†ä¸åŒæ ¼å¼çš„è¾“å…¥ã€‚ è¾“å…¥ç»“æŸï¼šå¦‚æœåœ¨è¾¾åˆ°åˆ†éš”ç¬¦ä¹‹å‰åˆ°è¾¾æ–‡ä»¶æœ«å°¾æˆ–å‘ç”Ÿé”™è¯¯ï¼Œgetline å°†è®¾ç½®è¾“å…¥æµçš„çŠ¶æ€æ ‡å¿—ã€‚ ç©ºè¡Œå¤„ç†ï¼šgetline ä¹Ÿèƒ½è¯»å–ç©ºè¡Œï¼Œæ­¤æ—¶è¿”å›çš„å­—ç¬¦ä¸²å°†ä¸ºç©ºã€‚ ç¤ºä¾‹ä»£ç  12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string line; std::cout &lt;&lt; &quot;è¯·è¾“å…¥ä¸€äº›æ–‡æœ¬ï¼ˆåŒ…å«ç©ºæ ¼ï¼‰: &quot;; std::getline(std::cin, line); std::cout &lt;&lt; &quot;ä½ è¾“å…¥çš„æ–‡æœ¬æ˜¯: &quot; &lt;&lt; line &lt;&lt; std::endl; return 0;&#125; è¿™ä¸ªä¾‹å­å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ std::getline ä»æ ‡å‡†è¾“å…¥è¯»å–ä¸€è¡Œæ–‡æœ¬ã€‚è¿™ç§æ–¹å¼å¯ä»¥æ­£ç¡®å¤„ç†å«æœ‰ç©ºæ ¼çš„å­—ç¬¦ä¸²è¾“å…¥ã€‚"},{"title":"stoi","path":"/wiki/C++/string/stoi.html","content":"stoi æ˜¯ C++11 æ ‡å‡†å¼•å…¥çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºå°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°ã€‚ä»¥ä¸‹æ˜¯è¯¦ç»†çš„è§£é‡Šï¼š åŸºæœ¬ç”¨æ³• stoi æ˜¯ä¸€ä¸ªæ ‡å‡†åº“å‡½æ•°ï¼Œå®šä¹‰åœ¨ &lt;string&gt; å¤´æ–‡ä»¶ä¸­ã€‚å®ƒçš„ä¸»è¦åŠŸèƒ½æ˜¯å°† std::string æˆ– C é£æ ¼å­—ç¬¦ä¸²è½¬æ¢ä¸º int ç±»å‹ã€‚ å‡½æ•°ç­¾åå¦‚ä¸‹ï¼š 1int stoi(const std::string&amp; str, std::size_t* pos = nullptr, int base = 10); ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ è¾“å…¥å‚æ•°ï¼š str: è¦è½¬æ¢çš„å­—ç¬¦ä¸²ã€‚ pos: ä¸€ä¸ªæŒ‡å‘ std::size_t çš„æŒ‡é’ˆï¼Œç”¨äºå­˜å‚¨ç¬¬ä¸€ä¸ªæœªå¤„ç†å­—ç¬¦çš„ä½ç½®ã€‚å¦‚æœä¸éœ€è¦è¿™ä¸ªä¿¡æ¯ï¼Œå¯ä»¥ä¼ é€’ nullptrã€‚ base: åŸºæ•°ï¼Œç”¨äºæŒ‡å®šæ•°å­—çš„è¿›åˆ¶ï¼Œé»˜è®¤ä¸º 10ã€‚æ”¯æŒ 2 åˆ° 36 ä¹‹é—´çš„ä»»ä½•è¿›åˆ¶ã€‚ è¿”å›å€¼ï¼š æˆåŠŸæ—¶ï¼Œè¿”å›å­—ç¬¦ä¸²è½¬æ¢åçš„ int å€¼ã€‚ å¼‚å¸¸å¤„ç†ï¼š std::invalid_argument: å¦‚æœå­—ç¬¦ä¸²ä¸åŒ…å«æœ‰æ•ˆçš„æ•°å­—ï¼Œå°†æŠ›å‡ºè¯¥å¼‚å¸¸ã€‚ std::out_of_range: å¦‚æœè½¬æ¢ç»“æœè¶…å‡ºäº† int ç±»å‹çš„èŒƒå›´ï¼Œå°†æŠ›å‡ºè¯¥å¼‚å¸¸ã€‚ æ³¨æ„äº‹é¡¹ï¼š ç¡®ä¿è¾“å…¥å­—ç¬¦ä¸²æ˜¯æœ‰æ•ˆçš„æ•´æ•°è¡¨ç¤ºï¼Œå¦åˆ™ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚ æ³¨æ„æ£€æŸ¥å¼‚å¸¸ä»¥é˜²æ­¢ç¨‹åºå´©æºƒã€‚ stoi ä»…èƒ½å¤„ç†è¡¨ç¤ºæ•´æ•°çš„å­—ç¬¦ä¸²ï¼Œå¯¹äºæµ®ç‚¹æ•°è½¬æ¢è¯·ä½¿ç”¨ stofã€stod æˆ– stoldã€‚ ç¤ºä¾‹ä»£ç  ä»¥ä¸‹æ˜¯ä¸€äº›ä½¿ç”¨ stoi çš„ç¤ºä¾‹ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; // ç¤ºä¾‹ 1ï¼šåŸºæœ¬ç”¨æ³• std::string str = &quot;123&quot;; int num = std::stoi(str); std::cout &lt;&lt; &quot;å­—ç¬¦ä¸² \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; è½¬æ¢ä¸ºæ•´æ•°: &quot; &lt;&lt; num &lt;&lt; std::endl; // ç¤ºä¾‹ 2ï¼šå¤„ç†æ— æ•ˆè¾“å…¥ try &#123; std::string invalid_str = &quot;abc&quot;; int invalid_num = std::stoi(invalid_str); &#125; catch (const std::invalid_argument&amp; e) &#123; std::cerr &lt;&lt; &quot;æ— æ•ˆçš„è¾“å…¥å­—ç¬¦ä¸²: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; // ç¤ºä¾‹ 3ï¼šå¤„ç†è¶…å‡ºèŒƒå›´çš„è¾“å…¥ try &#123; std::string out_of_range_str = &quot;99999999999999999999999999&quot;; int out_of_range_num = std::stoi(out_of_range_str); &#125; catch (const std::out_of_range&amp; e) &#123; std::cerr &lt;&lt; &quot;è¾“å…¥å­—ç¬¦ä¸²è¶…å‡ºèŒƒå›´: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; // ç¤ºä¾‹ 4ï¼šä½¿ç”¨ä¸åŒçš„è¿›åˆ¶ std::string hex_str = &quot;1A&quot;; int hex_num = std::stoi(hex_str, nullptr, 16); std::cout &lt;&lt; &quot;16 è¿›åˆ¶å­—ç¬¦ä¸² \\&quot;&quot; &lt;&lt; hex_str &lt;&lt; &quot;\\&quot; è½¬æ¢ä¸ºæ•´æ•°: &quot; &lt;&lt; hex_num &lt;&lt; std::endl; return 0;&#125; ç»“è®º stoi æ˜¯ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„å‡½æ•°ï¼Œé€‚ç”¨äºä»å­—ç¬¦ä¸²ä¸­æå–æ•´æ•°å€¼ã€‚é€šè¿‡æ­£ç¡®çš„å¼‚å¸¸å¤„ç†ï¼Œå¯ä»¥å®‰å…¨åœ°ä½¿ç”¨å®ƒæ¥å¤„ç†ä¸åŒæ ¼å¼çš„è¾“å…¥ã€‚"},{"title":"unordered_map åŸºç¡€","path":"/wiki/C++/unordered_map/unordered_map åŸºç¡€.html","content":"unordered_map æ˜¯ C++ æ ‡å‡†æ¨¡æ¿åº“ï¼ˆSTLï¼‰ä¸­çš„ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„å®¹å™¨ã€‚å®ƒè¢«ç”¨æ¥å­˜å‚¨é”®å€¼å¯¹ï¼Œå…¶ä¸­æ¯ä¸ªé”®éƒ½æ˜¯å”¯ä¸€çš„ã€‚è¿™ä¸ªå®¹å™¨ä½¿ç”¨å“ˆå¸Œè¡¨æ¥å®ç°ï¼Œå› æ­¤å…¶åœ¨å¹³å‡æƒ…å†µä¸‹ä¸ºé”®çš„æŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œæä¾›äº†å¸¸æ•°æ—¶é—´å¤æ‚åº¦ï¼ˆO(1)ï¼‰ã€‚ä¸‹é¢æ˜¯å…³äº unordered_map çš„è¯¦ç»†ä»‹ç»ï¼š åŸºæœ¬ç”¨æ³• åˆå§‹åŒ–ï¼šå¯ä»¥é€šè¿‡ç›´æ¥å£°æ˜æˆ–ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨æ¥åˆ›å»º unordered_mapã€‚ æ’å…¥å…ƒç´ ï¼šä½¿ç”¨ insert æ–¹æ³•æˆ– [] æ“ä½œç¬¦æ¥æ’å…¥æ–°å…ƒç´ ã€‚ è®¿é—®å…ƒç´ ï¼šä½¿ç”¨ [] æ“ä½œç¬¦æˆ– at æ–¹æ³•æ¥è®¿é—®å…ƒç´ ã€‚ åˆ é™¤å…ƒç´ ï¼šä½¿ç”¨ erase æ–¹æ³•æ¥åˆ é™¤å…ƒç´ ã€‚ æŸ¥æ‰¾å…ƒç´ ï¼šä½¿ç”¨ find æ–¹æ³•æ¥æŸ¥æ‰¾ç‰¹å®šé”®çš„å…ƒç´ ã€‚ å¤§å°å’Œå®¹é‡ï¼šä½¿ç”¨ size æ–¹æ³•è·å–å…ƒç´ ä¸ªæ•°ï¼Œempty æ£€æŸ¥æ˜¯å¦ä¸ºç©ºã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ æ€§èƒ½ï¼šåœ¨å¹³å‡æƒ…å†µä¸‹ï¼Œæ’å…¥ã€åˆ é™¤å’ŒæŸ¥æ‰¾æ“ä½œçš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ O(1)ã€‚ä½†åœ¨æœ€åæƒ…å†µä¸‹ï¼Œè¿™äº›æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å¯èƒ½é€€åŒ–ä¸º O(n)ã€‚ å“ˆå¸Œå‡½æ•°ï¼šunordered_map ä½¿ç”¨å“ˆå¸Œå‡½æ•°å°†é”®æ˜ å°„åˆ°å“ˆå¸Œè¡¨ä¸­çš„æ¡¶ã€‚å¯¹äºè‡ªå®šä¹‰ç±»å‹ï¼Œå¯èƒ½éœ€è¦å®šä¹‰è‡ªå·±çš„å“ˆå¸Œå‡½æ•°ã€‚ ç¢°æ’å¤„ç†ï¼šå½“ä¸¤ä¸ªé”®æ˜ å°„åˆ°åŒä¸€ä¸ªæ¡¶æ—¶ï¼Œunordered_map é€šè¿‡é“¾è¡¨æ¥å¤„ç†ç¢°æ’ã€‚ æ— åºæ€§ï¼šå¦‚å…¶åæ‰€ç¤ºï¼Œunordered_map ä¸­çš„å…ƒç´ æ˜¯æ— åºå­˜å‚¨çš„ï¼Œä¸ä¿è¯å…ƒç´ çš„é¡ºåºã€‚ å”¯ä¸€é”®ï¼šæ¯ä¸ªé”®åœ¨ unordered_map ä¸­å¿…é¡»æ˜¯å”¯ä¸€çš„ã€‚ ç¤ºä¾‹ä»£ç  12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;unordered_map&gt;int main() &#123; std::unordered_map&lt;std::string, int&gt; umap; // æ’å…¥å…ƒç´  umap[&quot;apple&quot;] = 5; umap[&quot;banana&quot;] = 8; // è®¿é—®å…ƒç´  std::cout &lt;&lt; &quot;apple count: &quot; &lt;&lt; umap[&quot;apple&quot;] &lt;&lt; std::endl; // æŸ¥æ‰¾å…ƒç´  if (umap.find(&quot;banana&quot;) != umap.end()) &#123; std::cout &lt;&lt; &quot;banana found&quot; &lt;&lt; std::endl; &#125; // åˆ é™¤å…ƒç´  umap.erase(&quot;apple&quot;); // éå†å…ƒç´  for (auto&amp; item : umap) &#123; std::cout &lt;&lt; item.first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; item.second &lt;&lt; std::endl; &#125; return 0;&#125; è¿™ä¸ªç¤ºä¾‹å±•ç¤ºäº† unordered_map çš„åŸºæœ¬ç”¨æ³•ï¼ŒåŒ…æ‹¬å¦‚ä½•æ’å…¥ã€è®¿é—®ã€æŸ¥æ‰¾å’Œåˆ é™¤å…ƒç´ ã€‚ä½¿ç”¨ unordered_map å¯ä»¥æœ‰æ•ˆåœ°å¤„ç†å¤§é‡çš„æ•°æ®ï¼Œå°¤å…¶æ˜¯åœ¨éœ€è¦å¿«é€ŸæŸ¥æ‰¾å’Œæ›´æ–°æ•°æ®çš„åœºåˆã€‚"},{"title":"move","path":"/wiki/C++/utility/move.html","content":"åœ¨ C++ ä¸­ï¼Œâ€œmoveâ€æ“ä½œæ˜¯ä¸€ç§ä¼˜åŒ–æŠ€æœ¯ï¼Œä¸»è¦ç”¨äºå‡å°‘ä¸å¿…è¦çš„å¯¹è±¡å¤åˆ¶ï¼Œä»è€Œæé«˜ç¨‹åºæ€§èƒ½ã€‚å®ƒæ˜¯ C++11 æ ‡å‡†ä¸­å¼•å…¥çš„ä¸€ä¸ªé‡è¦ç‰¹æ€§ã€‚ä¸‹é¢ï¼Œæˆ‘å°†åˆ†åˆ«ä»åŸºæœ¬ç”¨æ³•ã€ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ã€ä»¥åŠç¤ºä¾‹ä»£ç ä¸‰ä¸ªæ–¹é¢æ¥è®²è§£ move æ“ä½œã€‚ åŸºæœ¬ç”¨æ³• std::move æ˜¯ä¸€ä¸ªå‡½æ•°æ¨¡æ¿ï¼Œå®šä¹‰åœ¨å¤´æ–‡ä»¶ &lt;utility&gt; ä¸­ã€‚å®ƒå¯ä»¥å°†ä¸€ä¸ªå¯¹è±¡è½¬æ¢ä¸ºå³å€¼å¼•ç”¨ï¼Œä»è€Œä½¿å¾—è¯¥å¯¹è±¡çš„èµ„æºå¯ä»¥è¢«â€œç§»åŠ¨â€è€Œéå¤åˆ¶ã€‚ ä½¿ç”¨ move æ“ä½œæ—¶ï¼ŒåŸå¯¹è±¡ä¼šè½¬å…¥ä¸€ä¸ªä¸ç¡®å®šä½†æœ‰æ•ˆçš„çŠ¶æ€ã€‚è¿™æ„å‘³ç€ï¼ŒåŸå¯¹è±¡ä»ç„¶å¯ä»¥ææ„æˆ–èµ‹äºˆæ–°å€¼ï¼Œä½†å…¶å…·ä½“å†…å®¹ä¸å†ç¡®å®šã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ æ€§èƒ½æå‡ï¼šé€šè¿‡ç§»åŠ¨å¯¹è±¡è€Œéå¤åˆ¶å¯¹è±¡ï¼Œå¯ä»¥æ˜¾è‘—å‡å°‘å†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾ï¼Œæé«˜ç¨‹åºçš„è¿è¡Œæ•ˆç‡ã€‚ æ‰€æœ‰æƒè½¬ç§»ï¼šæ‰§è¡Œ move æ“ä½œåï¼Œèµ„æºçš„æ‰€æœ‰æƒä»ä¸€ä¸ªå¯¹è±¡è½¬ç§»åˆ°å¦ä¸€ä¸ªå¯¹è±¡ï¼ŒåŸå¯¹è±¡ä¸å†æ‹¥æœ‰è¿™äº›èµ„æºã€‚ å®‰å…¨ä½¿ç”¨ï¼šä½¿ç”¨ move åï¼ŒåŸå§‹å¯¹è±¡å¤„äºä¸€ä¸ªä¸ç¡®å®šçš„çŠ¶æ€ã€‚å› æ­¤ï¼Œé™¤éé‡æ–°èµ‹å€¼ï¼Œå¦åˆ™ä¸åº”å†æ¬¡ä½¿ç”¨è¿™äº›è¢«ç§»åŠ¨çš„å¯¹è±¡ã€‚ å…¼å®¹æ€§ï¼šmove æ“ä½œåªé€‚ç”¨äºæ”¯æŒç§»åŠ¨è¯­ä¹‰çš„å¯¹è±¡ã€‚å¯¹äºä¸æ”¯æŒç§»åŠ¨è¯­ä¹‰çš„å¯¹è±¡ï¼Œmove æ“ä½œä¼šé€€åŒ–ä¸ºå¤åˆ¶æ“ä½œã€‚ ç¤ºä¾‹ä»£ç  ä¸‹é¢æ˜¯ä¸€ä¸ªä½¿ç”¨ std::move çš„ç¤ºä¾‹ï¼Œå±•ç¤ºäº†å¦‚ä½•é€šè¿‡ç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼æ“ä½œç¬¦æ¥å®ç°ä¸¤ä¸ªå¯¹è±¡ä¹‹é—´çš„èµ„æºè½¬ç§»ã€‚ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;vector&gt;class MovableClass &#123;public: std::vector&lt;int&gt; data; // ç§»åŠ¨æ„é€ å‡½æ•° MovableClass(MovableClass&amp;&amp; other) noexcept : data(std::move(other.data)) &#123; std::cout &lt;&lt; &quot;Moved!&quot; &lt;&lt; std::endl; &#125; // ç§»åŠ¨èµ‹å€¼æ“ä½œç¬¦ MovableClass&amp; operator=(MovableClass&amp;&amp; other) noexcept &#123; if (this != &amp;other) &#123; data = std::move(other.data); std::cout &lt;&lt; &quot;Moved assignment!&quot; &lt;&lt; std::endl; &#125; return *this; &#125;&#125;;int main() &#123; MovableClass obj1; obj1.data = &#123;1, 2, 3&#125;; // ä½¿ç”¨ç§»åŠ¨æ„é€ å‡½æ•° MovableClass obj2 = std::move(obj1); // ä½¿ç”¨ç§»åŠ¨èµ‹å€¼æ“ä½œç¬¦ MovableClass obj3; obj3 = std::move(obj2); return 0;&#125; åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼æ“ä½œç¬¦å®ç°äº† MovableClass å¯¹è±¡ä¹‹é—´çš„èµ„æºè½¬ç§»ã€‚æ³¨æ„ï¼Œåœ¨ç§»åŠ¨æ“ä½œä¹‹åï¼ŒåŸå¯¹è±¡ï¼ˆä¾‹å¦‚ obj1 å’Œ obj2ï¼‰è¿›å…¥äº†ä¸ç¡®å®šçš„çŠ¶æ€ï¼Œä½†å®ƒä»¬ä»ç„¶å¤„äºä¸€ä¸ªæœ‰æ•ˆçš„çŠ¶æ€ï¼Œå¯ä»¥è¢«ææ„æˆ–é‡æ–°èµ‹å€¼ã€‚"},{"title":"assign","path":"/wiki/C++/vector/assign.html","content":"åœ¨C++ä¸­ï¼Œstd::vector ç±»çš„ assign æ–¹æ³•ç”¨äºåœ¨å‘é‡ä¸­è®¾ç½®æ–°å†…å®¹ï¼Œæ›¿æ¢å…¶å½“å‰å†…å®¹ã€‚ä»¥ä¸‹æ˜¯è¯¦ç»†çš„è§£é‡Šï¼š åŸºæœ¬ç”¨æ³• assign æ–¹æ³•æœ‰å‡ ç§é‡è½½å½¢å¼ï¼Œå…è®¸ä½ ç”¨ä¸åŒçš„æ–¹å¼è®¾ç½® vector çš„å†…å®¹ï¼š assign(size_type n, const T&amp; val)ï¼šå°†å‘é‡çš„å†…å®¹æ›¿æ¢ä¸º n ä¸ª val çš„å‰¯æœ¬ã€‚ assign(InputIterator first, InputIterator last)ï¼šä½¿ç”¨ä¸¤ä¸ªè¿­ä»£å™¨ first å’Œ last æŒ‡å®šçš„èŒƒå›´æ¥æ›¿æ¢å‘é‡çš„å†…å®¹ã€‚ assign(initializer_list&lt;T&gt; il)ï¼šä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨ il ä¸­çš„å…ƒç´ æ¥æ›¿æ¢å‘é‡çš„å†…å®¹ã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ assign æ–¹æ³•æ”¹å˜å‘é‡çš„å¤§å°å’Œå†…å®¹ã€‚ å¦‚æœæ–°å¤§å°å¤§äºå½“å‰å¤§å°ï¼Œä¼šåˆ›å»ºæ–°å…ƒç´ ã€‚å¦‚æœæ–°å¤§å°å°äºå½“å‰å¤§å°ï¼Œåˆ™å¤šä½™çš„å…ƒç´ ä¼šè¢«é”€æ¯ã€‚ ä½¿ç”¨è¿­ä»£å™¨èŒƒå›´é‡è½½æ—¶ï¼ŒèŒƒå›´ [first, last) åº”æœ‰æ•ˆä¸”ä¸åº”æŒ‡å‘åŒä¸€ vector ä¸­çš„å…ƒç´ ã€‚ åˆ†é…æ–°å†…å®¹å¯èƒ½å¯¼è‡´æ‰€æœ‰ç°æœ‰çš„è¿­ä»£å™¨ã€å¼•ç”¨å’ŒæŒ‡é’ˆå¤±æ•ˆã€‚ ç¤ºä¾‹ä»£ç  123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; vec; // ä½¿ç”¨åˆå§‹å€¼èµ‹å€¼ vec.assign(4, 100); for (int i : vec) &#123; std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; // è¾“å‡º: 100 100 100 100 &#125; std::cout &lt;&lt; &quot; &quot;; // ä½¿ç”¨è¿­ä»£å™¨èµ‹å€¼ std::vector&lt;int&gt; anotherVec&#123;1, 2, 3, 4, 5&#125;; vec.assign(anotherVec.begin(), anotherVec.end()); for (int i : vec) &#123; std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; // è¾“å‡º: 1 2 3 4 5 &#125; std::cout &lt;&lt; &quot; &quot;; // ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨èµ‹å€¼ vec.assign(&#123;10, 20, 30&#125;); for (int i : vec) &#123; std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; // è¾“å‡º: 10 20 30 &#125; std::cout &lt;&lt; &quot; &quot;; return 0;&#125; åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ä¸åŒçš„ assign æ–¹æ³•æ¥è®¾ç½® vector çš„å†…å®¹ã€‚æ¯ç§æ–¹æ³•éƒ½æ¸…é™¤åŸæœ‰å†…å®¹ï¼Œå¹¶æ ¹æ®æä¾›çš„æ–°å€¼è®¾ç½® vectorã€‚"},{"title":"emplace_back","path":"/wiki/C++/vector/emplace_back.html","content":"std::vector çš„ emplace_back æ–¹æ³•æ˜¯ C++11 å¼•å…¥çš„ä¸€é¡¹åŠŸèƒ½ï¼Œå®ƒç”¨äºåœ¨å‘é‡çš„æœ«å°¾ç›´æ¥æ„é€ æ–°å…ƒç´ ï¼Œè€Œä¸æ˜¯å…ˆæ„é€ ç„¶åå¤åˆ¶æˆ–ç§»åŠ¨åˆ°å‘é‡ä¸­ã€‚è¿™å¯ä»¥æé«˜æ•ˆç‡ï¼Œå°¤å…¶æ˜¯å¯¹äºé‚£äº›ä¸æ”¯æŒå¤åˆ¶æˆ–æ•ˆç‡è¾ƒä½çš„å¤åˆ¶æ“ä½œçš„å¯¹è±¡ã€‚ åŸºæœ¬ç”¨æ³• emplace_back(args...)ï¼šæ­¤æ–¹æ³•æ¥å—ä¸å…ƒç´ ç±»å‹æ„é€ å‡½æ•°ç›¸åŒçš„å‚æ•°é›†ï¼Œå¹¶åœ¨å‘é‡æœ«å°¾ç›´æ¥æ„é€ ä¸€ä¸ªæ–°å…ƒç´ ã€‚è¿™æ„å‘³ç€å®ƒå¯ä»¥é¿å…é¢å¤–çš„å¤åˆ¶æˆ–ç§»åŠ¨æ“ä½œã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ ç›´æ¥æ„é€ ï¼šä¸ push_back ä¸åŒï¼Œemplace_back ç›´æ¥åœ¨å‘é‡çš„å†…å­˜ç©ºé—´ä¸­æ„é€ å…ƒç´ ï¼Œè¿™å¯ä»¥æé«˜æ€§èƒ½ï¼Œç‰¹åˆ«æ˜¯å¯¹äºå¤§å‹å¯¹è±¡æˆ–æ‹¥æœ‰å¤æ‚ç§»åŠ¨è¯­ä¹‰çš„å¯¹è±¡ã€‚ å‚æ•°è½¬å‘ï¼šå®ƒå°†å‚æ•°å®Œç¾è½¬å‘åˆ°å…ƒç´ çš„æ„é€ å‡½æ•°ï¼Œæ„å‘³ç€å¯ä»¥æ ¹æ®ä¼ é€’çš„å‚æ•°è‡ªåŠ¨é€‰æ‹©åˆé€‚çš„æ„é€ å‡½æ•°ã€‚ å®¹é‡å˜åŒ–ï¼šå¦‚æœå½“å‰å‘é‡çš„å¤§å°ç­‰äºå®¹é‡ï¼Œemplace_back ä¼šå¼•èµ·å‘é‡çš„é‡æ–°åˆ†é…ï¼Œè¿™å¯èƒ½å¯¼è‡´æ‰€æœ‰ç°æœ‰çš„è¿­ä»£å™¨ã€å¼•ç”¨å’ŒæŒ‡é’ˆå¤±æ•ˆã€‚ å¼‚å¸¸å®‰å…¨æ€§ï¼šå¦‚æœæ„é€ å‡½æ•°æŠ›å‡ºå¼‚å¸¸ï¼Œemplace_back ä¿è¯ä¸ä¼šå¯¼è‡´å†…å­˜æ³„æ¼ã€‚ ç¤ºä¾‹ä»£ç  12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;struct MyClass &#123; MyClass(int x, std::string y) : num(x), str(y) &#123;&#125; int num; std::string str;&#125;;int main() &#123; std::vector&lt;MyClass&gt; vec; // ç›´æ¥åœ¨å‘é‡æœ«å°¾æ„é€ ä¸€ä¸ª MyClass å¯¹è±¡ vec.emplace_back(10, &quot;Hello&quot;); for (const auto&amp; item : vec) &#123; std::cout &lt;&lt; item.num &lt;&lt; &quot;, &quot; &lt;&lt; item.str &lt;&lt; std::endl; &#125; return 0;&#125; åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œemplace_back è¢«ç”¨æ¥ç›´æ¥åœ¨ vector æœ«å°¾æ„é€ ä¸€ä¸ª MyClass å¯¹è±¡ã€‚è¿™é¿å…äº†å…ˆæ„é€ ä¸€ä¸ªä¸´æ—¶å¯¹è±¡ç„¶åå°†å…¶å¤åˆ¶æˆ–ç§»åŠ¨åˆ°å‘é‡ä¸­çš„æƒ…å†µã€‚ ä¸push_backçš„åŒºåˆ« push_back å’Œ emplace_back éƒ½æ˜¯ç”¨äºå‘å®¹å™¨ï¼ˆå¦‚ std::vectorï¼‰ä¸­æ·»åŠ å…ƒç´ çš„æˆå‘˜å‡½æ•°ï¼Œä½†å®ƒä»¬åœ¨æ·»åŠ æ–°å…ƒç´ æ—¶çš„æ–¹å¼å’Œæ€§èƒ½æœ‰æ‰€ä¸åŒã€‚ push_back: è¿™ä¸ªå‡½æ•°ç”¨äºåœ¨å®¹å™¨çš„æœ«å°¾æ·»åŠ ä¸€ä¸ªæ–°å…ƒç´ ã€‚å½“ä½¿ç”¨ push_back æ—¶ï¼Œå®ƒä¼šåˆ›å»ºè¯¥å…ƒç´ çš„å‰¯æœ¬æˆ–ç§»åŠ¨ï¼Œè¿™å–å†³äºæä¾›çš„å‚æ•°ã€‚å¦‚æœå‚æ•°æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œé‚£ä¹ˆ push_back ä¼šè°ƒç”¨è¯¥å¯¹è±¡çš„æ‹·è´æ„é€ å‡½æ•°æˆ–ç§»åŠ¨æ„é€ å‡½æ•°ï¼ˆå¦‚æœé€‚ç”¨ï¼‰ã€‚è¿™å¯èƒ½ä¼šå¯¼è‡´é¢å¤–çš„æ€§èƒ½å¼€é”€ï¼Œç‰¹åˆ«æ˜¯å½“å¯¹è±¡è¾ƒå¤§æˆ–å¤æ‚æ—¶ã€‚ emplace_back: è¿™ä¸ªå‡½æ•°ä¹Ÿç”¨äºåœ¨å®¹å™¨æœ«å°¾æ·»åŠ æ–°å…ƒç´ ï¼Œä½†å®ƒçš„å·¥ä½œæ–¹å¼ç•¥æœ‰ä¸åŒã€‚emplace_back ä¼šç›´æ¥åœ¨å®¹å™¨çš„æœ«å°¾æ„é€ å…ƒç´ ï¼Œè€Œä¸æ˜¯é¦–å…ˆåˆ›å»ºä¸€ä¸ªä¸´æ—¶å¯¹è±¡ç„¶åæ‹·è´æˆ–ç§»åŠ¨åˆ°å®¹å™¨ä¸­ã€‚å®ƒé€šè¿‡æ¥å—æ„é€ å‡½æ•°çš„å‚æ•°æ¥å®ç°è¿™ä¸€ç‚¹ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå·²ç»æ„é€ å¥½çš„å¯¹è±¡ã€‚è¿™æ„å‘³ç€ä½¿ç”¨ emplace_back å¯ä»¥å‡å°‘ä¸å¿…è¦çš„æ‹·è´æˆ–ç§»åŠ¨æ“ä½œï¼Œä»è€Œæé«˜æ•ˆç‡ã€‚ ç®€è€Œè¨€ä¹‹ï¼Œemplace_back é€šå¸¸æä¾›æ›´å¥½çš„æ€§èƒ½ï¼Œå°¤å…¶æ˜¯åœ¨æ·»åŠ å¤æ‚å¯¹è±¡åˆ°å®¹å™¨ä¸­æ—¶ï¼Œå› ä¸ºå®ƒå‡å°‘äº†æ‹·è´å’Œç§»åŠ¨çš„æ¬¡æ•°ã€‚ç„¶è€Œï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä½¿ç”¨ push_back å’Œ emplace_back çš„æ•ˆæœå¯èƒ½æ˜¯ç›¸åŒçš„ï¼Œå°¤å…¶æ˜¯å¯¹äºç®€å•æˆ–å°å‹æ•°æ®ç±»å‹ã€‚"},{"title":"insert","path":"/wiki/C++/vector/insert.html","content":"åœ¨ C++ ä¸­ï¼Œvector ç±»å‹çš„ insert æ–¹æ³•æ˜¯ä¸€ä¸ªé‡è¦çš„æˆå‘˜å‡½æ•°ï¼Œç”¨äºåœ¨æŒ‡å®šä½ç½®æ’å…¥å…ƒç´ ã€‚ä¸‹é¢å°†è¯¦ç»†ä»‹ç»è¿™ä¸ªæ–¹æ³•çš„åŸºæœ¬ç”¨æ³•ã€ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ï¼Œä»¥åŠæä¾›ä¸€ä¸ªç¤ºä¾‹ä»£ç ã€‚ åŸºæœ¬ç”¨æ³• std::vector çš„ insert æ–¹æ³•å…è®¸åœ¨å‘é‡ä¸­çš„ç‰¹å®šä½ç½®æ’å…¥ä¸€ä¸ªæˆ–å¤šä¸ªå…ƒç´ ã€‚è¿™ä¸ªæ–¹æ³•æ¥æ”¶çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡ç¤ºæ’å…¥ä½ç½®ã€‚å…¶ä½™å‚æ•°å–å†³äºæ’å…¥æ“ä½œçš„ç±»å‹ã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ ä½ç½®æŒ‡å®šï¼šinsert æ–¹æ³•éœ€è¦ä¸€ä¸ªè¿­ä»£å™¨æ¥æŒ‡å®šæ’å…¥çš„ä½ç½®ã€‚å¦‚æœä½ç½®è¿­ä»£å™¨ä¸åˆæ³•ï¼ˆæ¯”å¦‚è¶…å‡ºäº†å‘é‡çš„å½“å‰èŒƒå›´ï¼‰ï¼Œç¨‹åºå¯èƒ½ä¼šå´©æºƒã€‚ æ€§èƒ½è€ƒè™‘ï¼šåœ¨ vector ä¸­é—´æ’å…¥å…ƒç´ å¯èƒ½å¯¼è‡´åé¢æ‰€æœ‰å…ƒç´ çš„ç§»åŠ¨ï¼Œè¿™å¯èƒ½æ˜¯ä¸€ä¸ªå¼€é”€è¾ƒå¤§çš„æ“ä½œï¼Œç‰¹åˆ«æ˜¯å¯¹äºå«æœ‰å¤§é‡å…ƒç´ çš„ vectorã€‚ å®¹é‡è°ƒæ•´ï¼šå¦‚æœéœ€è¦çš„è¯ï¼Œinsert æ“ä½œä¼šå¢åŠ  vector çš„å®¹é‡ï¼Œä»¥å®¹çº³æ–°å…ƒç´ ã€‚ å¤šç§é‡è½½ï¼šinsert æ–¹æ³•æœ‰å¤šç§é‡è½½å½¢å¼ï¼Œå¯ä»¥æ’å…¥å•ä¸ªå…ƒç´ ã€æ’å…¥å¦ä¸€ä¸ªå®¹å™¨ä¸­çš„å…ƒç´ èŒƒå›´ï¼Œç”šè‡³æ’å…¥å¤šä¸ªé‡å¤çš„å…ƒç´ ã€‚ ç¤ºä¾‹ä»£ç  1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; vec = &#123;10, 20, 30, 40&#125;; // æ’å…¥å•ä¸ªå…ƒç´  auto it = vec.begin() + 2; // åœ¨ç¬¬ä¸‰ä¸ªå…ƒç´ ä¹‹å‰æ’å…¥ vec.insert(it, 25); // æ’å…¥å¤šä¸ªé‡å¤å…ƒç´  vec.insert(vec.begin() + 1, 3, 15); // åœ¨ç¬¬äºŒä¸ªå…ƒç´ ä½ç½®æ’å…¥ä¸‰ä¸ª15 // è¾“å‡ºç»“æœ for (int num : vec) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; return 0;&#125; åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆåœ¨ç¬¬ä¸‰ä¸ªå…ƒç´ å‰æ’å…¥äº†ä¸€ä¸ªå€¼ä¸º 25 çš„å…ƒç´ ï¼Œç„¶ååœ¨ç¬¬äºŒä¸ªå…ƒç´ çš„ä½ç½®æ’å…¥äº†ä¸‰ä¸ªå€¼ä¸º 15 çš„å…ƒç´ ã€‚æ³¨æ„åœ¨æ’å…¥å…ƒç´ åï¼Œè¿­ä»£å™¨å¯èƒ½ä¼šå¤±æ•ˆï¼Œå› æ­¤åœ¨æ’å…¥åé‡æ–°è·å–è¿­ä»£å™¨çš„ä½ç½®æ˜¯ä¸€ä¸ªå¥½ä¹ æƒ¯ã€‚ vectorä¸­insertå¦ä¸€ä¸ªvector å¦‚æœè¦ä½¿ç”¨ std::vector çš„ insert æ–¹æ³•æ’å…¥å¦ä¸€ä¸ª vectorï¼Œå¯ä»¥é€šè¿‡æŒ‡å®šæ’å…¥èŒƒå›´çš„æ–¹å¼æ¥å®Œæˆã€‚è¿™é€šå¸¸æ¶‰åŠåˆ°æä¾›ä¸€ä¸ªæ’å…¥ç‚¹ï¼ˆé€šè¿‡è¿­ä»£å™¨æŒ‡å®šï¼‰ä»¥åŠè¢«æ’å…¥ vector çš„å¼€å§‹å’Œç»“æŸè¿­ä»£å™¨ã€‚ ä½¿ç”¨èŒƒå›´æ’å…¥çš„åŸºæœ¬è¯­æ³•å¦‚ä¸‹ï¼š 1vector.insert(position, startIterator, endIterator); position æ˜¯ä¸€ä¸ªæŒ‡å‘åŸ vector ä¸­çš„ä½ç½®çš„è¿­ä»£å™¨ï¼Œè¡¨ç¤ºæ–°å…ƒç´ æ’å…¥çš„ä½ç½®ã€‚ startIterator å’Œ endIterator åˆ†åˆ«æ˜¯è¢«æ’å…¥ vector çš„å¼€å§‹å’Œç»“æŸè¿­ä»£å™¨ï¼Œå®šä¹‰äº†è¦æ’å…¥çš„å…ƒç´ èŒƒå›´ã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ è¿­ä»£å™¨å¤±æ•ˆï¼šåœ¨ insert æ“ä½œåï¼ŒåŸ vector çš„è¿­ä»£å™¨å¯èƒ½ä¼šå¤±æ•ˆï¼Œç‰¹åˆ«æ˜¯å¦‚æœå‘ç”Ÿå†…å­˜é‡æ–°åˆ†é…æ—¶ã€‚ æ€§èƒ½å½±å“ï¼šæ’å…¥æ“ä½œä¼šå¯¼è‡´ä»æ’å…¥ç‚¹åˆ° vector æœ«å°¾çš„æ‰€æœ‰å…ƒç´ è¢«ç§»åŠ¨ï¼Œå› æ­¤åœ¨å¤§å‹ vector ä¸­æ‰§è¡Œæ’å…¥æ“ä½œå¯èƒ½ä¼šå½±å“æ€§èƒ½ã€‚ è‡ªæˆ‘æ’å…¥ï¼šè¦æ³¨æ„ä¸è¦å°è¯•å°† vector çš„éƒ¨åˆ†å†…å®¹æ’å…¥åˆ°è‡ªèº«ä¸­ï¼Œè¿™å¯èƒ½å¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚ ç¤ºä¾‹ä»£ç  1234567891011121314151617#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; vec1 = &#123;1, 2, 3, 4&#125;; std::vector&lt;int&gt; vec2 = &#123;5, 6, 7, 8&#125;; // åœ¨ vec1 çš„ç¬¬ä¸‰ä¸ªå…ƒç´ å‰æ’å…¥ vec2 çš„æ‰€æœ‰å…ƒç´  vec1.insert(vec1.begin() + 2, vec2.begin(), vec2.end()); // è¾“å‡º vec1 çš„å†…å®¹ for (int num : vec1) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; return 0;&#125; åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œvec1 åˆå§‹åŒ…å«å…ƒç´  &#123;1, 2, 3, 4&#125;ï¼Œç„¶åæˆ‘ä»¬åœ¨å…¶ç¬¬ä¸‰ä¸ªå…ƒç´ å‰æ’å…¥äº† vec2 ä¸­çš„æ‰€æœ‰å…ƒç´ ï¼Œæœ€ç»ˆ vec1 çš„å†…å®¹å˜ä¸º &#123;1, 2, 5, 6, 7, 8, 3, 4&#125;ã€‚"},{"title":"resize","path":"/wiki/C++/vector/resize.html","content":"åŸºæœ¬ç”¨æ³• åœ¨ C++ ä¸­ï¼Œstd::vector ç±»çš„ resize æ–¹æ³•ç”¨äºæ”¹å˜å‘é‡çš„å¤§å°ã€‚å½“ä½ è°ƒç”¨ resize(n) æ—¶ï¼Œå®ƒä¼šå°†å‘é‡çš„å¤§å°è°ƒæ•´ä¸º nã€‚å¦‚æœ n å¤§äºå½“å‰å‘é‡çš„å¤§å°ï¼Œåˆ™æ–°å…ƒç´ å°†è¢«æ·»åŠ åˆ°å‘é‡çš„æœ«å°¾ï¼Œè¿™äº›æ–°å…ƒç´ ä¼šè¢«åˆå§‹åŒ–ä¸ºé»˜è®¤å€¼ã€‚å¦‚æœ n å°äºå½“å‰å‘é‡çš„å¤§å°ï¼Œå‘é‡å°†è¢«ç¼©å‡ï¼Œå¤šä½™çš„å…ƒç´ ä¼šè¢«ä¸¢å¼ƒã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ æ”¹å˜å¤§å°çš„å½±å“ï¼šå½“ resize å¢åŠ å‘é‡å¤§å°æ—¶ï¼Œæ–°æ·»åŠ çš„å…ƒç´ ä¼šè¢«é»˜è®¤åˆå§‹åŒ–ã€‚å¯¹äºåŸºæœ¬æ•°æ®ç±»å‹ï¼ˆå¦‚ intã€double ç­‰ï¼‰ï¼Œè¿™æ„å‘³ç€æ–°å…ƒç´ çš„åˆå§‹å€¼ä¸ç¡®å®šã€‚å¯¹äºç±»å¯¹è±¡ï¼Œå°†è°ƒç”¨é»˜è®¤æ„é€ å‡½æ•°ã€‚ æ•ˆç‡è€ƒè™‘ï¼šé¢‘ç¹è°ƒç”¨ resize å¯èƒ½å½±å“æ€§èƒ½ï¼Œå› ä¸ºæ¯æ¬¡å¤§å°æ”¹å˜å¯èƒ½æ¶‰åŠå†…å­˜åˆ†é…å’Œå…ƒç´ å¤åˆ¶æˆ–é”€æ¯ã€‚ å®‰å…¨æ€§ï¼šä¸ reserve æ–¹æ³•ä¸åŒï¼Œresize ä¼šæ”¹å˜å‘é‡çš„å®é™…å…ƒç´ æ•°é‡ï¼Œè€Œ reserve åªæ”¹å˜å®¹é‡ã€‚ é‡è½½ç‰ˆæœ¬ï¼šresize è¿˜æœ‰ä¸€ä¸ªé‡è½½ç‰ˆæœ¬ resize(n, value)ï¼Œå¯ä»¥æŒ‡å®šæ–°æ·»åŠ å…ƒç´ çš„åˆå§‹å€¼ã€‚ ç¤ºä¾‹ä»£ç  1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; v = &#123;1, 2, 3&#125;; // å¢åŠ å¤§å°åˆ° 5ï¼Œé»˜è®¤åˆå§‹åŒ–æ–°å…ƒç´  v.resize(5); for (int i : v) std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; // è¾“å‡º: 1 2 3 0 0 std::cout &lt;&lt; &quot; &quot;; // å‡å°å¤§å°åˆ° 2ï¼Œç§»é™¤å¤šä½™å…ƒç´  v.resize(2); for (int i : v) std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; // è¾“å‡º: 1 2 std::cout &lt;&lt; &quot; &quot;; // å†æ¬¡å¢åŠ å¤§å°ï¼Œå¹¶æŒ‡å®šæ–°å…ƒç´ çš„åˆå§‹å€¼ä¸º 99 v.resize(4, 99); for (int i : v) std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; // è¾“å‡º: 1 2 99 99 std::cout &lt;&lt; &quot; &quot;; return 0;&#125; åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œä½ å¯ä»¥çœ‹åˆ°å¦‚ä½•ä½¿ç”¨ resize æ¥å¢åŠ å’Œå‡å°‘å‘é‡çš„å¤§å°ï¼Œä»¥åŠå¦‚ä½•æŒ‡å®šæ–°å…ƒç´ çš„åˆå§‹åŒ–å€¼ã€‚"},{"title":"vector åŸºç¡€","path":"/wiki/C++/vector/vector åŸºç¡€.html","content":"åœ¨ C++ ä¸­ï¼Œvector æ˜¯ä¸€ä¸ªåŸºäºæ¨¡æ¿çš„åºåˆ—å®¹å™¨ï¼Œå®ƒå°è£…äº†å¯ä»¥åŠ¨æ€æ”¹å˜å¤§å°çš„æ•°ç»„ã€‚ä»¥ä¸‹æ˜¯å…³äº vector çš„è¯¦ç»†è§£é‡Šï¼š åŸºæœ¬ç”¨æ³• å®šä¹‰å’Œåˆå§‹åŒ–: vector&lt;T&gt; å®šä¹‰ä¸€ä¸ªç±»å‹ä¸º T çš„å‘é‡ã€‚ä¾‹å¦‚ï¼Œvector&lt;int&gt; v; åˆ›å»ºä¸€ä¸ªç©ºçš„æ•´æ•°å‘é‡ã€‚ä½ ä¹Ÿå¯ä»¥ç”¨åˆå§‹åŒ–åˆ—è¡¨ vector&lt;int&gt; v = &#123;1, 2, 3&#125;; åˆ›å»ºå¹¶åˆå§‹åŒ–å‘é‡ã€‚ æ·»åŠ å…ƒç´ : ä½¿ç”¨ push_back(value) åœ¨å‘é‡çš„æœ«å°¾æ·»åŠ å…ƒç´ ã€‚ è®¿é—®å…ƒç´ : é€šè¿‡ operator[] æˆ– at(index) è®¿é—®å…ƒç´ ã€‚at æ–¹æ³•åœ¨è¶Šç•Œæ—¶æŠ›å‡ºå¼‚å¸¸ï¼Œè€Œ operator[] ä¸è¿›è¡Œè¾¹ç•Œæ£€æŸ¥ã€‚ å¤§å°å’Œå®¹é‡: ä½¿ç”¨ size() æ¥è·å–å‘é‡ä¸­çš„å…ƒç´ ä¸ªæ•°ï¼Œcapacity() è·å–å‘é‡çš„å½“å‰å®¹é‡ã€‚ è¿­ä»£å™¨: æä¾›è¿­ä»£å™¨ï¼ˆå¦‚ begin(), end()ï¼‰æ¥éå†å‘é‡ä¸­çš„å…ƒç´ ã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ åŠ¨æ€å¤§å°: ä¸æ™®é€šæ•°ç»„ä¸åŒï¼Œvector å¯ä»¥æ ¹æ®éœ€è¦åŠ¨æ€å¢é•¿å’Œæ”¶ç¼©ã€‚ å†…å­˜ç®¡ç†: å½“æ–°å…ƒç´ æ·»åŠ åˆ° vector ä½¿å¾—å½“å‰å®¹é‡ä¸è¶³æ—¶ï¼Œvector ä¼šè‡ªåŠ¨é‡æ–°åˆ†é…å†…å­˜ä»¥å®¹çº³æ›´å¤šå…ƒç´ ã€‚ æ€§èƒ½: vector æä¾›å¯¹å°¾éƒ¨å…ƒç´ çš„å¿«é€Ÿè®¿é—®å’Œæ·»åŠ ï¼Œä½†åœ¨ä¸­é—´æˆ–å¼€å§‹æ’å…¥å…ƒç´ å¯èƒ½è¾ƒæ…¢ï¼Œå› ä¸ºå¯èƒ½æ¶‰åŠå…ƒç´ çš„ç§»åŠ¨ã€‚ è¿ç»­å­˜å‚¨: vector çš„å…ƒç´ å­˜å‚¨åœ¨è¿ç»­çš„å†…å­˜ä½ç½®ä¸Šï¼Œè¿™æ„å‘³ç€ä½ å¯ä»¥åƒä½¿ç”¨æ•°ç»„ä¸€æ ·ï¼Œé€šè¿‡æŒ‡é’ˆç®—æœ¯æ“ä½œ vector çš„å…ƒç´ ã€‚ ç¤ºä¾‹ä»£ç  1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; vec; vec.push_back(10); vec.push_back(20); vec.push_back(30); // ä½¿ç”¨ç´¢å¼•è®¿é—®å…ƒç´  std::cout &lt;&lt; &quot;ç¬¬ä¸€ä¸ªå…ƒç´ : &quot; &lt;&lt; vec[0] &lt;&lt; std::endl; // ä½¿ç”¨è¿­ä»£å™¨éå†å‘é‡ for(auto it = vec.begin(); it != vec.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &#x27; &#x27;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; è¿™ä¸ªç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•åˆ›å»º vectorï¼Œå‘å…¶ä¸­æ·»åŠ å…ƒç´ ï¼Œè®¿é—®å…ƒç´ ä»¥åŠä½¿ç”¨è¿­ä»£å™¨éå† vectorã€‚"},{"title":"tuple åŸºç¡€","path":"/wiki/C++/tuple/tuple åŸºç¡€.html","content":"åœ¨C++ä¸­ï¼Œtupleæ˜¯ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„å·¥å…·ï¼Œå®ƒå…è®¸ä½ å°†ä¸åŒç±»å‹çš„å…ƒç´ ç»„åˆæˆå•ä¸€çš„å¤åˆç±»å‹ã€‚è¿™é‡Œï¼Œæˆ‘å°†æ ¹æ®ä½ çš„è¦æ±‚ï¼Œä¾æ¬¡ä»‹ç»tupleçš„åŸºæœ¬ç”¨æ³•ã€ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ï¼Œä»¥åŠæä¾›ä¸€äº›ç¤ºä¾‹ä»£ç ã€‚ åŸºæœ¬ç”¨æ³• tupleæ˜¯æ ‡å‡†æ¨¡æ¿åº“ï¼ˆSTLï¼‰çš„ä¸€éƒ¨åˆ†ï¼Œä½äº&lt;tuple&gt;å¤´æ–‡ä»¶ä¸­ã€‚å®ƒå¯ä»¥å­˜å‚¨ä»»æ„æ•°é‡å’Œç±»å‹çš„å…ƒç´ ï¼Œæ¯ä¸ªå…ƒç´ éƒ½æœ‰å…¶å¯¹åº”çš„ç±»å‹å’Œä½ç½®ã€‚tupleçš„å…ƒç´ å¯ä»¥é€šè¿‡std::getå‡½æ•°è®¿é—®ï¼Œå…¶ç´¢å¼•æ˜¯ä»0å¼€å§‹çš„ã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ ç±»å‹å®‰å…¨ï¼šä¸æ•°ç»„æˆ–ç»“æ„ä½“ç›¸æ¯”ï¼Œtupleæä¾›äº†æ›´å¼ºçš„ç±»å‹å®‰å…¨æ€§ï¼Œå› ä¸ºå®ƒå¯ä»¥å­˜å‚¨ä¸åŒç±»å‹çš„å…ƒç´ ã€‚ ä¸å®šé•¿ï¼štupleå¯ä»¥åŒ…å«ä»»æ„æ•°é‡çš„å…ƒç´ ï¼Œä½¿å¾—å®ƒéå¸¸çµæ´»ã€‚ å…ƒç´ è®¿é—®ï¼šé€šè¿‡std::get&lt;ç´¢å¼•&gt;(tupleå¯¹è±¡)æ¥è®¿é—®å…ƒç´ ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç´¢å¼•æ˜¯åœ¨ç¼–è¯‘æ—¶ç¡®å®šçš„ï¼Œå› æ­¤ä¸èƒ½åŠ¨æ€åœ°åœ¨è¿è¡Œæ—¶å†³å®šè¦è®¿é—®çš„å…ƒç´ ç´¢å¼•ã€‚ ä¸ç»“æ„ä½“çš„æ¯”è¾ƒï¼šå¯¹äºç®€å•çš„æ•°æ®èšåˆï¼Œç»“æ„ä½“å¯èƒ½æ˜¯æ›´å¥½çš„é€‰æ‹©ï¼Œå› ä¸ºå®ƒä»¬æä¾›äº†æ›´æ¸…æ™°çš„è¯­ä¹‰ã€‚ç„¶è€Œï¼Œå¯¹äºéœ€è¦å­˜å‚¨ä¸åŒç±»å‹æ•°æ®æˆ–æ•°æ®ç»“æ„åœ¨è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šçš„æƒ…å†µï¼Œtupleåˆ™æ›´åŠ é€‚ç”¨ã€‚ æ€§èƒ½è€ƒè™‘ï¼šå°½ç®¡tupleæä¾›äº†å¾ˆå¤§çš„çµæ´»æ€§ï¼Œä½†ä½¿ç”¨ä¸å½“å¯èƒ½ä¼šå¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚ç‰¹åˆ«æ˜¯é¢‘ç¹è®¿é—®tupleå…ƒç´ æ—¶ï¼Œåº”è€ƒè™‘æ˜¯å¦æœ‰æ›´åˆé€‚çš„æ•°æ®ç»“æ„ã€‚ ç¤ºä¾‹ä»£ç  åˆ›å»ºä¸€ä¸ªtupleå¹¶è®¿é—®å…¶å…ƒç´ ï¼š 123456789101112131415#include &lt;tuple&gt;#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; // åˆ›å»ºä¸€ä¸ªåŒ…å«æ•´æ•°ã€å­—ç¬¦ä¸²å’Œæµ®ç‚¹æ•°çš„tuple std::tuple&lt;int, std::string, double&gt; myTuple = std::make_tuple(10, &quot;Test&quot;, 3.14); // è®¿é—®å¹¶æ‰“å°tupleçš„å…ƒç´  std::cout &lt;&lt; &quot;æ•´æ•°: &quot; &lt;&lt; std::get&lt;0&gt;(myTuple) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;å­—ç¬¦ä¸²: &quot; &lt;&lt; std::get&lt;1&gt;(myTuple) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;æµ®ç‚¹æ•°: &quot; &lt;&lt; std::get&lt;2&gt;(myTuple) &lt;&lt; std::endl; return 0;&#125; è¿™æ®µä»£ç é¦–å…ˆåŒ…å«äº†å¿…è¦çš„å¤´æ–‡ä»¶ï¼Œç„¶ååˆ›å»ºäº†ä¸€ä¸ªtupleå¯¹è±¡myTupleï¼Œå®ƒåŒ…å«äº†ä¸€ä¸ªintç±»å‹ã€ä¸€ä¸ªstd::stringç±»å‹å’Œä¸€ä¸ªdoubleç±»å‹çš„å…ƒç´ ã€‚éšåé€šè¿‡std::getå‡½æ•°è®¿é—®å¹¶æ‰“å°äº†æ¯ä¸ªå…ƒç´ çš„å€¼ã€‚ tupleæ˜¯C++ä¸­ä¸€ä¸ªéå¸¸å¼ºå¤§ä¸”çµæ´»çš„å·¥å…·ï¼Œèƒ½å¤Ÿå¸®åŠ©ä½ å¤„ç†å¤æ‚çš„æ•°æ®ç»“æ„ã€‚ç„¶è€Œï¼Œåˆç†é€‰æ‹©æ•°æ®ç»“æ„å¯¹äºæé«˜ç¨‹åºæ€§èƒ½å’Œå¯è¯»æ€§éƒ½æ˜¯éå¸¸é‡è¦çš„ã€‚"},{"title":"unordered_set åŸºç¡€","path":"/wiki/C++/unordered_set/unordered_set åŸºç¡€.html","content":"unordered_set æ˜¯ C++ ä¸­çš„æ ‡å‡†åº“å®¹å™¨ï¼Œå®ƒæ˜¯ä¸€ä¸ªå­˜å‚¨å”¯ä¸€å…ƒç´ çš„é›†åˆï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ çš„ä½ç½®ä¸ç”±å…ƒç´ çš„å€¼å†³å®šã€‚unordered_set åŸºäºå“ˆå¸Œè¡¨å®ç°ï¼Œå› æ­¤å®ƒèƒ½å¤Ÿæä¾›å¹³å‡å¸¸æ•°æ—¶é—´å¤æ‚åº¦çš„æ’å…¥ã€åˆ é™¤å’ŒæŸ¥æ‰¾æ“ä½œã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘å°†ä»åŸºæœ¬ç”¨æ³•ã€ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ã€ä»¥åŠç¤ºä¾‹ä»£ç ä¸‰ä¸ªæ–¹é¢æ¥è®²è§£ unordered_setã€‚ åŸºæœ¬ç”¨æ³• å¤´æ–‡ä»¶ï¼šä½¿ç”¨ unordered_set å‰ï¼Œéœ€è¦åŒ…å«å¤´æ–‡ä»¶ &lt;unordered_set&gt;ã€‚ å£°æ˜ï¼šå¯ä»¥é€šè¿‡ std::unordered_set&lt;T&gt; å£°æ˜ä¸€ä¸ªé›†åˆï¼Œå…¶ä¸­ T æ˜¯å­˜å‚¨å…ƒç´ çš„ç±»å‹ã€‚ æ“ä½œï¼š .insert(value)ï¼šå‘é›†åˆä¸­æ’å…¥å…ƒç´  valueã€‚ .erase(value)ï¼šä»é›†åˆä¸­ç§»é™¤å…ƒç´  valueã€‚ .find(value)ï¼šæŸ¥æ‰¾å…ƒç´  valueï¼Œå¦‚æœæ‰¾åˆ°åˆ™è¿”å›ä¸€ä¸ªæŒ‡å‘è¯¥å…ƒç´ çš„è¿­ä»£å™¨ï¼Œå¦åˆ™è¿”å› end()ã€‚ .size()ï¼šè¿”å›é›†åˆä¸­å…ƒç´ çš„æ•°é‡ã€‚ .clear()ï¼šæ¸…ç©ºé›†åˆä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚ ç‰¹ç‚¹å’Œæ³¨æ„äº‹é¡¹ å”¯ä¸€æ€§ï¼šunordered_set ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½å¿…é¡»æ˜¯å”¯ä¸€çš„ï¼Œå³ä¸å…è®¸é‡å¤çš„å…ƒç´ ã€‚ æ— åºæ€§ï¼šå…ƒç´ åœ¨ unordered_set ä¸­çš„å­˜å‚¨æ˜¯æ— åºçš„ï¼Œä¸ä¿è¯ä»»ä½•ç‰¹å®šçš„å…ƒç´ é¡ºåºã€‚ æ€§èƒ½è€ƒè™‘ï¼šè™½ç„¶ unordered_set æä¾›äº†å¹³å‡å¸¸æ•°æ—¶é—´å¤æ‚åº¦çš„æ“ä½œæ€§èƒ½ï¼Œä½†æ˜¯å“ˆå¸Œå†²çªå’Œé‡å“ˆå¸Œæ“ä½œå¯èƒ½ä¼šå¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚ è‡ªå®šä¹‰ç±»å‹ï¼šå¦‚æœè¦åœ¨ unordered_set ä¸­å­˜å‚¨è‡ªå®šä¹‰ç±»å‹çš„å¯¹è±¡ï¼Œéœ€è¦å®šä¹‰ç›¸åº”çš„å“ˆå¸Œå‡½æ•°å’Œç›¸ç­‰åˆ¤æ–­å‡½æ•°ã€‚ ç¤ºä¾‹ä»£ç  ä¸‹é¢çš„ç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ unordered_set æ¥å­˜å‚¨å’Œæ“ä½œä¸€ç»„æ•´æ•°ï¼š 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;unordered_set&gt;int main() &#123; std::unordered_set&lt;int&gt; mySet; // æ’å…¥å…ƒç´  mySet.insert(1); mySet.insert(2); mySet.insert(3); mySet.insert(4); mySet.insert(1); // é‡å¤æ’å…¥ï¼Œä¸ä¼šå¢åŠ æ–°å…ƒç´  std::cout &lt;&lt; &quot;The set contains: &quot;; for (int num : mySet) &#123; std::cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; // æŸ¥æ‰¾å…ƒç´  if (mySet.find(2) != mySet.end()) &#123; std::cout &lt;&lt; &quot;Element found&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Element not found&quot; &lt;&lt; std::endl; &#125; // åˆ é™¤å…ƒç´  mySet.erase(2); std::cout &lt;&lt; &quot;Element 2 removed&quot; &lt;&lt; std::endl; // æ˜¾ç¤ºé›†åˆå¤§å° std::cout &lt;&lt; &quot;The set size is: &quot; &lt;&lt; mySet.size() &lt;&lt; std::endl; return 0;&#125; è¿™æ®µä»£ç é¦–å…ˆåˆ›å»ºäº†ä¸€ä¸ª unordered_set çš„å®ä¾‹ mySet å¹¶æ’å…¥äº†å‡ ä¸ªæ•´æ•°ã€‚æ³¨æ„åˆ°å°è¯•æ’å…¥é‡å¤çš„å…ƒç´ ï¼ˆå¦‚æ•°å­— 1ï¼‰ä¸ä¼šå¢åŠ æ–°å…ƒç´ ã€‚æ¥ç€ï¼Œä»£ç æ¼”ç¤ºäº†å¦‚ä½•æŸ¥æ‰¾ã€åˆ é™¤å…ƒç´ å’Œè·å–é›†åˆçš„å¤§å°ã€‚"},{"title":"0-1èƒŒåŒ…","path":"/wiki/OI-Knowledge/åŠ¨æ€è§„åˆ’/èƒŒåŒ…é—®é¢˜.html","content":"0-1èƒŒåŒ… é¢˜ç›®æè¿° æœ‰nnnä¸ªç‰©å“ï¼Œç¬¬iiiä¸ªç‰©ä½“çš„ä½“ç§¯ä¸ºw[i]w[i]w[i]ï¼Œä»·å€¼ä¸ºv[i]v[i]v[i]ï¼Œæ¯ä¸ªç‰©å“è‡³å¤šé€‰ä¸€ä¸ªï¼Œæ±‚ä½“ç§¯å’Œä¸è¶…è¿‡capacitycapacitycapacityæ—¶çš„æœ€å¤§ä»·å€¼å’Œã€‚ è§£å†³æ€è·¯ åç»­ä»£ç è§£å†³è¯¥ä¾‹é¢˜ï¼šP1048 [NOIP2005 æ™®åŠç»„] é‡‡è¯ - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn) è§£æ³•1ï¼šè®°å¿†åŒ–æœç´¢ é¦–å…ˆè€ƒè™‘æœ€ç›´è§‚çš„æƒ³æ³•ï¼Œå°±æ˜¯ä½¿ç”¨è®°å¿†åŒ–æœç´¢ï¼Œdfs(i,c)dfs(i,c)dfs(i,c)è¡¨ç¤ºçš„æ˜¯å½“å‰©ä½™å®¹é‡ä¸ºcæ—¶ï¼Œä»å‰iä¸ªç‰©å“ä¸­å¾—åˆ°çš„æœ€å¤§ä»·å€¼ã€‚ éœ€è¦è§£å†³çš„å­é—®é¢˜å°±æ˜¯å½“å‰©ä½™cçš„å®¹é‡æ—¶ï¼Œç¬¬iä¸ªç‰©å“é€‰è¿˜æ˜¯ä¸é€‰ã€‚å½“å‰çŠ¶æ€å¯ä»¥ç”±å¦‚ä¸‹æ–¹ç¨‹è½¬ç§»ï¼ˆå«ä¹‰æ˜¯é€‰è¿˜æ˜¯ä¸é€‰ç¬¬iä¸ªç‰©å“ï¼‰ï¼š dfs(i,c)=maxâ¡(dfs(iâˆ’1,c),dfs(iâˆ’1,câˆ’w[i])+v[i])dfs(i,c)=\\max (dfs(i-1, c),dfs(i-1, c-w[i])+v[i]) dfs(i,c)=max(dfs(iâˆ’1,c),dfs(iâˆ’1,câˆ’w[i])+v[i]) å®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617class Solution &#123;public: int solve(vector&lt;int&gt;&amp; times, vector&lt;int&gt;&amp; vals, int T)&#123; int n = times.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(T+1,-1)); function&lt;int(int,int)&gt; dfs = [&amp;](int i, int c) &#123; if (i &lt; 0) return 0; if (dp[i][c] &gt;= 0) return dp[i][c]; dp[i][c] = dfs(i - 1, c); if (times[i] &gt; c) return dp[i][c]; dp[i][c] = max(dfs(i-1,c-times[i])+vals[i], dp[i][c]); return dp[i][c]; &#125;; return dfs(n-1,T); &#125;&#125;; è§£æ³•2ï¼šé€’æ¨ çŸ¥é“äº†è®°å¿†åŒ–æœç´¢çš„è§£å†³æ–¹æ³•ï¼Œé‚£ä¹ˆé€’æ¨ä¹Ÿéå¸¸å¥½å®ç°ã€‚ 1234567891011121314class Solution &#123;public: int solve(vector&lt;int&gt;&amp; times, vector&lt;int&gt;&amp; vals, int T)&#123; int n = times.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(T+1,0)); for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;=T;++j)&#123; if (j &lt; times[i]) dp[i+1][j] = dp[i][j]; else dp[i+1][j] = max(dp[i][j],dp[i][j-times[i]]+vals[i]); &#125; &#125; return dp[n][T]; &#125;&#125;; è§£æ³•3ï¼šæ»šåŠ¨æ•°ç»„ å½“ç„¶è¿˜å¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„å¯¹ç©ºé—´å¤æ‚åº¦è¿›ä¸€æ­¥ä¼˜åŒ–ï¼š æ³¨æ„ï¼šç¬¬äºŒå±‚å¾ªç¯æ˜¯å€’ç€å¾ªç¯çš„ï¼Œç¡®ä¿æ¯ä¸ªç‰©å“æœ€å¤šè¢«é€‰1æ¬¡ 1234567891011121314class Solution &#123;public: int solve(vector&lt;int&gt;&amp; times, vector&lt;int&gt;&amp; vals, int T)&#123; int n = times.size();// vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(T+1,0)); vector&lt;int&gt; dp(T+1, 0); for(int i=0;i&lt;n;++i)&#123; for(int j=T;j&gt;=0;--j)&#123; if (j &gt;= times[i]) dp[j] = max(dp[j],dp[j-times[i]]+vals[i]); &#125; &#125; return dp[T]; &#125;&#125;; å®Œå…¨èƒŒåŒ… é¢˜ç›®æè¿° æœ‰nnnä¸ªç‰©å“ï¼Œç¬¬iiiä¸ªç‰©ä½“çš„ä½“ç§¯ä¸ºw[i]w[i]w[i]ï¼Œä»·å€¼ä¸ºv[i]v[i]v[i]ï¼Œæ¯ä¸ªç‰©å“å¯ä»¥æ— é™æ¬¡é‡å¤é€‰æ‹©ï¼Œæ±‚ä½“ç§¯å’Œä¸è¶…è¿‡capacitycapacitycapacityæ—¶çš„æœ€å¤§ä»·å€¼å’Œã€‚ è§£å†³æ€è·¯ åç»­ä»£ç è§£å†³è¯¥ä¾‹é¢˜ï¼šP1616 ç–¯ç‹‚çš„é‡‡è¯ - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn) è§£æ³•1ï¼šè®°å¿†åŒ–æœç´¢ ç›¸æ¯”ä¹‹å‰çš„å…¬å¼ï¼Œæœ‰ä¸€ç‚¹å°å˜åŒ–,å°±æ˜¯åœ¨é€‰æ‹©å½“å‰ç‰©å“çš„dpæ•°ç»„ä¸Ši-1å˜ä¸ºi dfs(i,c)=maxâ¡(dfs(iâˆ’1,c),dfs(i,câˆ’w[i])+v[i])dfs(i,c)=\\max (dfs(i-1, c),dfs(i, c-w[i])+v[i]) dfs(i,c)=max(dfs(iâˆ’1,c),dfs(i,câˆ’w[i])+v[i]) è¯¥å˜åŒ–è¡¨æ˜ï¼Œåœ¨é€‰æ‹©äº†ç¬¬iä»¶ç‰©å“åï¼Œä½ è¿˜å¯ä»¥ç»§ç»­é€‰æ‹©ç¬¬iä»¶ç‰©å“ã€‚ ä»£ç ä¹Ÿä»…æœ‰ä¸€ç‚¹å°å˜åŒ–ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415class Solution &#123; public: int solve(vector&lt;int&gt;&amp; times, vector&lt;int&gt;&amp; vals, int T)&#123; int n = times.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(T+1,-1)); function&lt;int(int,int)&gt; dfs = [&amp;](int i, int c) &#123; if (i &lt; 0) return 0; if (dp[i][c] &gt;= 0) return dp[i][c]; dp[i][c] = dfs(i - 1, c); if (times[i] &gt; c) return dp[i][c]; dp[i][c] = max(dfs(i,c-times[i])+vals[i], dp[i][c]); return dp[i][c]; &#125;; return dfs(n-1,T); &#125;&#125;; è§£æ³•2ï¼šé€’æ¨ åŒç†ï¼Œä¸€ç‚¹å°å˜åŒ–ï¼š 1234567891011121314class Solution &#123;public: int solve(vector&lt;int&gt;&amp; times, vector&lt;int&gt;&amp; vals, int T)&#123; int n = times.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(T+1,0)); for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;=T;++j)&#123; if (j &lt; times[i]) dp[i+1][j] = dp[i][j]; else dp[i+1][j] = max(dp[i][j],dp[i+1][j-times[i]]+vals[i]); &#125; &#125; return dp[n][T]; &#125;&#125;; è§£æ³•3ï¼šæ»šåŠ¨æ•°ç»„ åŒç†ä¹Ÿå¯ä»¥ä½¿ç”¨æ»šåŠ¨æ•°ç»„å¯¹ç©ºé—´å¤æ‚åº¦è¿›ä¸€æ­¥ä¼˜åŒ–ï¼š æ³¨æ„ï¼šæ­¤æ—¶ç¬¬äºŒå±‚å¾ªç¯æ˜¯æ­£ç€å¾ªç¯çš„ï¼Œç¡®ä¿æ¯ä¸ªç‰©å“èƒ½å¤Ÿè¢«å¤šæ¬¡é€‰æ‹© 1234567891011121314class Solution &#123;public: long long solve(vector&lt;long long&gt;&amp; times, vector&lt;long long&gt;&amp; vals, long long T)&#123; long long n = times.size();// vector&lt;vector&lt;long long&gt;&gt; dp(n+1, vector&lt;long long&gt;(T+1,0)); vector&lt;long long&gt; dp(T+1, 0); for(long long i=0;i&lt;n;++i)&#123; for(long long j=0;j&lt;=T;++j)&#123; if (j &gt;= times[i]) dp[j] = max(dp[j],dp[j-times[i]]+vals[i]); &#125; &#125; return dp[T]; &#125;&#125;; èƒŒåŒ…å˜ä½“ ä¸Šé¢æˆ‘ä»¬å±•ç°äº†ä¸¤ç§å¸¸è§èƒŒåŒ…çš„æ¨¡æ¿é—®é¢˜ä»¥åŠä»–ä»¬çš„è§£å†³æ–¹æ³•ï¼Œä¸‹é¢æˆ‘ä»¬è®¨è®ºä¸€ä¸‹èƒŒåŒ…é—®é¢˜å¸¸è§çš„ä¸‰ç§å˜å½¢ï¼Œä»–ä»¬åˆ†åˆ«æ˜¯ï¼š è‡³å¤šè£…capacitycapacitycapacityï¼Œæ±‚æ–¹æ¡ˆæ•°/æœ€å¤§ä»·å€¼å’Œ æ°å¥½è£…capacitycapacitycapacityï¼Œæ±‚æ–¹æ¡ˆæ•°/æœ€å¤§/æœ€å°ä»·å€¼å’Œ è‡³å°‘è£…capacitycapacitycapacityï¼Œæ±‚æ–¹æ¡ˆæ•°/æœ€å°ä»·å€¼å’Œ ä¸Šé¢å±•ç¤ºçš„ä¸¤ç§èƒŒåŒ…çš„æ¿é¢˜éƒ½æ˜¯åŸºäºç¬¬ä¸€ç§å˜å½¢ã€‚ å˜å½¢2 01èƒŒåŒ… é¢˜ç›®ä¼ é€é—¨ï¼š494. ç›®æ ‡å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä½¿ç”¨æ•°å­¦å…¬å¼è½¬æ¢ä¸€ä¸‹ï¼Œå¯ä»¥å‘ç°æ­¤é¢˜æ˜¯ä¸€ä¸ªæ°å¥½å¾—åˆ°nçš„æ–¹æ¡ˆæ•°01èƒŒåŒ…å˜å½¢ã€‚ï¼ˆæœ€åè¾¹ç•Œæ¡ä»¶å’Œè‡³å¤šæœ‰äº›ä¸åŒå…¶ä»–ä¸€æ ·ï¼‰ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123; if (target &lt; 0) target = -target; int sum_nums = 0; for(auto num : nums) sum_nums += num; if ((sum_nums+target)%2) return 0; int nw_target = (sum_nums+target)/2; vector&lt;int&gt; dp(nw_target+1, 0); dp[0] = 1; for(auto num : nums)&#123; for(int i=nw_target;i&gt;=0;--i)&#123; if(i&gt;=num) dp[i] += dp[i-num]; &#125; &#125; return dp[nw_target]; &#125;&#125;; å®Œå…¨èƒŒåŒ… é¢˜ç›®ä¼ é€é—¨ï¼š322. é›¶é’±å…‘æ¢ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åŒä¸Šï¼Œæ­¤é¢˜æ˜¯ä¸€ä¸ªæ°å¥½å¾—åˆ°nçš„æ–¹æ¡ˆæ•°å®Œå…¨èƒŒåŒ…å˜å½¢ï¼Œæ±‚çš„æ˜¯æœ€å°ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount+1,1e9+7); dp[0] = 0; for(auto coin : coins)&#123; for(int i=coin;i&lt;=amount;++i)&#123; dp[i] = min(dp[i],dp[i-coin]+1); &#125; &#125; return dp[amount]==1e9+7?-1:dp[amount]; &#125;&#125;; å˜å½¢3 01èƒŒåŒ… é¢˜ç›®ä¼ é€é—¨ï¼š2742. ç»™å¢™å£åˆ·æ²¹æ¼† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™é“é¢˜ç®€å•è½¬æ¢ä¸€ä¸‹å…¶å®è¿˜æ˜¯ä¸€ä¸ª01èƒŒåŒ…é—®é¢˜ï¼Œåªä¸è¿‡æœ€åéœ€è¦ä¿è¯ä»˜è´¹åˆ·å¢™çš„æ—¶é—´è¦å¤§äºç­‰äºå…è´¹åˆ·å¢™çš„å¢™æ•°ã€‚è‹¥æœ‰né¢å¢™ï¼Œåˆ™ï¼šå…è´¹åˆ·å¢™æ•° = n - ä»˜è´¹åˆ·å¢™æ•°ã€‚ å¸¦å…¥å‰é¢ä¸ç­‰å¼å¾—ï¼š ä»˜è´¹åˆ·å¢™æ•° + ä»˜è´¹åˆ·å¢™æ—¶é—´ &gt;= n ç›¸å½“äºæ¯å µè¢«æˆ‘ä»¬é€‰æ¥ä»˜è´¹åˆ·çš„å¢™ä»–çš„æ‰€éœ€æ—¶é—´+1ï¼Œæœ€åéœ€è¦ä¿è¯æ€»æ—¶é—´å¤§äºç­‰äºnçš„æƒ…å†µä¸‹å¼€é”€å°½å¯èƒ½å°ã€‚ é—®é¢˜æˆåŠŸè½¬å˜ä¸ºä¸€ä¸ªè‡³å°‘å˜å½¢çš„01èƒŒåŒ…é—®é¢˜ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415class Solution &#123;public: int paintWalls(vector&lt;int&gt; &amp;cost, vector&lt;int&gt; &amp;time) &#123; int n = cost.size(); vector&lt;int&gt; dp(n + 1, INT_MAX / 2); // é˜²æ­¢åŠ æ³•æº¢å‡º dp[0] = 0; for (int i = 0; i &lt; n; i++) &#123; int nw_cost = cost[i], nw_time = time[i]+1; for(int j=n;j&gt;=0;--j)&#123; dp[j] = min(dp[j], dp[max(0, j-nw_time)]+nw_cost); &#125; &#125; return dp[n]; &#125;&#125;; å¯èƒ½ä¸­é—´é‚£ä¸ªmaxæœ‰ä¸€ç‚¹ä¸å¥½ç†è§£ï¼Œæ­¤é¢˜ä¸ºmin/maxæ¨¡å‹ï¼Œå¦‚æœæ˜¯æ–¹æ¡ˆæ•°æ¨¡å‹ï¼Œåˆ™åŠ¨æ€è§„åˆ’æ–¹ç¨‹ä¼šå˜ä¸ºï¼ˆåˆå§‹dp[0]=1ï¼‰ï¼š dp[i]=dp[i]+dp[maxâ¡(0,iâˆ’c)]dp[i] = dp[i] + dp[\\max(0,i-c)] dp[i]=dp[i]+dp[max(0,iâˆ’c)] å¯ä»¥æƒ³æƒ³æœ€æé™çš„æƒ…å†µï¼Œå°±æ˜¯è‡³å°‘ä¸º0çš„æƒ…å†µä¸‹ï¼Œåœ¨è¯¥æƒ…å†µä¸‹ï¼Œæ‰€æœ‰æ ·æœ¬éƒ½å¯ä»¥é€‰æˆ–è€…ä¸é€‰ï¼Œåªæœ‰å¾ªç¯åˆ°0å¹¶ä¸”æŒ‰ç…§ä¸Šé¢è¿™æ ·å†™æ‰èƒ½å¯¹è‡³å°‘ä¸º0çš„æƒ…å†µçš„æ–¹æ¡ˆæ•°è¿›è¡Œæ­£ç¡®çš„æ›´æ–°ã€‚"},{"title":"å¿«é€Ÿå¹‚","path":"/wiki/OI-Knowledge/æ•°å­¦/å¿«é€Ÿå¹‚.html","content":"ç®—æ³•ç®€ä»‹ åœ¨è®¡ç®—æ•°å­¦ä¸­ï¼Œå¿«é€Ÿå¹‚ï¼ˆExponentiation by Squaringï¼‰æ˜¯ä¸€ç§é«˜æ•ˆçš„è®¡ç®—å¤§æ•´æ•°å¹‚çš„æ–¹æ³•ã€‚å®ƒé€šè¿‡å°†æŒ‡æ•°åˆ†è§£ä¸ºäºŒè¿›åˆ¶å½¢å¼ï¼Œä»è€Œå‡å°‘äº†ä¹˜æ³•è¿ç®—çš„æ¬¡æ•°ï¼Œæ˜¾è‘—æé«˜äº†è®¡ç®—æ•ˆç‡ã€‚å¿«é€Ÿå¹‚å¹¿æ³›åº”ç”¨äºå¯†ç å­¦ã€è®¡ç®—æœºå›¾å½¢å­¦å’Œç§‘å­¦è®¡ç®—ç­‰é¢†åŸŸã€‚ å¿«é€Ÿå¹‚ç®—æ³•çš„åŸç† å¿«é€Ÿå¹‚ç®—æ³•çš„åŸºæœ¬æ€æƒ³æ˜¯åˆ©ç”¨æŒ‡æ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºï¼Œå°†å¹‚è¿ç®—è½¬åŒ–ä¸ºä¸€ç³»åˆ—çš„å¹³æ–¹å’Œä¹˜ç§¯è¿ç®—ã€‚å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š äºŒè¿›åˆ¶åˆ†è§£ï¼šå°†æŒ‡æ•°ä»¥äºŒè¿›åˆ¶å½¢å¼è¡¨ç¤ºã€‚ä¾‹å¦‚ï¼ŒæŒ‡æ•°13çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸º1101ã€‚ å¹³æ–¹å’Œä¹˜ç§¯ï¼šæ ¹æ®äºŒè¿›åˆ¶ä½çš„å€¼ï¼Œå°†å¹‚è¿ç®—è½¬åŒ–ä¸ºä¸€ç³»åˆ—çš„å¹³æ–¹å’Œä¹˜ç§¯è¿ç®—ã€‚å…·ä½“æ¥è¯´ï¼Œå¦‚æœå½“å‰äºŒè¿›åˆ¶ä½ä¸º1ï¼Œåˆ™å°†å½“å‰ç»“æœä¹˜ä»¥åŸºæ•°çš„ç›¸åº”å¹‚æ¬¡ã€‚ è¿­ä»£è®¡ç®—ï¼šé€šè¿‡è¿­ä»£è®¡ç®—æ¯ä¸€ä½çš„å¹³æ–¹å’Œä¹˜ç§¯ï¼Œæœ€ç»ˆå¾—åˆ°ç»“æœã€‚ å¿«é€Ÿå¹‚ç®—æ³•çš„å®ç° å¿«é€Ÿå¹‚ç®—æ³•å¯ä»¥é€šè¿‡é€’å½’å’Œè¿­ä»£ä¸¤ç§æ–¹å¼å®ç°ã€‚ä»¥ä¸‹æ˜¯C++çš„é€’å½’å’Œè¿­ä»£å®ç°ä»£ç ï¼š é€’å½’å®ç° 12345678910111213141516171819#include &lt;iostream&gt;long long recursive_pow(long long base, long long exp, long long mod) &#123; if (exp == 0) return 1; long long half = recursive_pow(base, exp / 2, mod); half = (half * half) % mod; if (exp % 2 != 0) &#123; half = (half * base) % mod; &#125; return half;&#125;int main() &#123; long long base = 2; long long exp = 13; long long mod = 1000000007; std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; recursive_pow(base, exp, mod) &lt;&lt; std::endl; return 0;&#125; è¿­ä»£å®ç° 123456789101112131415161718192021#include &lt;iostream&gt;long long iterative_pow(long long base, long long exp, long long mod) &#123; long long result = 1; while (exp &gt; 0) &#123; if (exp % 2 != 0) &#123; result = (result * base) % mod; &#125; base = (base * base) % mod; exp /= 2; &#125; return result;&#125;int main() &#123; long long base = 2; long long exp = 13; long long mod = 1000000007; std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; iterative_pow(base, exp, mod) &lt;&lt; std::endl; return 0;&#125; å¿«é€Ÿå¹‚ç®—æ³•çš„ä¼˜åŠ¿ æ•ˆç‡é«˜ï¼šå¿«é€Ÿå¹‚ç®—æ³•é€šè¿‡å°†æŒ‡æ•°åˆ†è§£ä¸ºäºŒè¿›åˆ¶ï¼Œå‡å°‘äº†ä¹˜æ³•è¿ç®—çš„æ¬¡æ•°ï¼Œå…¶æ—¶é—´å¤æ‚åº¦ä¸ºO(log n)ã€‚ é€‚ç”¨æ€§å¹¿ï¼šå¿«é€Ÿå¹‚ç®—æ³•é€‚ç”¨äºå¤§æ•´æ•°çš„å¹‚è¿ç®—ï¼Œå°¤å…¶åœ¨æ¨¡è¿ç®—åœºæ™¯ä¸‹è¡¨ç°ä¼˜å¼‚ï¼Œå¦‚å¯†ç å­¦ä¸­çš„RSAç®—æ³•ã€‚ æ˜“äºå®ç°ï¼šç®—æ³•ç®€å•æ˜äº†ï¼Œæ—¢å¯ä»¥é€šè¿‡é€’å½’å®ç°ï¼Œä¹Ÿå¯ä»¥é€šè¿‡è¿­ä»£å®ç°ï¼Œä¾¿äºç†è§£å’Œåº”ç”¨ã€‚ åº”ç”¨åœºæ™¯ å¿«é€Ÿå¹‚ç®—æ³•å¹¿æ³›åº”ç”¨äºè®¡ç®—ç§‘å­¦å’Œå·¥ç¨‹é¢†åŸŸï¼Œå¦‚ï¼š å¯†ç å­¦ï¼šåœ¨RSAåŠ å¯†å’Œè§£å¯†è¿‡ç¨‹ä¸­ï¼Œéœ€è¦è¿›è¡Œå¤§é‡çš„å¤§æ•´æ•°å¹‚è¿ç®—ï¼Œå¿«é€Ÿå¹‚ç®—æ³•æ˜¾è‘—æé«˜äº†è®¡ç®—æ•ˆç‡ã€‚ è®¡ç®—æœºå›¾å½¢å­¦ï¼šåœ¨å›¾å½¢å˜æ¢å’ŒæŠ•å½±è®¡ç®—ä¸­ï¼Œéœ€è¦é¢‘ç¹è¿›è¡Œå¹‚è¿ç®—ã€‚ ç§‘å­¦è®¡ç®—ï¼šåœ¨æ•°å€¼åˆ†æå’Œæ¨¡æ‹Ÿè®¡ç®—ä¸­ï¼Œå¿«é€Ÿå¹‚ç®—æ³•ç”¨äºé«˜æ•ˆè®¡ç®—å¤§æ•°å€¼çš„å¹‚æ¬¡ã€‚ æ€»ç»“ å¿«é€Ÿå¹‚ç®—æ³•æ˜¯ä¸€ç§é«˜æ•ˆè®¡ç®—å¤§æ•´æ•°å¹‚çš„æ–¹æ³•ï¼Œé€šè¿‡äºŒè¿›åˆ¶åˆ†è§£æŒ‡æ•°ï¼Œå‡å°‘äº†ä¹˜æ³•è¿ç®—çš„æ¬¡æ•°ã€‚å…¶é€’å½’å’Œè¿­ä»£ä¸¤ç§å®ç°æ–¹å¼ç®€å•æ˜“æ‡‚ï¼Œé€‚ç”¨äºå¹¿æ³›çš„åº”ç”¨åœºæ™¯ã€‚æŒæ¡å¿«é€Ÿå¹‚ç®—æ³•ä¸ä»…èƒ½æé«˜è®¡ç®—æ•ˆç‡ï¼Œè¿˜èƒ½åœ¨å®é™…åº”ç”¨ä¸­è§£å†³å¤§é‡çš„å¹‚è¿ç®—é—®é¢˜ã€‚"},{"title":"Trieæ ‘","path":"/wiki/OI-Knowledge/å­—ç¬¦ä¸²/Trieæ ‘.html","content":"åœ¨è®¡ç®—æœºç§‘å­¦ä¸­ï¼Œå­—å…¸æ ‘ï¼ˆTrieæ ‘ï¼‰ï¼Œæ˜¯ä¸€ç§ç”¨äºå¿«é€Ÿæ£€ç´¢å­—ç¬¦ä¸²çš„æ•°æ®ç»“æ„ã€‚å­—å…¸æ ‘ç‰¹åˆ«é€‚ç”¨äºè¯å…¸ã€å‰ç¼€åŒ¹é…å’Œè‡ªåŠ¨è¡¥å…¨ç­‰åœºæ™¯ï¼Œå¯ä»¥åœ¨ O(m) æ—¶é—´å†…å®Œæˆæ’å…¥å’ŒæŸ¥è¯¢æ“ä½œï¼ˆå…¶ä¸­ m ä¸ºå­—ç¬¦ä¸²çš„é•¿åº¦ï¼‰ã€‚ åŸºæœ¬æ¦‚å¿µ å­—å…¸æ ‘çš„æ ¸å¿ƒæ€æƒ³æ˜¯é€šè¿‡å¤šå‰æ ‘ç»“æ„æ¥å­˜å‚¨å­—ç¬¦ä¸²ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€ä¸ªå­—ç¬¦ã€‚å…¶ä¸»è¦åŠŸèƒ½åŒ…æ‹¬ï¼š æ’å…¥æ“ä½œï¼šå°†ä¸€ä¸ªå­—ç¬¦ä¸²æ’å…¥åˆ°å­—å…¸æ ‘ä¸­ã€‚ æŸ¥è¯¢æ“ä½œï¼šåˆ¤æ–­æŸä¸ªå­—ç¬¦ä¸²æ˜¯å¦å­˜åœ¨äºå­—å…¸æ ‘ä¸­ã€‚ å‰ç¼€åŒ¹é…ï¼šæŸ¥æ‰¾å…·æœ‰å…±åŒå‰ç¼€çš„æ‰€æœ‰å­—ç¬¦ä¸²ã€‚ å­—å…¸æ ‘çš„ç»“æ„ å­—å…¸æ ‘ç”±ä¸€ç³»åˆ—èŠ‚ç‚¹ç»„æˆï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä»¥ä¸‹ä¿¡æ¯ï¼š ä¸€ä¸ªé•¿åº¦ä¸º 26 çš„å­èŠ‚ç‚¹æ•°ç»„ï¼ˆå‡è®¾å¤„ç†å°å†™è‹±æ–‡å­—æ¯ï¼‰ã€‚ ä¸€ä¸ªå¸ƒå°”å€¼æ ‡è®°ï¼Œè¡¨ç¤ºæ˜¯å¦æ˜¯ä¸€ä¸ªå®Œæ•´å­—ç¬¦ä¸²çš„ç»“å°¾ã€‚ ä»¥ä¸‹æ˜¯å­—å…¸æ ‘èŠ‚ç‚¹çš„å®šä¹‰ï¼š 1234567891011struct TrieNode &#123; TrieNode* children[26]; bool isEndOfWord; TrieNode() &#123; for (int i = 0; i &lt; 26; i++) &#123; children[i] = nullptr; &#125; isEndOfWord = false; &#125;&#125;; å­—å…¸æ ‘çš„æ“ä½œ æ’å…¥æ“ä½œ æ’å…¥æ“ä½œç”¨äºå°†ä¸€ä¸ªå­—ç¬¦ä¸²æ’å…¥åˆ°å­—å…¸æ ‘ä¸­ï¼Œé€å­—ç¬¦æ’å…¥ï¼Œå¹¶åœ¨å­—ç¬¦ä¸²ç»“å°¾å¤„æ ‡è®°ï¼š 1234567891011void insert(TrieNode* root, const string&amp; key) &#123; TrieNode* node = root; for (char c : key) &#123; int index = c - &#x27;a&#x27;; if (node-&gt;children[index] == nullptr) &#123; node-&gt;children[index] = new TrieNode(); &#125; node = node-&gt;children[index]; &#125; node-&gt;isEndOfWord = true;&#125; æŸ¥è¯¢æ“ä½œ æŸ¥è¯¢æ“ä½œç”¨äºåˆ¤æ–­æŸä¸ªå­—ç¬¦ä¸²æ˜¯å¦å­˜åœ¨äºå­—å…¸æ ‘ä¸­ï¼š 1234567891011bool search(TrieNode* root, const string&amp; key) &#123; TrieNode* node = root; for (char c : key) &#123; int index = c - &#x27;a&#x27;; if (node-&gt;children[index] == nullptr) &#123; return false; &#125; node = node-&gt;children[index]; &#125; return node != nullptr &amp;&amp; node-&gt;isEndOfWord;&#125; å‰ç¼€åŒ¹é… å‰ç¼€åŒ¹é…ç”¨äºæŸ¥æ‰¾å…·æœ‰å…±åŒå‰ç¼€çš„æ‰€æœ‰å­—ç¬¦ä¸²ï¼š 1234567891011bool startsWith(TrieNode* root, const string&amp; prefix) &#123; TrieNode* node = root; for (char c : prefix) &#123; int index = c - &#x27;a&#x27;; if (node-&gt;children[index] == nullptr) &#123; return false; &#125; node = node-&gt;children[index]; &#125; return true;&#125; ç¤ºä¾‹ å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå•è¯åˆ—è¡¨ [&quot;apple&quot;, &quot;app&quot;, &quot;application&quot;, &quot;bat&quot;, &quot;ball&quot;, &quot;cat&quot;]ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å­—å…¸æ ‘æ¥è¿›è¡Œå¿«é€Ÿçš„æ’å…¥å’ŒæŸ¥è¯¢æ“ä½œã€‚ ä»¥ä¸‹æ˜¯ç¤ºä¾‹ä»£ç ï¼š 1234567891011121314151617int main() &#123; TrieNode* root = new TrieNode(); vector&lt;string&gt; words = &#123;&quot;apple&quot;, &quot;app&quot;, &quot;application&quot;, &quot;bat&quot;, &quot;ball&quot;, &quot;cat&quot;&#125;; for (const string&amp; word : words) &#123; insert(root, word); &#125; cout &lt;&lt; search(root, &quot;app&quot;) &lt;&lt; endl; // è¾“å‡º 1ï¼ˆtrueï¼‰ cout &lt;&lt; search(root, &quot;application&quot;) &lt;&lt; endl; // è¾“å‡º 1ï¼ˆtrueï¼‰ cout &lt;&lt; search(root, &quot;appl&quot;) &lt;&lt; endl; // è¾“å‡º 0ï¼ˆfalseï¼‰ cout &lt;&lt; startsWith(root, &quot;app&quot;) &lt;&lt; endl; // è¾“å‡º 1ï¼ˆtrueï¼‰ cout &lt;&lt; startsWith(root, &quot;bat&quot;) &lt;&lt; endl; // è¾“å‡º 1ï¼ˆtrueï¼‰ cout &lt;&lt; startsWith(root, &quot;baller&quot;) &lt;&lt; endl; // è¾“å‡º 0ï¼ˆfalseï¼‰ return 0;&#125; ä¾‹é¢˜1ï¼š3045. ç»Ÿè®¡å‰åç¼€ä¸‹æ ‡å¯¹ II é¢˜ç›®ä¼ é€é—¨ï¼š3045. ç»Ÿè®¡å‰åç¼€ä¸‹æ ‡å¯¹ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ LeetCodeç¬¬ 385 åœºå‘¨èµ›çš„æœ€åä¸€é¢˜ï¼Œæ¯”è¾ƒæ¿å­ï¼Œä¸‹é¢æˆ‘ä»¬æ¥åˆ†æä¸€ä¸‹ï¼Œç›¸æ¯”å­—å…¸æ ‘ä¼ ç»Ÿè§£å†³çš„å‰ç¼€åŒ¹é…é—®é¢˜ï¼Œè¿™é‡Œé¢˜ç›®è¿˜è¦æ±‚æˆ‘ä»¬å¯¹åç¼€è¿›è¡ŒåŒ¹é…ã€‚è¿™é‡Œè¿ç”¨ä¸€ä¸ªå°trickå°±å¯ä»¥å°†è¿™ä¸ªé—®é¢˜è½¬åŒ–ä¸ºå‰ç¼€åŒ¹é…é—®é¢˜ã€‚å°±æ˜¯æˆ‘ä»¬æŠŠå­—ç¬¦ä¸²çš„ç¬¬nä½å˜åŒ–æˆç¬¬nä½å’Œå€’æ•°ç¬¬nä½çš„ç»„åˆï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åªè¿›è¡Œå‰ç¼€åŒ¹é…äº†ï¼ˆä»”ç»†æ€è€ƒä¸€ä¸‹å°±èƒ½æ˜ç™½ä¸ºå•¥ï¼‰ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425struct TrieNode&#123; unordered_map&lt;int, TrieNode*&gt; son; int cnt = 0;&#125;;class Solution &#123;public: long long countPrefixSuffixPairs(vector&lt;string&gt; &amp;words) &#123; long long ans = 0; TrieNode *root = new TrieNode(); for (string &amp;s : words) &#123; int n =s.size(); TrieNode *cur = root; for(int i=0;i&lt;n;++i)&#123; // åˆ›å»ºæ ‘é“¾ int p = (int)(s[i]-&#x27;a&#x27;)&lt;&lt;5 | (s[n - 1 - i] - &#x27;a&#x27;); if (cur-&gt;son[p]==nullptr) &#123; cur-&gt;son[p] = new TrieNode(); &#125; cur = cur-&gt;son[p]; ans += cur-&gt;cnt; // åˆ›å»ºçš„è¿‡ç¨‹ä¸­æ›´æ–°ç­”æ¡ˆ &#125; cur-&gt;cnt++; &#125; return ans; &#125;&#125;; æ€»ç»“ å­—å…¸æ ‘æ˜¯ä¸€ç§é«˜æ•ˆä¸”æ˜“äºå®ç°çš„æ•°æ®ç»“æ„ï¼Œç‰¹åˆ«é€‚ç”¨äºå­—ç¬¦ä¸²çš„æ’å…¥å’ŒæŸ¥è¯¢æ“ä½œã€‚é€šè¿‡å¤šå‰æ ‘ç»“æ„ï¼Œå­—å…¸æ ‘èƒ½å¤Ÿåœ¨ O(m) çš„æ—¶é—´å¤æ‚åº¦å†…å®Œæˆæ“ä½œï¼Œæå¤§åœ°æé«˜äº†æ€§èƒ½ã€‚"},{"title":"è´¨æ•°ç­›æ³•","path":"/wiki/OI-Knowledge/æ•°å­¦/è´¨æ•°ç­›æ³•.html","content":"æœ¬æ–‡ä»¥P5736 ã€æ·±åŸº7.ä¾‹2ã€‘è´¨æ•°ç­› - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn)ä¸ºä¾‹ï¼Œä»‹ç»ä¸€ä¸‹ä¸¤ç§å¸¸ç”¨çš„è´¨æ•°ç­›æ³•ï¼šåŸƒæ°ç­›ä¸æ¬§æ‹‰ç­› åŸƒæ°ç­› åŸƒæ°ç­›ï¼ˆSieve of Eratosthenesï¼‰æ˜¯ä¸€ç§å¤è€è€Œé«˜æ•ˆçš„ç®—æ³•ï¼Œç”¨äºæ‰¾å‡ºä¸€å®šèŒƒå›´å†…çš„æ‰€æœ‰è´¨æ•°ã€‚è´¨æ•°æ˜¯æŒ‡é™¤äº†1å’Œå…¶æœ¬èº«å¤–ï¼Œä¸èƒ½è¢«å…¶ä»–ä»»ä½•æ•°æ•´é™¤çš„è‡ªç„¶æ•°ã€‚åŸƒæ°ç­›ç®—æ³•çš„åå­—æ¥æºäºå¤å¸Œè…Šæ•°å­¦å®¶åŸƒæ‹‰æ‰˜è‰²å°¼ï¼Œä»–åœ¨å…¬å…ƒå‰3ä¸–çºªå‘æ˜äº†è¿™ä¸ªç®—æ³•ã€‚ åŸƒæ°ç­›ç®—æ³•çš„åŸç† åŸƒæ°ç­›çš„åŸºæœ¬æ€æƒ³æ˜¯ä»2å¼€å§‹ï¼Œå°†æ¯ä¸ªè´¨æ•°çš„å€æ•°æ ‡è®°ä¸ºéè´¨æ•°ï¼Œå‰©ä¸‹çš„æœªæ ‡è®°çš„æ•°å°±æ˜¯è´¨æ•°ã€‚å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š åˆå§‹åŒ–ä¸€ä¸ªæ•°ç»„ï¼šå‡è®¾æˆ‘ä»¬è¦æ‰¾å‡ºå°äºç­‰äºnçš„æ‰€æœ‰è´¨æ•°ï¼Œå…ˆåˆ›å»ºä¸€ä¸ªå¤§å°ä¸ºn+1çš„å¸ƒå°”æ•°ç»„isPrimeï¼Œå¹¶å°†æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºtrueï¼Œè¡¨ç¤ºè¿™äº›æ•°éƒ½æ˜¯æ½œåœ¨çš„è´¨æ•°ã€‚ç„¶åå°†isPrime[0]å’ŒisPrime[1]è®¾ç½®ä¸ºfalseï¼Œå› ä¸º0å’Œ1ä¸æ˜¯è´¨æ•°ã€‚ ä»2å¼€å§‹ï¼šä»ç¬¬ä¸€ä¸ªè´¨æ•°2å¼€å§‹ï¼Œæ ‡è®°æ‰€æœ‰2çš„å€æ•°ï¼ˆä»4å¼€å§‹ï¼Œé—´éš”ä¸º2çš„æ•°ï¼‰ä¸ºéè´¨æ•°ï¼Œå³å°†isPrime[4], isPrime[6], isPrime[8]ç­‰è®¾ç½®ä¸ºfalseã€‚ æ‰¾åˆ°ä¸‹ä¸€ä¸ªæœªæ ‡è®°çš„æ•°ï¼šæ‰¾åˆ°æ•°ç»„ä¸­ä¸‹ä¸€ä¸ªå€¼ä¸ºtrueçš„æ•°ï¼Œå®ƒæ˜¯ä¸‹ä¸€ä¸ªè´¨æ•°ã€‚ç„¶åæ ‡è®°è¿™ä¸ªæ•°çš„æ‰€æœ‰å€æ•°ä¸ºéè´¨æ•°ã€‚ é‡å¤æ­¥éª¤3ï¼šç»§ç»­è¿™ä¸ªè¿‡ç¨‹ï¼Œç›´åˆ°å¤„ç†åˆ°æ•°ç»„çš„å¹³æ–¹æ ¹ä½ç½®ã€‚ åŸƒæ°ç­›ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ åŸƒæ°ç­›ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n log log n)ã€‚è¿™æ˜¯å› ä¸ºåœ¨æ ‡è®°è¿‡ç¨‹ä¸­ï¼Œæ¯ä¸ªæ•°çš„å€æ•°ä»…è¢«æ ‡è®°ä¸€æ¬¡ã€‚ç›¸è¾ƒäºç›´æ¥åˆ¤æ–­æ¯ä¸ªæ•°æ˜¯å¦ä¸ºè´¨æ•°çš„O(nâˆšn)æ—¶é—´å¤æ‚åº¦ï¼ŒåŸƒæ°ç­›åœ¨å¤„ç†å¤§è§„æ¨¡æ•°æ®æ—¶å…·æœ‰æ˜¾è‘—çš„æ•ˆç‡ä¼˜åŠ¿ã€‚ åŸƒæ°ç­›ç®—æ³•çš„å®ç° ä»¥ä¸‹æ˜¯Pythonå®ç°åŸƒæ°ç­›ç®—æ³•çš„ä»£ç ï¼š 123456789101112131415def sieve_of_eratosthenes(n): is_prime = [True] * (n + 1) is_prime[0], is_prime[1] = False, False p = 2 while (p * p &lt;= n): if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_numbers = [p for p in range(n + 1) if is_prime[p]] return prime_numbers# ç¤ºä¾‹n = 30print(f&quot;å°äºç­‰äº &#123;n&#125; çš„è´¨æ•°æœ‰: &#123;sieve_of_eratosthenes(n)&#125;&quot;) C++å®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;// åŸƒæ°ç­›ç®—æ³•å‡½æ•°std::vector&lt;int&gt; sieve_of_eratosthenes(int n) &#123; std::vector&lt;bool&gt; is_prime(n + 1, true); is_prime[0] = is_prime[1] = false; // 0å’Œ1ä¸æ˜¯è´¨æ•° for (int p = 2; p * p &lt;= n; ++p) &#123; if (is_prime[p]) &#123; // å°†pçš„æ‰€æœ‰å€æ•°æ ‡è®°ä¸ºéè´¨æ•° for (int i = p * p; i &lt;= n; i += p) &#123; is_prime[i] = false; &#125; &#125; &#125; // æ”¶é›†æ‰€æœ‰çš„è´¨æ•° std::vector&lt;int&gt; prime_numbers; for (int p = 2; p &lt;= n; ++p) &#123; if (is_prime[p]) &#123; prime_numbers.push_back(p); &#125; &#125; return prime_numbers;&#125;int main() &#123; int n = 30; std::vector&lt;int&gt; primes = sieve_of_eratosthenes(n); std::cout &lt;&lt; &quot;å°äºç­‰äº &quot; &lt;&lt; n &lt;&lt; &quot; çš„è´¨æ•°æœ‰: &quot;; for (int prime : primes) &#123; std::cout &lt;&lt; prime &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; ä¸Šè¿°ä¾‹é¢˜ACä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;// åŸƒæ°ç­›ç®—æ³•å‡½æ•°vector&lt;int&gt; sieve_of_eratosthenes(int n) &#123; vector&lt;bool&gt; is_prime(n + 1, true); is_prime[0] = is_prime[1] = false; // 0å’Œ1ä¸æ˜¯è´¨æ•° for (int p = 2; p * p &lt;= n; ++p) &#123; if (is_prime[p]) &#123; // å°†pçš„æ‰€æœ‰å€æ•°æ ‡è®°ä¸ºéè´¨æ•° for (int i = p * p; i &lt;= n; i += p) &#123; is_prime[i] = false; &#125; &#125; &#125; // æ”¶é›†æ‰€æœ‰çš„è´¨æ•° vector&lt;int&gt; prime_numbers; for (int p = 2; p &lt;= n; ++p) &#123; if (is_prime[p]) &#123; prime_numbers.push_back(p); &#125; &#125; return prime_numbers;&#125;int main() &#123; int N = 100000,n; vector&lt;int&gt; primes = sieve_of_eratosthenes(N); set&lt;int&gt; primes_set(primes.begin(), primes.end()); scanf(&quot;%d&quot;, &amp;n); for(int i=1;i&lt;=n;++i)&#123; int a; cin &gt;&gt; a; if (primes_set.find(a)!=primes_set.end()) cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; åº”ç”¨ä¸ä¼˜åŠ¿ åŸƒæ°ç­›ä¸ä»…åœ¨ç†è®ºä¸Šå…·æœ‰é‡è¦æ„ä¹‰ï¼Œåœ¨å®é™…åº”ç”¨ä¸­ä¹Ÿéå¸¸å¹¿æ³›ã€‚å®ƒä¸ä»…é€‚ç”¨äºç¼–ç¨‹ç«èµ›ä¸­å¯»æ‰¾è´¨æ•°çš„é—®é¢˜ï¼Œä¹Ÿå¯ä»¥ç”¨äºåŠ å¯†ç®—æ³•ï¼ˆå¦‚RSAç®—æ³•ï¼‰ä¸­çš„å¤§è´¨æ•°ç”Ÿæˆã€‚ç”±äºå…¶é«˜æ•ˆæ€§ï¼ŒåŸƒæ°ç­›åœ¨å¤„ç†å¤§èŒƒå›´æ•°æ®æ—¶è¡¨ç°å‡ºè‰²ã€‚ æ€»ä¹‹ï¼ŒåŸƒæ°ç­›æ˜¯ä¸€ç§ç®€å•è€Œé«˜æ•ˆçš„è´¨æ•°ç­›é€‰ç®—æ³•ï¼Œé€šè¿‡å·§å¦™åœ°æ ‡è®°éè´¨æ•°ï¼Œæ˜¾è‘—å‡å°‘äº†åˆ¤æ–­è´¨æ•°çš„è®¡ç®—é‡ï¼Œæ˜¯è®¡ç®—æ•°å­¦ä¸­çš„ä¸€ä¸ªç»å…¸ç®—æ³•ã€‚ æ¬§æ‹‰ç­› æ¬§æ‹‰ç­›ï¼ˆSieve of Eulerï¼‰æ˜¯ä¸€ç§ç”¨äºå¯»æ‰¾ä¸€å®šèŒƒå›´å†…æ‰€æœ‰è´¨æ•°çš„é«˜æ•ˆç®—æ³•ï¼Œæ˜¯åŸƒæ°ç­›çš„ä¼˜åŒ–ç‰ˆæœ¬ã€‚æ¬§æ‹‰ç­›åœ¨æ ‡è®°åˆæ•°æ—¶ï¼Œé¿å…äº†é‡å¤æ ‡è®°ï¼Œä½¿å¾—å…¶æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦éƒ½ä¼˜äºåŸƒæ°ç­›ã€‚ æ¬§æ‹‰ç­›ç®—æ³•çš„åŸç† æ¬§æ‹‰ç­›çš„åŸºæœ¬æ€æƒ³æ˜¯é€šè¿‡çº¿æ€§ç­›é€‰çš„æ–¹æ³•ï¼Œåœ¨æ ‡è®°åˆæ•°æ—¶ï¼Œæ¯ä¸ªåˆæ•°åªä¼šè¢«å…¶æœ€å°çš„è´¨å› æ•°æ ‡è®°ä¸€æ¬¡ï¼Œä»è€Œé¿å…äº†é‡å¤æ ‡è®°ã€‚å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š åˆå§‹åŒ–æ•°ç»„ï¼šåˆ›å»ºä¸€ä¸ªå¤§å°ä¸ºn+1çš„å¸ƒå°”æ•°ç»„isPrimeï¼Œæ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºtrueï¼Œè¡¨ç¤ºè¿™äº›æ•°éƒ½æ˜¯æ½œåœ¨çš„è´¨æ•°ã€‚åŒæ—¶ï¼Œåˆ›å»ºä¸€ä¸ªç©ºåˆ—è¡¨primesï¼Œç”¨äºå­˜å‚¨æ‰¾åˆ°çš„è´¨æ•°ã€‚ ä»2å¼€å§‹ç­›é€‰ï¼šä»2å¼€å§‹ï¼Œä¾æ¬¡æ£€æŸ¥æ¯ä¸ªæ•°æ˜¯å¦ä¸ºè´¨æ•°ã€‚å¦‚æœæ˜¯è´¨æ•°ï¼Œå°†å…¶åŠ å…¥primesåˆ—è¡¨ä¸­ã€‚ æ ‡è®°åˆæ•°ï¼šå¯¹æ¯ä¸€ä¸ªè´¨æ•°pï¼Œæ ‡è®°ä»på¼€å§‹çš„æ‰€æœ‰pçš„å€æ•°ä¸ºéè´¨æ•°ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¯¹äºæ¯ä¸ªåˆæ•°ï¼Œåªç”¨å…¶æœ€å°çš„è´¨å› æ•°æ¥æ ‡è®°ï¼Œè¿™æ ·å¯ä»¥é¿å…é‡å¤æ ‡è®°ã€‚ ç»§ç»­ç­›é€‰ï¼šé‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´åˆ°éå†åˆ°nã€‚ æ¬§æ‹‰ç­›ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ æ¬§æ‹‰ç­›çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œæ¯”åŸƒæ°ç­›çš„O(n log log n)æ›´ä¸ºé«˜æ•ˆã€‚è¿™æ˜¯å› ä¸ºæ¬§æ‹‰ç­›åœ¨æ ‡è®°è¿‡ç¨‹ä¸­ï¼Œæ¯ä¸ªåˆæ•°åªä¼šè¢«æ ‡è®°ä¸€æ¬¡ï¼Œä¸ä¼šåƒåŸƒæ°ç­›é‚£æ ·å­˜åœ¨é‡å¤æ ‡è®°çš„æƒ…å†µã€‚ æ¬§æ‹‰ç­›ç®—æ³•çš„å®ç° ä»¥ä¸‹æ˜¯Pythonå®ç°æ¬§æ‹‰ç­›ç®—æ³•çš„ä»£ç ï¼š 1234567891011121314151617def sieve_of_euler(n): is_prime = [True] * (n + 1) primes = [] for i in range(2, n + 1): if is_prime[i]: primes.append(i) for p in primes: if i * p &gt; n: break is_prime[i * p] = False if i % p == 0: break return primes# ç¤ºä¾‹n = 30print(f&quot;å°äºç­‰äº &#123;n&#125; çš„è´¨æ•°æœ‰: &#123;sieve_of_euler(n)&#125;&quot;) C++å®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;std::vector&lt;int&gt; sieve_of_euler(int n) &#123; std::vector&lt;bool&gt; is_prime(n + 1, true); std::vector&lt;int&gt; primes; for (int i = 2; i &lt;= n; ++i) &#123; if (is_prime[i]) &#123; primes.push_back(i); &#125; for (int p : primes) &#123; if (i * p &gt; n) break; is_prime[i * p] = false; if (i % p == 0) break; &#125; &#125; return primes;&#125;int main() &#123; int n = 30; std::vector&lt;int&gt; primes = sieve_of_euler(n); std::cout &lt;&lt; &quot;å°äºç­‰äº &quot; &lt;&lt; n &lt;&lt; &quot; çš„è´¨æ•°æœ‰: &quot;; for (int prime : primes) &#123; std::cout &lt;&lt; prime &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; ä¸Šè¿°ä¾‹é¢˜ACä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;// æ¬§æ‹‰ç­›ç®—æ³•å‡½æ•°std::vector&lt;int&gt; sieve_of_euler(int n) &#123; std::vector&lt;bool&gt; is_prime(n + 1, true); std::vector&lt;int&gt; primes; for (int i = 2; i &lt;= n; ++i) &#123; if (is_prime[i]) &#123; primes.push_back(i); &#125; for (int p : primes) &#123; if (i * p &gt; n) break; is_prime[i * p] = false; if (i % p == 0) break; &#125; &#125; return primes;&#125;int main() &#123; int N = 100000,n; vector&lt;int&gt; primes = sieve_of_euler(N); set&lt;int&gt; primes_set(primes.begin(), primes.end()); scanf(&quot;%d&quot;, &amp;n); for(int i=1;i&lt;=n;++i)&#123; int a; cin &gt;&gt; a; if (primes_set.find(a)!=primes_set.end()) cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; åº”ç”¨ä¸ä¼˜åŠ¿ æ¬§æ‹‰ç­›åœ¨å¯»æ‰¾è´¨æ•°çš„åº”ç”¨ä¸­è¡¨ç°å‡ºè‰²ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤„ç†å¤§è§„æ¨¡æ•°æ®æ—¶ï¼Œå…¶çº¿æ€§æ—¶é—´å¤æ‚åº¦æ˜¾è‘—æå‡äº†ç®—æ³•çš„æ•ˆç‡ã€‚ä¸åŸƒæ°ç­›ç›¸æ¯”ï¼Œæ¬§æ‹‰ç­›é€šè¿‡å‡å°‘é‡å¤æ ‡è®°çš„æ“ä½œï¼Œä¼˜åŒ–äº†ç©ºé—´å’Œæ—¶é—´çš„ä½¿ç”¨ï¼Œæ˜¯è´¨æ•°ç­›é€‰ç®—æ³•ä¸­çš„ä¸€ç§é‡è¦æ”¹è¿›ã€‚ æ€»çš„æ¥è¯´ï¼Œæ¬§æ‹‰ç­›æ˜¯ä¸€ç§é«˜æ•ˆä¸”ä¼˜åŒ–çš„è´¨æ•°ç­›é€‰ç®—æ³•ï¼Œé€šè¿‡é¿å…é‡å¤æ ‡è®°åˆæ•°ï¼Œæ˜¾è‘—æå‡äº†ç­›é€‰é€Ÿåº¦å’Œç©ºé—´åˆ©ç”¨ç‡ï¼Œæ˜¯è®¡ç®—æ•°å­¦ä¸­ä¸å¯æˆ–ç¼ºçš„å·¥å…·ã€‚æ— è®ºæ˜¯åœ¨ç†è®ºç ”ç©¶è¿˜æ˜¯å®é™…åº”ç”¨ä¸­ï¼Œæ¬§æ‹‰ç­›éƒ½å±•ç°å‡ºäº†å…¶ç‹¬ç‰¹çš„ä¼˜åŠ¿ã€‚ æ€»ç»“ä¸å¯¹æ¯” åŸƒæ°ç­› åŸç†ï¼šä»2å¼€å§‹ï¼Œå°†æ¯ä¸ªè´¨æ•°çš„å€æ•°æ ‡è®°ä¸ºéè´¨æ•°ï¼Œå‰©ä¸‹çš„å³ä¸ºè´¨æ•°ã€‚ æ—¶é—´å¤æ‚åº¦ï¼šO(n log log n)ã€‚ ç©ºé—´å¤æ‚åº¦ï¼šO(n)ã€‚ ä¼˜ç‚¹ï¼šå®ç°ç®€å•ï¼Œé€‚åˆåˆå­¦è€…ã€‚ æ¬§æ‹‰ç­› åŸç†ï¼šçº¿æ€§ç­›é€‰ï¼Œæ¯ä¸ªåˆæ•°åªä¼šè¢«å…¶æœ€å°è´¨å› æ•°æ ‡è®°ä¸€æ¬¡ï¼Œé¿å…é‡å¤æ ‡è®°ã€‚ æ—¶é—´å¤æ‚åº¦ï¼šO(n)ã€‚ ç©ºé—´å¤æ‚åº¦ï¼šO(n)ã€‚ ä¼˜ç‚¹ï¼šæ•ˆç‡æ›´é«˜ï¼Œé€‚åˆå¤„ç†å¤§è§„æ¨¡æ•°æ®ã€‚ å¯¹æ¯” æ•ˆç‡ï¼šæ¬§æ‹‰ç­›æ›´é«˜æ•ˆï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œé€‚åˆå¤§è§„æ¨¡æ•°æ®ï¼›åŸƒæ°ç­›ä¸ºO(n log log n)ã€‚ æ ‡è®°è¿‡ç¨‹ï¼šæ¬§æ‹‰ç­›é¿å…äº†é‡å¤æ ‡è®°ï¼Œæ ‡è®°è¿‡ç¨‹æ›´ä¼˜åŒ–ã€‚ å®ç°å¤æ‚åº¦ï¼šåŸƒæ°ç­›ç®€å•ç›´è§‚ï¼Œæ¬§æ‹‰ç­›ç¨å¤æ‚ä½†æ›´é«˜æ•ˆã€‚ æ€»ç»“ åŸƒæ°ç­›å’Œæ¬§æ‹‰ç­›å„æœ‰ä¼˜åŠ¿ï¼ŒåŸƒæ°ç­›å®ç°ç®€å•ï¼Œé€‚åˆåˆå­¦è€…å’Œå¤„ç†è¾ƒå°è§„æ¨¡çš„æ•°æ®ã€‚è€Œæ¬§æ‹‰ç­›åœ¨æ•ˆç‡ä¸Šæ›´èƒœä¸€ç­¹ï¼Œé€‚åˆå¤„ç†å¤§è§„æ¨¡çš„æ•°æ®ï¼Œåœ¨é«˜æ•ˆæ€§ä¸Šè¡¨ç°å°¤ä¸ºçªå‡ºã€‚é€‰æ‹©å“ªç§ç®—æ³•å–å†³äºå…·ä½“åº”ç”¨åœºæ™¯å’Œæ•°æ®è§„æ¨¡ã€‚åœ¨å­¦ä¹ å’Œç ”ç©¶è¿‡ç¨‹ä¸­ï¼Œå¯ä»¥ä»åŸƒæ°ç­›å…¥æ‰‹ï¼Œé€æ­¥ç†è§£å’Œå®ç°æ¬§æ‹‰ç­›ï¼Œæ·±å…¥æŒæ¡è´¨æ•°ç­›é€‰ç®—æ³•çš„ä¼˜åŒ–å’Œé«˜æ•ˆå®ç°ã€‚"},{"title":"æ ‘çŠ¶æ•°ç»„","path":"/wiki/OI-Knowledge/é«˜çº§æ•°æ®ç»“æ„/æ ‘çŠ¶æ•°ç»„.html","content":"åœ¨è®¡ç®—æœºç§‘å­¦ä¸­ï¼Œæ ‘çŠ¶æ•°ç»„ï¼ˆBinary Indexed Treeï¼ŒBITï¼‰ï¼Œä¹Ÿç§°ä¸ºFenwick Treeï¼Œæ˜¯ä¸€ç§ç”¨äºé«˜æ•ˆå¤„ç†å‰ç¼€å’ŒæŸ¥è¯¢å’Œæ›´æ–°æ“ä½œçš„æ•°æ®ç»“æ„ã€‚æ ‘çŠ¶æ•°ç»„éå¸¸é€‚åˆè§£å†³åŠ¨æ€æ•°ç»„çš„å‰ç¼€å’Œé—®é¢˜ï¼Œå¯ä»¥åœ¨O(log n)æ—¶é—´å†…å®Œæˆæ›´æ–°å’ŒæŸ¥è¯¢æ“ä½œã€‚ åŸºæœ¬æ¦‚å¿µ æ ‘çŠ¶æ•°ç»„çš„æ ¸å¿ƒæ€æƒ³æ˜¯é€šè¿‡ç»´æŠ¤ä¸€ç»„ç´¯åŠ å’Œæ¥å®ç°å¿«é€Ÿçš„å‰ç¼€å’ŒæŸ¥è¯¢å’Œæ›´æ–°ã€‚å…¶ä¸»è¦åŠŸèƒ½åŒ…æ‹¬ï¼š å‰ç¼€å’ŒæŸ¥è¯¢ï¼ˆåŒºé—´æŸ¥è¯¢ï¼‰ï¼šåœ¨ç»™å®šæ•°ç»„ä¸­å¿«é€Ÿæ±‚å‡ºå‰ç¼€å’Œã€‚ å•ç‚¹æ›´æ–°ï¼šåœ¨ç»™å®šæ•°ç»„ä¸­å¿«é€Ÿæ›´æ–°æŸä¸ªä½ç½®çš„å€¼ã€‚ æ ‘çŠ¶æ•°ç»„çš„ç»“æ„ æ ‘çŠ¶æ•°ç»„ä½¿ç”¨ä¸€ä¸ªè¾…åŠ©æ•°ç»„ BIT æ¥ç»´æŠ¤ä¿¡æ¯ã€‚å¯¹äºä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•°ç»„ï¼Œæˆ‘ä»¬æ„å»ºä¸€ä¸ªé•¿åº¦ä¸º n+1 çš„ BIT æ•°ç»„ï¼Œå…¶ä¸­ BIT[i] è¡¨ç¤ºä»æŸä¸ªèµ·å§‹ç‚¹åˆ°ä½ç½® i çš„éƒ¨åˆ†å’Œã€‚å…·ä½“æ¥è¯´ï¼ŒBIT çš„ç´¢å¼•å’ŒåŸæ•°ç»„çš„ç´¢å¼•ä¹‹é—´æœ‰ä¸€å®šçš„æ˜ å°„å…³ç³»ï¼Œè¿™ç§å…³ç³»é€šè¿‡ä½è¿ç®—æ¥ç¡®å®šã€‚ æ³¨æ„æ ‘çŠ¶æ•°ç»„çš„ä¸‹æ ‡ä»1å¼€å§‹(åŒçº¿æ®µæ ‘root=1) æ ‘çŠ¶æ•°ç»„çš„æ“ä½œ æ„å»ºæ ‘çŠ¶æ•°ç»„ åˆå§‹åŒ–æ ‘çŠ¶æ•°ç»„éœ€è¦éå†åŸæ•°ç»„ï¼Œå¹¶è°ƒç”¨æ›´æ–°æ“ä½œæ¥å¡«å…… BIT æ•°ç»„ï¼š 123456void buildBIT(vector&lt;int&gt;&amp; arr, vector&lt;int&gt;&amp; BIT) &#123; int n = arr.size(); for (int i = 0; i &lt; n; i++) &#123; updateBIT(BIT, n, i, arr[i]); &#125;&#125; æ›´æ–°æ“ä½œ æ›´æ–°æ“ä½œç”¨äºåœ¨æ•°ç»„çš„æŸä¸ªä½ç½®æ·»åŠ ä¸€ä¸ªå€¼ï¼Œå¹¶ç›¸åº”åœ°æ›´æ–° BIT æ•°ç»„ï¼š 1234567void updateBIT(vector&lt;int&gt;&amp; BIT, int n, int index, int val) &#123; index += 1; // BIT array is 1-indexed while (index &lt;= n) &#123; BIT[index] += val; index += index &amp; (-index); &#125;&#125; æŸ¥è¯¢æ“ä½œ æŸ¥è¯¢æ“ä½œç”¨äºè®¡ç®—æ•°ç»„ä¸­ä»èµ·å§‹ä½ç½®åˆ°æŸä¸ªä½ç½®çš„å‰ç¼€å’Œï¼š 123456789int queryBIT(vector&lt;int&gt;&amp; BIT, int index) &#123; int sum = 0; index += 1; // BIT array is 1-indexed while (index &gt; 0) &#123; sum += BIT[index]; index -= index &amp; (-index); &#125; return sum;&#125; ç¤ºä¾‹ å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªæ•°ç»„ arr ä¸º [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3]ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ ‘çŠ¶æ•°ç»„æ¥è¿›è¡Œå¿«é€Ÿçš„å‰ç¼€å’ŒæŸ¥è¯¢å’Œå•ç‚¹æ›´æ–°ã€‚ æ­£å¦‚ä¹‹å‰æ‰€è¯´ï¼Œæ ‘çŠ¶æ•°ç»„å¹¿æ³›åº”ç”¨äºå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢çš„é¢˜ç›®ä¸­ ä¾‹é¢˜1ï¼šã€æ¨¡æ¿ã€‘æ ‘çŠ¶æ•°ç»„1 é¢˜ç›®ä¼ é€é—¨ï¼šP3374 ã€æ¨¡æ¿ã€‘æ ‘çŠ¶æ•°ç»„ 1 - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€(luogu.com.cn) æ ‘çŠ¶æ•°ç»„å•ç‚¹ä¿®æ”¹+åŒºé—´æŸ¥è¯¢æ¨¡æ¿é¢˜ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š %% ä¸åŒäºä¸€èˆ¬ä½¿ç”¨æ ‘çŠ¶æ•°ç»„æ‰€è§£å†³çš„å•ç‚¹ä¿®æ”¹+åŒºé—´æŸ¥è¯¢é—®é¢˜ï¼Œæ­¤é¢˜éœ€è¦æˆ‘ä»¬è§£å†³çš„æ˜¯åŒºé—´ä¿®æ”¹+å•ç‚¹æŸ¥è¯¢é—®é¢˜ã€‚ç®€å•åˆ†æä¸éš¾å‘ç°é€šè¿‡æŠŠåŸæ¥çš„é˜Ÿåˆ—è½¬åŒ–ä¸ºä¸€ä¸ªå·®åˆ†åºåˆ—ï¼Œå°±å¯ä»¥å°†åŒºé—´ä¿®æ”¹å˜ä¸ºå•ç‚¹ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢å˜ä¸ºåŒºé—´æŸ¥è¯¢ã€‚ %% å®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/********************************************************************************************************************** * Problem: P3374 ã€æ¨¡æ¿ã€‘æ ‘çŠ¶æ•°ç»„ 1 * URL: https://www.luogu.com.cn/problem/P3374 * Description: Binary Indexed Tree * Created by Vegetabot on 6/8/2024.**********************************************************************************************************************/#include&lt;bits/stdc++.h&gt;#define N 500003using namespace std;int lowbit(int x) &#123;return x &amp; (-x);&#125;int n, m;vector&lt;int&gt; arr(N), bit(N);void updateBIT(int index, int val) &#123;// index += 1; // BIT array is 1-indexed while (index &lt;= n) &#123; bit[index] += val; index += lowbit(index); &#125;&#125;int queryBIT(int index) &#123; int sum = 0;// index += 1; // BIT array is 1-indexed while (index &gt; 0) &#123; sum += bit[index]; index -= lowbit(index); &#125; return sum;&#125;void buildBIT() &#123; for (int i = 1; i &lt;= n; i++) &#123; updateBIT(i, arr[i]); &#125;&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d&quot;, &amp;arr[i]); &#125; buildBIT(); for(int i=1; i&lt;=m; ++i) &#123; int op, a, b; cin &gt;&gt; op &gt;&gt; a &gt;&gt; b; if (op == 1) &#123; updateBIT(a, b); &#125; else &#123; cout &lt;&lt; queryBIT(b) - queryBIT(a-1) &lt;&lt; endl; &#125; &#125; return 0;&#125; æ€»ç»“ æ ‘çŠ¶æ•°ç»„æ˜¯ä¸€ç§é«˜æ•ˆä¸”æ˜“äºå®ç°çš„æ•°æ®ç»“æ„ï¼Œç‰¹åˆ«é€‚ç”¨äºåŠ¨æ€æ•°ç»„çš„å‰ç¼€å’Œé—®é¢˜ã€‚é€šè¿‡å·§å¦™çš„ä½è¿ç®—ï¼Œæ ‘çŠ¶æ•°ç»„èƒ½å¤Ÿåœ¨ O(log n) çš„æ—¶é—´å¤æ‚åº¦å†…å®Œæˆæ›´æ–°å’ŒæŸ¥è¯¢æ“ä½œï¼Œæå¤§åœ°æé«˜äº†æ€§èƒ½ã€‚"},{"title":"çº¿æ®µæ ‘","path":"/wiki/OI-Knowledge/é«˜çº§æ•°æ®ç»“æ„/çº¿æ®µæ ‘.html","content":"çº¿æ®µæ ‘æ˜¯ä¸€ç§ç”¨äºå­˜å‚¨åŒºé—´æˆ–æ®µçš„æ ‘å½¢æ•°æ®ç»“æ„ï¼Œä½¿å¾—åœ¨å…¶ä¸Šè¿›è¡Œå¿«é€Ÿçš„æŸ¥è¯¢å’Œä¿®æ”¹æ“ä½œæˆä¸ºå¯èƒ½ã€‚å®ƒå¸¸ç”¨äºå¤„ç†æ¶‰åŠåŒºé—´çš„æŸ¥è¯¢é—®é¢˜ï¼Œå¦‚æ±‚åŒºé—´å’Œã€åŒºé—´æœ€å°å€¼ã€åŒºé—´æœ€å¤§å€¼ç­‰ã€‚ åŸºæœ¬æ¦‚å¿µ çº¿æ®µæ ‘æ˜¯ä¸€æ£µäºŒå‰æ ‘ï¼Œä¸»è¦ç”¨äºé«˜æ•ˆåœ°è§£å†³ä¸€ç±»åŒºé—´æŸ¥è¯¢é—®é¢˜ã€‚å…¶æ¯ä¸ªèŠ‚ç‚¹è¡¨ç¤ºä¸€ä¸ªåŒºé—´ï¼Œå¶èŠ‚ç‚¹è¡¨ç¤ºæ•°ç»„ä¸­çš„å•ä¸ªå…ƒç´ ï¼Œå†…éƒ¨èŠ‚ç‚¹è¡¨ç¤ºå…¶å­èŠ‚ç‚¹åŒºé—´çš„å¹¶é›†ã€‚ çº¿æ®µæ ‘çš„ç»“æ„ å¶èŠ‚ç‚¹ï¼šå¶èŠ‚ç‚¹å¯¹åº”æ•°ç»„çš„å•ä¸ªå…ƒç´ ã€‚ å†…éƒ¨èŠ‚ç‚¹ï¼šæ¯ä¸ªå†…éƒ¨èŠ‚ç‚¹è¡¨ç¤ºå…¶å­èŠ‚ç‚¹æ‰€ä»£è¡¨çš„åŒºé—´çš„å¹¶é›†ã€‚ ä¾‹å¦‚ï¼Œç»™å®šæ•°ç»„ [1, 3, 5, 7, 9, 11]ï¼Œå…¶çº¿æ®µæ ‘çš„ç»“æ„å¦‚ä¸‹ï¼š 1234567 [0, 5] / \\ [0, 2] [3, 5] / \\ / \\ [0, 1] [2, 2] [3, 4] [5, 5] / \\ / \\[0, 0] [1, 1] [3, 3] [4, 4] æ„å»ºçº¿æ®µæ ‘ çº¿æ®µæ ‘çš„æ„å»ºæ—¶é—´å¤æ‚åº¦ä¸º O(n)ï¼Œå…¶ä¸­ n æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚æ„å»ºè¿‡ç¨‹å¦‚ä¸‹ï¼š é€’å½’åˆ†å‰²åŒºé—´ï¼šä»æ•°ç»„çš„ä¸­é—´åˆ†å‰²ï¼Œå°†æ•°ç»„åˆ†ä¸ºå·¦å³ä¸¤ä¸ªåŒºé—´ã€‚ æ„å»ºå­æ ‘ï¼šå¯¹å·¦å³åŒºé—´åˆ†åˆ«æ„å»ºçº¿æ®µæ ‘ã€‚ è®¡ç®—èŠ‚ç‚¹å€¼ï¼šå†…éƒ¨èŠ‚ç‚¹çš„å€¼ç”±å…¶å·¦å³å­èŠ‚ç‚¹çš„å€¼è®¡ç®—å¾—åˆ°ã€‚ ä¸€èˆ¬å»ºæ ‘ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910111213void buildTree(LL k, LL l, LL r)&#123; if (l == r) &#123; node[k].val = arr[l]; node[k].left = l; node[k].right = r; return; &#125; node[k].left = l; node[k].right = r; LL mid = l + (r - l) / 2; buildTree(k*2, l, mid); buildTree(k*2+1, mid+1, r); node[k].val = node[k*2].val + node[k*2+1].val;&#125; çº¿æ®µæ ‘çš„æ“ä½œ å•ç‚¹/åŒºé—´æŸ¥è¯¢ï¼šæŸ¥è¯¢æŸä¸€èŒƒå›´å†…çš„æ•°æ®ï¼Œå¦‚åŒºé—´å’Œã€åŒºé—´æœ€å°å€¼ç­‰ã€‚ å•ç‚¹/åŒºé—´æ›´æ–°ï¼šæ›´æ–°æ•°ç»„ä¸­çš„æŸä¸ª/åŒºé—´å…ƒç´ ï¼Œå¹¶æ›´æ–°ç›¸å…³åŒºé—´çš„ä¿¡æ¯ã€‚ ä¸€èˆ¬åœ¨çº¿æ®µæ ‘ä¸­ä¼šå®ç°å¦‚ä¸‹å‡½æ•°ï¼š query(left, right) æ–¹æ³•ç”¨äºæŸ¥è¯¢ [left, right] åŒºé—´çš„å’Œã€‚ update(index, value) æ–¹æ³•ç”¨äºæ›´æ–°æ•°ç»„ä¸­ index ä½ç½®çš„å€¼ï¼Œå¹¶æ›´æ–°ç›¸å…³åŒºé—´çš„ä¿¡æ¯ã€‚ pushDown(k)ç”¨äºä¸‹æ”¾èŠ‚ç‚¹kä¸Šçš„lazyTag ä¸Šè¿°ä»£ç å®ç°è§ä¸‹é¢åº”ç”¨éƒ¨åˆ†çš„ä¾‹é¢˜ã€‚ çº¿æ®µæ ‘çš„åº”ç”¨ çº¿æ®µæ ‘å¹¿æ³›åº”ç”¨äºè§£å†³ä»¥ä¸‹é—®é¢˜ï¼š åŒºé—´æ±‚å’Œ åŒºé—´æœ€å°å€¼/æœ€å¤§å€¼æŸ¥è¯¢ åŒºé—´æ›´æ–°æ“ä½œ åŠ¨æ€é¡ºåºç»Ÿè®¡ é€šè¿‡çº¿æ®µæ ‘ï¼Œå¯ä»¥åœ¨ O(log n) æ—¶é—´å¤æ‚åº¦å†…å®ŒæˆåŒºé—´æŸ¥è¯¢å’Œæ›´æ–°æ“ä½œï¼Œä½¿å…¶åœ¨å¤„ç†åŠ¨æ€æ•°ç»„é—®é¢˜æ—¶éå¸¸é«˜æ•ˆã€‚ ä¾‹é¢˜1ï¼šã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘1 é¢˜ç›®ä¼ é€é—¨ï¼šP3372 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 1 - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn) çº¿æ®µæ ‘åŒºé—´ä¿®æ”¹+åŒºé—´æŸ¥è¯¢æ¨¡æ¿é¢˜ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/********************************************************************************************************************** * Problem: P3372 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 1 * URL: https://www.luogu.com.cn/problem/P3372 * Description: Segment Treeï¼ˆåŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ï¼‰ * Created by Vegetabot on 6/7/2024.**********************************************************************************************************************/#include&lt;bits/stdc++.h&gt;#define N 100005#define LL long longusing namespace std;LL n,m,root=1;vector&lt;LL&gt; arr(N);struct TreeNode&#123; LL val, add, left, right; TreeNode() : val(0), add(0), left(-1), right(-1) &#123;&#125;&#125;;vector&lt;TreeNode&gt; node(N*3);void buildTree(LL k, LL l, LL r)&#123; if (l == r) &#123; node[k].val = arr[l]; node[k].left = l; node[k].right = r; return; &#125; node[k].left = l; node[k].right = r; LL mid = l + (r - l) / 2; buildTree(k*2, l, mid); buildTree(k*2+1, mid+1, r); node[k].val = node[k*2].val + node[k*2+1].val;&#125;void addTag(LL k, LL val)&#123; node[k].val += val * (node[k].right - node[k].left + 1); node[k].add += val;&#125;void pushDown(LL k)&#123; addTag(k*2, node[k].add); addTag(k*2+1, node[k].add); node[k].add = 0;&#125;void modify(LL k, LL l, LL r, LL val)&#123; if (l &lt;= node[k].left &amp;&amp; node[k].right &lt;= r) &#123; addTag(k, val); return; &#125; pushDown(k); LL mid = node[k].left + (node[k].right - node[k].left)/2; if (l&lt;=mid) modify(k*2, l, r, val); if (r&gt;mid) modify(k*2+1, l, r, val); node[k].val = node[k*2].val + node[k*2+1].val;&#125;LL query(LL k, LL l, LL r)&#123; if (l &lt;= node[k].left &amp;&amp; node[k].right &lt;= r) &#123; return node[k].val; &#125; pushDown(k); LL mid = node[k].left + (node[k].right - node[k].left)/2, res = 0; if (l &lt;= mid) res += query(k*2, l, r); if (r &gt; mid) res += query(k*2+1, l, r); return res;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i=1; i&lt;=n; ++i)&#123; scanf(&quot;%lld&quot;, &amp;arr[i]); &#125; buildTree(root, 1, n); for(int i=1; i&lt;=m; ++i) &#123; LL op, a, b, c; scanf(&quot;%lld&quot;, &amp;op); if (op == 1) &#123; scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c); modify(root, a, b, c); &#125; else &#123; scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b); printf(&quot;%lld &quot;, query(root, a, b)); &#125; &#125; return 0;&#125; ä¾‹é¢˜2ï¼šã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘2 é¢˜ç›®ä¼ é€é—¨ï¼šP3373 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 2 - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn) æ­¤é¢˜åŒæ ·æ˜¯çº¿æ®µæ ‘åŒºé—´ä¿®æ”¹+åŒºé—´æŸ¥è¯¢æ¨¡æ¿é¢˜ï¼Œç›¸æ¯”ä¸Šä¸€é“æ¨¡æ¿é¢˜ï¼Œéš¾åº¦ä¸»è¦åŠ åœ¨äº†å¦‚ä½•æ‰“lazyTagä¸Šï¼Œæœ¬é¢˜æ¶‰åŠä¸¤ç§lazyTagï¼ˆä¹˜æ³•ï¼ŒåŠ æ³•ï¼‰ï¼Œè§£å†³è¿™é“é¢˜åªéœ€ç‰¢è®°ä¸‹æ”¾lazyTagæ—¶ä¸¥æ ¼éµå¾ªå…ˆä¹˜ååŠ å³å¯ã€‚ å®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/********************************************************************************************************************** * Problem: P3373 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 2 * URL: https://www.luogu.com.cn/problem/P3373 * Description: Segment Tree * Created by Vegetabot on 6/8/2024.**********************************************************************************************************************/#include&lt;bits/stdc++.h&gt;#define N 100003#define LL long long using namespace std;LL n, q, m, root=1;vector&lt;LL&gt; arr(N);struct TreeNode&#123; LL val, add, multi, left, right; TreeNode(): val(0), add(0), multi(1), left(-1), right(-1) &#123;&#125;&#125;;vector&lt;TreeNode&gt; node(N*3);void buildTree(LL k, LL l, LL r)&#123; node[k].left = l; node[k].right = r; if (l == r) &#123; node[k].val = arr[l]; return; &#125; LL mid = l + (r - l) / 2; buildTree(k*2, l, mid); buildTree(k*2+1, mid+1, r); node[k].val = node[k*2].val + node[k*2+1].val;&#125;void addTag(LL k,LL val, LL op) &#123; if (op == 1)&#123; node[k].val = (node[k].val * val) % m; node[k].add = (node[k].add * val) % m; node[k].multi = (node[k].multi * val) % m; &#125; else &#123; node[k].val = (node[k].val + val*(node[k].right - node[k].left+1)) % m; node[k].add = (node[k].add + val) % m; &#125;&#125;void pushDown(LL k)&#123; addTag(k*2 ,node[k].multi, 1); addTag(k*2, node[k].add, 2); addTag(k*2+1, node[k].multi, 1); addTag(k*2+1, node[k].add, 2); node[k].multi = 1; node[k].add = 0;&#125;void modify(LL k, LL l, LL r, LL val ,LL op) &#123; if (l &lt;= node[k].left &amp;&amp; node[k].right &lt;= r) &#123; addTag(k, val, op); return; &#125; pushDown(k); LL mid = node[k].left + (node[k].right - node[k].left)/2; if (l &lt;= mid) modify(k*2, l, r, val, op); if (r &gt; mid) modify(k*2+1, l, r, val, op); node[k].val = node[k*2].val + node[k*2+1].val;&#125;LL query(LL k, LL l, LL r) &#123; if (l &lt;= node[k].left &amp;&amp; node[k].right &lt;= r) &#123; return node[k].val; &#125; pushDown(k); LL mid = node[k].left + (node[k].right - node[k].left)/2, res = 0; if (l &lt;= mid) res = (res + query(k*2, l, r)) % m; if (r &gt; mid) res = (res + query(k*2+1, l, r)) % m; return res;&#125;int main() &#123; scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;q, &amp;m); for(LL i=1; i&lt;=n; ++i) &#123; cin &gt;&gt; arr[i]; &#125; buildTree(root, 1, n); for(LL i=1;i&lt;=q;++i)&#123; LL op, a, b, c; scanf(&quot;%lld&quot;, &amp;op); if (op == 1 || op == 2) &#123; scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c); modify(root, a, b, c%m, op); &#125; else &#123; scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b); printf(&quot;%lld &quot;,query(root, a, b)); &#125; &#125; return 0;&#125; æ³¨æ„äº‹é¡¹ ä¹¦å†™çº¿æ®µæ ‘çš„æ—¶å€™éœ€è¦æ³¨æ„ä»¥ä¸‹äº‹é¡¹ï¼š buildTreeå’Œmodifyå‡½æ•°åœ¨é€’å½’å®Œæˆåçš„å›æº¯é˜¶æ®µéœ€è¦æ›´æ–°ä¸Šå±‚çš„ç»Ÿè®¡å€¼ ä¸‹æ”¾lazyTagæ‰€æ¶‰åŠçš„å‡½æ•°pushDownåœ¨queryå’Œmodifyä¸­éƒ½æ˜¯å…ˆè°ƒç”¨å†è¿›è¡Œé€’å½’ åŠ lazyTagæ ‡è®°ä»¥åŠåŒºé—´æ›´æ–°å‡½æ•°addTagéƒ½æ˜¯å¯¹å½“å‰åŒºé—´è¿›è¡Œæ“ä½œï¼ˆæ ‡è®°æ˜¯åŠ ç»™å„¿å­èŠ‚ç‚¹çœ‹çš„,æ–¹ä¾¿åç»­pushDownä¸‹å»å¯¹å„¿å­åŒºé—´è¿›è¡Œæ›´æ–°ï¼‰ æ€»ç»“ çº¿æ®µæ ‘æ˜¯ä¸€ç§å¼ºå¤§çš„æ•°æ®ç»“æ„ï¼Œç‰¹åˆ«é€‚åˆäºè§£å†³åŒºé—´æŸ¥è¯¢å’Œæ›´æ–°é—®é¢˜ã€‚ç†è§£çº¿æ®µæ ‘çš„æ„å»ºå’Œæ“ä½œåŸç†ï¼Œå¹¶æŒæ¡å…¶å®ç°æ–¹æ³•ï¼Œå¯ä»¥å¸®åŠ©æˆ‘ä»¬é«˜æ•ˆåœ°è§£å†³è®¸å¤šå¤æ‚çš„æ•°æ®å¤„ç†é—®é¢˜ã€‚"},{"title":"ğŸ”§ä½¿ç”¨å·¥å…·å¢å¼ºChatbot","path":"/wiki/LLM/LangGraph/ğŸ”§ä½¿ç”¨å·¥å…·å¢å¼ºChatbot.html","content":"å¼•è¨€ åœ¨ä¸Šä¸€ç¯‡æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ LangGraph æ„å»ºäº†ä¸€ä¸ªç®€å•çš„ Chatbotã€‚è™½ç„¶è¿™ä¸ª Chatbot èƒ½å¤Ÿå¤„ç†åŸºæœ¬çš„å¯¹è¯ï¼Œä½†åœ¨é¢å¯¹ä¸€äº›éœ€è¦å®æ—¶ä¿¡æ¯æˆ–è¶…å‡ºå…¶çŸ¥è¯†èŒƒå›´çš„é—®é¢˜æ—¶ï¼Œå®ƒçš„è¡¨ç°å¯èƒ½ä¼šæ˜¾å¾—åŠ›ä¸ä»å¿ƒã€‚ä¾‹å¦‚ï¼Œå½“ç”¨æˆ·è¯¢é—®â€œä»Šå¤©çš„å¤©æ°”å¦‚ä½•ï¼Ÿâ€æˆ–â€œæœ€æ–°çš„æ–°é—»æ˜¯ä»€ä¹ˆï¼Ÿâ€æ—¶ï¼ŒChatbot æ— æ³•â€œå‡­è®°å¿†â€å›ç­”è¿™äº›é—®é¢˜ã€‚ ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥ä¸º Chatbot é›†æˆä¸€ä¸ªç½‘ç»œæœç´¢å·¥å…·ã€‚é€šè¿‡è¿™ä¸ªå·¥å…·ï¼ŒChatbot å¯ä»¥å®æ—¶æŸ¥æ‰¾ç›¸å…³ä¿¡æ¯ï¼Œå¹¶æä¾›æ›´å‡†ç¡®ã€æ›´åŠæ—¶çš„å“åº”ã€‚åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ tavily-python å’Œ langchain_community åº“æ¥å®ç°è¿™ä¸€åŠŸèƒ½ã€‚ ä»€ä¹ˆæ˜¯ç½‘ç»œæœç´¢å·¥å…·ï¼Ÿ ç½‘ç»œæœç´¢å·¥å…·æ˜¯ä¸€ç§èƒ½å¤Ÿé€šè¿‡ API è®¿é—®äº’è”ç½‘èµ„æºå¹¶æ£€ç´¢ç›¸å…³ä¿¡æ¯çš„å·¥å…·ã€‚é€šè¿‡é›†æˆç½‘ç»œæœç´¢å·¥å…·ï¼ŒChatbot å¯ä»¥åœ¨å¯¹è¯è¿‡ç¨‹ä¸­åŠ¨æ€è·å–å¤–éƒ¨æ•°æ®ï¼Œä»è€Œå¢å¼ºå…¶å›ç­”èƒ½åŠ›ã€‚ä¾‹å¦‚ï¼Œå½“ç”¨æˆ·è¯¢é—®æŸä¸ªç‰¹å®šè¯é¢˜çš„æœ€æ–°ä¿¡æ¯æ—¶ï¼ŒChatbot å¯ä»¥é€šè¿‡ç½‘ç»œæœç´¢å·¥å…·æŸ¥æ‰¾ç›¸å…³å†…å®¹ï¼Œå¹¶å°†å…¶æ•´åˆåˆ°å¯¹è¯ä¸­ã€‚ åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ tavily-python åº“æ¥å®ç°ç½‘ç»œæœç´¢åŠŸèƒ½ã€‚tavily-python æ˜¯ä¸€ä¸ªç®€å•æ˜“ç”¨çš„ Python åº“ï¼Œèƒ½å¤Ÿå¿«é€Ÿæ£€ç´¢ç½‘ç»œä¸Šçš„ç›¸å…³ä¿¡æ¯ã€‚ å®‰è£…ä¾èµ– åœ¨å¼€å§‹ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å®‰è£…ä¸€äº›é¢å¤–çš„ä¾èµ–åº“ã€‚ä½ å¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤å®‰è£…è¿™äº›åº“ï¼š 1pip install -U tavily-python langchain_community tavily-python: ç”¨äºå®ç°ç½‘ç»œæœç´¢åŠŸèƒ½ã€‚ langchain_community: æä¾›ä¸ LangChain ç›¸å…³çš„å·¥å…·å’Œé›†æˆã€‚ å®‰è£…å®Œæˆåï¼Œæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹é›†æˆç½‘ç»œæœç´¢å·¥å…·äº†ã€‚ å®šä¹‰å·¥å…· åœ¨ LangGraph ä¸­ï¼Œå·¥å…·ï¼ˆToolï¼‰æ˜¯ä¸€ç§å¯ä»¥æ‰©å±• Chatbot åŠŸèƒ½çš„ç»„ä»¶ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡å®šä¹‰å·¥å…·æ¥å®ç°ç½‘ç»œæœç´¢åŠŸèƒ½ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªå·¥å…·ç±»ï¼Œå¹¶åœ¨å…¶ä¸­å®ç°æœç´¢é€»è¾‘ã€‚ 123456789101112from langchain_community.tools.tavily_search import TavilySearchResults# è®¾ç½®æœç´¢å¯†é’¥import osimport getpassif not os.environ.get(&quot;TAVILY_API_KEY&quot;): os.environ[&quot;TAVILY_API_KEY&quot;] = getpass.getpass(&quot;Enter API key for Tavily: &quot;)tool = TavilySearchResults(max_results=2)tools = [tool]tool.invoke(&quot;What&#x27;s a &#x27;node&#x27; in LangGraph?&quot;) åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ª TavilySearchResults å·¥å…·ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªæŸ¥è¯¢å­—ç¬¦ä¸²å¹¶è¿”å›æœç´¢ç»“æœã€‚max_results=2 è¡¨ç¤ºæ¯æ¬¡æœç´¢æœ€å¤šè¿”å› 2 ä¸ªç»“æœã€‚ é›†æˆå·¥å…·åˆ° Chatbot æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦å°†è¿™ä¸ªå·¥å…·é›†æˆåˆ° Chatbot ä¸­ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¿®æ”¹ Chatbot çš„é€»è¾‘ï¼Œä½¿å…¶åœ¨é‡åˆ°æ— æ³•å›ç­”çš„é—®é¢˜æ—¶è°ƒç”¨æœç´¢å·¥å…·ã€‚ 12345678910from langchain_openai import ChatOpenAI# è®¾ç½®LLMå¯†é’¥if not os.environ.get(&quot;OPENAI_API_KEY&quot;): os.environ[&quot;OPENAI_API_KEY&quot;] = getpass.getpass(&quot;Enter API key for OpenAI: &quot;)llm = ChatOpenAI(model=&quot;gpt-4o-mini&quot;,base_url=&quot;https://api.chatanywhere.tech/v1&quot;)# ç»‘å®šå·¥å…·åˆ°LLMllm_with_tools = llm.bind_tools(tools) åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ bind_tools æ–¹æ³•å°†å·¥å…·ç»‘å®šåˆ°è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰ã€‚è¿™æ ·ï¼ŒLLM åœ¨ç”Ÿæˆå“åº”æ—¶ï¼Œå¯ä»¥æ ¹æ®éœ€è¦è°ƒç”¨å·¥å…·æ¥è·å–å¤–éƒ¨ä¿¡æ¯ã€‚ æ„å»ºå¢å¼ºç‰ˆå¯¹è¯å›¾ ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¢å¼ºç‰ˆçš„ Chatbot å‡½æ•°æ¥æ„å»ºä¸€ä¸ªæ–°çš„å¯¹è¯å›¾ã€‚ 1234567891011from langgraph.graph import StateGraph, START, ENDfrom langgraph.graph.message import add_messagesclass State(TypedDict): messages: Annotated[list, add_messages]def chatbot(state: State): return &#123;&quot;messages&quot;: [llm_with_tools.invoke(state[&quot;messages&quot;])]&#125;graph_builder = StateGraph(State)graph_builder.add_node(&quot;chatbot&quot;, chatbot) åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å¯¹è¯å›¾ï¼Œå¹¶ä½¿ç”¨ chatbot å‡½æ•°ä½œä¸ºèŠ‚ç‚¹ã€‚å¯¹è¯å›¾çš„ç»“æ„ä¸ä¹‹å‰çš„ç‰ˆæœ¬ç±»ä¼¼ï¼Œä½† Chatbot çš„åŠŸèƒ½å¾—åˆ°äº†å¢å¼ºã€‚ æ·»åŠ å·¥å…·èŠ‚ç‚¹ ä¸ºäº†è®© Chatbot èƒ½å¤Ÿè°ƒç”¨å·¥å…·ï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ ä¸€ä¸ªå·¥å…·èŠ‚ç‚¹ã€‚è¿™ä¸ªèŠ‚ç‚¹è´Ÿè´£æ‰§è¡Œå·¥å…·è°ƒç”¨ï¼Œå¹¶å°†ç»“æœè¿”å›ç»™ Chatbotã€‚ 1234567891011121314151617181920212223242526import jsonfrom langchain_core.messages import ToolMessageclass BasicToolNode: def __init__(self, tools: list) -&gt; None: self.tools_by_name = &#123;tool.name: tool for tool in tools&#125; def __call__(self, inputs: dict): if messages := inputs.get(&quot;messages&quot;, []): message = messages[-1] else: raise ValueError(&quot;No message found in input&quot;) outputs = [] for tool_call in message.tool_calls: tool_result = self.tools_by_name[tool_call[&quot;name&quot;]].invoke(tool_call[&quot;args&quot;]) outputs.append( ToolMessage( content=json.dumps(tool_result), name=tool_call[&quot;name&quot;], tool_call_id=tool_call[&quot;id&quot;], ) ) return &#123;&quot;messages&quot;: outputs&#125;tool_node = BasicToolNode(tools=[tool])graph_builder.add_node(&quot;tools&quot;, tool_node) åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ª BasicToolNode ç±»ï¼Œå®ƒè´Ÿè´£æ‰§è¡Œå·¥å…·è°ƒç”¨å¹¶è¿”å›ç»“æœã€‚ç„¶åï¼Œæˆ‘ä»¬å°†è¿™ä¸ªå·¥å…·èŠ‚ç‚¹æ·»åŠ åˆ°å¯¹è¯å›¾ä¸­ã€‚ å®šä¹‰è·¯ç”±å™¨å‡½æ•° ä¸ºäº†è®© Chatbot åœ¨éœ€è¦æ—¶è°ƒç”¨å·¥å…·ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€ä¸ªè·¯ç”±å™¨å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°ä¼šæ ¹æ® Chatbot çš„è¾“å‡ºå†³å®šä¸‹ä¸€æ­¥æ˜¯è°ƒç”¨å·¥å…·è¿˜æ˜¯ç»“æŸå¯¹è¯ã€‚ 12345678910111213141516171819def route_tools(state: State): if isinstance(state, list): ai_message = state[-1] elif messages := state.get(&quot;messages&quot;, []): ai_message = messages[-1] else: raise ValueError(f&quot;No messages found in input state to tool_edge: &#123;state&#125;&quot;) if hasattr(ai_message, &quot;tool_calls&quot;) and len(ai_message.tool_calls) &gt; 0: return &quot;tools&quot; return ENDgraph_builder.add_conditional_edges( &quot;chatbot&quot;, route_tools, &#123;&quot;tools&quot;: &quot;tools&quot;, END: END&#125;,)graph_builder.add_edge(&quot;tools&quot;, &quot;chatbot&quot;)graph_builder.add_edge(START, &quot;chatbot&quot;)graph = graph_builder.compile() åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œroute_tools å‡½æ•°ä¼šæ£€æŸ¥ Chatbot çš„è¾“å‡ºæ˜¯å¦åŒ…å«å·¥å…·è°ƒç”¨ã€‚å¦‚æœæœ‰å·¥å…·è°ƒç”¨ï¼Œåˆ™è·¯ç”±åˆ°å·¥å…·èŠ‚ç‚¹ï¼›å¦åˆ™ï¼Œç»“æŸå¯¹è¯ã€‚ æ ¹æ®ä¸Šé¢å»ºè¾¹æƒ…å†µï¼Œå¯ä»¥å¾—åˆ°å¦‚ä¸‹çš„è·¯ç”±å›¾ï¼š è¿è¡Œå¢å¼ºç‰ˆ Chatbot æœ€åï¼Œæˆ‘ä»¬å¯ä»¥è¿è¡Œå¢å¼ºç‰ˆ Chatbot å¹¶è§‚å¯Ÿå…¶è¡Œä¸ºã€‚é€šè¿‡ graph.stream æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç”¨æˆ·è¾“å…¥ä¼ é€’ç»™ Chatbotï¼Œå¹¶é€æ­¥ç”Ÿæˆå¯¹è¯ã€‚ 12345678910111213141516171819def stream_graph_updates(user_input: str): for event in graph.stream(&#123;&quot;messages&quot;: [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: user_input&#125;]&#125;): for value in event.values(): print(&quot;Assistant:&quot;, value[&quot;messages&quot;][-1].content)while True: try: user_input = input(&quot;User: &quot;) if user_input.lower() in [&quot;quit&quot;, &quot;exit&quot;, &quot;q&quot;]: print(&quot;Goodbye!&quot;) break stream_graph_updates(user_input) except: # fallback if input() is not available user_input = &quot;What do you know about LangGraph?&quot; print(&quot;User: &quot; + user_input) stream_graph_updates(user_input) break åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªç®€å•çš„äº¤äº’å¼å¾ªç¯ï¼Œç”¨æˆ·å¯ä»¥è¾“å…¥æ¶ˆæ¯ï¼Œå¢å¼ºç‰ˆ Chatbot ä¼šç”Ÿæˆå“åº”ã€‚å¦‚æœç”¨æˆ·è¾“å…¥ &quot;quit&quot;ã€&quot;exit&quot; æˆ– &quot;q&quot;ï¼Œç¨‹åºå°†é€€å‡ºã€‚ ç»“è®º é€šè¿‡æœ¬æ•™ç¨‹ï¼Œæˆ‘ä»¬å­¦ä¹ äº†å¦‚ä½•ä¸º Chatbot é›†æˆç½‘ç»œæœç´¢å·¥å…·ï¼Œä»è€Œå¢å¼ºå…¶å›ç­”èƒ½åŠ›ã€‚æˆ‘ä»¬å®šä¹‰äº†æœç´¢å·¥å…·ã€ä¿®æ”¹äº† Chatbot çš„é€»è¾‘ï¼Œå¹¶æœ€ç»ˆè¿è¡Œäº†å¢å¼ºç‰ˆ Chatbotã€‚è¿™ä¸ªå¢å¼ºç‰ˆ Chatbot èƒ½å¤Ÿå¤„ç†æ›´å¤šç±»å‹çš„é—®é¢˜ï¼Œå¹¶æä¾›æ›´å‡†ç¡®ã€æ›´åŠæ—¶çš„å“åº”ã€‚ å¸Œæœ›è¿™ç¯‡æ•™ç¨‹å¯¹ä½ ç†è§£å¦‚ä½•å¢å¼º Chatbot çš„åŠŸèƒ½æœ‰æ‰€å¸®åŠ©ï¼å¦‚æœä½ æœ‰ä»»ä½•é—®é¢˜æˆ–å»ºè®®ï¼Œæ¬¢è¿åœ¨è¯„è®ºåŒºç•™è¨€ã€‚ ä½œè€…: Mudrobot æ—¥æœŸ: 2025.01.24 æ ‡ç­¾: LangGraph, Chatbot, ç½‘ç»œæœç´¢, NLP, è‡ªç„¶è¯­è¨€å¤„ç†"},{"title":"ğŸ¤–æ„å»ºç®€æ˜“èŠå¤©æœºå™¨äºº","path":"/wiki/LLM/LangGraph/ğŸ¤–æ„å»ºç®€æ˜“èŠå¤©æœºå™¨äºº.html","content":"å¼•è¨€ åœ¨äººå·¥æ™ºèƒ½å’Œè‡ªç„¶è¯­è¨€å¤„ç†ï¼ˆNLPï¼‰é¢†åŸŸï¼Œæ„å»ºä¸€ä¸ªèƒ½å¤Ÿä¸ç”¨æˆ·è¿›è¡Œè‡ªç„¶å¯¹è¯çš„Chatbotæ˜¯ä¸€ä¸ªéå¸¸æœ‰è¶£ä¸”å…·æœ‰æŒ‘æˆ˜æ€§çš„ä»»åŠ¡ã€‚Chatbotçš„åº”ç”¨åœºæ™¯éå¸¸å¹¿æ³›ï¼Œä»å®¢æˆ·æœåŠ¡åˆ°ä¸ªäººåŠ©æ‰‹ï¼Œå†åˆ°æ•™è‚²å·¥å…·ï¼ŒChatbotæ­£åœ¨æ”¹å˜æˆ‘ä»¬ä¸æŠ€æœ¯äº¤äº’çš„æ–¹å¼ã€‚ç„¶è€Œï¼Œæ„å»ºä¸€ä¸ªé«˜æ•ˆä¸”çµæ´»çš„Chatbotå¹¶ä¸å®¹æ˜“ï¼Œå°¤å…¶æ˜¯å½“æˆ‘ä»¬éœ€è¦å¤„ç†å¤æ‚çš„å¯¹è¯æµç¨‹æ—¶ã€‚ LangGraphæ˜¯ä¸€ä¸ªå¼ºå¤§çš„å·¥å…·ï¼Œå®ƒå¯ä»¥å¸®åŠ©æˆ‘ä»¬æ›´è½»æ¾åœ°æ„å»ºå’Œç†è§£Chatbotçš„å·¥ä½œæµç¨‹ã€‚é€šè¿‡å›¾å½¢åŒ–çš„æ–¹å¼å®šä¹‰å¯¹è¯æµç¨‹ï¼ŒLangGraphä½¿å¾—å¼€å‘è€…èƒ½å¤Ÿæ›´ç›´è§‚åœ°è®¾è®¡å’Œè°ƒè¯•å¯¹è¯ç³»ç»Ÿã€‚æœ¬æ•™ç¨‹çš„ç›®çš„æ˜¯é€šè¿‡æ„å»ºä¸€ä¸ªç®€å•çš„Chatbotæ¥ç†è§£LangGraphçš„åŸºæœ¬æ¦‚å¿µå’Œå·¥ä½œæµç¨‹ã€‚ ä»€ä¹ˆæ˜¯LangGraphï¼Ÿ LangGraphæ˜¯ä¸€ä¸ªç”¨äºæ„å»ºå’Œå¯è§†åŒ–è‡ªç„¶è¯­è¨€å¤„ç†å·¥ä½œæµç¨‹çš„Pythonåº“ã€‚å®ƒå…è®¸å¼€å‘è€…é€šè¿‡å›¾å½¢åŒ–çš„æ–¹å¼å®šä¹‰Chatbotçš„å¯¹è¯æµç¨‹ï¼Œä»è€Œæ›´ç›´è§‚åœ°ç†è§£å’Œè°ƒè¯•å¯¹è¯ç³»ç»Ÿã€‚LangGraphçš„æ ¸å¿ƒæ€æƒ³æ˜¯å°†å¯¹è¯æµç¨‹è¡¨ç¤ºä¸ºä¸€ä¸ªæœ‰å‘å›¾ï¼Œå…¶ä¸­èŠ‚ç‚¹ä»£è¡¨å¯¹è¯çŠ¶æ€æˆ–æ“ä½œï¼Œè¾¹ä»£è¡¨çŠ¶æ€ä¹‹é—´çš„è½¬æ¢ã€‚ é€šè¿‡ä½¿ç”¨LangGraphï¼Œå¼€å‘è€…å¯ä»¥æ›´å®¹æ˜“åœ°ç®¡ç†å¤æ‚çš„å¯¹è¯é€»è¾‘ï¼Œç¡®ä¿Chatbotèƒ½å¤Ÿæ ¹æ®ç”¨æˆ·çš„è¾“å…¥åšå‡ºæ­£ç¡®çš„å“åº”ã€‚æ— è®ºæ˜¯ç®€å•çš„é—®ç­”ç³»ç»Ÿï¼Œè¿˜æ˜¯å¤šè½®å¯¹è¯çš„å¤æ‚åœºæ™¯ï¼ŒLangGraphéƒ½èƒ½æä¾›å¼ºå¤§çš„æ”¯æŒã€‚ å®‰è£…LangGraph åœ¨å¼€å§‹æ„å»ºChatbotä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå®‰è£…LangGraphåº“ã€‚ä½ å¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤ä½¿ç”¨pipè¿›è¡Œå®‰è£…ï¼š 1pip install langgraph å®‰è£…å®Œæˆåï¼Œæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹ä½¿ç”¨LangGraphæ¥æ„å»ºæˆ‘ä»¬çš„Chatbotäº†ã€‚ å¥½çš„ï¼æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸¤éƒ¨åˆ†åˆå¹¶åˆ°ä¸€ä¸ªæ ‡é¢˜ä¸‹ï¼Œä¿æŒå†…å®¹çš„è¿è´¯æ€§ã€‚ä»¥ä¸‹æ˜¯è°ƒæ•´åçš„å†…å®¹ï¼š è®¾ç½® OpenAI API å¯†é’¥å¹¶åˆå§‹åŒ–è¯­è¨€æ¨¡å‹ åœ¨æ„å»º Chatbot ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦é…ç½® OpenAI çš„ API å¯†é’¥ï¼Œå¹¶åˆå§‹åŒ–ä¸€ä¸ªè¯­è¨€æ¨¡å‹å®ä¾‹ã€‚OpenAI æä¾›äº†å¼ºå¤§çš„è¯­è¨€æ¨¡å‹ï¼ˆå¦‚ GPT-4ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ API è°ƒç”¨æ¥ç”Ÿæˆå¯¹è¯å†…å®¹ã€‚ä»¥ä¸‹æ˜¯ç›¸å…³ä»£ç åŠå…¶è§£é‡Šï¼š 123456789import getpassimport osif not os.environ.get(&quot;OPENAI_API_KEY&quot;): os.environ[&quot;OPENAI_API_KEY&quot;] = getpass.getpass(&quot;Enter API key for OpenAI: &quot;)from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=&quot;gpt-4o-mini&quot;, base_url=&quot;https://api.chatanywhere.tech/v1&quot;) ä»£ç è§£é‡Šï¼š è·å– API å¯†é’¥ï¼š getpass æ¨¡å—ï¼šç”¨äºå®‰å…¨åœ°è·å–ç”¨æˆ·è¾“å…¥çš„ API å¯†é’¥ï¼Œé¿å…å¯†é’¥ç›´æ¥æ˜¾ç¤ºåœ¨ç»ˆç«¯æˆ–è„šæœ¬ä¸­ã€‚ os.environ.get(&quot;OPENAI_API_KEY&quot;)ï¼šæ£€æŸ¥ç¯å¢ƒå˜é‡ä¸­æ˜¯å¦å·²ç»è®¾ç½®äº† OPENAI_API_KEYã€‚å¦‚æœå·²ç»è®¾ç½®ï¼Œåˆ™æ— éœ€å†æ¬¡è¾“å…¥ã€‚ getpass.getpass(&quot;Enter API key for OpenAI: &quot;)ï¼šå¦‚æœç¯å¢ƒå˜é‡ä¸­æ²¡æœ‰è®¾ç½® API å¯†é’¥ï¼Œç¨‹åºä¼šæç¤ºç”¨æˆ·è¾“å…¥å¯†é’¥ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨ç¯å¢ƒå˜é‡ä¸­ã€‚ åˆå§‹åŒ–è¯­è¨€æ¨¡å‹ï¼š ChatOpenAIï¼šè¿™æ˜¯ langchain_openai åº“ä¸­çš„ä¸€ä¸ªç±»ï¼Œç”¨äºä¸ OpenAI çš„èŠå¤©æ¨¡å‹è¿›è¡Œäº¤äº’ã€‚ model=&quot;gpt-4o-mini&quot;ï¼šæŒ‡å®šä½¿ç”¨çš„è¯­è¨€æ¨¡å‹ã€‚è¿™é‡Œä½¿ç”¨çš„æ˜¯ gpt-4o-miniï¼Œä½ å¯ä»¥æ ¹æ®éœ€è¦æ›¿æ¢ä¸ºå…¶ä»–æ¨¡å‹ï¼Œä¾‹å¦‚ gpt-4 æˆ– gpt-3.5-turboã€‚ base_url=&quot;https://api.chatanywhere.tech/v1&quot;ï¼šæŒ‡å®š OpenAI API çš„åŸºç¡€ URLã€‚è¿™é‡Œä½¿ç”¨çš„æ˜¯ https://api.chatanywhere.tech/v1ï¼Œè¿™æ˜¯ä¸€ä¸ªç¬¬ä¸‰æ–¹ä»£ç†æœåŠ¡ï¼Œç”¨äºè®¿é—® OpenAI çš„ APIã€‚å¦‚æœä½ æœ‰å®˜æ–¹çš„ OpenAI API è®¿é—®æƒé™ï¼Œå¯ä»¥å°† base_url æ›¿æ¢ä¸ºå®˜æ–¹çš„ API åœ°å€ï¼ˆå¦‚ https://api.openai.com/v1ï¼‰ã€‚ æ€»ç»“ï¼š è¿™æ®µä»£ç çš„ä½œç”¨æ˜¯ï¼š å®‰å…¨åœ°è·å–å¹¶è®¾ç½® OpenAI çš„ API å¯†é’¥ã€‚ åˆå§‹åŒ–ä¸€ä¸ª OpenAI çš„è¯­è¨€æ¨¡å‹å®ä¾‹ï¼Œç”¨äºåç»­çš„å¯¹è¯ç”Ÿæˆã€‚ é€šè¿‡è¿™æ®µä»£ç ï¼Œæˆ‘ä»¬ä¸º Chatbot æä¾›äº†å¼ºå¤§çš„è¯­è¨€ç”Ÿæˆèƒ½åŠ›ï¼Œä½¿å…¶èƒ½å¤Ÿæ ¹æ®ç”¨æˆ·è¾“å…¥ç”Ÿæˆè‡ªç„¶ã€æµç•…çš„å¯¹è¯å†…å®¹ã€‚ å½“ç„¶å¯ä»¥ï¼åŸºäºä½ æä¾›çš„ demo.ipynb æ–‡ä»¶å†…å®¹ï¼Œæˆ‘ä»¬å¯ä»¥ç»§ç»­å®Œå–„åšå®¢çš„åç»­éƒ¨åˆ†ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†ä»å®šä¹‰å¯¹è¯çŠ¶æ€å¼€å§‹ï¼Œé€æ­¥å®Œæˆæ•™ç¨‹çš„å‰©ä½™éƒ¨åˆ†ã€‚ å®šä¹‰å¯¹è¯çŠ¶æ€ åœ¨LangGraphä¸­ï¼Œå¯¹è¯çŠ¶æ€æ˜¯Chatbotçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ã€‚å®ƒä»£è¡¨äº†Chatbotåœ¨å¯¹è¯è¿‡ç¨‹ä¸­æ‰€å¤„çš„ä¸åŒé˜¶æ®µã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡å®šä¹‰ä¸€ä¸ª State ç±»æ¥è¡¨ç¤ºå¯¹è¯çŠ¶æ€ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼ŒState ç±»åŒ…å«ä¸€ä¸ª messages å­—æ®µï¼Œç”¨äºå­˜å‚¨å¯¹è¯ä¸­çš„æ¶ˆæ¯åˆ—è¡¨ã€‚ 123456789from typing import Annotatedfrom typing_extensions import TypedDictfrom langgraph.graph.message import add_messagesclass State(TypedDict): # Messages have the type &quot;list&quot;. The `add_messages` function # in the annotation defines how this state key should be updated # (in this case, it appends messages to the list, rather than overwriting them) messages: Annotated[list, add_messages] åœ¨è¿™ä¸ªå®šä¹‰ä¸­ï¼Œmessages æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œç”¨äºå­˜å‚¨å¯¹è¯ä¸­çš„æ¶ˆæ¯ã€‚add_messages å‡½æ•°ç¡®ä¿æ¯æ¬¡æ›´æ–°çŠ¶æ€æ—¶ï¼Œæ–°çš„æ¶ˆæ¯ä¼šè¢«è¿½åŠ åˆ°åˆ—è¡¨ä¸­ï¼Œè€Œä¸æ˜¯è¦†ç›–åŸæœ‰çš„æ¶ˆæ¯ã€‚ æ„å»ºå¯¹è¯å›¾ æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦æ„å»ºä¸€ä¸ªå¯¹è¯å›¾ã€‚å¯¹è¯å›¾ç”±èŠ‚ç‚¹å’Œè¾¹ç»„æˆï¼ŒèŠ‚ç‚¹ä»£è¡¨å¯¹è¯çŠ¶æ€æˆ–æ“ä½œï¼Œè¾¹ä»£è¡¨çŠ¶æ€ä¹‹é—´çš„è½¬æ¢ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ StateGraph ç±»æ¥æ„å»ºè¿™ä¸ªå›¾ã€‚ 123from langgraph.graph import StateGraph, START, ENDgraph_builder = StateGraph(State) åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ª StateGraph å¯¹è±¡ï¼Œå¹¶ä¼ å…¥äº†ä¹‹å‰å®šä¹‰çš„ State ç±»ä½œä¸ºçŠ¶æ€ç±»å‹ã€‚ æ·»åŠ èŠ‚ç‚¹ åœ¨å¯¹è¯å›¾ä¸­ï¼ŒèŠ‚ç‚¹ä»£è¡¨Chatbotçš„æ“ä½œæˆ–çŠ¶æ€ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ add_node æ–¹æ³•å‘å›¾ä¸­æ·»åŠ èŠ‚ç‚¹ã€‚æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„åç§°å’Œä¸€ä¸ªå¯¹åº”çš„å‡½æ•°æˆ–å¯¹è±¡ï¼Œç”¨äºåœ¨èŠ‚ç‚¹è¢«è°ƒç”¨æ—¶æ‰§è¡Œç›¸åº”çš„æ“ä½œã€‚ 1234567def chatbot(state: State): return &#123;&quot;messages&quot;: [llm.invoke(state[&quot;messages&quot;])]&#125;# The first argument is the unique node name# The second argument is the function or object that will be called whenever# the node is used.graph_builder.add_node(&quot;chatbot&quot;, chatbot) åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ª chatbot å‡½æ•°ï¼Œå®ƒæ¥æ”¶å½“å‰çš„å¯¹è¯çŠ¶æ€å¹¶è°ƒç”¨ llm.invoke æ–¹æ³•æ¥ç”Ÿæˆæ–°çš„æ¶ˆæ¯ã€‚ç„¶åï¼Œæˆ‘ä»¬å°†è¿™ä¸ªå‡½æ•°æ·»åŠ ä¸ºå›¾ä¸­çš„èŠ‚ç‚¹ï¼Œå‘½åä¸º &quot;chatbot&quot;ã€‚ æ·»åŠ è¾¹ è¾¹ä»£è¡¨çŠ¶æ€ä¹‹é—´çš„è½¬æ¢ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ add_edge æ–¹æ³•å‘å›¾ä¸­æ·»åŠ è¾¹ã€‚è¾¹çš„èµ·ç‚¹å’Œç»ˆç‚¹åˆ†åˆ«æ˜¯ä¸¤ä¸ªèŠ‚ç‚¹çš„åç§°ã€‚ 12graph_builder.add_edge(START, &quot;chatbot&quot;)graph_builder.add_edge(&quot;chatbot&quot;, END) åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æ·»åŠ äº†ä¸¤æ¡è¾¹ï¼šä¸€æ¡ä» START èŠ‚ç‚¹åˆ° &quot;chatbot&quot; èŠ‚ç‚¹ï¼Œå¦ä¸€æ¡ä» &quot;chatbot&quot; èŠ‚ç‚¹åˆ° END èŠ‚ç‚¹ã€‚è¿™æ„å‘³ç€å¯¹è¯å°†ä» START èŠ‚ç‚¹å¼€å§‹ï¼Œç»è¿‡ &quot;chatbot&quot; èŠ‚ç‚¹ç”Ÿæˆæ¶ˆæ¯ï¼Œç„¶åç»“æŸã€‚ ç¼–è¯‘å¯¹è¯å›¾ åœ¨æ·»åŠ å®ŒèŠ‚ç‚¹å’Œè¾¹ä¹‹åï¼Œæˆ‘ä»¬éœ€è¦ç¼–è¯‘å¯¹è¯å›¾ï¼Œä½¿å…¶å¯ä»¥è¿è¡Œã€‚ 1graph = graph_builder.compile() ç¼–è¯‘åçš„ graph å¯¹è±¡å¯ä»¥ç”¨äºæ‰§è¡Œå¯¹è¯æµç¨‹ã€‚ å¯è§†åŒ–å¯¹è¯å›¾ ä¸ºäº†æ›´å¥½åœ°ç†è§£å¯¹è¯å›¾çš„ç»“æ„ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶å¯è§†åŒ–ã€‚LangGraph æä¾›äº† draw_mermaid_png æ–¹æ³•ï¼Œå¯ä»¥å°†å¯¹è¯å›¾ç»˜åˆ¶ä¸º Mermaid æ ¼å¼çš„å›¾è¡¨ã€‚ 1234567from IPython.display import Image, displaytry: display(Image(graph.get_graph().draw_mermaid_png()))except Exception: # This requires some extra dependencies and is optional pass å¦‚æœç¯å¢ƒæ”¯æŒï¼Œè¿™æ®µä»£ç å°†æ˜¾ç¤ºå¯¹è¯å›¾çš„å¯è§†åŒ–ç»“æœã€‚ è¿è¡ŒChatbot æœ€åï¼Œæˆ‘ä»¬å¯ä»¥è¿è¡ŒChatbotå¹¶è§‚å¯Ÿå…¶è¡Œä¸ºã€‚é€šè¿‡ graph.stream æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç”¨æˆ·è¾“å…¥ä¼ é€’ç»™Chatbotï¼Œå¹¶é€æ­¥ç”Ÿæˆå¯¹è¯ã€‚ 12345678910111213141516171819def stream_graph_updates(user_input: str): for event in graph.stream(&#123;&quot;messages&quot;: [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: user_input&#125;]&#125;): for value in event.values(): print(&quot;Assistant:&quot;, value[&quot;messages&quot;][-1].content)while True: try: user_input = input(&quot;User: &quot;) if user_input.lower() in [&quot;quit&quot;, &quot;exit&quot;, &quot;q&quot;]: print(&quot;Goodbye!&quot;) break stream_graph_updates(user_input) except: # fallback if input() is not available user_input = &quot;What do you know about LangGraph?&quot; print(&quot;User: &quot; + user_input) stream_graph_updates(user_input) break åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªç®€å•çš„äº¤äº’å¼å¾ªç¯ï¼Œç”¨æˆ·å¯ä»¥è¾“å…¥æ¶ˆæ¯ï¼ŒChatbot ä¼šç”Ÿæˆå“åº”ã€‚å¦‚æœç”¨æˆ·è¾“å…¥ &quot;quit&quot;ã€&quot;exit&quot; æˆ– &quot;q&quot;ï¼Œç¨‹åºå°†é€€å‡ºã€‚ ç»“è®º é€šè¿‡æœ¬æ•™ç¨‹ï¼Œæˆ‘ä»¬å­¦ä¹ äº†å¦‚ä½•ä½¿ç”¨ LangGraph æ„å»ºä¸€ä¸ªç®€å•çš„ Chatbotã€‚æˆ‘ä»¬å®šä¹‰äº†å¯¹è¯çŠ¶æ€ã€æ„å»ºäº†å¯¹è¯å›¾ã€æ·»åŠ äº†èŠ‚ç‚¹å’Œè¾¹ï¼Œå¹¶æœ€ç»ˆè¿è¡Œäº† Chatbotã€‚è™½ç„¶è¿™ä¸ª Chatbot éå¸¸ç®€å•ï¼Œä½†å®ƒå±•ç¤ºäº† LangGraph çš„åŸºæœ¬å·¥ä½œæµç¨‹ã€‚ä½ å¯ä»¥åœ¨æ­¤åŸºç¡€ä¸Šè¿›ä¸€æ­¥æ‰©å±•å’Œä¼˜åŒ– Chatbot çš„åŠŸèƒ½ï¼Œä¾‹å¦‚æ·»åŠ æ›´å¤šçš„å¯¹è¯çŠ¶æ€ã€å¤„ç†å¤æ‚çš„ç”¨æˆ·è¾“å…¥ç­‰ã€‚ å¸Œæœ›è¿™ç¯‡æ•™ç¨‹å¯¹ä½ ç†è§£ LangGraph æœ‰æ‰€å¸®åŠ©ï¼å¦‚æœä½ æœ‰ä»»ä½•é—®é¢˜æˆ–å»ºè®®ï¼Œæ¬¢è¿åœ¨è¯„è®ºåŒºç•™è¨€ã€‚ ä½œè€…: Mudrobot æ—¥æœŸ: 2025.01.23 æ ‡ç­¾: LangGraph, Chatbot, NLP, è‡ªç„¶è¯­è¨€å¤„ç†"},{"title":"äºŒåˆ†æŸ¥æ‰¾","path":"/wiki/LeetCode/ä¸“é¡¹è®­ç»ƒ/äºŒåˆ†æŸ¥æ‰¾.html","content":"åŸºç¡€åŸç† æœ¬æ¿å—æ•´ç†è‡ªçµèŒ¶å±±è‰¾åºœbç«™è§†é¢‘äºŒåˆ†æŸ¥æ‰¾ çº¢è“æŸ“è‰²æ³•_å“”å“©å“”å“©_bilibili é€šè¿‡ä¸€é“ä¾‹é¢˜è¿›è¡Œè®²è§£ï¼š ä¾‹é¢˜è¿”å›æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªâ‰¥8\\geq 8â‰¥8 æ•°å­—çš„ä½ç½®ï¼Œå¦‚æœæ‰€æœ‰æ•°éƒ½&lt;8&lt; 8&lt;8 åˆ™è¿”å›é•¿åº¦å€¼ éå¸¸æ˜æ˜¾è¿™é“é¢˜æˆ‘ä»¬å¯ä»¥é‡‡ç”¨äºŒåˆ†æŸ¥æ‰¾çš„æ–¹æ³•æ¥è§£å†³ï¼Œé¦–å…ˆæˆ‘ä»¬å…ˆè®²è§£ä¸€ä¸‹é—­åŒºé—´äºŒåˆ†è§£å†³è¿™é“é¢˜çš„å†™æ³•ï¼š é—­åŒºé—´äºŒåˆ†å†™æ³• å‡è®¾é˜Ÿåˆ—é•¿åº¦ä¸ºmï¼Œé¦–å…ˆè®¾å·¦æŒ‡é’ˆLæŒ‡å‘0ï¼Œå³æŒ‡é’ˆæŒ‡å‘m-1ã€‚æ¯æ¬¡å–ä¸­é—´çš„å…ƒç´ è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœä¸­é—´çš„å…ƒç´ â‰¥8\\geq 8â‰¥8 åˆ™ R= mid-1å¦åˆ™L = mid+1ï¼ŒæŒç»­æ›´æ–°ç›´åˆ°L&gt;R 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; arr = &#123;5,7,7,8,8,10&#125;;int main()&#123; int len = arr.size(); int l = 0, r = len-1; while(l&lt;=r)&#123; int mid = l+(r-l)/2; if (arr[mid]&gt;=8) r = mid-1; else l = mid+1; &#125; cout&lt;&lt;l; return 0;&#125; æ³¨æ„ï¼šäºŒåˆ†ä¸­æ±‚midçš„å†™æ³•ï¼Œåƒä¸Šé¢è¿™æ ·å†™èƒ½æœ‰æ•ˆçš„é¿å… è¿™é‡Œå…¶å®å°±å¯ä»¥æ„Ÿè§‰åˆ°ï¼Œåœ¨æ›´æ–°çš„è¿‡ç¨‹ä¸­ï¼Œæ— è®ºä½•æ—¶L-1æŒ‡å‘çš„ä¸€å®šæ˜¯&lt;8çš„æ•°R+1æŒ‡å‘çš„ä¸€å®šæ˜¯&gt;=8çš„æ•° å·¦é—­å³å¼€äºŒåˆ†å†™æ³• è¿™ä¸ªæ˜¯ç»å¸¸çœ‹åˆ°çš„äºŒåˆ†çš„å†™æ³• åŒæ ·å‡è®¾é˜Ÿåˆ—é•¿åº¦ä¸ºmï¼Œå·¦æŒ‡é’ˆLæŒ‡å‘0ï¼Œå³æŒ‡é’ˆæŒ‡å‘mï¼Œæ¯æ¬¡å–ä¸­é—´å…ƒç´ è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœä¸­é—´å…ƒç´ â‰¥8\\geq 8â‰¥8åˆ™R = midï¼Œå¦åˆ™L = mid+1ï¼ŒæŒç»­æ›´æ–°ç›´åˆ° Lâ‰¥RL\\geq RLâ‰¥R 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; arr = &#123;5,7,7,8,8,10&#125;;int main() &#123; int len = arr.size(); int l = 0, r = len; while(l&lt;r)&#123; int mid = l+(r-l)/2; if(arr[mid] &gt;= 8) r = mid; else l = mid+1; &#125; cout&lt;&lt; l; return 0;&#125; å¼€åŒºé—´äºŒåˆ†å†™æ³• åŒæ ·å‡è®¾é˜Ÿåˆ—é•¿åº¦ä¸ºmï¼Œå·¦æŒ‡é’ˆæŒ‡å‘-1ï¼Œå³æŒ‡é’ˆæŒ‡å‘mï¼Œæ¯æ¬¡å–ä¸­é—´å…ƒç´ è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœä¸­é—´å…ƒç´ â‰¥8\\geq 8â‰¥8åˆ™R = mid, å¦åˆ™L = midï¼ŒæŒç»­æ›´æ–°ç›´åˆ°L+1â‰¥RL+1 \\geq RL+1â‰¥R 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; arr = &#123;5,7,7,8,8,10&#125;;int main() &#123; int len = arr.size(); int l = -1, r = len; while(l+1&lt;r)&#123; int mid = l + (r-l)/2; if (mid&gt;=8) r = mid; else l = mid; &#125; cout &lt;&lt; r; return 0;&#125; ä¸€é“ä¾‹é¢˜ é¢˜ç›®ä¼ é€é—¨ï¼š34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å…¶ä¸­æ‰¾å½“å‰æ•°å‡ºç°çš„æœ€åä¸€ä¸ªï¼Œå°±æ˜¯æ‰¾æ¯”ä»–å¤§1çš„æ•°çš„ç¬¬ä¸€ä¸ªä½ç½®ï¼Œç„¶åæŠŠè¿™ä¸ªä½ç½®-1ã€‚ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); int l = 0, r = len; while(l&lt;r)&#123; int mid = l+(r-l)/2; if (nums[mid]&gt;=target) r=mid; else l = mid+1; &#125; if (l == len || nums[l]!=target)&#123; vector&lt;int&gt; nw = &#123;-1,-1&#125;; return nw; &#125; vector&lt;int&gt; ans; ans.emplace_back(l); l = 0; r = len; while(l&lt;r)&#123; int mid= l+(r-l)/2; if(nums[mid]&gt;=target+1) r=mid; else l = mid+1; &#125; ans.emplace_back(l-1); return ans; &#125;&#125;; å½“ç„¶è¿™é“é¢˜ä½¿ç”¨lower_boundå’Œupper_boundä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œå…·ä½“ä½¿ç”¨æ–¹æ³•è§C++éƒ¨åˆ†ã€‚ 123456789class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; auto it = lower_bound(nums.begin(),nums.end(),target); if (it == nums.end() || *it != target) return vector&lt;int&gt;&#123;-1,-1&#125;; auto it2 = upper_bound(nums.begin(), nums.end(), target); return vector&lt;int&gt;&#123;int(it-nums.begin()),int(it2-nums.begin())-1&#125;; &#125;&#125;; æ€»ç»“ å¯èƒ½çœ‹å®Œä¸Šé¢çš„å‡ ç§å†™æ³•ï¼Œè¿˜æ˜¯æ²¡æœ‰ç†è§£äºŒåˆ†çš„æœ¬è´¨æ˜¯ä»€ä¹ˆï¼Œè¿™é‡Œå°±æ¥æ€»ç»“ä¸€ä¸‹ã€‚å…¶å®é€šè¿‡è§‚å¯Ÿä¸Šé¢å¸¸è§çš„ä¸‰ç§å†™æ³•æˆ‘ä»¬ä¸éš¾å‘ç°ï¼ŒäºŒåˆ†çš„ç›®çš„æ˜¯åˆ¤æ–­æ•´ä¸ªåŒºé—´å’Œä¸€ä¸ªç›®æ ‡å€¼çš„å¤§å°å…³ç³»ï¼Œä¸ºäº†è¾¾åˆ°è¿™ä¸ªç›®çš„ï¼Œæˆ‘ä»¬éœ€è¦ç‰¢è®°åŒºé—´çš„å®šä¹‰ï¼åŒºé—´å†…çš„æ•°ï¼ˆä¸‹æ ‡ï¼‰éƒ½æ˜¯è¿˜æœªç¡®å®šä¸ target çš„å¤§å°å…³ç³»çš„ï¼Œæœ‰çš„æ˜¯ &lt; targetï¼Œæœ‰çš„æ˜¯ â‰¥ targetï¼›åŒºé—´å¤–çš„æ•°ï¼ˆä¸‹æ ‡ï¼‰éƒ½æ˜¯ç¡®å®šä¸ target çš„å¤§å°å…³ç³»çš„ã€‚ ç†è§£äº†ä¸Šè¿°å®šä¹‰ï¼Œåˆ™äºŒåˆ†æŸ¥æ‰¾ç®—æ³•ä¹Ÿå°±ç†è§£äº†ã€‚ äºŒåˆ†é¢˜å•ï¼ˆå³è¾¹æ•°å­—ä¸ºéš¾åº¦åˆ†ï¼‰ äºŒåˆ†ç­”æ¡ˆ H æŒ‡æ•° II ä½¿ç»“æœä¸è¶…è¿‡é˜ˆå€¼çš„æœ€å°é™¤æ•° 1542 å®Œæˆæ—…é€”çš„æœ€å°‘æ—¶é—´ 1641 æ¯ä¸ªå°å­©æœ€å¤šèƒ½åˆ†åˆ°å¤šå°‘ç³–æœ 1646 å‡†æ—¶åˆ°è¾¾çš„åˆ—è½¦æœ€å°æ—¶é€Ÿ 1676 åœ¨ D å¤©å†…é€è¾¾åŒ…è£¹çš„èƒ½åŠ› 1725 çˆ±åƒé¦™è•‰çš„ç‚ç‚ 1766 å¯ç§»é™¤å­—ç¬¦çš„æœ€å¤§æ•°ç›® 1913 åˆ¶ä½œ m æŸèŠ±æ‰€éœ€çš„æœ€å°‘å¤©æ•° 1946 å¯ä»¥åˆ°è¾¾çš„æœ€è¿œå»ºç­‘ 1962 æœ€å¤§åˆé‡‘æ•° 1981 é€ƒç¦»ç«ç¾ 2347 275. HæŒ‡æ•° é¢˜ç›®ä¼ é€é—¨ï¼š275. H æŒ‡æ•° II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ äºŒåˆ†åˆ¤å®šæ¡ä»¶å°±æ˜¯å¦‚æœå½“å‰citationæ•°é‡ä»ç„¶å¤§äºç­‰äºåé¢çš„æ–‡ç« æ•°é‡å°±è¿˜å¯ä»¥å¾€å‰äºŒåˆ†ã€‚éœ€è¦æ³¨æ„çš„æ˜¯è¦åˆ¤æ–­ä¸€ä¸‹æ•°ç»„æœ‰æ²¡æœ‰è¶Šç•Œã€‚ å·¦é—­å³å¼€äºŒåˆ†å¦‚ä¸‹ï¼š 1234567891011121314151617class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; int len = citations.size(); int l = 0,r = len; function&lt;bool(int)&gt; judge = [&amp;](int x)&#123; if (citations[x]&gt;=len-x) return true; else return false; &#125;; while(l &lt; r)&#123; int mid = l+(r-l)/2; if (judge(mid)) r = mid; else l = mid+1; &#125; return l==len?0:min(len-l,citations[l]); &#125;&#125;; 1283. ä½¿ç»“æœä¸è¶…è¿‡é˜ˆå€¼çš„æœ€å°é™¤æ•° é¢˜ç›®ä¼ é€é—¨ï¼š1283. ä½¿ç»“æœä¸è¶…è¿‡é˜ˆå€¼çš„æœ€å°é™¤æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“éå¸¸æ˜æ˜¾çš„äºŒåˆ†é¢˜ç›®ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯æ˜¯ä¸Šå–æ•´ï¼Œè¿™ç‚¹æœ‰ç‚¹å‘ã€‚ å¼€åŒºé—´äºŒåˆ†å¦‚ä¸‹ï¼š 1234567891011121314151617181920class Solution &#123;public: int smallestDivisor(vector&lt;int&gt;&amp; nums, int threshold) &#123; function&lt;bool(int)&gt; judge = [&amp;](int x)&#123; int ans = 0; for (auto &amp;num:nums) &#123; if (num%x) ans = ans+num/x+1; else ans += num/x; &#125; return ans&lt;=threshold; &#125;; int l=0,r=1000001; while (l+1&lt;r) &#123; int mid = l+(r-l)/2; if (judge(mid)) r=mid; else l=mid; &#125; return r; &#125;&#125;; 2187. å®Œæˆæ—…é€”çš„æœ€å°‘æ—¶é—´ é¢˜ç›®ä¼ é€é—¨ï¼š2187. å®Œæˆæ—…é€”çš„æœ€å°‘æ—¶é—´ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ é—­åŒºé—´äºŒåˆ†å¦‚ä¸‹ï¼š 1234567891011121314151617181920class Solution &#123;public: long long minimumTime(vector&lt;int&gt;&amp; time, int totalTrips) &#123; long long r = 100000000000003; long long l = 0; function&lt;bool(long long)&gt; judge=[&amp;](long long x)&#123; long long ans = 0; for (auto tim:time) &#123; ans += x / tim; &#125; return ans&gt;=(long long)totalTrips?true:false; &#125;; while (l &lt;= r) &#123; long long mid = l + (r - l)/2; if (judge(mid)) r = mid-1; else l = mid+1; &#125; return l; &#125;&#125;; 2226. æ¯ä¸ªå°å­©æœ€å¤šèƒ½åˆ†åˆ°å¤šå°‘ç³–æœ é¢˜ç›®ä¼ é€é—¨ï¼š2226. æ¯ä¸ªå°å­©æœ€å¤šèƒ½åˆ†åˆ°å¤šå°‘ç³–æœ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ é—­åŒºé—´äºŒåˆ†å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223class Solution &#123;public: int maximumCandies(vector&lt;int&gt;&amp; candies, long long k) &#123; auto maxit = max_element(candies.begin(),candies.end()); int max_ele = *maxit; function&lt;bool(long long)&gt; judge = [&amp;](int x) &#123; long long ans = 0; if (x==0) return true; for (auto candy:candies) &#123; ans += candy/x; &#125; return ans&gt;=k?true:false; &#125;; int l=0,r=max_ele; while (l&lt;=r) &#123; int mid = l + (r-l)/2; if(judge(mid)) l=mid+1; else r=mid-1; &#125; return r; &#125;&#125;; 1870. å‡†æ—¶åˆ°è¾¾çš„åˆ—è½¦æœ€å°æ—¶é€Ÿ é¢˜ç›®ä¼ é€é—¨ï¼š1870. å‡†æ—¶åˆ°è¾¾çš„åˆ—è½¦æœ€å°æ—¶é€Ÿ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å·¦é—­å³å¼€åŒºé—´äºŒåˆ†å¦‚ä¸‹ï¼š 12345678910111213141516171819202122class Solution &#123;public: int minSpeedOnTime(vector&lt;int&gt;&amp; dist, double hour) &#123; int len = dist.size(); function&lt;bool(int)&gt; judge = [&amp;](int v) &#123; int time=0; for(int i=0;i&lt;len-1;++i) &#123; time += dist[i]/v; if (dist[i]%v) time += 1; &#125; double fin_time = (double)time + (double) dist[len-1]/(double)v; return fin_time &lt;= hour?true:false; &#125;; int l = 1,r = 10000001; while (l&lt;r) &#123; int mid = l + (r-l)/2; if(judge(mid)) r = mid; else l = mid+1; &#125; return judge(l)?l:-1; &#125;&#125;; æ³¨æ„ï¼šæœ€åè¿”å›çš„æ—¶å€™è¦åˆ¤æ–­ä¸€ä¸‹å½“å‰é€Ÿåº¦èƒ½ä¸èƒ½æŒ‰è§„å®šåˆ°è¾¾ç›®çš„åœ° 1011. åœ¨ D å¤©å†…é€è¾¾åŒ…è£¹çš„èƒ½åŠ› é¢˜ç›®ä¼ é€é—¨ï¼š1011. åœ¨ D å¤©å†…é€è¾¾åŒ…è£¹çš„èƒ½åŠ› - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å·¦é—­å³å¼€åŒºé—´äºŒåˆ†ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910111213141516171819202122232425class Solution &#123;public: int shipWithinDays(vector&lt;int&gt;&amp; weights, int days) &#123; function&lt;bool(int)&gt; judge = [&amp;](int x)&#123; int cur=0,cur_day=1; for (auto weight:weights) &#123; if(cur+weight &lt;= x)&#123; cur = cur+weight; &#125; else &#123; cur_day++; cur = weight; &#125; &#125; return cur_day&lt;=days?true:false; &#125;; int l = *max_element(weights.begin(), weights.end()); int r = accumulate(weights.begin(),weights.end(),0)+1; while (l&lt;r) &#123; int mid = l + (r-l)/2; if (judge(mid)) r = mid; else l = mid+1; &#125; return l; &#125;&#125;; å¯ä»¥ç•™æ„ä¸€ä¸‹é‡Œé¢accumulateæ±‚å’Œå‡½æ•°çš„ç”¨æ³• 875. çˆ±åƒé¦™è•‰çš„ç‚ç‚ 875. çˆ±åƒé¦™è•‰çš„ç‚ç‚ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å¼€åŒºé—´äºŒåˆ†ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920class Solution &#123;public: int minEatingSpeed(vector&lt;int&gt;&amp; piles, int h) &#123; function&lt;bool(int)&gt; judge = [&amp;](int v)&#123; long long cos = 0; for(auto pile:piles)&#123; cos += pile/v; if(pile%v) cos += 1; &#125; return cos&lt;=(long long)h?true:false; &#125;; int l = 0,r = INT_MAX; while (l+1&lt;r) &#123; int mid = l + (r-l)/2; if(judge(mid)) r = mid; else l = mid; &#125; return r; &#125;&#125;; 1898. å¯ç§»é™¤å­—ç¬¦çš„æœ€å¤§æ•°ç›® é¢˜ç›®ä¼ é€é—¨ï¼š1898. å¯ç§»é™¤å­—ç¬¦çš„æœ€å¤§æ•°ç›® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åŒæ ·é¦–å…ˆè§‚å¯Ÿæ•°æ®èŒƒå›´ï¼Œ1e5çš„æ•°æ®èŒƒå›´ï¼Œé¢„æ„Ÿè¿™é“é¢˜åº”è¯¥ä½¿ç”¨äºŒåˆ†ã€‚ è¿™é“é¢˜æ¯”ä¹‹å‰çš„é¢˜ç›®è¦ç¨å¾®éš¾ä¸€ç‚¹ï¼Œéš¾ç‚¹ä¸»è¦é›†ä¸­åœ¨judgeå‡½æ•°çš„ä¹¦å†™ä¸Šï¼Œå…¶å®åªè¦åœ¨æ¯æ¬¡åˆ¤æ–­æ—¶ä½¿ç”¨ä¸€ä¸ªå“ˆå¸Œæ•°ç»„è®°å½•ä¸€ä¸‹å½“å‰å­—ç¬¦æœ‰æ²¡æœ‰è¢«åˆ é™¤ï¼Œå°±å¯ä»¥è¾ƒä¸ºç®€å•çš„è§£å†³è¿™é“é¢˜ã€‚ä»¥ä¸‹æä¾›ä¸¤ç§å¼€åŒºé—´äºŒåˆ†å†™æ³•ï¼Œæ³¨æ„åŒºåˆ†å…¶ä¸­ç»†èŠ‚ï¼Œå¦‚æœèƒ½å¤ŸåŒºåˆ†å‡ºæ¥å·®åˆ«ï¼Œé‚£æ­å–œï¼Œè¯´æ˜ä½ å¾ˆå¥½çš„æŒæ¡äº†çš„äºŒåˆ†æŸ¥æ‰¾ğŸ‡ã€‚ äºŒåˆ†ä¸‹æ ‡ï¼ˆåˆ¤æ–­åˆ°å½“å‰ä¸‹æ ‡ä¹‹å‰ï¼ˆåŒ…å«å½“å‰ä¸‹æ ‡ï¼‰èƒ½å¦è¢«removeï¼‰ 12345678910111213141516171819202122232425class Solution &#123;public: int maximumRemovals(string s, string p, vector&lt;int&gt;&amp; removable) &#123; int len = s.size(); function&lt;bool(int)&gt; judge=[&amp;](int x)&#123; vector&lt;bool&gt; vis(len,true); for (int i=0;i&lt;=x;++i) vis[removable[i]] = false; int pp = 0; for(int i=0;i&lt;len;++i)&#123; if (s[i]==p[pp]&amp;&amp;vis[i])&#123; pp++; if (pp == p.size()) return true; &#125; &#125; return false; &#125;; int l = -1, r = removable.size(); while (l+1&lt;r) &#123; int mid = l + (r-l)/2; if (judge(mid)) l = mid; else r = mid; &#125; return l+1; &#125;&#125;; äºŒåˆ†å‰nä¸ªremoveçš„è¿™ä¸ªnï¼š 12345678910111213141516171819202122232425class Solution &#123;public: int maximumRemovals(string s, string p, vector&lt;int&gt;&amp; removable) &#123; int len = s.size(); function&lt;bool(int)&gt; judge=[&amp;](int x)&#123; vector&lt;bool&gt; vis(len,true); for (int i=0;i&lt;x;++i) vis[removable[i]] = false; int pp = 0; for(int i=0;i&lt;len;++i)&#123; if (s[i]==p[pp]&amp;&amp;vis[i])&#123; pp++; if (pp == p.size()) return true; &#125; &#125; return false; &#125;; int l = -1, r = removable.size()+1; while (l+1&lt;r) &#123; int mid = l + (r-l)/2; if (judge(mid)) l = mid; else r = mid; &#125; return l; &#125;&#125;; 1482. åˆ¶ä½œ m æŸèŠ±æ‰€éœ€çš„æœ€å°‘å¤©æ•° é¢˜ç›®ä¼ é€é—¨ï¼š1482. åˆ¶ä½œ m æŸèŠ±æ‰€éœ€çš„æœ€å°‘å¤©æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åŒæ ·é¦–å…ˆè§‚å¯Ÿæ•°æ®èŒƒå›´ï¼Œ1e5çš„æ•°æ®èŒƒå›´ï¼Œé¢„æ„Ÿè¿™é“é¢˜åº”è¯¥ä½¿ç”¨äºŒåˆ†ã€‚ åŒä¸Šï¼Œå°±æ˜¯éœ€è¦è®¾è®¡ä¸€ä¸‹judgeå‡½æ•° 123456789101112131415161718192021222324252627class Solution &#123;public: int minDays(vector&lt;int&gt;&amp; bloomDay, int m, int k) &#123; auto judge = [&amp;](int x) &#123; int cnt=0,cur=0; for (auto bloom:bloomDay) &#123; if (bloom &lt;= x) &#123; cur++; if (cur == k) &#123; cur = 0; cnt ++; if (cnt == m) return true; &#125; &#125; else cur = 0; &#125; return false; &#125;; int l = 1, r = *max_element(bloomDay.begin(),bloomDay.end()); while (l &lt;= r) &#123; int mid = l + (r-l)/2; if (judge(mid)) r=mid-1; else l=mid+1; &#125; return judge(l)?l:-1; &#125;&#125;; 1642. å¯ä»¥åˆ°è¾¾çš„æœ€è¿œå»ºç­‘ é¢˜ç›®ä¼ é€é—¨ï¼š1642. å¯ä»¥åˆ°è¾¾çš„æœ€è¿œå»ºç­‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åŒæ ·é¦–å…ˆè§‚å¯Ÿæ•°æ®èŒƒå›´ï¼Œ1e5çš„æ•°æ®èŒƒå›´ï¼Œé¢„æ„Ÿè¿™é“é¢˜åº”è¯¥ä½¿ç”¨äºŒåˆ†ã€‚ å·¦é—­å³å¼€åŒºé—´äºŒåˆ†å†™æ³•å¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910111213141516171819202122class Solution &#123;public: int furthestBuilding(vector&lt;int&gt;&amp; heights, int bricks, int ladders) &#123; auto judge = [&amp;](int x) &#123; vector&lt;int&gt; h_diffs; for(int i=1;i&lt;=x;++i)&#123; if (heights[i] &gt; heights[i-1]) h_diffs.emplace_back(heights[i]-heights[i-1]); &#125; if (ladders&gt;=h_diffs.size()) return true; sort(h_diffs.begin(),h_diffs.end()); int sum_diff = accumulate(h_diffs.begin(),h_diffs.end()-ladders,0); return sum_diff &lt;= bricks?true:false; &#125;; int l=0,r=heights.size(); while(l&lt;r)&#123; int mid = l + (r-l)/2; if (judge(mid)) l = mid+1; else r=mid; &#125; return l-1; &#125;&#125;; æ³¨æ„ï¼šè¯¥é¢˜åˆæ³•åŒºé—´åœ¨å·¦è¾¹ï¼Œæ‰€ä»¥æœ€ç»ˆå·¦é—­å³å¼€åŒºé—´äºŒåˆ†è¿”å›å€¼åº”è¯¥æ˜¯l-1 2861. æœ€å¤§åˆé‡‘æ•° é¢˜ç›®ä¼ é€é—¨ï¼š2861. æœ€å¤§åˆé‡‘æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ é¢˜ç›®ä¸­è§„å®šåªèƒ½ä½¿ç”¨ä¸€ä¸ªæœºå™¨ç”Ÿäº§æ‰€æœ‰åˆé‡‘ï¼Œæ‰€ä»¥å°±éå¸¸ç®€å•äº†ï¼Œå’Œä¹‹å‰çš„äºŒåˆ†å·®ä¸å¤šï¼Œåªä¸è¿‡ä¸­é—´è®¡ç®—å¼€é”€çš„æ—¶å€™ä¼šçˆ†intæ‰€ä»¥è®¾ç½®æˆlong longã€‚ å·¦å¼€å³é—­äºŒåˆ†ä¹¦å†™å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223class Solution &#123;public: int maxNumberOfAlloys(int n, int k, int budget, vector&lt;vector&lt;int&gt;&gt;&amp; composition, vector&lt;int&gt;&amp; stock, vector&lt;int&gt;&amp; cost) &#123; auto judge = [&amp;](int x) &#123; for(int i=0; i&lt;k; ++i) &#123; long long cost_all = 0; for(int j=0; j&lt;n; ++j) &#123; cost_all += max((long long)0, ((long long)x*composition[i][j]-stock[j]))*cost[j]; if(cost_all &gt; budget) break; &#125; if (cost_all &lt;= budget) return true; &#125; return false; &#125;; int l = 0, r = INT_MAX; while (l&lt;r) &#123; int mid = l + (r-l)/2; if(judge(mid)) l = mid+1; else r = mid; &#125; return l-1; &#125;&#125;; 2258. é€ƒç¦»ç«ç¾ è¿™é“é¢˜è¿˜æ˜¯éå¸¸æœ‰æ„æ€çš„ï¼Œæ˜¯ä¸€é“bfså’ŒäºŒåˆ†çš„ç»“åˆï¼Œé¦–å…ˆæˆ‘ä»¬å…ˆä½¿ç”¨bfsé¢„å¤„ç†ä¸€éå°†æ¯ä¸ªæ ¼å­ç€ç«çš„æ—¶é—´éƒ½å…ˆå¤„ç†å‡ºæ¥ã€‚ç„¶åæˆ‘ä»¬ä½¿ç”¨äºŒåˆ†ï¼ŒäºŒåˆ†ç­‰å¾…æ—¶é—´ï¼ŒäºŒåˆ†åˆ¤æ–­å‡½æ•°å°±æ˜¯ç¬¬äºŒæ¬¡bfsï¼Œåˆ¤æ–­åœ¨å½“å‰ç­‰å¾…æ—¶é—´ä¸‹èƒ½å¦è¿›å…¥å®‰å…¨å±‹ã€‚æ‰€ä»¥ä¸€å…±éœ€è¦æä¾›ä¸¤ä¸ªbfså‡½æ•°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123;public: int maximumMinutes(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; int n = grid.size(),m = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; tim_burn(n,vector&lt;int&gt;(m,INT_MAX)); auto judge = [&amp;](int x,int y) &#123; if (x&lt;0||y&lt;0||x&gt;=n||y&gt;=m) return false; if (grid[x][y] == 2) return false; return true; &#125;; auto bfs1 = [&amp;](int x, int y)&#123; &#125;; auto bfs2 = [&amp;](int stay_time)&#123; vector&lt;vector&lt;int&gt;&gt; reach(n,vector&lt;int&gt;(m,INT_MAX)); if (stay_time &gt; tim_burn[0][0]) return false; queue&lt;vector&lt;int&gt;&gt; que; que.push(vector&lt;int&gt;&#123;0,0&#125;); reach[0][0] = stay_time; while (!que.empty()) &#123; vector&lt;int&gt; nw = que.front();que.pop(); for(auto dir:dirs) &#123; if (judge(nw[0]+dir[0],nw[1]+dir[1])) &#123; int nx = nw[0]+dir[0], ny = nw[1]+dir[1]; if (nx == n-1 &amp;&amp; ny == m-1 &amp;&amp; tim_burn[nx][ny] &gt;= reach[nw[0]][nw[1]]+1) return true; if (tim_burn[nx][ny] &gt; reach[nw[0]][nw[1]]+1) &#123; if (reach[nx][ny] &gt; reach[nw[0]][nw[1]]+1)&#123; reach[nx][ny] = reach[nw[0]][nw[1]]+1; que.push(vector&lt;int&gt;&#123;nx,ny&#125;); &#125; &#125; &#125; &#125; &#125; return false; &#125;; queue&lt;vector&lt;int&gt;&gt; que1; for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;m;++j)&#123; if (grid[i][j]==1) &#123; tim_burn[i][j] = 0; que1.push(vector&lt;int&gt;&#123;i,j&#125;); &#125; &#125; &#125; while (!que1.empty()) &#123; vector&lt;int&gt; nw = que1.front();que1.pop(); for(auto dir:dirs) &#123; if (judge(nw[0]+dir[0],nw[1]+dir[1])) &#123; int nx = nw[0]+dir[0], ny = nw[1]+dir[1]; if (tim_burn[nx][ny] &gt; tim_burn[nw[0]][nw[1]]+1) &#123; tim_burn[nx][ny] = tim_burn[nw[0]][nw[1]]+1; que1.push(vector&lt;int&gt;&#123;nx,ny&#125;); &#125; &#125; &#125; &#125; // close interval int l = 0, r = 1000000000; while(l &lt;= r) &#123; int mid = l + (r-l)/2; if(bfs2(mid)) l = mid+1; else r = mid-1; &#125; return bfs2(1000000000)?1000000000:l-1; &#125;&#125;; æ³¨æ„ç¬¬ä¸€æ¬¡é¢„å¤„ç†çš„æ—¶å€™å°±å°†æ‰€æœ‰çš„ç«æºéƒ½å‹å…¥bfsé˜Ÿåˆ—ä¸­é¢„å¤„ç†ä¸€æ¬¡å°±è¡Œäº†ï¼Œä¸è¦æ¯æ¬¡å‘ç°ä¸€ä¸ªç«æºå°±bfsä¸€æ¬¡ï¼Œéå¸¸çš„æµªè´¹æ—¶é—´ã€‚ æœ€å°åŒ–æœ€å¤§å€¼ åˆ†é…ç»™å•†åº—çš„æœ€å¤šå•†å“çš„æœ€å°å€¼ 1886 è¢‹å­é‡Œæœ€å°‘æ•°ç›®çš„çƒ 1940 æœ€å°åŒ–æ•°ç»„ä¸­çš„æœ€å¤§å€¼ 1965 æ‰“å®¶åŠ«èˆ IV 2081 æ°´ä½ä¸Šå‡çš„æ³³æ± ä¸­æ¸¸æ³³ 2097 æœ€å°åŒ–æ•°å¯¹çš„æœ€å¤§å·®å€¼ 2155 æœ€å°åŒ–ä¸¤ä¸ªæ•°ç»„ä¸­çš„æœ€å¤§å€¼ 2302 æœ€å¤§åŒ–æœ€å°å€¼ ä¸¤çƒä¹‹é—´çš„ç£åŠ› 1920 æœ€å¤§åˆé‡‘æ•° 1981 ç¤¼ç›’çš„æœ€å¤§ç”œèœœåº¦ 2021 æ‰¾å‡ºæœ€å®‰å…¨è·¯å¾„ 2154 æœ€å¤§åŒ–åŸå¸‚çš„æœ€å°ä¾›ç”µç«™æ•°ç›® 2236"},{"title":"åŠ¨æ€è§„åˆ’","path":"/wiki/LeetCode/ä¸“é¡¹è®­ç»ƒ/åŠ¨æ€è§„åˆ’.html","content":"æ”¹é¢˜å•é€‰è‡ªçµç¥ï¼šåˆ†äº«ä¸¨ã€é¢˜å•ã€‘åŠ¨æ€è§„åˆ’ï¼ˆå…¥é—¨/èƒŒåŒ…/çŠ¶æ€æœº/åˆ’åˆ†/åŒºé—´/çŠ¶å‹/æ•°ä½/æ ‘å½¢/æ•°æ®ç»“æ„ä¼˜åŒ–ï¼‰ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€ã€å…¥é—¨ DP 1.0 é¢˜ç›®æ¸…å• 1. çˆ¬æ¥¼æ¢¯ 70. çˆ¬æ¥¼æ¢¯ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 746. ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 377. ç»„åˆæ€»å’Œ â…£ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 2466. ç»Ÿè®¡æ„é€ å¥½å­—ç¬¦ä¸²çš„æ–¹æ¡ˆæ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 2266. ç»Ÿè®¡æ‰“å­—æ–¹æ¡ˆæ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 2. æ‰“å®¶åŠ«èˆ 198. æ‰“å®¶åŠ«èˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰~1500 740. åˆ é™¤å¹¶è·å¾—ç‚¹æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰~1600 2320. ç»Ÿè®¡æ”¾ç½®æˆ¿å­çš„æ–¹å¼æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰1608 213. æ‰“å®¶åŠ«èˆ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰~1650 3. æœ€å¤§å­æ•°ç»„å’Œï¼ˆæœ€å¤§å­æ®µå’Œï¼‰ 53. æœ€å¤§å­æ•°ç»„å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 1400 2606. æ‰¾åˆ°æœ€å¤§å¼€é”€çš„å­å­—ç¬¦ä¸² - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 1422 1749. ä»»æ„å­æ•°ç»„å’Œçš„ç»å¯¹å€¼çš„æœ€å¤§å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 1542 1191. K æ¬¡ä¸²è”åæœ€å¤§å­æ•°ç»„ä¹‹å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 1748 918. ç¯å½¢å­æ•°ç»„çš„æœ€å¤§å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 1777 2321. æ‹¼æ¥æ•°ç»„çš„æœ€å¤§åˆ†æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 1791 æ€ç»´æ‹“å±•é¢˜ï¼š152. ä¹˜ç§¯æœ€å¤§å­æ•°ç»„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 1.1 çˆ¬æ¥¼æ¢¯ç±» 70. çˆ¬æ¥¼æ¢¯ é¢˜ç›®ä¼ é€é—¨ï¼š70. çˆ¬æ¥¼æ¢¯ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç®€å•é€’æ¨ç›´æ¥ç§’äº†ï¼Œæœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011class Solution &#123;public: int climbStairs(int n) &#123; vector&lt;int&gt; dp(n+1,0); dp[0] = 1; dp[1] = 1; for(int i=2;i&lt;=n;++i)&#123; dp[i] = dp[i-1] + dp[i-2]; &#125; return dp[n]; &#125;&#125;; 746. ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯ é¢˜ç›®ä¼ é€é—¨ï¼š746. ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åŒä¸Šï¼Œé€’æ¨å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int n = cost.size(); vector&lt;int&gt; dp(n+1,0); for(int i=2;i&lt;=n;++i)&#123; dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]); &#125; return dp[n]; &#125;&#125;; 377. ç»„åˆæ€»å’Œ â…£ é¢˜ç›®ä¼ é€é—¨ï¼š377. ç»„åˆæ€»å’Œ â…£ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ­¤é¢˜ç±»ä¼¼ä¸€ä¸ªå®Œå…¨èƒŒåŒ…é—®é¢˜ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„ä¸€ä¸‹å†…å¤–å¾ªç¯é¡ºåºï¼Œå…ˆå¾ªç¯targetå†å¾ªç¯ç»™å®šæ•°ç»„ä¸­çš„æ•°ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415class Solution &#123;public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;unsigned&gt; dp(target+1,0); dp[0] = 1; int n = nums.size(); for(int i=1; i&lt;=target; ++i)&#123; for(int j=0; j&lt;n; ++j)&#123; if (nums[j] &gt; i) continue; dp[i] += dp[i-nums[j]]; &#125; &#125; return dp[target]; &#125;&#125;; 2466. ç»Ÿè®¡æ„é€ å¥½å­—ç¬¦ä¸²çš„æ–¹æ¡ˆæ•° é¢˜ç›®ä¼ é€é—¨ï¼š2466. ç»Ÿè®¡æ„é€ å¥½å­—ç¬¦ä¸²çš„æ–¹æ¡ˆæ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è·Ÿä¸Šé¢é‚£é“é¢˜ç›®æ€è·¯ä¸€æ ·ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617class Solution &#123;public: int countGoodStrings(int low, int high, int zero, int one) &#123; vector&lt;int&gt; dp(1e5+2,0); dp[0] = 1; int MOD = 1e9+7; for(int i=1;i&lt;=high;++i)&#123; if (i&gt;=zero) dp[i] += dp[i-zero]; if (i&gt;=one) dp[i] += dp[i-one]; dp[i] %= MOD; &#125; int ans = 0; for(int i=low; i&lt;=high; ++i)&#123; ans = (ans + dp[i]) % MOD; &#125; return ans; &#125;&#125;; 2266. ç»Ÿè®¡æ‰“å­—æ–¹æ¡ˆæ•° é¢˜ç›®ä¼ é€é—¨ï¼š2266. ç»Ÿè®¡æ‰“å­—æ–¹æ¡ˆæ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä»ç„¶æ˜¯çˆ¬æ¥¼æ¢¯ç±»é—®é¢˜ï¼Œä½†æ˜¯å¹¶ä¸æ˜¯é‚£ç§å¯ä»¥ç›´æ¥è§£å†³çš„ï¼Œå¯ä»¥é‡‡ç”¨å¦‚ä¸‹æ–¹å¼è§£å†³ï¼š å°†ç›¸åŒå­—ç¬¦åˆ†ä¸ºä¸€ç»„ï¼Œæ¯ç»„å†…åªæœ‰ä¸€ç§å­—ç¬¦ã€‚è€ƒè™‘ä»¥ä¸‹åŠ¨æ€è§„åˆ’ï¼ˆDPï¼‰æ–¹æ³•ï¼š å¯¹äºå­—ç¬¦ä¸ä¸º7æˆ–9çš„æƒ…å†µï¼Œå®šä¹‰( f[i] )è¡¨ç¤ºé•¿åº¦ä¸º( i )çš„åªæœ‰ä¸€ç§å­—ç¬¦çš„å­—ç¬¦ä¸²å¯¹åº”çš„æ–‡å­—ä¿¡æ¯ç§ç±»æ•°ã€‚æˆ‘ä»¬å¯ä»¥å°†æœ«å°¾çš„1ä¸ªã€2ä¸ªæˆ–3ä¸ªå­—ç¬¦å•ç‹¬è§†ä½œä¸€ä¸ªå­—æ¯ï¼Œé‚£ä¹ˆæœ‰è½¬ç§»æ–¹ç¨‹ï¼š f[i]=f[iâˆ’1]+f[iâˆ’2]+f[iâˆ’3]f[i] = f[i-1] + f[i-2] + f[i-3] f[i]=f[iâˆ’1]+f[iâˆ’2]+f[iâˆ’3] å¯¹äºå­—ç¬¦ä¸º7æˆ–9çš„æƒ…å†µï¼Œå®šä¹‰( g[i] )è¡¨ç¤ºé•¿åº¦ä¸º( i )çš„åªæœ‰ä¸€ç§å­—ç¬¦çš„å­—ç¬¦ä¸²å¯¹åº”çš„æ–‡å­—ä¿¡æ¯ç§ç±»æ•°ï¼Œå¯ä»¥å¾—åˆ°ç±»ä¼¼çš„è½¬ç§»æ–¹ç¨‹ï¼š g[i]=g[iâˆ’1]+g[iâˆ’2]+g[iâˆ’3]+g[iâˆ’4]g[i] = g[i-1] + g[i-2] + g[i-3] + g[i-4] g[i]=g[iâˆ’1]+g[iâˆ’2]+g[iâˆ’3]+g[iâˆ’4] è¿™æ ·èƒ½ç®—å‡ºæ¯ç»„å­—ç¬¦ä¸²çš„æ–‡å­—ä¿¡æ¯ç§ç±»æ•°ã€‚ ç”±äºä¸åŒç»„ä¹‹é—´äº’ä¸å½±å“ï¼Œæ ¹æ®ä¹˜æ³•åŸç†ï¼ŒæŠŠä¸åŒç»„çš„æ–‡å­—ä¿¡æ¯ç§ç±»æ•°ç›¸ä¹˜ï¼Œå¾—åˆ°ç­”æ¡ˆã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int countTexts(string pressedKeys) &#123; int MOD = 1e9 +7, n = pressedKeys.size(); vector&lt;long long&gt; dp_3(100003,0),dp_4(100003,0); dp_3[0] = 1; dp_3[1] = 1; dp_3[2] = 2; dp_3[3] = 4; dp_4[0] = 1; dp_4[1] = 1; dp_4[2] = 2; dp_4[3] = 4; for (int i=4;i&lt;=n;++i) &#123; dp_3[i] = dp_3[i-1] + dp_3[i-2] + dp_3[i-3]; dp_4[i] = dp_4[i-1] + dp_4[i-2] + dp_4[i-3] + dp_4[i-4]; dp_3[i] %= MOD; dp_4[i] %= MOD; &#125; int cnt = 1; long long ans = 1; char ch = pressedKeys[0]; for(int i=1;i&lt;n;++i)&#123; if (pressedKeys[i]!=ch)&#123; if (ch == &#x27;7&#x27;||ch == &#x27;9&#x27;) ans = (dp_4[cnt] * ans) % MOD; else ans = (dp_3[cnt] * ans) % MOD; cnt = 1; ch = pressedKeys[i]; &#125; else &#123; cnt++; &#125; &#125; int tmp; if(ch == &#x27;7&#x27;||ch == &#x27;9&#x27;) tmp = dp_4[cnt]; else tmp = dp_3[cnt]; return ((ans*tmp)%MOD); &#125;&#125;; 1.2 æ‰“å®¶åŠ«èˆ 198. æ‰“å®¶åŠ«èˆ é¢˜ç›®ä¼ é€é—¨ï¼š198. æ‰“å®¶åŠ«èˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å®šä¹‰åŠ¨æ€è§„åˆ’æ•°ç»„dp[i]è¡¨ç¤ºå·åˆ°ç¬¬iä¸ªæˆ¿å­ï¼Œæ‰€èƒ½ç›—å–çš„æœ€å¤§é‡‘é¢ã€‚ é‚£ä¹ˆä¸éš¾å†™å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š 1dp[i] = max(dp[i-1],dp[i-2]+nums[i-1]); æœ€åç¡®å®šä¸€ä¸‹åˆå§‹çŠ¶æ€dp[0] = 0,dp[1] = nums[0],å®Œæˆè§£ç­”ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; dp(n+2, 0); dp[1] = nums[0]; for(int i=2;i&lt;=n;++i)&#123; dp[i] = max(dp[i-1],dp[i-2]+nums[i-1]); &#125; return dp[n]; &#125;&#125;; 740. åˆ é™¤å¹¶è·å¾—ç‚¹æ•° é¢˜ç›®ä¼ é€é—¨ï¼š740. åˆ é™¤å¹¶è·å¾—ç‚¹æ•° è§‚å¯Ÿæ•°æ®èŒƒå›´åä¸éš¾å‘ç°å°±æ˜¯ä¸Šé¢æ‰“å®¶åŠ«èˆè¿™ç§ç±»å‹çš„é¢˜ç›®ï¼Œæ’åºåï¼ŒåŠ¨æ€è§„åˆ’åŒä¸Šä¸€é¢˜ç›®ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122class Solution &#123;public: int deleteAndEarn(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt;nums_all(10004, 0), dp(10004, 0); sort(nums.begin(), nums.end()); int prev = nums[0], cnt = 0; for(int i=0;i&lt;n;++i)&#123; if (nums[i]==prev) cnt++; else &#123; nums_all[prev] = cnt * prev; cnt = 1; prev = nums[i]; &#125; &#125; nums_all[prev] = prev * cnt; dp[1] = nums_all[1]; for(int i=2;i&lt;=nums[n-1];++i)&#123; dp[i] = max(dp[i-1], dp[i-2]+nums_all[i]); &#125; return dp[nums[n-1]]; &#125;&#125;; 2320. ç»Ÿè®¡æ”¾ç½®æˆ¿å­çš„æ–¹å¼æ•° é¢˜ç›®ä¼ é€é—¨ï¼š2320. ç»Ÿè®¡æ”¾ç½®æˆ¿å­çš„æ–¹å¼æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è§‚å¯Ÿæ¯ä¸ªä½ç½®çš„æ”¾ç½®çŠ¶æ€ä¸€å…±æœ‰4ç§æƒ…å†µï¼š ä¸Šæ— ä¸‹æ—  ä¸Šæœ‰ä¸‹æ—  ä¸Šæ— ä¸‹æœ‰ ä¸Šæœ‰ä¸‹æœ‰ å› æ­¤å¯ä»¥è®¾è®¡ä¸€ä¸ªdp[n][4]åŠ¨æ€è§„åˆ’æ•°ç»„ï¼Œå¯¹äºå½“å‰æ¯ä¸€ç§çŠ¶æ€ï¼Œéƒ½å¯ä»¥ä»ä¸Šä¸€ä¸ªä½ç½®å…¶ä»–çŠ¶æ€æ¨å¯¼è€Œæ¥ï¼Œæœ€åçš„ç­”æ¡ˆå°±æ˜¯æœ€åä¸€ä¸ªä½ç½®çš„æ‰€æœ‰4ç§çŠ¶æ€ä¹‹å’Œã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415class Solution &#123;public: int countHousePlacements(int n) &#123; int MOD = 1e9 + 7; vector&lt;vector&lt;int&gt;&gt; dp(10002,vector&lt;int&gt;(4,0)); dp[1][0] = 1; dp[1][1] = 1; dp[1][2] = 1; dp[1][3] = 1; for(int i=2;i&lt;=n;++i)&#123; dp[i][1] = (dp[i-1][0] + dp[i-1][2])%MOD; dp[i][2] = (dp[i-1][0] + dp[i-1][1])%MOD; dp[i][3] = dp[i-1][0]; dp[i][0] = ((dp[i-1][0]+dp[i-1][1])%MOD + (dp[i-1][2]+dp[i-1][3])%MOD)%MOD; &#125; return ((dp[n][0]+dp[n][1])%MOD + (dp[n][2]+dp[n][3])%MOD)%MOD; &#125;&#125;; 213. æ‰“å®¶åŠ«èˆ II é¢˜ç›®ä¼ é€é—¨ï¼š213. æ‰“å®¶åŠ«èˆ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ­¤é¢˜å°±æ˜¯ä¹‹å‰çš„æ‰“å®¶åŠ«èˆä½†æ˜¯å°†é¡ºåºçš„ç»“æ„æ”¹æˆäº†ç¯å½¢çš„ç»“æ„ã€‚ä¸ºäº†é˜²æ­¢åŒæ—¶é€‰åˆ°ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªï¼Œå¯ä»¥åšä¸¤éDPã€‚ æ³¨æ„ï¼š æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; dp1(n+2,0), dp2(n+2,0); // ç‰¹æ®Šåˆ¤æ–­ï¼ˆåªæœ‰ä¸€ä¸ªå…ƒç´ ï¼‰ if (n == 1) return nums[0]; // ä¸é€‰ç¬¬ä¸€ä¸ª dp1[1] = 0; for(int i=2;i&lt;=n;++i)&#123; dp1[i] = max(dp1[i-1], dp1[i-2]+nums[i-1]); &#125; // ä¸é€‰æœ€åä¸€ä¸ª dp2[1] = nums[0]; for(int i=2;i&lt;n;++i)&#123; dp2[i] = max(dp2[i-1], dp2[i-2]+nums[i-1]); &#125; return max(dp1[n], dp2[n-1]); &#125;&#125;; 1.3 æœ€å¤§å­æ•°ç»„å’Œï¼ˆæœ€å¤§å­æ®µå’Œï¼‰ 53. æœ€å¤§å­æ•°ç»„å’Œ é¢˜ç›®ä¼ é€é—¨ï¼š53. æœ€å¤§å­æ•°ç»„å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸åŒäºä¹‹å‰çš„DPï¼Œè¿™é‡Œå®šä¹‰çš„DPæ•°ç»„dp[i]å«ä¹‰æ˜¯ï¼Œä»¥ç¬¬iä¸ªæ•°ç»“å°¾çš„è¿ç»­å­æ•°ç»„æœ€å¤§å’Œï¼ˆå› ä¸ºæ¡ä»¶ä¸­åŒ…å«è¿ç»­è¿™ä¸€è¦æ±‚ï¼Œå› æ­¤åªæœ‰è¿™æ ·æ‰èƒ½æè¿°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼‰ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; dp(n+2,0); dp[1] = nums[0]; for(int i=1;i&lt;=n;++i)&#123; dp[i] = max(dp[i-1]+nums[i-1],nums[i-1]); &#125; int ans = 0; for(int i=1;i&lt;=n;++i) ans = max(ans,dp[i]); return ans; &#125;&#125;; 2606. æ‰¾åˆ°æœ€å¤§å¼€é”€çš„å­å­—ç¬¦ä¸² é¢˜ç›®ä¼ é€é—¨ï¼š2606. æ‰¾åˆ°æœ€å¤§å¼€é”€çš„å­å­—ç¬¦ä¸² - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ€è·¯åŒä¸Š æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718class Solution &#123;public: int maximumCostSubstring(string s, string chars, vector&lt;int&gt;&amp; vals) &#123; int n = s.size(); vector&lt;int&gt; dp(n+2,0); unordered_map&lt;char,int&gt; mp; int m = chars.size(); for(int i=0; i&lt;26; ++i) mp[&#x27;a&#x27;+i] = i+1; for(int i=0; i&lt;m; ++i) mp[chars[i]] = vals[i]; for(int i=1;i&lt;=n;++i) &#123; int val = mp[s[i-1]]; dp[i] = max(dp[i-1]+val, val); &#125; int ans = dp[0]; for(int i=1;i&lt;=n;++i) ans = max(ans, dp[i]); return ans; &#125;&#125;; 1749. ä»»æ„å­æ•°ç»„å’Œçš„ç»å¯¹å€¼çš„æœ€å¤§å€¼ é¢˜ç›®ä¼ é€é—¨ï¼š1749. ä»»æ„å­æ•°ç»„å’Œçš„ç»å¯¹å€¼çš„æœ€å¤§å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ€è·¯ä¸Šå’Œä¹‹å‰ä¸€æ ·ï¼Œ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516class Solution &#123;public: int maxAbsoluteSum(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(2,0)); for(int i=1;i&lt;=n;++i)&#123; dp[i][0] = max(dp[i-1][0]+nums[i-1],nums[i-1]); dp[i][1] = min(dp[i-1][1]+nums[i-1],nums[i-1]); &#125; int ans = 0; for(int i=1;i&lt;=n;++i)&#123; ans = max(ans,max(-dp[i][1], dp[i][0])); &#125; return ans; &#125;&#125;; è¿™é“é¢˜è¿™æ ·åšå¯èƒ½è¿˜éº»çƒ¦äº†ä¸€äº›ï¼Œè¿˜å¯ä»¥åˆ©ç”¨å‰ç¼€å’Œçš„æ€æƒ³è¿›è¡Œç®€åŒ–ã€‚å…·ä½“è€Œè¨€å°±æ˜¯æ‰¾åˆ°è¿™ä¸ªæ•°ç»„ä¸­å‰ç¼€å’Œæœ€å¤§å’Œå‰ç¼€å’Œæœ€å°ï¼Œç›¸å‡å°±å¯ä»¥å¾—å‡ºæƒ³è¦çš„ç­”æ¡ˆã€‚ 12345678910111213class Solution &#123;public: int maxAbsoluteSum(vector&lt;int&gt;&amp; nums) &#123; int maxx = 0, minn = 0; int nw=0; for(int num : nums)&#123; nw += num; maxx = max(maxx, nw); minn = min(minn, nw); &#125; return maxx - minn; &#125;&#125;; 1191. K æ¬¡ä¸²è”åæœ€å¤§å­æ•°ç»„ä¹‹å’Œ é¢˜ç›®ä¼ é€é—¨ï¼š1191. K æ¬¡ä¸²è”åæœ€å¤§å­æ•°ç»„ä¹‹å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ­¤é¢˜å®šä¹‰çš„DPæ•°ç»„ï¼ˆå®é™…æœªå®šä¹‰ï¼Œä½¿ç”¨ä¸€ä¸ªå˜é‡ä¼˜åŒ–æ‰äº†ï¼‰åŒä¹‹å‰ä¸€æ ·ï¼Œä¹Ÿæ˜¯è¡¨ç°çš„æ˜¯ä»¥å½“å‰æ•°ç»“å°¾çš„æœ€å¤§å­æ•°ç»„å’Œã€‚ è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯é¢˜ç›®ä¸­çš„kå…¶å®æ˜¯å“äººçš„ï¼Œæˆ‘ä»¬ä»”ç»†åˆ†æä¸€ä¸‹ä¾¿å¯å¾—çŸ¥: å½“kä¸º1æ—¶ï¼ŒåŒæœ€å¤§å­æ•°ç»„å’Œ å½“kä¸º2æ—¶ï¼Œç”±äºå­˜åœ¨ç‰¹æ®Šæƒ…å†µï¼ˆé€‰ç¬¬ä¸€ä¸ªæ•°ç»„åç¼€+ç¬¬äºŒä¸ªæ•°ç»„çš„å‰ç¼€ï¼‰å°†æ•°ç»„æ‹¼æ¥åœ¨ä¸€èµ·ï¼ŒåŒç†å¯ä»¥è½¬å˜ä¸ºæœ€å¤§å­æ•°ç»„å’Œ å½“kå¤§äº2æ—¶ï¼Œç›¸æ¯”ä¸Šä¸€ç§æƒ…å†µï¼Œè¦å¤šè€ƒè™‘ï¼Œå¦‚æœå‡ºç°æ¨ªè·¨æ•°ç»„çš„æƒ…å†µçš„è¯ï¼Œç›¸å½“äºä¸­é—´æ•°ç»„çš„å’ŒåŠ ä¸Šå•ä¸ªæ•°ç»„çš„æœ€å¤§å‰ç¼€å’Œä¸æœ€å¤§åç¼€å’Œã€‚ ç»¼ä¸Šåˆ†ä¸‰ç±»è®¨è®ºå³å¯ã€‚å®é™…ä¸Šæ²¡æœ‰å°†æ•°ç»„æ‰©å±•kå€ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223class Solution &#123;public: int kConcatenationMaxSum(vector&lt;int&gt;&amp; arr, int k) &#123; int n = arr.size(); int MOD = 1e9 + 7; long long maxx = 0,minn = 0,sum_arr = 0;// å‰ç¼€å’Œ // å‰ç¼€å’Œé¢„å¤„ç† for(int i=0;i&lt;n;++i)&#123; sum_arr += arr[i]; maxx = max(maxx, sum_arr); minn = min(minn, sum_arr); &#125; if (k!=1) arr.insert(arr.end(),arr.begin(),arr.end()); int m = arr.size(); long long tmp = 0,ans=0; for(int i=0;i&lt;m;++i)&#123; tmp = max(tmp,(long long)(0)) + arr[i]; ans = max(ans, tmp); &#125; if (k&lt;=2) return ans%MOD; else return max(ans, (k-2)*sum_arr + maxx + sum_arr-minn)%MOD; &#125;&#125;; 918. ç¯å½¢å­æ•°ç»„çš„æœ€å¤§å’Œ é¢˜ç›®ä¼ é€é—¨ï¼š918. ç¯å½¢å­æ•°ç»„çš„æœ€å¤§å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åŒæ ·è¿˜æ˜¯åˆ†ç±»è®¨è®ºçš„æ€æƒ³ã€‚ å¯¹äºéç¯å½¢æ•°ç»„çš„æƒ…å†µï¼Œå…¶è§£å†³æ–¹æ³•ç±»ä¼¼äºå¯»æ‰¾æœ€å¤§å­æ•°ç»„å’Œï¼Œè¿™é‡Œä¸å†è¯¦è¿°ã€‚è€Œå¯¹äºç¯å½¢æ•°ç»„ï¼Œå¯ä»¥å°†é—®é¢˜è½¬åŒ–ä¸ºå¯»æ‰¾æœ€å¤§çš„å‰ç¼€å’Œä¸åç¼€å’Œï¼Œè¿™ä¸¤éƒ¨åˆ†ä¸èƒ½æœ‰äº¤é›†ã€‚é€šè¿‡è®¡ç®—æ¯ä¸ªä½ç½®çš„æœ€å¤§å‰åç¼€å’Œï¼Œå¯ä»¥è§£å†³ç¯å½¢é—®é¢˜ã€‚å› æ­¤ï¼Œæ•´ä½“é—®é¢˜å¯è§†ä¸ºæ±‚è§£â€œæœ€å¤§å­æ•°ç»„å’Œâ€ä¸â€œæœ€å¤§å‰åç¼€å’Œâ€çš„è¾ƒå¤§è€…ã€‚æœ€ç»ˆï¼Œæ¯”è¾ƒè¿™ä¸¤ä¸ªç»“æœï¼Œè¿”å›è¾ƒå¤§çš„å€¼å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxSubarraySumCircular(vector&lt;int&gt;&amp; nums) &#123; // æ•°ç»„å†…æœ€å¤§å€¼ int ans1=nums[0], tmp=0; for(auto num : nums)&#123; tmp = max(num, num + tmp); ans1 = max(tmp,ans1); &#125; // ç»´æŠ¤å‰åç¼€æœ€å¤§å€¼ int n = nums.size(); vector&lt;int&gt; pre(n+1,0),pos(n+1,0); int pre_tmp = 0, pos_tmp = 0; for(int i=1;i&lt;=n;++i)&#123; pre_tmp += nums[i-1]; if(i&gt;1) pre[i] = max(pre[i-1], pre_tmp); else pre[i] = pre_tmp; pos_tmp += nums[n-i]; if(i&gt;1) pos[i] = max(pos[i-1], pos_tmp); else pos[i] = pos_tmp; &#125; int ans2 = pre[1]+pos[n-1]; for(int i=1;i&lt;n;++i)&#123; ans2 = max(ans2,pre[i]+pos[n-i]); &#125; return max(ans1, ans2); &#125;&#125;; 2321. æ‹¼æ¥æ•°ç»„çš„æœ€å¤§åˆ†æ•° é¢˜ç›®ä¼ é€é—¨ï¼š2321. æ‹¼æ¥æ•°ç»„çš„æœ€å¤§åˆ†æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æˆ‘ä»¬å°†ä¸¤ä¸ªæ•°ç»„ä½œå·®å¾—åˆ°ä¸¤ä¸ªå·®å€¼æ•°ç»„diff1å’Œdiff2ï¼Œä»”ç»†è§‚å¯Ÿåå¯ä»¥å°†æ­¤é¢˜è½¬åŒ–ä¸ºæœ€å¤§å­æ•°ç»„å’Œè¿™ä¸ªé—®é¢˜ï¼Œ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314class Solution &#123;public: int maximumsSplicedArray(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int n = nums1.size(),sum1=0,sum2=0; int max2=0,max1=0,tmp1=0,tmp2=0; for(int i=0;i&lt;n;++i) &#123; sum1 += nums1[i]; sum2 += nums2[i]; tmp1 = max(tmp1, 0) + nums1[i] - nums2[i]; tmp2 = max(tmp2, 0) + nums2[i] - nums1[i]; max1 = max(max1, tmp1); max2 = max(max2, tmp2); &#125; return max(sum1 + max2, sum2 + max1); &#125;&#125;; 152. ä¹˜ç§¯æœ€å¤§å­æ•°ç»„ é¢˜ç›®ä¼ é€é—¨ï¼š152. ä¹˜ç§¯æœ€å¤§å­æ•°ç»„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¯¥é¢˜ä½œä¸ºæœ€å¤§å­æ•°ç»„å’Œçš„ä¸€ä¸ªæ‰©å±•ï¼Œè¿˜æ˜¯éå¸¸æœ‰æ„æ€ï¼Œå¤šç»´æŠ¤ä¸€ä¸ªæœ€å°å€¼å°±å¯ä»¥ã€‚ æ³¨æ„ï¼šæœ€å¤§å€¼åŒç†ä¹Ÿå¯ä»¥çŠ¶æ€è½¬ç§»åˆ°æœ€å°å€¼ï¼Œæœ€å°å€¼åŒç†ä¹Ÿå¯ä»¥çŠ¶æ€è½¬ç§»åˆ°æœ€å¤§å€¼ (æ¯”å¦‚å½“å‰ä½ç½®æ˜¯ä¸€ä¸ªè´Ÿæ•°ï¼Œå°±å¯èƒ½å‘ç”Ÿä¸Šè¿°è½¬åŒ–) è¿™é‡Œé¢æœ‰ä¸€ä¸ªå¾ˆâ€œæœ‰è¶£â€çš„æµ‹è¯•ç”¨ä¾‹: 1[0,10,10,10,10,10,10,10,10,10,-10,10,10,10,10,10,10,10,10,10,0] è¿™ä¸ªç”¨ä¾‹å¾ˆæœ‰è¶£ï¼Œæœ€å¤§ä¼šæœ‰ 10^19 è¦å­˜å‚¨ï¼ŒåŠ ä¸Šç¬¦å·ä½æ˜¯65ä½ï¼Œåˆšå¥½ä¸å¤Ÿ long long æ¥å­˜ã€‚è€Œdoubleè™½ç„¶ä¹Ÿæ˜¯64ä½ï¼Œä½†å®ƒçš„æ•°æ®ç»“æ„æœ‰æ‰€ä¸åŒï¼Œé‡‡ç”¨ 1ç¬¦å·+11æŒ‡æ•°+52 å°¾æ•°çš„æ–¹å¼ï¼Œæœ€å¤šå¯ä»¥å­˜åˆ° 2^1024 çš„å¤§æ•°ã€‚è™½ç„¶åœ¨ 52ä½äºŒè¿›åˆ¶æ•°ä»¥ä¸Šçš„ç²¾åº¦ä¸èƒ½ä¿è¯ï¼Œä½†è¿™é¢˜ç”±é¢˜ç›®ä¿è¯æœ€å¤šåªç”¨åˆ°32ä½ï¼Œå†å¤šçš„åªæ˜¯ä¸ºäº†æ»¡è¶³ä¸æº¢å‡ºã€‚ æ‰€ä»¥ï¼Œæˆ‘ä»¬å°†ä¸´æ—¶å˜é‡ç”± int æ”¹ä¸º doubleï¼Œå³å¯é€šè¿‡æ­¤ç”¨ä¾‹ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; double ans=nums[0], max_now=nums[0],min_now=nums[0]; int n = nums.size(); for(int i=1;i&lt;n;++i)&#123; double max_tmp = max_now, min_tmp = min_now; max_now = max(max_now*nums[i], max((double)nums[i],min_tmp*nums[i])); min_now = min(min_now*nums[i], min((double)nums[i],max_tmp*nums[i])); ans = max(ans,max_now); &#125; return int(ans); &#125;&#125;; äºŒã€ç½‘æ ¼å›¾ DP 2.0 é¢˜ç›®æ¸…å• 1. åŸºç¡€ LCR 166. ç å®çš„æœ€é«˜ä»·å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 62. ä¸åŒè·¯å¾„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 63. ä¸åŒè·¯å¾„ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 64. æœ€å°è·¯å¾„å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 120. ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 931. ä¸‹é™è·¯å¾„æœ€å°å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 1573 2684. çŸ©é˜µä¸­ç§»åŠ¨çš„æœ€å¤§æ¬¡æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 1626 2.1 åŸºç¡€ LCR 166. ç å®çš„æœ€é«˜ä»·å€¼ é¢˜ç›®ä¼ é€é—¨ï¼šLCR 166. ç å®çš„æœ€é«˜ä»·å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç½‘æ ¼DPæ±‚æœ€å¤§å€¼é¢˜ï¼Œç½‘æ ¼å›¾DPåŸºç¡€æ¿å­é¢˜ï¼Œä»å·¦ä¾§å’Œä¸Šä¾§è¿›è¡ŒçŠ¶æ€è½¬ç§»å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213class Solution &#123;public: int jewelleryValue(vector&lt;vector&lt;int&gt;&gt;&amp; frame) &#123; int n = frame.size(), m = frame[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1,0)); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + frame[i-1][j-1]; &#125; &#125; return dp[n][m]; &#125;&#125;; 62. ä¸åŒè·¯å¾„ é¢˜ç›®ä¼ é€é—¨ï¼š62. ä¸åŒè·¯å¾„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç½‘æ ¼DPæ–¹æ¡ˆæ•°é¢˜ï¼ŒåŒä¸Šï¼Œç½‘æ ¼å›¾DPåŸºç¡€æ¿å­é¢˜ï¼Œä»å·¦ä¾§å’Œä¸Šä¾§è¿›è¡ŒçŠ¶æ€è½¬ç§»å³å¯ã€‚ æ³¨æ„ä¸€ä¸‹åˆå§‹åŒ–å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1, 0)); dp[1][1] = 1; for(int i=1;i&lt;=m;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; dp[i][j] += dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; 63. ä¸åŒè·¯å¾„ II é¢˜ç›®ä¼ é€é—¨ï¼š63. ä¸åŒè·¯å¾„ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç½‘æ ¼DPæ–¹æ¡ˆæ•°é¢˜ï¼Œåœ¨ä¸Šä¸€é“é¢˜çš„åŸºç¡€ä¸Šå¢åŠ äº†éšœç¢ç‰©çš„è®¾å®šï¼Œåªéœ€è¦åœ¨æ¯æ¬¡å¾ªç¯çš„æ—¶å€™åˆ¤å®šå½“å‰æ˜¯ä¸æ˜¯éšœç¢ç‰©å³å¯ï¼Œå¦‚æœæ˜¯å°±ä¸æ›´æ–°ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int n = obstacleGrid.size(), m = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1,0)); // if (obstacleGrid[0][0]) return 0; dp[1][1] = obstacleGrid[0][0]==0?1:0; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; if (obstacleGrid[i-1][j-1]) continue; dp[i][j] += dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[n][m]; &#125;&#125;; 64. æœ€å°è·¯å¾„å’Œ é¢˜ç›®ä¼ é€é—¨ï¼š64. æœ€å°è·¯å¾„å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç½‘æ ¼DPæ±‚æœ€å°å€¼é¢˜ï¼Œä¸Šé¢å·²ç»é‡åˆ°äº†æ–¹æ¡ˆæ•°é‡å’Œæ±‚æœ€å¤§çš„è®¾å®šï¼Œæ­¤é¢˜ä¸ºä¸€ä¸ªæ±‚æœ€å°è®¾å®šã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n = grid.size(), m = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1, INT_MAX/2)); dp[0][1] = 0; dp[1][0] = 0; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1]; &#125; &#125; return dp[n][m]; &#125;&#125;; 120. ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ é¢˜ç›®ä¼ é€é—¨ï¼š120. ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç½‘æ ¼DPæ±‚æœ€å°å€¼é¢˜ï¼Œä¸Šä¸€é“é¢˜çš„ç®€å•æ”¹ç‰ˆï¼Œä»çŸ©å½¢å˜æˆäº†ä¸‰è§’å½¢ï¼Œæœ€ååˆ¤æ–­ä¸€ä¸‹æœ€åä¸€è¡Œæœ€å°çš„å€¼å³å¯ã€‚ å¤‡æ³¨ï¼šé¡ºä¾¿å¯ä»¥çœ‹ä¸€ä¸‹min_elementçš„ç”¨æ³• æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int n = triangle.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(n+1, (INT_MAX/2))); dp[1][1] = triangle[0][0]; for(int i=2;i&lt;=n;++i)&#123; for(int j=1;j&lt;=i;++j)&#123; dp[i][j] = triangle[i-1][j-1] + min(dp[i-1][j-1] , dp[i-1][j]); &#125; &#125; return *min_element(dp[n].begin(), dp[n].end()); &#125;&#125;; 931. ä¸‹é™è·¯å¾„æœ€å°å’Œ é¢˜ç›®ä¼ é€é—¨ï¼š931. ä¸‹é™è·¯å¾„æœ€å°å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç½‘æ ¼DPæ±‚æœ€å°å€¼é¢˜ï¼ŒåŒä¸Šï¼Œä»ä¸Šä¸€è¡Œç›¸é‚»ä¸‰ä¸ªè½¬ç§»ï¼Œä½¿ç”¨ä¸Šä¸€è¡Œä¸‰ä¸ªå€¼ä¸­çš„æœ€å°å€¼åŠ ä¸Šå½“å‰ä½ç½®å€¼å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314class Solution &#123;public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(n+2, INT_MAX/2)); for(int i=1;i&lt;=n;++i) dp[0][i] = 0; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; dp[i][j] = min(dp[i-1][j], min(dp[i-1][j-1], dp[i-1][j+1])) + matrix[i-1][j-1]; &#125; &#125; return *min_element(dp[n].begin()+1, dp[n].begin()+1+n); &#125;&#125;; 2684. çŸ©é˜µä¸­ç§»åŠ¨çš„æœ€å¤§æ¬¡æ•° é¢˜ç›®ä¼ é€é—¨ï¼š2684. çŸ©é˜µä¸­ç§»åŠ¨çš„æœ€å¤§æ¬¡æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç½‘æ ¼DPæ±‚æœ€å¤§å€¼é¢˜ï¼ŒåŒä¸Šï¼Œåªä¸è¿‡éœ€è¦åœ¨æ›´æ–°çš„è¿‡ç¨‹ä¸­æ—¶åˆ»ç»´æŠ¤ä¸€ä¸ªå…¨å±€æ­¥æ•°çš„æœ€å¤§å€¼å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1"},{"title":"å•è°ƒæ ˆ","path":"/wiki/LeetCode/ä¸“é¡¹è®­ç»ƒ/å•è°ƒæ ˆ.html","content":"åŸºç¡€ æœ¬æ¿å—æ•´ç†è‡ªçµèŒ¶å±±è‰¾åºœbç«™è§†é¢‘å•è°ƒæ ˆã€åŸºç¡€ç®—æ³•ç²¾è®² 26ã€‘_å“”å“©å“”å“©_bilibili é€šè¿‡ä¸€é“ä¾‹é¢˜è¿›è¡Œè®²è§£ï¼š é¢˜ç›®ä¼ é€é—¨ï¼š[739.æ¯æ—¥æ¸©åº¦ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/daily-temperatures/) æœ´ç´ ç®—æ³•å°±æ˜¯ï¼Œæˆ‘ä»¬ç›´æ¥è€ƒè™‘å¯¹äºæ¯ä¸ªå…ƒç´ éå†ï¼Œæ‰¾åˆ°ä»–å³è¾¹ç¬¬ä¸€ä¸ªæ¯”ä»–å¤§çš„æ•°ï¼Œä½†æ˜¯è¿™æ ·æ˜æ˜¾æ˜¯ä¸€ä¸ªO(n2)O(n^2)O(n2)å¤æ‚åº¦çš„ç®—æ³•ï¼Œå¦‚ä½•ä¼˜åŒ–å‘¢ï¼Ÿ é¦–å…ˆä¸éš¾æƒ³åˆ°çš„æ˜¯æˆ‘ä»¬å€’ç€è¿›è¡Œéå†ï¼Œå¦‚æœæˆ‘ä»¬çš„æ¸©åº¦åºåˆ—æ˜¯ 1,6,3,5,5,2,1,61,6,3,5,5,2,1,61,6,3,5,5,2,1,6,å¹¶ä¸”æˆ‘ä»¬å·²ç»éå†å®Œäº†æœ€åçš„4ä¸ªæ•°,é‚£ä¹ˆæˆ‘ä»¬ä¸éš¾æ¨å‡ºï¼Œå†åç»­çš„éå†ä¸­æ¯”å½“å‰å€¼å¤§çš„æ•°ä¸å¯èƒ½æ˜¯2ï¼Œ1ï¼ˆå› ä¸ºå‰é¢æœ‰ä¸€ä¸ª5æ›´å¤§ï¼‰ã€‚ æ€»ç»“ä¸€ä¸‹å½“å‰æƒ…å†µæ˜¯ï¼Œç”±äº5çš„å‡ºç°ï¼Œå³ä¾§2ï¼Œ1ä¸€å®šä¸ä¼šæˆä¸ºå·¦ä¾§æŸä¸ªæ•°ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°äº†ã€‚æ‰€ä»¥å†åç»­çš„éå†ä¸­æˆ‘ä»¬å°±å¯ä»¥æŠŠè¿™ä¸¤ä¸ªæ•°å»æ‰ï¼Œä¸å»éå†ä»–ä»¬ä¸¤ä¸ªäº†ã€‚ ä»¥ä¸Šå°±æ˜¯å•è°ƒæ ˆç®—æ³•çš„æ ¸å¿ƒæ€æƒ³äº† ä¸‹é¢ä»‹ç»ä¸¤ç§å¸¸è§çš„å•è°ƒæ ˆå†™æ³•ï¼š ä»å³åˆ°å·¦ï¼ˆå°†ä¸‹ä¸€ä¸ªæœ€å¤§æ•°å­˜å…¥æ ˆä¸­ï¼‰ æ­¤æ—¶ç»´æŠ¤çš„æ ˆæ˜¯ä¸€ä¸ªé¡¶å°åº•å¤§çš„æ ˆï¼š 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; int n = temperatures.size(); vector&lt;int&gt; ans(n); stack&lt;int&gt; st; for(int i=n-1;i&gt;=0;--i)&#123; int t = temperatures[i]; while (!st.empty()&amp;&amp;t &gt;= temperatures[st.top()]) st.pop(); if (!st.empty()) &#123; ans[i] = st.top() - i; &#125; st.push(i); &#125; return ans; &#125;&#125;; ä»å·¦åˆ°å³ï¼ˆå°†è¿˜æ²¡æœ‰æ‰¾åˆ°ä¸‹ä¸€ä¸ªæœ€å¤§çš„æ•°å­˜å…¥æ ˆä¸­ï¼‰ æ­¤æ—¶ç»´æŠ¤çš„æ ˆä»æ˜¯ä¸€ä¸ªé¡¶å°åº•å¤§çš„æ ˆï¼š 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; int n = temperatures.size(); vector&lt;int&gt; ans(n); stack&lt;int&gt; st; for(int i=0;i&lt;n;++i)&#123; int t = temperatures[i]; while (!st.empty() &amp;&amp; t &gt; temperatures[st.top()]) &#123; ans[st.top()] = i-st.top(); st.pop(); &#125; st.push(i); &#125; return ans; &#125;&#125;; å•è°ƒæ ˆé¢˜å• å•è°ƒæ ˆ æ¯æ—¥æ¸©åº¦ï¼ˆå•è°ƒæ ˆæ¨¡æ¿é¢˜ï¼‰ å•†å“æŠ˜æ‰£åçš„æœ€ç»ˆä»·æ ¼ ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  I ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªæ›´å¤§èŠ‚ç‚¹ 1571 è‚¡ç¥¨ä»·æ ¼è·¨åº¦ 1709 è¡¨ç°è‰¯å¥½çš„æœ€é•¿æ—¶é—´æ®µ 1908 132 æ¨¡å¼ ~2000 ç¾ä¸½å¡” II 2072 ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  IV 2175 ä½¿æ•°ç»„æŒ‰éé€’å‡é¡ºåºæ’åˆ— 2482 æ¯ä¸ªå…ƒç´ ä¸ºæœ€å¤§å€¼çš„æœ€å¤§èŒƒå›´ï¼ˆä¼šå‘˜é¢˜ï¼‰ çŸ©å½¢ç³»åˆ— æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢ æœ€å¤§çŸ©å½¢ ç»Ÿè®¡å…¨ 1 å­çŸ©å½¢ 1845 å­—å…¸åºæœ€å° å»é™¤é‡å¤å­—æ¯ æ‰©å±•ï¼šé‡å¤ä¸ªæ•°ä¸è¶…è¿‡ limit ç§»æ‰ K ä½æ•°å­— ~1800 æ‰¾å‡ºæœ€å…·ç«äº‰åŠ›çš„å­åºåˆ— 1802 æ‹¼æ¥æœ€å¤§æ•° è´¡çŒ®æ³•ï¼ˆè®¡ç®—æ‰€æœ‰å­æ•°ç»„çš„â€¦â€¦çš„å’Œï¼‰ å­æ•°ç»„çš„æœ€å°å€¼ä¹‹å’Œ 1976 å­æ•°ç»„èŒƒå›´å’Œï¼ˆæœ€å¤§å€¼-æœ€å°å€¼ï¼‰ O(n)\\mathcal{O}(n)O(n) åšæ³• ~2000 å­æ•°ç»„æœ€å°ä¹˜ç§¯çš„æœ€å¤§å€¼ 2051 æ“ä½œä½¿å¾—åˆ†æœ€å¤§ 2397 å·«å¸ˆçš„æ€»åŠ›é‡å’Œï¼ˆæœ€å°å€¼*å’Œï¼‰ 2621"},{"title":"ç¬¬ä¸‰ç«  å¤§è¯­è¨€æ¨¡å‹èµ„æº","path":"/wiki/LLM/Basic/ç¬¬ä¸‰ç«  å¤§è¯­è¨€æ¨¡å‹èµ„æº.html","content":"3.1 å…¬å¼€å¯ç”¨çš„æ¨¡å‹æ£€æŸ¥ç‚¹æˆ–API 3.1.1 å…¬å¼€å¯ç”¨çš„é€šç”¨å¤§è¯­è¨€æ¨¡å‹æ£€æŸ¥ç‚¹ LLaMAå’ŒLLaMA-2ï¼š7Bï¼Œ13Bï¼Œ34Bï¼Œ70B ChatGLMï¼š6B Falconï¼š7Bï¼Œ40Bï¼Œ180B Baichuan å’Œ Baichuan-2ï¼š7Bï¼Œ13B InternLM å’ŒInternLM-2ï¼š7Bï¼Œ20B Qwenï¼šä»0.5B åˆ°72B çš„ä¸åŒå‚æ•°è§„æ¨¡ç‰ˆæœ¬ Mistralï¼š7B DeepSeek LLMï¼š7Bï¼Œ67B Mixtralï¼šMoEæ¶æ„ï¼Œ46.7Bï¼Œä½†å¤„ç†æ—¶åªä¼šç”¨åˆ°12.9B Gemmaï¼š2Bå’Œ7B MiniCPMï¼š2B YuLan-Chatï¼š13Bï¼Œ65B 3.1.2 LLaMA å˜ä½“ç³»åˆ—"},{"title":"ç¬¬äºŒç«  åŸºç¡€ä»‹ç»","path":"/wiki/LLM/Basic/ç¬¬äºŒç«  åŸºç¡€ä»‹ç».html","content":"å¤§è¯­è¨€æ¨¡å‹æ˜¯æŒ‡åœ¨æµ·é‡æ— æ ‡æ³¨æ–‡æœ¬æ•°æ®ä¸Šè¿›è¡Œé¢„è®­ç»ƒå¾—åˆ°çš„å¤§å‹é¢„è®­ç»ƒè¯­è¨€æ¨¡å‹ æœ¬éƒ¨åˆ†å°†ä»‹ç»å¤§è¯­è¨€æ¨¡å‹çš„æ„å»ºè¿‡ç¨‹ã€æ‰©å±•æ³•åˆ™ï¼ˆScaling Lawï¼‰ã€æ¶Œç°èƒ½åŠ›ï¼ˆEmergent Abilitiesï¼‰ï¼Œç„¶åå°†ä»‹ç»GPT ç³»åˆ—æ¨¡å‹çš„ç ”å‘å†ç¨‹ã€‚ 2.1 å¤§è¯­è¨€æ¨¡å‹çš„æ„å»ºè¿‡ç¨‹ Transformerç»“æ„ ä¸¤æ­¥éª¤ï¼šå¤§è§„æ¨¡é¢„è®­ç»ƒï¼ŒæŒ‡ä»¤å¾®è°ƒ&amp;äººç±»å¯¹é½ 2.1.1 å¤§è§„æ¨¡é¢„è®­ç»ƒ è§£ç å™¨æ¶æ„+é¢„æµ‹ä¸‹ä¸€ä¸ªè¯ 2.1.2 æŒ‡ä»¤å¾®è°ƒä¸äººç±»å¯¹é½ æŒ‡ä»¤å¾®è°ƒï¼ˆä¹Ÿå«åšæœ‰ç›‘ç£å¾®è°ƒï¼ŒSupervised Fine-tuning, SFTï¼‰ äººç±»å¯¹é½ï¼šå°†è¯­è¨€æ¨¡å‹ä¸äººç±»ä»·å€¼è§‚å¯¹é½ 2.2 æ‰©å±•æ³•åˆ™ å’Œå°è¯­è¨€æ¨¡å‹ç›¸ä¼¼çš„ç»“æ„ï¼Œä½†æ˜¯é€šè¿‡æ‰©å±•å‚æ•°è§„æ¨¡ã€æ•°æ®è§„æ¨¡å’Œè®¡ç®—ç®—åŠ›ï¼Œå¤§è¯­è¨€æ¨¡å‹çš„èƒ½åŠ›æ˜¾è‘—è¶…è¶Šäº†å°å‹è¯­è¨€æ¨¡å‹çš„èƒ½åŠ›ã€‚ 2.2.1 KMæ‰©å±•æ³•åˆ™ï¼ˆOpenAIï¼‰ KM æ‰©å±•æ³•åˆ™ï¼ˆKaplan ç­‰äºº, 2020ï¼‰æè¿°äº†ç¥ç»è¯­è¨€æ¨¡å‹çš„æ€§èƒ½å¦‚ä½•éšæ¨¡å‹è§„æ¨¡ï¼ˆNï¼‰ã€æ•°æ®è§„æ¨¡ï¼ˆDï¼‰å’Œè®¡ç®—ç®—åŠ›ï¼ˆCï¼‰ å˜åŒ–ï¼Œé‡‡ç”¨å¹‚å¾‹å…¬å¼åˆ»ç”»å…¶å…³ç³»ï¼š L(N)âˆ¼Nâˆ’Î±N,L(D)âˆ¼Dâˆ’Î±D,L(C)âˆ¼Câˆ’Î±CL(N) \\sim N^{-\\alpha_N}, \\quad L(D) \\sim D^{-\\alpha_D}, \\quad L(C) \\sim C^{-\\alpha_C} L(N)âˆ¼Nâˆ’Î±Nâ€‹,L(D)âˆ¼Dâˆ’Î±Dâ€‹,L(C)âˆ¼Câˆ’Î±Câ€‹ å…¶ä¸­ï¼ŒL(Â·) ä»£è¡¨äº¤å‰ç†µæŸå¤±ï¼Œå®éªŒè¡¨æ˜æ¨¡å‹æ‰©å±•åï¼ŒæŸå¤±å‘ˆå¹‚å¾‹ä¸‹é™ã€‚ æ ¸å¿ƒç»“è®º æ¨¡å‹è§„æ¨¡ã€æ•°æ®é‡å’Œç®—åŠ›ä¸‰è€…ç´§å¯†ç›¸å…³ï¼Œå¢åŠ ä»»ä¸€å› ç´ éƒ½èƒ½æ”¹å–„æ€§èƒ½ï¼Œä½†éœ€ç¡®ä¿èµ„æºåŒ¹é…ã€‚ å¹‚å¾‹å…³ç³»æä¾›ä¼˜åŒ–æŒ‡å¯¼ï¼Œç”¨äºåˆç†åˆ†é…è®¡ç®—èµ„æºï¼Œæå‡æ¨¡å‹æ•ˆæœã€‚ OpenAI è¿›ä¸€æ­¥æ‹†åˆ†æŸå¤±ï¼š ä¸å¯çº¦æŸå¤±ï¼ˆæ•°æ®ç‰¹æ€§å†³å®šï¼Œæ— æ³•ä¼˜åŒ–ï¼‰ã€‚ å¯çº¦æŸå¤±ï¼ˆå¯é€šè¿‡å¢åŠ è®¡ç®—æˆ–ä¼˜åŒ–ç®—æ³•å‡å°‘ï¼‰ã€‚ æ„ä¹‰ è¯¥æ³•åˆ™ä¸ºå¤§è§„æ¨¡ç¥ç»ç½‘ç»œçš„ä¼˜åŒ–æä¾›äº†ç»éªŒæŒ‡å¯¼ï¼Œè¯´æ˜å¦‚ä½•åœ¨ç®—åŠ›æœ‰é™çš„æƒ…å†µä¸‹åˆç†æ‰©å±•æ¨¡å‹è§„æ¨¡å’Œæ•°æ®é‡ä»¥è·å¾—æœ€ä½³æ€§èƒ½ã€‚ 2.2.2 Chinchilla æ‰©å±•æ³•åˆ™ï¼ˆDeepMindï¼‰ Chinchilla æ‰©å±•æ³•åˆ™ç”± DeepMind å›¢é˜Ÿï¼ˆ2022ï¼‰æå‡ºï¼Œæ—¨åœ¨ä¼˜åŒ–è®¡ç®—èµ„æºçš„åˆ©ç”¨ï¼ŒæŒ‡å¯¼å¤§è¯­è¨€æ¨¡å‹å¦‚ä½•åœ¨ç»™å®šç®—åŠ›ä¸‹åˆç†åˆ†é…æ¨¡å‹è§„æ¨¡ï¼ˆNï¼‰å’Œæ•°æ®è§„æ¨¡ï¼ˆDï¼‰ï¼Œä»è€Œæé«˜è®­ç»ƒæ•ˆç‡ã€‚ æ ¸å¿ƒå…¬å¼ Chinchilla æ‰©å±•æ³•åˆ™ç»™å‡ºçš„æ¨¡å‹æŸå¤±å‡½æ•°ä¸ºï¼š L(N,D)=E+ANÎ±+BDÎ²L(N, D) = E + \\frac{A}{N^\\alpha} + \\frac{B}{D^\\beta} L(N,D)=E+NÎ±Aâ€‹+DÎ²Bâ€‹ å…¶ä¸­ï¼ŒEEEã€AAAã€BBB ä¸ºå®éªŒæ‹Ÿåˆå‚æ•°ï¼ŒÎ±=0.34\\alpha = 0.34Î±=0.34ï¼ŒÎ²=0.28\\beta = 0.28Î²=0.28ã€‚ åœ¨çº¦æŸæ¡ä»¶ Câ‰ˆ6NDC \\approx 6NDCâ‰ˆ6ND ä¸‹ï¼Œæœ€ä¼˜çš„ N å’Œ D åˆ†é…æ–¹æ¡ˆï¼š Nopt(C)=G(C6)a,Dopt(C)=Gâˆ’1(C6)bN_{\\text{opt}}(C) = G \\left(\\frac{C}{6}\\right)^a, \\quad D_{\\text{opt}}(C) = G^{-1} \\left(\\frac{C}{6}\\right)^b Noptâ€‹(C)=G(6Câ€‹)a,Doptâ€‹(C)=Gâˆ’1(6Câ€‹)b å…¶ä¸­ï¼Œa=Î±Î±+Î²a = \\frac{\\alpha}{\\alpha + \\beta}a=Î±+Î²Î±â€‹ï¼Œb=Î²Î±+Î²b = \\frac{\\beta}{\\alpha + \\beta}b=Î±+Î²Î²â€‹ï¼Œç”¨äºè®¡ç®—æ¨¡å‹å‚æ•°ä¸æ•°æ®çš„æœ€ä½³é…æ¯”ã€‚ ä¸ KM æ‰©å±•æ³•åˆ™çš„å¯¹æ¯” ç ”ç©¶å‘ç°ï¼ŒChinchilla æ‰©å±•æ³•åˆ™å’Œ KM æ‰©å±•æ³•åˆ™å‡å¯è¿‘ä¼¼è¡¨ç¤ºä¸ºè®¡ç®—åŠ›ä¸»å¯¼çš„å¹‚å¾‹å…³ç³»ï¼š Noptâˆ¼Ca,Doptâˆ¼CbN_{\\text{opt}} \\sim C^a, \\quad D_{\\text{opt}} \\sim C^b Noptâ€‹âˆ¼Ca,Doptâ€‹âˆ¼Cb ä½†äºŒè€…åœ¨æ•°æ®ä¸å‚æ•°çš„æ‰©å±•è¶‹åŠ¿ä¸Šæœ‰æ‰€ä¸åŒï¼š KM æ‰©å±•æ³•åˆ™ï¼ˆaâ‰ˆ0.73,bâ‰ˆ0.27a \\approx 0.73, b \\approx 0.27aâ‰ˆ0.73,bâ‰ˆ0.27ï¼‰ï¼šæ›´å€¾å‘äºå¢åŠ æ¨¡å‹å‚æ•° NNNã€‚ Chinchilla æ‰©å±•æ³•åˆ™ï¼ˆaâ‰ˆ0.46,bâ‰ˆ0.54a \\approx 0.46, b \\approx 0.54aâ‰ˆ0.46,bâ‰ˆ0.54ï¼‰ï¼šä¸»å¼ æ¨¡å‹å‚æ•°ä¸æ•°æ®è§„æ¨¡æ¥è¿‘ç­‰æ¯”ä¾‹å¢é•¿ã€‚ é‡è¦æ„ä¹‰ ä¼˜åŒ–ç®—åŠ›èµ„æºåˆ†é…ï¼šä»¥å¾€é¢„è®­ç»ƒåå‘æ‰©å¤§æ¨¡å‹è§„æ¨¡ï¼Œå¿½è§†æ•°æ®é‡ï¼Œå¦‚ GPT-3ï¼ˆ175B å‚æ•°ï¼‰ä»…ç”¨ 300B è¯å…ƒè®­ç»ƒï¼Œæ•°æ®é‡è¿œæœªè¾¾åˆ°æ¨¡å‹æ€§èƒ½é¥±å’Œç‚¹ã€‚Chinchilla ç ”ç©¶è¡¨æ˜ï¼Œé€‚é‡å¢åŠ æ•°æ®æ¯”å•çº¯å¢å¤§æ¨¡å‹æ›´æœ‰æ•ˆï¼Œå¦‚ Chinchillaï¼ˆ70B å‚æ•°ï¼‰ä½¿ç”¨ 1.4T è¯å…ƒ è®­ç»ƒã€‚ æŒ‘æˆ˜â€œæ›´å¤§æ¨¡å‹=æ›´å¥½â€å‡è®¾ï¼šLLama-2ï¼ˆ7Bï¼‰ç­‰æ–°æ¨¡å‹è¶‹åŠ¿è¡¨æ˜ï¼Œé«˜è´¨é‡æ•°æ®+é€‚å½“è§„æ¨¡çš„æ¨¡å‹ï¼Œè€Œéå•çº¯å¢å¤§å‚æ•°ï¼Œæ‰æ˜¯æå‡æ€§èƒ½çš„å…³é”®ã€‚ Transformer æ¶æ„çš„å±€é™ï¼šå½“å‰å°šæ— å……åˆ†å®éªŒæ”¯æŒæ— é™æ‰©å¤§æ¨¡å‹è§„æ¨¡èƒ½ç»§ç»­æé«˜æ€§èƒ½ï¼Œè€Œé€‚å½“æ‰©å±•æ•°æ®å¯èƒ½æ›´å…·æ€§ä»·æ¯”ã€‚ æ€»ç»“ Chinchilla æ‰©å±•æ³•åˆ™æå‡ºäº†ä¸€ç§æ›´å‡è¡¡çš„å‚æ•°ä¸æ•°æ®å¢é•¿ç­–ç•¥ï¼Œçªç ´äº†å¤§æ¨¡å‹ä»…é å‚æ•°æ‰©å±•çš„æƒ¯æ€§æ€ç»´ï¼Œä¸ºä¼˜åŒ–å¤§è¯­è¨€æ¨¡å‹è®­ç»ƒèµ„æºçš„åˆ†é…æä¾›äº†æ›´ç§‘å­¦çš„æŒ‡å¯¼ã€‚ ä½†æ˜¯æ‰©å±•æ³•åˆ™æ„ä¹‰ä¸å¤§ï¼ˆå•çº¯çº ç»“æ•°å­—ï¼Œï¼‰å› ä¸ºå°æ¨¡å‹åœ¨æ•°æ®é‡æ›´å¤§çš„æƒ…å†µæ•ˆæœä¹Ÿä¼šæ›´å¥½ã€‚ ä¾‹å¦‚ï¼ŒLLaMA-2 (7B) çš„æ¨¡å‹å°±ä½¿ç”¨äº†2T çš„è¯å…ƒè¿›è¡Œè®­ç»ƒï¼Œå¾ˆå¤šæ›´å°çš„æ¨¡å‹ä¹Ÿèƒ½å¤Ÿé€šè¿‡ä½¿ç”¨è¶…å¤§è§„æ¨¡çš„é¢„è®­ç»ƒæ•°æ®è·å¾—è¾ƒå¤§çš„æ¨¡å‹æ€§èƒ½æå‡ã€‚è¿™ç§ç°è±¡çš„ä¸€ä¸ªé‡è¦åŸå› æ˜¯ç”±äºTransformer æ¶æ„å…·æœ‰è¾ƒå¥½çš„æ•°æ®æ‰©å±•æ€§ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œè¿˜æ²¡æœ‰å®éªŒèƒ½å¤Ÿæœ‰æ•ˆéªŒè¯ç‰¹å®šå‚æ•°è§„æ¨¡è¯­è¨€æ¨¡å‹çš„é¥±å’Œæ•°æ®è§„æ¨¡ï¼ˆå³éšç€æ•°æ®è§„æ¨¡çš„æ‰©å±•ï¼Œæ¨¡å‹æ€§èƒ½ä¸å†æå‡ï¼‰ã€‚ 2.2.3 å…³äºæ‰©å±•æ³•åˆ™çš„è®¨è®º å¯é¢„æµ‹çš„æ‰©å±•ï¼š è¾ƒå°ç®—åŠ›èµ„æºé¢„æµ‹è¾ƒå¤§èµ„æºæŠ•å…¥åçš„æ¨¡å‹æ€§èƒ½ ä»»åŠ¡å±‚é¢çš„å¯é¢„æµ‹æ€§ 2.3 æ¶Œç°èƒ½åŠ› åœ¨å°å‹æ¨¡å‹ä¸­ä¸å­˜åœ¨ä½†åœ¨å¤§æ¨¡å‹ä¸­å‡ºç°çš„èƒ½åŠ› å…·ä½“æ˜¯æŒ‡å½“æ¨¡å‹æ‰©å±•åˆ°ä¸€å®šè§„æ¨¡æ—¶ï¼Œæ¨¡å‹çš„ç‰¹å®šä»»åŠ¡æ€§èƒ½çªç„¶å‡ºç°æ˜¾è‘—è·ƒå‡çš„è¶‹åŠ¿ï¼Œè¿œè¶…è¿‡éšæœºæ°´å¹³ã€‚ 2.3.1 ä»£è¡¨æ€§çš„æ¶Œç°èƒ½åŠ› ä¸Šä¸‹æ–‡å­¦ä¹ ï¼š åœ¨æç¤ºä¸­ä¸ºè¯­è¨€æ¨¡å‹æä¾›è‡ªç„¶è¯­è¨€æŒ‡ä»¤å’Œå¤šä¸ªä»»åŠ¡ç¤ºä¾‹ï¼ˆDemonstrationï¼‰ï¼Œæ— éœ€æ˜¾å¼çš„è®­ç»ƒæˆ–æ¢¯åº¦æ›´æ–°ï¼Œä»…è¾“å…¥æ–‡æœ¬çš„å•è¯åºåˆ—å°±èƒ½ä¸ºæµ‹è¯•æ ·æœ¬ç”Ÿæˆé¢„æœŸçš„è¾“å‡ºã€‚ æŒ‡ä»¤éµå¾ªï¼š æŒ‡ä»¤éµå¾ªèƒ½åŠ›æ˜¯æŒ‡å¤§è¯­è¨€æ¨¡å‹èƒ½å¤ŸæŒ‰ç…§è‡ªç„¶è¯­è¨€æŒ‡ä»¤æ¥æ‰§è¡Œå¯¹åº”çš„ä»»åŠ¡[28, 39, 40] é€æ­¥æ¨ç†ï¼š å¤§è¯­è¨€æ¨¡å‹åˆ™å¯ä»¥åˆ©ç”¨æ€ç»´é“¾ï¼ˆChain-of-Thought, CoTï¼‰æç¤ºç­–ç•¥[25] æ¥åŠ å¼ºæ¨ç†æ€§èƒ½ã€‚å…·ä½“æ¥è¯´ï¼Œå¤§è¯­è¨€æ¨¡å‹å¯ä»¥åœ¨æç¤ºä¸­å¼•å…¥ä»»åŠ¡ç›¸å…³çš„ä¸­é—´æ¨ç†æ­¥éª¤æ¥åŠ å¼ºå¤æ‚ä»»åŠ¡çš„æ±‚è§£ï¼Œä»è€Œè·å¾—æ›´ä¸ºå¯é çš„ç­”æ¡ˆã€‚ 2.3.2 æ¶Œç°èƒ½åŠ›ä¸æ‰©å±•æ³•åˆ™çš„å…³ç³» æ‰©å±•æ³•åˆ™ï¼šè¯­è¨€å»ºæ¨¡æŸå¤± æ¶Œç°èƒ½åŠ›ï¼šä»»åŠ¡æ€§èƒ½è¡¡é‡æ¨¡å‹æ€§èƒ½ é¡¿æ‚Ÿï¼šæŒç»­è®­ç»ƒæµ‹è¯•è¯¯å·®çªç„¶ä¸‹é™ 2.4 GPT ç³»åˆ—æ¨¡å‹çš„æŠ€æœ¯æ¼”å˜ è®­ç»ƒèƒ½å¤Ÿå‡†ç¡®é¢„æµ‹ä¸‹ä¸€ä¸ªè¯çš„Transformer ï¼ˆåªåŒ…å«è§£ç å™¨ï¼‰è¯­è¨€æ¨¡å‹ æ‰©å±•è¯­è¨€æ¨¡å‹çš„è§„æ¨¡ä»¥åŠæ‰©å±•é¢„è®­ç»ƒæ•°æ®çš„è§„æ¨¡ã€‚ 2.4.1 æ—©æœŸæ¢ç´¢é˜¶æ®µ GPT-1ï¼šGenerative Pre-Trainingï¼ˆä»…æœ‰è§£ç å™¨çš„ï¼‰å‚æ•°100M GPT-2ï¼šGPT-2 æ²¿ç”¨äº†GPT-1 çš„ç±»ä¼¼æ¶æ„ï¼Œå°†å‚æ•°è§„æ¨¡æ‰©å¤§åˆ°1.5Bï¼Œå¹¶ä½¿ç”¨ å¤§è§„æ¨¡ç½‘é¡µæ•°æ®é›†WebText è¿›è¡Œé¢„è®­ç»ƒã€‚ 2.4.2 è§„æ¨¡æ‰©å±• GPT-3ï¼š175Bï¼Œ100å€çš„å‚æ•°æ‰©å¼ ï¼Œæå‡ºä¸Šä¸‹æ–‡å­¦ä¹ æ¦‚å¿µï¼ˆå»ºç«‹ä»¥æç¤ºå­¦ä¹ æ–¹æ³•ä¸ºåŸºç¡€æŠ€æœ¯è·¯çº¿çš„ä»»åŠ¡æ±‚è§£èŒƒå¼ï¼‰ 2.4.3 èƒ½åŠ›å¢å¼º ä»£ç æ•°æ®è®­ç»ƒï¼šåœ¨ä»£ç æ•°æ®ä¸Šè¿›è¡Œè®­ç»ƒæœ‰åŠ©äºæé«˜GPTæ¨¡å‹çš„ç»¼åˆæ€§èƒ½ äººç±»å¯¹é½ï¼šä½¿ç”¨äººç±»åé¦ˆã€ååŠ©äººç±»è¯„ä¼°ã€è¿›è¡Œå¯¹é½ç ”ç©¶ 2.4.4 æ€§èƒ½è·ƒå‡ ChatGPT GPT-4ï¼šå•æ¨¡æ€å˜å¤šæ¨¡æ€ï¼Œå¹²é¢„ç­–ç•¥ç¼“è§£å¹»è§‰ï¼Œéšç§æ³„æ¼ç­‰é—®é¢˜ï¼Œå¼•å…¥çº¢é˜Ÿæ”»å‡»å‡å°‘ç”Ÿæˆæœ‰æ¯’æœ‰å®³å†…å®¹ã€‚ GPT-4Vï¼ŒGPT-4 Turboä»¥åŠå¤šæ¨¡æ€æ”¯æŒæ¨¡å‹"},{"title":"ç¬¬ 400 åœºå‘¨èµ›","path":"/wiki/LeetCode/å‘¨èµ›/ç¬¬ 400 åœºå‘¨èµ›.html","content":"æ€»ç»“ æœ€å€¼å¾—åšçš„è¿˜æ˜¯æœ€åä¸€é¢˜ï¼Œæœ€åä¸€é¢˜ä½¿ç”¨é›†åˆè®ºçš„æ€æƒ³éå¸¸çš„æœ‰æ„æ€ï¼Œå€¼å¾—æ€»ç»“ã€‚ Q1ï¼š3168. å€™è¯Šå®¤ä¸­çš„æœ€å°‘æ¤…å­æ•° é¢˜ç›®ä¼ é€é—¨ï¼š3168. å€™è¯Šå®¤ä¸­çš„æœ€å°‘æ¤…å­æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å‘¨å¸¸ç­¾åˆ°é¢˜ç›®ï¼Œéå†ä¸€éå³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112class Solution &#123;public: int minimumChairs(string s) &#123; int ans = 0, tmp = 0; for (char &amp;c : s)&#123; if (c == &#x27;E&#x27;) tmp++; else tmp--; ans = max(ans, tmp); &#125; return ans; &#125;&#125;; Q2ï¼š3169. æ— éœ€å¼€ä¼šçš„å·¥ä½œæ—¥ é¢˜ç›®ä¼ é€é—¨ï¼š3169. æ— éœ€å¼€ä¼šçš„å·¥ä½œæ—¥ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å¯¹åŒºé—´è¿›è¡Œä¸€ä¸ªä»å°åˆ°å¤§çš„æ’åºï¼Œç„¶ååˆå¹¶åŒºé—´çš„é€”ä¸­è®¡ç®—åŒºé—´è¦†ç›–çš„å¤©æ•°ï¼Œæœ€åä½¿ç”¨æ€»å¤©æ•°-å¼€ä¼šå¤©æ•°å¾—åˆ°æœ€ç»ˆçš„ç©ºé—²å¤©æ•°ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223class Solution &#123;public: int countDays(int days, vector&lt;vector&lt;int&gt;&gt;&amp; meetings) &#123; int n = meetings.size(); sort(meetings.begin(), meetings.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)&#123; if (a[0]!=b[0]) return a[0] &lt; b[0]; return a[1] &lt; b[1]; &#125;); int meetdays = 0; int start = meetings[0][0], end = meetings[0][1]; for (int i=1;i&lt;n;++i) &#123; if (meetings[i][0] &gt;= start &amp;&amp; meetings[i][0] &lt;= end) &#123; end = max(meetings[i][1], end); &#125; else &#123; meetdays += (end - start + 1); start = meetings[i][0]; end = meetings[i][1]; &#125; &#125; meetdays += (end-start + 1); return days - meetdays; &#125;&#125;; Q3ï¼š3170. åˆ é™¤æ˜Ÿå·ä»¥åå­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸² é¢˜ç›®ä¼ é€é—¨ï¼š3170. åˆ é™¤æ˜Ÿå·ä»¥åå­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸² - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å“ˆå¸Œè¡¨ï¼Œä½¿ç”¨ä¸€å¼ å“ˆå¸Œè¡¨å­˜å‚¨æ¯ç§å­—ç¬¦ï¼ˆ26ä¸ªï¼‰å‡ºç°çš„ä½ç½®ï¼Œéå†å­—ç¬¦ä¸²ï¼Œå‘ç°*æ—¶ï¼Œä»å°åˆ°å¤§éå†å“ˆå¸Œè¡¨ï¼Œä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤æœ€å°å­—ç¬¦æœ€åå‡ºç°çš„ä½ç½®å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728class Solution &#123;public: string clearStars(string s) &#123; int n = s.size(); vector&lt;bool&gt; vis(100003,true); vector&lt;vector&lt;int&gt;&gt; mp(26); for (int i=0; i&lt;n; ++i) &#123; char c = s[i]; if (c != &#x27;*&#x27;) mp[c-&#x27;a&#x27;].push_back(i); else &#123; vis[i] = false; for (auto &amp;loc : mp) &#123; if (loc.size()) &#123; int nn = loc.size(); vis[loc[nn-1]] = false; loc.pop_back(); break; &#125; &#125; &#125; &#125; string ans = &quot;&quot;; for(int i=0; i&lt;n; ++i )&#123; if (vis[i]) ans += s[i]; &#125; return ans; &#125;&#125;; Q4ï¼š3171. æ‰¾åˆ°æŒ‰ä½æˆ–æœ€æ¥è¿‘ K çš„å­æ•°ç»„ é¢˜ç›®ä¼ é€é—¨ï¼š3171. æ‰¾åˆ°æŒ‰ä½æˆ–æœ€æ¥è¿‘ K çš„å­æ•°ç»„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ é¢˜è§£å‚è€ƒâ€çµèŒ¶å±±è‰¾åºœâ€œ æš´åŠ›ç®—æ³•éå¸¸å®¹æ˜“æƒ³åˆ°ï¼ŒåŒå±‚å¾ªç¯è®¡ç®—æ‰€æœ‰å¯èƒ½çš„æˆ–å³å¯ã€‚ ä»å·¦åˆ°å³æ­£å‘éå† numsnumsnumsï¼Œå¯¹äº x=nums[i]x = nums[i]x=nums[i]ï¼Œä» iâˆ’1i - 1iâˆ’1 å¼€å§‹å€’ç€éå† nums[j]nums[j]nums[j]ï¼Œæ›´æ–° nums[j]=nums[j]âˆ£xnums[j] = nums[j] | xnums[j]=nums[j]âˆ£xã€‚ i=1i = 1i=1 æ—¶ï¼Œæˆ‘ä»¬ä¼šæŠŠ nums[0]nums[0]nums[0] åˆ° nums[1]nums[1]nums[1] çš„ OR è®°å½•åœ¨ nums[0]nums[0]nums[0] ä¸­ã€‚ i=2i = 2i=2 æ—¶ï¼Œæˆ‘ä»¬ä¼šæŠŠ nums[1]nums[1]nums[1] åˆ° nums[2]nums[2]nums[2] çš„ OR è®°å½•åœ¨ nums[1]nums[1]nums[1] ä¸­ï¼Œnums[0]nums[0]nums[0] åˆ° nums[2]nums[2]nums[2] çš„ OR è®°å½•åœ¨ nums[0]nums[0]nums[0] ä¸­ã€‚ i=3i = 3i=3 æ—¶ï¼Œæˆ‘ä»¬ä¼šæŠŠ nums[2]nums[2]nums[2] åˆ° nums[3]nums[3]nums[3] çš„ OR è®°å½•åœ¨ nums[2]nums[2]nums[2] ä¸­ï¼›nums[1]nums[1]nums[1] åˆ° nums[3]nums[3]nums[3] çš„ OR è®°å½•åœ¨ nums[1]nums[1]nums[1] ä¸­ï¼›nums[0]åˆ°nums[3]nums[0] åˆ° nums[3]nums[0]åˆ°nums[3] çš„ OR è®°å½•åœ¨ nums[0]nums[0]nums[0] ä¸­ã€‚ æŒ‰ç…§è¯¥ç®—æ³•ï¼Œå¯ä»¥è®¡ç®—å‡ºæ‰€æœ‰å­æ•°ç»„çš„ ORã€‚æ³¨æ„å•ä¸ªå…ƒç´ ä¹Ÿç®—å­æ•°ç»„ã€‚ O(n2)O(n^2)O(n2)å¤æ‚åº¦ï¼Œå¾ˆæ˜æ˜¾ä¼šè¶…æ—¶ï¼Œæ‰€ä»¥éœ€è¦ä¼˜åŒ–ã€‚ æˆ‘ä»¬å°†è¿™ä¸ªé—®é¢˜çœ‹æˆä¸€ä¸ªé›†åˆçš„é—®é¢˜ï¼Œé‚£ä¹ˆæˆ–è¿ç®—å°±å¯ä»¥å½“ä½œæ˜¯é›†åˆæ±‚å¹¶é›†æ“ä½œã€‚ è¿›è¡Œæ¥ä¸‹æ¥çš„æ¨ç†éœ€è¦ç‰¢è®°ä¸‹é¢è¿™ä¸ªå®šç†ï¼š å¯¹äºä¸¤ä¸ªäºŒè¿›åˆ¶æ•°aaa,bbb,å¦‚æœaâˆ£b=aa|b=aaâˆ£b=a,ä»é›†åˆçš„è§’åº¦ä¸Šçœ‹ï¼Œbbbå¯¹åº”çš„é›†åˆæ˜¯aaaå¯¹åº”çš„é›†åˆçš„å­é›†ã€‚ äºæ˜¯æˆ‘ä»¬å¯ä»¥å¯¹ä¸Šé¢çš„æš´åŠ›è§£æ³•åšå‡ºå¦‚ä¸‹ä¼˜åŒ–ï¼š ä»ç„¶æ˜¯ä»å·¦åˆ°å³æ­£å‘éå†numsï¼Œå¯¹äºx=nums[i]ï¼Œä»i-1å¼€å§‹å€’ç€éå†nums[j]: nums[j]âˆ£xâ‰ nums[j]nums[j]|x eq nums[j]nums[j]âˆ£xî€ =nums[j]ï¼Œè¯´æ˜nums[j]çš„é›†åˆå¯ä»¥ç»§ç»­æ‰©å±•ï¼Œåˆ™æ›´æ–°nums[j]=nums[j]âˆ£xnums[j] = nums[j]|xnums[j]=nums[j]âˆ£x å¦åˆ™nums[j]âˆ£x=nums[j]nums[j]|x=nums[j]nums[j]âˆ£x=nums[j],æ­¤æ—¶æˆ‘ä»¬å¯ä»¥å¾—å‡ºç»“è®ºï¼Œxxxä¸ä»…æ˜¯nums[j]nums[j]nums[j]çš„å­é›†ï¼Œä¹Ÿæ˜¯nums[k](k&lt;j)nums[k](k&lt;j)nums[k](k&lt;j)çš„å­é›†ï¼ˆå¯ä»¥é€šè¿‡æ”¹å˜æ±‚å¹¶é›†é¡ºåºè¯æ˜ï¼‰ï¼Œå‘ç°ç­‰äºååé¢çš„è®¡ç®—å°±å¯ä»¥ä¸ç”¨è¿›è¡Œäº†ï¼Œå› ä¸ºç»“æœéƒ½ä¸€æ ·ï¼Œæå‰é€€å‡ºå¾ªç¯ã€‚ åœ¨å¾ªç¯ä¸­è®°å¾—ç”¨âˆ£nums[j]âˆ’kâˆ£|nums[j]-k|âˆ£nums[j]âˆ’kâˆ£æ›´æ–°ç­”æ¡ˆçš„æœ€å°å€¼ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617class Solution &#123;public: int minimumDifference(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); int ans = abs(k-nums[0]); for(int i=0;i&lt;n;++i)&#123; ans = min(ans, abs(nums[i]-k)); for(int j=i-1;j&gt;=0;--j)&#123; int tmp = nums[j] | nums[i]; if (nums[j]==tmp) break; ans = min(abs(tmp-k), ans); nums[j] = tmp; &#125; &#125; return ans; &#125;&#125;; æ—¶é—´å¤æ‚åº¦: O(nlogU)O(n log U)O(nlogU)ï¼Œå…¶ä¸­ nnn æ˜¯ numsnumsnums çš„é•¿åº¦ï¼ŒU=max(nums)U = max(nums)U=max(nums)ã€‚ç”±äº 229âˆ’1&lt;109&lt;230âˆ’12^{29} - 1 &lt; 10^9 &lt; 2^{30} - 1229âˆ’1&lt;109&lt;230âˆ’1ï¼ŒäºŒè¿›åˆ¶æ•°å¯¹åº”é›†åˆçš„å¤§å°ä¸ä¼šè¶…è¿‡ 292929ï¼Œå› æ­¤åœ¨ OR è¿ç®—ä¸‹ï¼Œæ¯ä¸ªæ•°å­—è‡³å¤šå¯ä»¥å¢åŠ  292929 æ¬¡ã€‚æ€»ä½“ä¸Šçœ‹ï¼ŒäºŒé‡å¾ªç¯çš„æ€»å¾ªç¯æ¬¡æ•°ç­‰äºæ¯ä¸ªæ•°å­—å¯ä»¥å¢å¤§çš„æ¬¡æ•°ä¹‹å’Œï¼Œå³ O(nlogU)O(n log U)O(nlogU)ã€‚"},{"title":"ç¬¬ 401 åœºå‘¨èµ›","path":"/wiki/LeetCode/å‘¨èµ›/ç¬¬ 401 åœºå‘¨èµ›.html","content":"æ€»ç»“ ç¬¬å››é¢˜ä½œä¸ºç¬¬ä¸‰é¢˜çš„å»¶ç”³ï¼Œå­¦ä¹ åˆ°äº†ä½¿ç”¨bitsetå¯¹DPé—®é¢˜è¿›è¡Œä¼˜åŒ–çš„æŠ€å·§ Q1ï¼š3178. æ‰¾å‡º K ç§’åæ‹¿ç€çƒçš„å­©å­ é¢˜ç›®ä¼ é€é—¨ï¼š3178. æ‰¾å‡º K ç§’åæ‹¿ç€çƒçš„å­©å­ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011class Solution &#123;public: int numberOfChild(int n, int k) &#123; int res = k % ((n-1)*2); if (res &gt; n-1) &#123; res -= (n-1); return n-1-res; &#125; return res; &#125;&#125;; Q2ï¼š3179. K ç§’åç¬¬ N ä¸ªå…ƒç´ çš„å€¼ é¢˜ç›®ä¼ é€é—¨ï¼š3179. K ç§’åç¬¬ N ä¸ªå…ƒç´ çš„å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜*2 æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415class Solution &#123;public: int valueAfterKSeconds(int n, int k) &#123; vector&lt;int&gt; a(n,1); int MOD = 1e9 + 7; for(int i=1;i&lt;=k;++i)&#123; int nw = 0; for(int j=0;j&lt;n;++j)&#123; a[j] = (a[j] + nw)%MOD; nw = a[j]; nw = nw % MOD; &#125; &#125; return a[n-1]; &#125;&#125;; Q3ï¼š3180. æ‰§è¡Œæ“ä½œå¯è·å¾—çš„æœ€å¤§æ€»å¥–åŠ± I é¢˜ç›®ä¼ é€é—¨ï¼š3180. æ‰§è¡Œæ“ä½œå¯è·å¾—çš„æœ€å¤§æ€»å¥–åŠ± I - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æœ‰ç‚¹æ„æ€çš„ä¸€é“é¢˜,å¯¹äºrewardValuesä¸­çš„æ•°ï¼Œå¦‚æœå…ˆé€‰å¤§çš„ï¼Œå°±æ²¡æ³•å†é€‰å°çš„ï¼Œæ‰€ä»¥æŒ‰ç…§ä»å°åˆ°å¤§çš„é¡ºåºé€‰æ˜¯æœ€å¥½çš„ã€‚ æ’åºåé—®é¢˜å˜ä¸ºäº†ä¸€ä¸ª01èƒŒåŒ…é—®é¢˜ï¼Œå®šä¹‰dp[i]dp[i]dp[i]è¡¨ç¤ºçš„æ˜¯èƒ½å¦é€‰åˆ°å¥–åŠ±ä¸ºiï¼Œåˆå§‹æ¡ä»¶dp[0]=trueã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920class Solution &#123;public: int maxTotalReward(vector&lt;int&gt;&amp; rewardValues) &#123; sort(rewardValues.begin(),rewardValues.end()); vector&lt;bool&gt; dp(300000,false);dp[0]=true; int maxx = 0; for(auto rewardValue : rewardValues)&#123; for(int i=min(maxx,rewardValue-1);i&gt;=0;--i)&#123; if (dp[i]) &#123; dp[rewardValue+i] = true; maxx = max(rewardValue+i,maxx); &#125; &#125; &#125; for(int i=maxx;i&gt;=0;--i)&#123; if (dp[i]) return i; &#125; return 0; &#125;&#125;; Q4ï¼š3181. æ‰§è¡Œæ“ä½œå¯è·å¾—çš„æœ€å¤§æ€»å¥–åŠ± II é¢˜ç›®ä¼ é€é—¨ï¼š3181. æ‰§è¡Œæ“ä½œå¯è·å¾—çš„æœ€å¤§æ€»å¥–åŠ± II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¯¥é¢˜ç›¸æ¯”ä¸Šä¸€é¢˜å°±æ˜¯æ•°æ®èŒƒå›´å˜å¤§äº†ä¸€äº›ï¼Œä»2000å˜ä¸ºäº†50000ï¼Œå› æ­¤ä¸Šä¸€é¢˜çš„åšæ³•æ— æ³•ç›´æ¥ç”¨è¿›æ¥ï¼Œéœ€è¦ä¸€äº›ä¼˜åŒ–ã€‚è§‚å¯Ÿåˆ°æˆ‘ä»¬çš„DPæ•°ç»„æ˜¯ä¸€ä¸ªboolæ•°ç»„ï¼Œå› æ­¤è€ƒè™‘å¯ä»¥ç”¨bitsetè¿›è¡Œä¼˜åŒ–ã€‚ å°†bool DPæ•°ç»„è½¬åŒ–ä¸ºä¸€ä¸ªäºŒè¿›åˆ¶æ•°åï¼Œé€‰æ‹©æ•°Vç›¸å½“äºæŠŠå½“å‰äºŒè¿›åˆ¶åVé¡¹å·¦ç§»Vä½å’Œå½“å‰é¡¹è¿›è¡Œæˆ–è¿ç®— å› ä¸ºPythonå¯¹å¤§æ•°æ”¯æŒå¾ˆå¥½æ‰€ä»¥å…ˆå±•ç¤ºPythonä»£ç ï¼š 12345678class Solution: def maxTotalReward(self, rewardValues: List[int]) -&gt; int: rewardValues.sort() dp = 1 for rewardValue in rewardValues: mask = (1&lt;&lt;rewardValue) - 1 # ç”Ÿæˆmaské€‰å–æœ€åvä¸ªé¡¹ dp |= (dp&amp;mask)&lt;&lt;rewardValue return dp.bit_length() - 1 CPPç”±äºä¸æ”¯æŒå¤§æ•°ä¸èƒ½åƒPythonä¸€æ ·å®ç°çš„è¿™ä¹ˆç›´æ¥ï¼Œéœ€è¦ä½¿ç”¨bitsetåº“ï¼Œbitsetåº“è¯¦ç»†ç”¨æ³•è§C++æ•™ç¨‹æ ç›®ã€‚ æ­¤å¤–è¿˜éœ€æ³¨æ„çš„æ˜¯ï¼Œå¯¹äºmaskçš„ç”Ÿæˆä¸èƒ½åƒPythonä¸€æ ·å…ˆå®šä¹‰ä¸€ä¸ªå…¨1 maskè¿›è¡Œæ±‚å¹¶é›†è¿ç®—ï¼Œè€Œæ˜¯è¦é‡‡ç”¨å…ˆå·¦ç§»åå³ç§»çš„æ–¹å¼ã€‚ CPPæœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314class Solution &#123;public: int maxTotalReward(vector&lt;int&gt;&amp; rewardValues) &#123; sort(rewardValues.begin(), rewardValues.end()); bitset&lt;100000&gt; dp(1); for (auto rewardValue : rewardValues) &#123; int shift = dp.size() - rewardValue; dp |= (dp&lt;&lt;shift&gt;&gt;shift)&lt;&lt;rewardValue; &#125; for(int i=rewardValues.back()*2-1;;i--)&#123; if(dp.test(i)) return i; &#125; &#125;&#125;; æ—¶é—´å¤æ‚åº¦ æ—¶é—´å¤æ‚åº¦ä¸Šï¼Œä½¿ç”¨bitsetä¼˜åŒ–çš„DPç›¸æ¯”åŸæ¥çš„æ•°ç»„DPèƒ½å¤Ÿæä¾›32å€åˆ°64å€é€Ÿåº¦ä¸Šçš„ä¼˜åŒ–ï¼ˆå–å†³äºæœºå™¨æ˜¯32ä½è¿˜æ˜¯64ä½çš„ï¼‰"},{"title":"ç¬¬ 402 åœºå‘¨èµ›","path":"/wiki/LeetCode/å‘¨èµ›/ç¬¬ 402 åœºå‘¨èµ›.html","content":"æ€»ç»“ æˆåŠŸAKäº†ï¼Œæœ€åä¸€é¢˜æ˜¯ä¸€é“æ•°æ®ç»“æ„æ¿å­é¢˜ï¼Œä½†æ˜¯æ²¡å‚èµ›æœ‰ç‚¹å¯æƒœã€‚ Q1ï¼š3184. æ„æˆæ•´å¤©çš„ä¸‹æ ‡å¯¹æ•°ç›® I é¢˜ç›®ä¼ é€é—¨ï¼š3184. æ„æˆæ•´å¤©çš„ä¸‹æ ‡å¯¹æ•°ç›® I - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾ä¸ªåˆ° æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112class Solution &#123;public: int countCompleteDayPairs(vector&lt;int&gt;&amp; hours) &#123; int n = hours.size(), ans=0; for(int i=0;i&lt;n;++i)&#123; for(int j=i+1;j&lt;n;++j)&#123; if((hours[i]+hours[j])%24==0) ans++; &#125; &#125; return ans; &#125;&#125;; Q2ï¼š3185. æ„æˆæ•´å¤©çš„ä¸‹æ ‡å¯¹æ•°ç›® II é¢˜ç›®ä¼ é€é—¨ï¼š3185. æ„æˆæ•´å¤©çš„ä¸‹æ ‡å¯¹æ•°ç›® II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å“ˆå¸Œä¸€ä¸‹ï¼Œç­¾åˆ°Ã—2 æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314class Solution &#123;public: long long countCompleteDayPairs(vector&lt;int&gt;&amp; hours) &#123; int n = hours.size(); for(int i=0;i&lt;n;++i) hours[i] = hours[i] % 24; long long ans = 0; vector&lt;long long&gt; dp(24,0); for(int i=0;i&lt;n;++i)&#123; ans += dp[(24-hours[i])%24]; dp[hours[i]]++; &#125; return ans; &#125;&#125;; Q3ï¼š3186. æ–½å’’çš„æœ€å¤§æ€»ä¼¤å®³ é¢˜ç›®ä¼ é€é—¨ï¼š3186. æ–½å’’çš„æœ€å¤§æ€»ä¼¤å®³ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ‰“å®¶åŠ«èˆè¶…çº§åŠ å¼ºç‰ˆï¼Œä½¿ç”¨ä¸€ä¸ªæ•°ç»„é¢„å¤„ç†ä¸€ä¸‹å°±å¥½ï¼ˆæ’åºåï¼Œç›¸åŒçš„åˆå¹¶ï¼‰ï¼Œè¯¦ç»†å®ç°è§ä»£ç ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223class Solution &#123;public: long long maximumTotalDamage(vector&lt;int&gt;&amp; power) &#123; int n = power.size(); sort(power.begin(), power.end()); vector&lt;pair&lt;long long,long long&gt;&gt; nw_power; int prev = -1,m=0; for(int i=0;i&lt;n;++i)&#123; if (power[i]==prev) nw_power[m-1].second += power[i]; else nw_power.emplace_back(power[i], power[i]), prev = power[i], m++; &#125; vector&lt;long long&gt; dp(m+3,0); dp[1] = nw_power[0].second; for(int i=2;i&lt;=m;++i)&#123; long long nw_pw = nw_power[i-1].first; long long val = nw_power[i-1].second; int j = i-2; while(j&gt;=0&amp;&amp;(nw_power[j].first==nw_pw-1||nw_power[j].first==nw_pw-2)) j--; dp[i] = max(dp[i-1], dp[j+1]+val); &#125; return dp[m]; &#125;&#125;; Q4ï¼š3187. æ•°ç»„ä¸­çš„å³°å€¼ é¢˜ç›®ä¼ é€é—¨ï¼š3187. æ•°ç»„ä¸­çš„å³°å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ çº¿æ®µæ ‘å¤§æ³•å¥½ï¼è¿™é‡Œçœ‹ç€å°±éå¸¸åƒçº¿æ®µæ ‘æ¿é¢˜ï¼Œä½†æ˜¯è¿˜æ˜¯æœ‰åŒºåˆ«ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯åˆå¹¶åŒºé—´çš„æ—¶å€™ï¼ˆå·¦ä¾§åŒºé—´å³ç«¯ç‚¹æˆ–è€…å³ä¾§åŒºé—´å·¦ç«¯ç‚¹ï¼‰å¯èƒ½ä¼šäº§ç”Ÿæ–°çš„å³°å€¼ï¼Œéœ€è¦å†™ä¸€ä¸ªå‡½æ•°è¿›è¡Œåˆ¤å®šã€‚è¿™ä¸ªå‡½æ•°çš„å†™æ³•ä¹Ÿæœ‰è®²ç©¶ï¼Œå› ä¸ºåœ¨æœ€ååˆå¹¶å°åŒºé—´çš„æ—¶å€™ï¼Œä¸åŒåŒºé—´çš„é•¿åº¦å¯èƒ½å†³å®šäº†ä¸¤ä¸ªç«¯ç‚¹èƒ½å¦å½“ç«¯ç‚¹ï¼Œä¸¾ä¸ªä¾‹å­ï¼š å·¦ 3ï¼Œ å³ 2 è¿›è¡Œåˆå¹¶å’Œ å·¦1 3 å³2è¿›è¡Œåˆå¹¶ï¼Œäº§ç”Ÿçš„å³°å€¼æ•°æ˜¯ä¸åŒçš„ã€‚ å› æ­¤è¯¥å‡½æ•°éœ€è¦ä¼ å…¥åˆå¹¶æ—¶æ€»åŒºé—´çš„å·¦ä¾§å’Œå³ä¾§è¾¹ç•Œä½ç½®ï¼š 123456int judge(int k,int l,int r,vector&lt;int&gt;&amp; arr)&#123;\tint loc = node[k*2].right;\tif (loc-1&gt;=l&amp;&amp;arr[loc]&gt;arr[loc-1]&amp;&amp;arr[loc]&gt;arr[loc+1]) return 1;\tif (loc+2&lt;=r&amp;&amp;arr[loc+1]&gt;arr[loc]&amp;&amp;arr[loc+1]&gt;arr[loc+2]) return 1;\treturn 0;&#125; æŸ¥è¯¢çš„æ—¶å€™ä¹Ÿå’Œä¼ ç»Ÿçš„çº¿æ®µæ ‘ä¸å¤ªç›¸åŒï¼Œéœ€è¦ç‰¹åˆ«æ³¨æ„æŸ¥è¯¢ä¼ å…¥çš„åŒºé—´å·¦å³ä½ç½®ï¼š 123456789int queryAns(int k, int l,int r,vector&lt;int&gt;&amp; arr)&#123;\tif (l==node[k].left&amp;&amp;node[k].right==r) return node[k].val;\tint mid = node[k].left + (node[k].right-node[k].left)/2;\tint ans = 0;\tif (r&lt;=mid) ans = queryAns(k*2,l,r,arr);\telse if (l&gt;mid) ans = queryAns(k*2+1,l,r,arr);\telse ans = queryAns(k*2,l,mid,arr)+queryAns(k*2+1,mid+1,r,arr)+judge(k,l,r,arr);\treturn ans;&#125; æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;private: struct TreeNode&#123; int val, left, right; TreeNode() : val(0), left(-1), right(-1) &#123;&#125; &#125;; vector&lt;TreeNode&gt; node; int judge(int k,int l,int r,vector&lt;int&gt;&amp; arr)&#123; int loc = node[k*2].right; if (loc-1&gt;=l&amp;&amp;arr[loc]&gt;arr[loc-1]&amp;&amp;arr[loc]&gt;arr[loc+1]) return 1; if (loc+2&lt;=r&amp;&amp;arr[loc+1]&gt;arr[loc]&amp;&amp;arr[loc+1]&gt;arr[loc+2]) return 1; return 0; &#125; void update(int k,vector&lt;int&gt;&amp; arr)&#123; node[k].val = node[k*2].val + node[k*2+1].val + judge(k,node[k].left,node[k].right,arr); &#125; void buildTree(int k,int l,int r,vector&lt;int&gt;&amp; arr)&#123; node[k].left = l; node[k].right = r; if(l==r) return; int mid = l + (r-l)/2; buildTree(k*2,l,mid,arr); buildTree(k*2+1,mid+1,r,arr); update(k, arr); &#125; int queryAns(int k, int l,int r,vector&lt;int&gt;&amp; arr)&#123; if (l==node[k].left&amp;&amp;node[k].right==r) return node[k].val; int mid = node[k].left + (node[k].right-node[k].left)/2; int ans = 0; if (r&lt;=mid) ans = queryAns(k*2,l,r,arr); else if (l&gt;mid) ans = queryAns(k*2+1,l,r,arr); else ans = queryAns(k*2,l,mid,arr)+queryAns(k*2+1,mid+1,r,arr)+judge(k,l,r,arr); return ans; &#125; void modify(int k,int index,int val,vector&lt;int&gt;&amp; arr)&#123; if(node[k].left == node[k].right &amp;&amp; node[k].left == index) &#123; arr[index] = val; return;&#125; int mid = node[k].left + (node[k].right-node[k].left)/2; if(index&lt;=mid) modify(k*2,index,val,arr); else modify(k*2+1,index,val,arr); update(k, arr); &#125;public: Solution() : node(300005) &#123;&#125; vector&lt;int&gt; countOfPeaks(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123; int root = 1, n = nums.size(); buildTree(root, 0, n-1, nums); vector&lt;int&gt; ans; for(auto query : queries)&#123; if(query[0]==1) ans.push_back(queryAns(root, query[1], query[2], nums)); else modify(root, query[1], query[2], nums); &#125; return ans; &#125;&#125;; è¿™ä¹Ÿæ˜¯ç¬¬ä¸€æ¬¡ä¸ªäººåœ¨ç±»é‡Œå®ç°å¹³çº§å‡½æ•°ï¼ˆä¹‹å‰éƒ½æ˜¯ä½¿ç”¨çš„å‡½æ•°åµŒå¥—ï¼‰"},{"title":"ç¬¬ 405 åœºå‘¨èµ›","path":"/wiki/LeetCode/å‘¨èµ›/ç¬¬ 405 åœºå‘¨èµ›.html","content":"æ€»ç»“ å‰ä¸‰é¢˜æ¯”è¾ƒåŸºç¡€ï¼Œç¬¬ä¸‰é¢˜æ˜¯ä¸€ä¸ªå‰ç¼€å’Œï¼Œå› ä¸ºä¹‹å‰è§è¿‡æ‰€ä»¥å¾ˆå¿«å°±è¿‡äº†ã€‚æœ€åä¸€é¢˜å¼ƒç–—äº†ï¼Œçœ‹ä¸Šå»åƒä¸€ä¸ªDPä¼˜åŒ–é—®é¢˜ï¼Œä½†æ˜¯ç¡®å®å®åŠ›é™åˆ¶æ²¡æœ‰æƒ³å‡ºæ¥ï¼Œå‡†å¤‡å¬ä¸€ä¸‹è®²è§£ã€‚ Q1ï¼š100339. æ‰¾å‡ºåŠ å¯†åçš„å­—ç¬¦ä¸² é¢˜ç›®ä¼ é€é—¨ï¼šæ‰¾å‡ºåŠ å¯†åçš„å­—ç¬¦ä¸² - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011class Solution &#123;public: string getEncryptedString(string s, int k) &#123; int n = s.size(); string ans = s; for(int i=0;i&lt;n;++i)&#123; ans[i] = s[(i+k)%n]; &#125; return ans; &#125;&#125;; Q2ï¼š100328. ç”Ÿæˆä¸å«ç›¸é‚»é›¶çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸² é¢˜ç›®ä¼ é€é—¨ï¼šç”Ÿæˆä¸å«ç›¸é‚»é›¶çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸² - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æœ¬æ¥ä»¥ä¸ºæ˜¯ä¸€é“DPï¼ˆä½†åº”è¯¥ä¹Ÿå¯ä»¥å§ï¼‰ï¼Œä¸€çœ‹æ•°æ®èŒƒå›´æœæ–­æš´æœã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314class Solution &#123;public: vector&lt;string&gt; validStrings(int n) &#123; vector&lt;string&gt; ans; function&lt;void(int,int,string)&gt; dfs = [&amp;](int now,int last,string tmp)&#123; if(now==n) &#123;ans.push_back(tmp);return;&#125; dfs(now+1,1,tmp+&#x27;1&#x27;); if(last==1) dfs(now+1,0,tmp+&#x27;0&#x27;); &#125;; dfs(0,1,&quot;&quot;); return ans; &#125;&#125;; Q3ï¼š100359. ç»Ÿè®¡ X å’Œ Y é¢‘æ•°ç›¸ç­‰çš„å­çŸ©é˜µæ•°é‡ é¢˜ç›®ä¼ é€é—¨ï¼šç»Ÿè®¡ X å’Œ Y é¢‘æ•°ç›¸ç­‰çš„å­çŸ©é˜µæ•°é‡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å‰ç¼€å’Œé¢˜ç›® æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718class Solution &#123;public: int numberOfSubmatrices(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; int n = grid.size(), m = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1, 0)); vector&lt;vector&lt;bool&gt;&gt; vis(n+1,vector&lt;bool&gt;(m+1, false)); int ans = 0; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; int nw = grid[i-1][j-1]==&#x27;.&#x27;?0:(grid[i-1][j-1]==&#x27;X&#x27;?1:-1); dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + nw; vis[i][j] = vis[i-1][j] | vis[i][j-1] | (nw!=0); if (dp[i][j]==0&amp;&amp;vis[i][j]) ans++; &#125; &#125; return ans; &#125;&#125;; Q4ï¼š100350. æœ€å°ä»£ä»·æ„é€ å­—ç¬¦ä¸² é¢˜ç›®ä¼ é€é—¨ï¼šæœ€å°ä»£ä»·æ„é€ å­—ç¬¦ä¸² - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åšä¸æ¥å‘œå‘œå‘œğŸ˜­ å®˜æ–¹ç»™å‡ºçš„è§£æ³•æ˜¯ä½¿ç”¨å­—å…¸æ ‘ï¼Œä½†æ˜¯çµç¥æŠŠä»–Hackäº†ã€‚ å­—å…¸æ ‘åšæ³•æ ¸å¿ƒæ€æƒ³å°±æ˜¯ç”¨å­—å…¸æ ‘è¿™ä¸ªæ•°æ®ç»“æ„ä¼˜åŒ–æˆ‘ä»¬æ¯æ¬¡çš„å­—ç¬¦ä¸²åŒ¹é…é—®é¢˜ æ­£è§£æ˜¯ä½¿ç”¨å­—ç¬¦ä¸²å“ˆå¸Œ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1"},{"title":"ç¬¬ 406 åœºå‘¨èµ›","path":"/wiki/LeetCode/å‘¨èµ›/ç¬¬ 406 åœºå‘¨èµ›.html","content":"æ€»ç»“ å½»åº•å¤±è´¥å¥½å§ï¼Œåé¢ä¸¤ä¸ªé¢˜ç¡®å®æ²¡è€ƒè™‘æ¸…æ¥šã€‚è¿™ä¸‹è¦æ‰å¤§åˆ†å’¯ğŸ˜­ğŸ˜­ğŸ˜­ Q1ï¼š100352. äº¤æ¢åå­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸² é¢˜ç›®ä¼ é€é—¨ï¼š100352. äº¤æ¢åå­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸² - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ—¥å¸¸ç­¾åˆ°é¢˜ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516class Solution &#123;public: string getSmallestString(string s) &#123; int n = s.size(); for(int i=1;i&lt;n;++i)&#123; int a = s[i-1]-&#x27;0&#x27;, b = s[i]-&#x27;0&#x27;; if (a%2==b%2&amp;&amp;b&lt;a) &#123; char tmp = s[i]; s[i] = s[i-1]; s[i-1] = tmp; break; &#125; &#125; return s; &#125;&#125;; Q2ï¼š100368. ä»é“¾è¡¨ä¸­ç§»é™¤åœ¨æ•°ç»„ä¸­å­˜åœ¨çš„èŠ‚ç‚¹ é¢˜ç›®ä¼ é€é—¨ï¼š100368. ä»é“¾è¡¨ä¸­ç§»é™¤åœ¨æ•°ç»„ä¸­å­˜åœ¨çš„èŠ‚ç‚¹ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ é“¾è¡¨é¢˜ï¼Œé“¾è¡¨å¥½ä¹…æ²¡å†™äº†è¿˜å¡äº†ä¸€ä¸‹ğŸ˜­ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* modifiedList(vector&lt;int&gt;&amp; nums, ListNode* head) &#123; vector&lt;bool&gt; vis(100003, false); for(auto num : nums) vis[num] = true; ListNode *hhead = new ListNode(-1, head); ListNode *tmp = head; ListNode *prev = hhead; while (tmp!=nullptr) &#123; while (tmp!=nullptr&amp;&amp;vis[tmp-&gt;val]) tmp = tmp-&gt;next; prev-&gt;next = tmp; prev = tmp; if (tmp!=nullptr)tmp = tmp-&gt;next; &#125; return hhead-&gt;next; &#125;&#125;; ä»¥ä¸Šä¸ºè€ƒè¯•æ—¶å®ç°çš„ä»£ç ï¼Œç¬¬22è¡Œéœ€è¦æ³¨æ„è¦åˆ¤æ–­ä¸€ä¸‹ï¼Œä¸ç„¶ä¼šæœ‰nullptrå»æŒ‡ä¸‹ä¸€ä¸ªçš„æƒ…å†µã€‚ ä¸Šé¢çš„ä»£ç è¿˜æ˜¯å¤ªä¸‘äº†ï¼Œcopyä¸€ä¸ªæ ‡å‡†ç­”æ¡ˆï¼Œä»¥åå¯ä»¥è¿™ä¹ˆå†™é€»è¾‘ä¼šæ›´æ¸…æ™°ä¸€äº›ã€‚ 12345678910111213141516class Solution &#123;public: ListNode* modifiedList(vector&lt;int&gt;&amp; nums, ListNode* head) &#123; unordered_set&lt;int&gt; st(nums.begin(), nums.end()); ListNode dummy(0, head); ListNode* cur = &amp;dummy; while (cur-&gt;next) &#123; // ä»ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹çœ‹ if (st.contains(cur-&gt;next-&gt;val)) &#123; cur-&gt;next = cur-&gt;next-&gt;next; // åˆ é™¤ &#125; else &#123; cur = cur-&gt;next; // å‘åç§»åŠ¨ &#125; &#125; return dummy.next; &#125;&#125;; æ³¨æ„ï¼šLeetCodeä¸­çš„é“¾è¡¨é¢˜éƒ½æ˜¯æ²¡æœ‰å“¨å…µèŠ‚ç‚¹çš„ï¼ï¼ï¼ Q3ï¼š100361. åˆ‡è›‹ç³•çš„æœ€å°æ€»å¼€é”€ I é¢˜ç›®ä¼ é€é—¨ï¼š100361. åˆ‡è›‹ç³•çš„æœ€å°æ€»å¼€é”€ I - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åˆ’åˆ†å‹é—®é¢˜ï¼Œå¯ä»¥ç”¨äºŒç»´DPæ€æƒ³æ¥åšï¼Œä½†æ˜¯ç”¨åˆ°ç¬¬å››é¢˜ä¼šè¶…æ—¶ã€‚ ç¡®å®ï¼Œå¬å®Œäº†çµç¥çš„è§£æï¼Œæ­¤é¢˜å°±æ˜¯ä¸€é“è´ªå¿ƒï¼Œè€ƒè¯•çš„æ—¶å€™å¤§ä½“æ€è·¯æ˜¯å¯¹çš„ï¼Œè´ªå¿ƒæœ‰ä¸€ä¸ªåœ°æ–¹å†™é”™äº†å¯¼è‡´æ­¤é¢˜æ²¡æœ‰åšå‡ºæ¥ï¼Œç¡®å®ä¹Ÿæ˜¯è€ƒè¯•çš„æ—¶å€™æ€è€ƒä¸å¤Ÿç»†è‡´å¯¼è‡´çš„ï¼Œè¿™ä¸ªè¿˜éœ€å¤šåŠ ç»ƒä¹ ã€‚ è§£å†³è¿™é¢˜åˆæ­¥éœ€è¦æƒ³åˆ°ï¼š æ¯æ¡è¾¹éƒ½ä¼šè¢«åˆ‡å®Œ æ¨ªåˆ‡çš„ä»£ä»·æ˜¯ï¼Œå½“å‰ç«–å—æ•° * æ¨ªåˆ‡æ¶ˆè€— ç«–åˆ‡çš„ä»£ä»·æ˜¯ï¼Œå½“å‰æ¨ªå—æ•° * ç«–åˆ‡æ¶ˆè€— æ­¤é¢˜ä¼šä½¿ç”¨äº¤æ¢è®ºè¯æ³•è¿™ç§æ€æƒ³ï¼Œå…·ä½“è¯æ˜è¿˜æ˜¯æ¨èçµç¥çš„é¢˜è§£ï¼šè´ªå¿ƒåŠå…¶è¯æ˜ï¼šäº¤æ¢è®ºè¯æ³•ï¼ˆPython/Java/C++/Goï¼‰ ä»€ä¹ˆæ˜¯äº¤æ¢è®ºè¯æ³•å‘¢ï¼Ÿå…·ä½“è€Œè¨€å°±æ˜¯æˆ‘ä»¬å°†è¿™ä¸ªå¤§é—®é¢˜å…ˆç®€åŒ–ä¸ºè®¨è®ºç›¸é‚»ä¸¤ä¸ªå†³ç­–çš„æ€§è´¨ï¼ˆè®¨è®ºäº¤æ¢å†³ç­–é¡ºåºå¯¹æœ€ç»ˆç»“æœé€ æˆçš„å½±å“ï¼‰ï¼Œå¯¹äºæœ¬é¢˜ä¸€ä¸ªæ“ä½œåºåˆ—ä¸éš¾æƒ³åˆ°ï¼š äº¤æ¢ç›¸é‚»ä¸¤ä¸ªæ¨ªåˆ‡æ“ä½œï¼Œå¯¹æœ€ç»ˆç­”æ¡ˆä¸ä¼šæœ‰å½±å“ åŒç†ï¼Œäº¤æ¢ç›¸é‚»ä¸¤ä¸ªç«–åˆ‡æ“ä½œï¼Œå¯¹æœ€ç»ˆç­”æ¡ˆä¹Ÿä¸ä¼šé€ æˆå½±å“ å› æ­¤å…³é”®éœ€è¦è®¨è®ºäº¤æ¢ä¸¤ä¸ªä¸åŒçš„æ“ä½œï¼Œæˆ‘ä»¬è®¾è¿™ä¸¤ä¸ªæ“ä½œçš„ä»£ä»·åˆ†åˆ«æ˜¯ï¼šç«–åˆ‡costVcostVcostVå’Œæ¨ªåˆ‡costHcostHcostHï¼Œåœ¨è¿›è¡Œè¿™ä¸¤ä¸ªæ“ä½œä¹‹å‰ï¼Œå·²ç»æœ‰cntHcntHcntHä¸ªæ¨ªå—ï¼ŒcntVcntVcntVä¸ªç«–å—ã€‚ä¸éš¾å¾—çŸ¥å…ˆæ‰§è¡Œæ¨ªåˆ‡å†æ‰§è¡Œç«–åˆ‡åˆ™æ‰€éœ€è€—è´¹çš„ä»£ä»·æ˜¯ï¼š costHÃ—cntV+costVÃ—(cntH+1)costH \\times cntV + costV \\times (cntH+1) costHÃ—cntV+costVÃ—(cntH+1) åŒç†ï¼Œå…ˆæ‰§è¡Œç«–åˆ‡å†æ‰§è¡Œæ¨ªåˆ‡æ‰€è€—è´¹çš„ä»£ä»·æ˜¯ï¼š costVÃ—cntH+costHÃ—(cntV+1)costV\\times cntH + costH\\times (cntV+1) costVÃ—cntH+costHÃ—(cntV+1) å¦‚æœå…ˆæ‰§è¡Œç«–åˆ‡å†æ‰§è¡Œæ¨ªåˆ‡ä¼šæœ‰æ›´å°çš„ä»£ä»·,ä¸éš¾åˆ—å‡ºä¸‹é¢çš„å¼å­ï¼š costVÃ—cntH+costHÃ—(cntV+1)&lt;costHÃ—cntV+costVÃ—(cntH+1)costV\\times cntH + costH\\times (cntV+1) &lt; costH \\times cntV + costV \\times (cntH+1) costVÃ—cntH+costHÃ—(cntV+1)&lt;costHÃ—cntV+costVÃ—(cntH+1) åŒ–ç®€å¾—ï¼š costH&lt;costVcostH &lt; costV costH&lt;costV è¿™æ„å‘³ç€ï¼Œæ— è®ºæ°´å¹³åˆ‡å‰²è¿˜æ˜¯å‚ç›´åˆ‡å‰²ï¼Œä¼˜å…ˆåˆ‡å¼€é”€è¾ƒå¤§çš„é‚£æ¡çº¿ï¼Œå¹¶ä¸”è¿™ä¸ªä¼˜å…ˆé¡ºåºä¸æ°´å¹³å’Œå‚ç›´åˆ‡å‰²çš„æ¬¡æ•°ï¼ˆcntVcntVcntV,cntHcntHcntHï¼‰æ— å…³ã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœæŒ‰ç…§è¿™ä¸ªè§„åˆ™è¿›è¡Œåˆ‡å‰²ï¼Œå°†å¼€é”€è¾ƒå¤§çš„æ“ä½œç§»åŠ¨åˆ°åé¢ï¼Œä¼šå¯¼è‡´æ€»å¼€é”€æ›´å¤§ã€‚ è¿™ä¸‹è¿™ä¸ªé—®é¢˜è½¬å˜ä¸ºäº†ä¸€ä¸ªä½¿ç”¨åŒæŒ‡é’ˆå®ç°çš„è´ªå¿ƒé—®é¢˜ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627class Solution &#123;public: int minimumCost(int m, int n, vector&lt;int&gt;&amp; horizontalCut, vector&lt;int&gt;&amp; verticalCut) &#123; int cnt_vert = 1,cnt_horz = 1,ans=0; priority_queue&lt;int&gt; horiz,verti; for(auto cut : horizontalCut) horiz.push(cut); for(auto cut : verticalCut) verti.push(cut); while (!horiz.empty()&amp;&amp;!verti.empty()) &#123; if (horiz.top() &lt; verti.top()) &#123; ans += verti.top()*cnt_horz; cnt_vert++; verti.pop(); &#125; else &#123; ans += horiz.top()*cnt_vert; cnt_horz++; horiz.pop(); &#125; &#125; while (!horiz.empty())&#123; ans += horiz.top()*cnt_vert; cnt_horz++; horiz.pop(); &#125; while (!verti.empty())&#123; ans += verti.top()*cnt_horz; cnt_vert++; verti.pop(); &#125; return ans; &#125;&#125;; Q4ï¼š100367. åˆ‡è›‹ç³•çš„æœ€å°æ€»å¼€é”€ II é¢˜ç›®ä¼ é€é—¨ï¼š100367. åˆ‡è›‹ç³•çš„æœ€å°æ€»å¼€é”€ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åŒQ3 æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728class Solution &#123;public: long long minimumCost(int m, int n, vector&lt;int&gt;&amp; horizontalCut, vector&lt;int&gt;&amp; verticalCut) &#123; int cnt_vert = 1,cnt_horz = 1; long long ans=0; priority_queue&lt;int&gt; horiz,verti; for(auto cut : horizontalCut) horiz.push(cut); for(auto cut : verticalCut) verti.push(cut); while (!horiz.empty()&amp;&amp;!verti.empty()) &#123; if (horiz.top() &lt; verti.top()) &#123; ans += verti.top()*cnt_horz; cnt_vert++; verti.pop(); &#125; else &#123; ans += horiz.top()*cnt_vert; cnt_horz++; horiz.pop(); &#125; &#125; while (!horiz.empty())&#123; ans += horiz.top()*cnt_vert; cnt_horz++; horiz.pop(); &#125; while (!verti.empty())&#123; ans += verti.top()*cnt_horz; cnt_vert++; verti.pop(); &#125; return ans; &#125;&#125;;"},{"title":"ç¬¬ 407 åœºå‘¨èµ›","path":"/wiki/LeetCode/å‘¨èµ›/ç¬¬ 407 åœºå‘¨èµ›.html","content":"æ€»ç»“ å› ä¸ºæ—©ä¸Šè¦å¼€ä¼šï¼Œæ‰€ä»¥å¹¶æ²¡æœ‰å‚åŠ è¯¥åœºå‘¨èµ›ï¼Œæœ‰ç‚¹å¯æƒœï¼Œä¸‹é¢å°±æ¥åšä¸€ä¸‹ã€‚ å‰ä¸‰é¢˜è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œä½†æ˜¯å‰ä¸¤é¢˜åšçš„æ—¶å€™éƒ½å…ˆé”™äº†ä¸€ééå¸¸çš„å¯æƒœï¼Œè¯´æ˜è‡ªå·±ä»£ç èƒ½åŠ›è¿˜æ˜¯ä¸å¤Ÿçš„ç†Ÿç»ƒéœ€è¦ç»§ç»­é”»ç‚¼ã€‚ ç¬¬å››é¢˜å·®åˆ†æ•°ç»„é¢˜ç›®ï¼Œä¹‹å‰æ²¡æœ‰è§è¿‡ï¼Œä½†æ˜¯æ„Ÿè§‰æ˜¯ä¸€ä¸ªæ¨¡æ¿å¯ä»¥è®°å¿†ä¸€ä¸‹ã€‚ Q1ï¼š100372. ä½¿ä¸¤ä¸ªæ•´æ•°ç›¸ç­‰çš„ä½æ›´æ”¹æ¬¡æ•° é¢˜ç›®ä¼ é€é—¨ï¼š100372. ä½¿ä¸¤ä¸ªæ•´æ•°ç›¸ç­‰çš„ä½æ›´æ”¹æ¬¡æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ é”»ç‚¼ä¸€ä¸‹äºŒè¿›åˆ¶èƒ½åŠ›ï¼Œç­¾åˆ°é¢˜ç›®ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415class Solution &#123;public: int minChanges(int n, int k) &#123; int ans = 0; while(n||k)&#123; int a = n&amp;1, b = k&amp;1; if (a^b)&#123; if (a==0) return -1; ans++; &#125; n = n&gt;&gt;1; k = k&gt;&gt;1; &#125; return ans; &#125;&#125;; Q2ï¼š100335. å­—ç¬¦ä¸²å…ƒéŸ³æ¸¸æˆ é¢˜ç›®ä¼ é€é—¨ï¼š100335. å­—ç¬¦ä¸²å…ƒéŸ³æ¸¸æˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è„‘ç­‹æ€¥è½¬å¼¯ï¼Œåšçš„æ—¶å€™è¿˜é”™äº†ä¸€æ¬¡ğŸ˜‚ï¼Œ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213class Solution &#123;public: bool doesAliceWin(string s) &#123; int ans = 0; for(char c : s)&#123; if (c==&#x27;a&#x27;||c==&#x27;e&#x27;||c==&#x27;i&#x27;||c==&#x27;o&#x27;||c==&#x27;u&#x27;) ans++; &#125; if (ans==0) return false; if (ans==1) return true; if (ans==2) return true; return true; &#125;&#125;; Q3ï¼š100360. å°† 1 ç§»åŠ¨åˆ°æœ«å°¾çš„æœ€å¤§æ“ä½œæ¬¡æ•° é¢˜ç›®ä¼ é€é—¨ï¼š100360. å°† 1 ç§»åŠ¨åˆ°æœ«å°¾çš„æœ€å¤§æ“ä½œæ¬¡æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡æ‹Ÿé¢˜ï¼Œä»å¤´å¼€å§‹éå†ï¼Œè®°å½•1çš„ä¸ªæ•°ï¼Œç¢°åˆ°0æ—¶ï¼Œå°±è¦æŠŠå‰é¢æ‰€æœ‰çš„1å¾€åç§»åŠ¨ç›´åˆ°ç¢°åˆ°ä¸‹ä¸€ä¸ª1æˆ–è€…æœ«å°¾ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112class Solution &#123;public: int maxOperations(string s) &#123; int cnt=0, ans=0; bool flag = true; for (char c : s) &#123; if(c==&#x27;1&#x27;) flag=true, cnt++; if(c==&#x27;0&#x27;&amp;&amp;flag) flag=false, ans += cnt; &#125; return ans; &#125;&#125;; Q4ï¼š100329. ä½¿æ•°ç»„ç­‰äºç›®æ ‡æ•°ç»„æ‰€éœ€çš„æœ€å°‘æ“ä½œæ¬¡æ•° é¢˜ç›®ä¼ é€é—¨ï¼š100329. ä½¿æ•°ç»„ç­‰äºç›®æ ‡æ•°ç»„æ‰€éœ€çš„æœ€å°‘æ“ä½œæ¬¡æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™ä¸ªé¢˜åšå‡ºæ¥è¿æ°”æˆåˆ†æ¯”è¾ƒå¤§ï¼Œè§‚å¯Ÿé¢˜ç›®å‘ç°æ˜¯å¯¹å­æ•°ç»„ï¼ˆå…·æœ‰è¿ç»­æ€§ï¼‰è¿›è¡Œæ“ä½œï¼Œå°±å°†å·®åˆ†æ•°ç»„å°±ç›´æ¥æ‹¿æ¥ç”¨äº†ã€‚ æ ¸å¿ƒæ€æƒ³ï¼šé€šè¿‡å·®åˆ†æ•°ç»„ï¼ŒæŠŠå¯¹å­æ•°ç»„çš„æ“ä½œï¼Œè½¬æ¢æˆä¸¤ä¸ªä½ç½®çš„å˜åŒ–ï¼Œè®¡ç®—target[i]-nums[i]çš„å·®åˆ†æ•°ç»„ï¼Œåˆ†æè¿™ä¸ªå·®åˆ†æ•°ç»„éœ€è¦çš„æ“ä½œæ¬¡æ•° æ•´ä½“æ­¥éª¤åˆ†ä¸ºå¦‚ä¸‹3æ­¥ï¼š è®¡ç®—target[i]-nums[i]å¾—åˆ°ä¸€ä¸ªæ•°ç»„aï¼Œç›¸å½“äºæˆ‘éœ€è¦ä¸€ä¸ªå…¨ä¸º0çš„æ•°ç»„ï¼Œæ“ä½œæˆæ•°ç»„a æ±‚açš„å·®åˆ†æ•°ç»„ï¼ŒåŸæ¥çš„æ¯æ¬¡å­æ•°ç»„æ“ä½œï¼ˆä¸€å †ï¼‰è½¬åŒ–æˆæ¯æ¬¡ä¸¤ä¸ªä½ç½®çš„æ“ä½œ ä»å·¦åˆ°å³éå†å·®åˆ†æ•°ç»„ï¼Œç»Ÿè®¡æ“ä½œæ¬¡æ•°ï¼ˆç»Ÿè®¡ç›¸åŒç¬¦å·çš„å’Œå³å¯ï¼‰ ä¸ºä»€ä¹ˆåªç»Ÿè®¡ç›¸åŒç¬¦å·çš„å’Œå³å¯ï¼Ÿ ç”±äºæ¯æ¬¡æ“ä½œä¼šäº§ç”Ÿä¸€ä¸ªÂ +1Â å’Œä¸€ä¸ªÂ âˆ’1ï¼Œæ‰€ä»¥æ“ä½œæ¬¡æ•°å°±ç­‰äºæ‰€æœ‰æ­£æ•°Â d[i]Â ä¹‹å’Œã€‚ æœ€åå®ç°çš„ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415class Solution &#123;public: long long minimumOperations(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; target) &#123; int n = nums.size(); vector&lt;int&gt; op_nums(n), op_diff(n+1,0); for (int i=0; i&lt;n; ++i) &#123; op_nums[i] = target[i] - nums[i]; &#125;op_diff[0] = op_nums[0]; for(int i=1;i&lt;n;++i) op_diff[i] = op_nums[i] - op_nums[i-1]; op_diff[n] = 0 - op_nums[n-1]; long long ans = 0; for(int i=0;i&lt;=n;++i)&#123; if (op_diff[i]&gt;0) ans += op_diff[i]; &#125; return ans; &#125;&#125;;"},{"title":"ç¬¬ 408 åœºå‘¨èµ›","path":"/wiki/LeetCode/å‘¨èµ›/ç¬¬ 408 åœºå‘¨èµ›.html","content":"æ€»ç»“ æ ¹æ®çµç¥æ€»ç»“çš„è§„å¾‹ï¼Œæœç„¶è¿™å‘¨çš„å‘¨èµ›éå¸¸çš„éš¾ï¼ŒQ1å‘¨å¸¸ç­¾åˆ°é¢˜ä¸å¤šèµ˜è¿°ï¼ŒQ2å…ˆçœ‹å‡ºæ¥ç‰¹æ®Šæ•°æ˜¯å¹³æ–¹æ•°ï¼Œä½†æ˜¯å¤§æ„äº†æ²¡ä»”ç»†æƒ³åªæ˜¯è´¨æ•°å¹³æ–¹æ‰è¡Œï¼Œå› æ­¤WAäº†ä¸€å‘ã€‚Q3è€ƒè¯•çš„æ—¶å€™æ„Ÿè§‰æ˜¯ä¸€ä¸ªO(nn)O(n\\sqrt{n})O(nnâ€‹)æˆ–è€…O(nlogâ¡n)O(n\\log n)O(nlogn)çš„åšæ³•ï¼Œæ„Ÿè§‰æ˜¯æš´åŠ›ä½†æ˜¯å¸¦ä¼˜åŒ–ï¼ˆå‰ªæï¼Ÿï¼‰,ä½†æ˜¯æ²¡æƒ³å‡ºæ¥ğŸ˜‚ã€‚è€ƒè¯•æœ€åçš„æ—¶é—´ä¸»è¦åœ¨æ”»å…‹Q4ï¼Œçœ‹å‡ºæ¥è§„å¾‹æ˜¯åˆ¤å®šè¿é€šå—+åˆ¤å®šåœ†å’Œè¾¹ç•Œæ˜¯å¦ç›¸äº¤ï¼Œä½†æ˜¯æœ€åç”±äºé‡‡ç”¨çš„æ˜¯DFSåˆ¤è¿é€šï¼ŒREäº†å¯¼è‡´æ²¡è¿‡ã€‚ æœ¬æ¬¡å‘¨èµ›åªé€šè¿‡äº†å‰ä¸¤é¢˜ï¼Œä½†ä¾ç„¶å’Œä¹‹å‰ä¸€æ ·æ’å600+ï¼Œè¯´æ˜æœ€åä¸¤é¢˜æ˜¯éå¸¸æœ‰å«é‡‘é‡çš„å¯ä»¥å¥½å¥½æ€»ç»“ä¸€ä¸‹ã€‚ Q1ï¼š3232. åˆ¤æ–­æ˜¯å¦å¯ä»¥èµ¢å¾—æ•°å­—æ¸¸æˆ é¢˜ç›®ä¼ é€é—¨ï¼š3232. åˆ¤æ–­æ˜¯å¦å¯ä»¥èµ¢å¾—æ•°å­—æ¸¸æˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å‘¨å¸¸ç­¾åˆ°é¢˜ï¼Œéå†ä¸€éå³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112class Solution &#123;public: bool canAliceWin(vector&lt;int&gt;&amp; nums) &#123; int sum_num = 0,sum_sing = 0; for(auto num : nums)&#123; sum_num += num; if (num &lt; 10) sum_sing += num; &#125; return sum_num - sum_sing == sum_sing?false:true; &#125;&#125;; Q2ï¼š3233. ç»Ÿè®¡ä¸æ˜¯ç‰¹æ®Šæ•°å­—çš„æ•°å­—æ•°é‡ é¢˜ç›®ä¼ é€é—¨ï¼š3233. ç»Ÿè®¡ä¸æ˜¯ç‰¹æ®Šæ•°å­—çš„æ•°å­—æ•°é‡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è´¨æ•°é¢„å¤„ç†+å•æ¬¡åŒºé—´æŸ¥è¯¢ï¼Œè¿™é“é¢˜å°±å¼€å§‹ä¸Šå¼ºåº¦äº†ï¼Œä»”ç»†ç†è§£é¢˜ç›®åä¸éš¾å‘ç°ï¼Œæ»¡è¶³ç‰¹æ®Šæ•°å­—çš„è¦æ±‚æ˜¯ï¼šå½“ä¸”ä»…å½“å½“å‰æ•°æ˜¯ä¸€ä¸ªè´¨æ•°å¹³æ–¹æ—¶ï¼Œæ‰èƒ½æ°å¥½æœ‰ä¸¤ä¸ªçœŸå› å­ã€‚ è´¨æ•°é¢„å¤„ç†éƒ¨åˆ†ï¼Œç”±äºæ•°æ®èŒƒå›´æ˜¯1e9ï¼Œå› æ­¤ä¸èƒ½ç”¨æš´åŠ›è¿›è¡Œé¢„å¤„ç†ï¼Œå¯ä»¥ä½¿ç”¨åŸƒæ°ç­›æˆ–è€…æ¬§æ‹‰ç­›ï¼Œè´¨æ•°ç­›æ³•è®²è§£è¯¦æƒ…è§OI-Knowledgeä¸“é¢˜æ•°å­¦éƒ¨åˆ†ã€‚ å•æ¬¡åŒºé—´æŸ¥è¯¢ç›´æ¥éå†ä¸€éå°±å¯ä»¥äº†ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930class Solution &#123;public: int nonSpecialCount(int l, int r) &#123; int n = 100000; vector&lt;bool&gt; is_prime(n+1, true); vector&lt;int&gt; primes; for (int i = 2; i &lt;= n; ++i) &#123; if (is_prime[i]) &#123; primes.push_back(i); &#125; for (int j = 0; j &lt; primes.size() &amp;&amp; i * primes[j] &lt;= n; ++j) &#123; is_prime[i * primes[j]] = false; if (i % primes[j] == 0) &#123; break; &#125; &#125; &#125; vector&lt;long long&gt; speics; for(auto prime : primes)&#123; speics.push_back((long long)prime*prime); &#125; int all_num = r-l+1; int ll = 0; while (speics[ll]&lt;l)ll++; int rr = ll; while (speics[rr]&lt;=r)rr++; return all_num - (rr-ll); &#125;&#125;; Q3ï¼š3234. ç»Ÿè®¡ 1 æ˜¾è‘—çš„å­—ç¬¦ä¸²çš„æ•°é‡ é¢˜ç›®ä¼ é€é—¨ï¼š3234. ç»Ÿè®¡ 1 æ˜¾è‘—çš„å­—ç¬¦ä¸²çš„æ•°é‡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æš´åŠ›ä¼˜åŒ–ï¼Œè®¾å­—ç¬¦ä¸²é•¿ä¸ºnï¼Œå…¶ä¸­æœ‰cnt0ä¸ª0ï¼Œcnt1ä¸ª1ï¼Œè¦æ‰¾çš„å­ä¸²éœ€è¦æ»¡è¶³çš„æ¡ä»¶æ˜¯cnt0*cnt0 &lt;= cnt1,åˆå·²çŸ¥cnt1 &lt;= nï¼Œæ‰€ä»¥ä¸éš¾æ¨å‡ºcnt0 &lt;= sqrt(n)ã€‚ å†æ¬¡è§‚å¯Ÿnçš„å–å€¼èŒƒå›´ï¼Œå¯ä»¥å‘ç°n&lt;1e4å¯ä»¥æ‰¿å—ä¸€ä¸ªsqrt(n)ä¸‰æ¬¡æ–¹æ—¶é—´å¤æ‚åº¦çš„ç®—æ³•ï¼Œä¸éš¾æƒ³åˆ°ä¼˜åŒ–æš´åŠ›éœ€è¦å’Œ0çš„ä¸ªæ•°ç‰µæ‰¯ä¸Šå…³ç³»ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1 Q4ï¼š é¢˜ç›®ä¼ é€é—¨ï¼š æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1"},{"title":"2023å¹´11æœˆæ¯æ—¥ä¸€é¢˜","path":"/wiki/LeetCode/æ¯æ—¥ä¸€é¢˜/2023å¹´11æœˆæ¯æ—¥ä¸€é¢˜.html","content":"2023-11-22 é¢˜ç›®ä¼ é€é—¨ï¼š2304. ç½‘æ ¼ä¸­çš„æœ€å°è·¯å¾„ä»£ä»· - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“æ¯”è¾ƒç®€å•çš„dpåˆ·è¡¨é¢˜ï¼š 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int minPathCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt;&gt;&amp; moveCost) &#123; int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for(int i=0;i&lt;n;++i) dp[0][i] = grid[0][i]; for(int i=1;i&lt;m;++i)&#123; for(int j=0;j&lt;n;++j)&#123; for(int k=0;k&lt;n;++k)&#123; if(k==0) dp[i][j] = dp[i-1][k] + moveCost[grid[i-1][k]][j] + grid[i][j]; else dp[i][j] = min(dp[i][j],dp[i-1][k] + moveCost[grid[i-1][k]][j] + grid[i][j]); &#125; &#125; &#125; int maxx = dp[m-1][0]; for(int i=0;i&lt;n;++i) maxx = min(maxx,dp[m-1][i]); return maxx; &#125;&#125;;int main()&#123; vector&lt;vector&lt;int&gt;&gt; grid = &#123;&#123;5,3&#125;,&#123;4,0&#125;,&#123;2,1&#125;&#125;,moveCost = &#123;&#123;9,8&#125;,&#123;1,5&#125;,&#123;10,12&#125;,&#123;18,6&#125;,&#123;2,4&#125;,&#123;14,3&#125;&#125;; cout&lt;&lt;Solution().minPathCost(grid,moveCost)&lt;&lt;endl; return 0;&#125; 2023-11-24 é¢˜ç›®ä¼ é€é—¨ï¼š2824. ç»Ÿè®¡å’Œå°äºç›®æ ‡çš„ä¸‹æ ‡å¯¹æ•°ç›® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ éå¸¸åŸºæœ¬çš„ä¸€é“ç­¾åˆ°é¢˜ç›® 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int countPairs(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(),cnt=0; for(int i=0;i&lt;n;++i)&#123; for(int j=i+1;j&lt;n;++j)&#123; if(nums[i]+nums[j] &lt; target) ++cnt; &#125; &#125; return cnt; &#125;&#125;;int main() &#123; vector&lt;int&gt; nums = &#123;-1, 1, 2, 3, 1&#125;; int target = 2; cout&lt;&lt;Solution().countPairs(nums, target); return 0;&#125;"},{"title":"2023å¹´12æœˆæ¯æ—¥ä¸€é¢˜","path":"/wiki/LeetCode/æ¯æ—¥ä¸€é¢˜/2023å¹´12æœˆæ¯æ—¥ä¸€é¢˜.html","content":"2023-12-01 é¢˜ç›®ä¼ é€é—¨ï¼š2661. æ‰¾å‡ºå æ¶‚å…ƒç´  - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æœ¬é¢˜ä¸»è¦å°±æ˜¯ä¸€ä¸ªå“ˆå¸Œè¡¨çš„æ€æƒ³ï¼Œå…ˆä½¿ç”¨ä¸€ä¸ªmapæ•°æ®ç»“æ„å°†æ¯ä¸ªå…ƒç´ å’Œä»–çš„äºŒç»´ä½ç½®å¯¹åº”èµ·æ¥ï¼Œè¿™æ ·å¯ä»¥å®ç°O(1)æŸ¥è¯¢ï¼Œç„¶åè®¾ç½®ä¸¤ä¸ªæ•°ç»„å¤§å°ä¸ºæ¯è¡Œæ¯åˆ—ï¼Œè®°å½•å½“å‰è¡Œåˆ—è¿˜å‰©çš„æ²¡æŸ“è‰²çš„æ ¼å­çš„æ•°é‡ï¼Œç„¶åéå†arrä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œæ›´æ–°å…ƒç´ å¯¹åº”è¡Œåˆ—å‰©ä½™æœªæŸ“è‰²æ ¼å­çš„ä¸ªæ•°ã€‚å½“å‘ç°å½“å‰å…ƒç´ å¯¹åº”è¡Œåˆ—æœ‰ä¸€ä¸ªæœªæŸ“è‰²æ ¼å­å‰©ä½™é‡ä¸º0æ—¶ï¼Œè¾“å‡ºå³å¯ã€‚ 1234567891011121314151617181920class Solution &#123;public: int firstCompleteIndex(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123; int m = mat.size(), n =mat[0].size(); vector&lt;int&gt; row(m,n); vector&lt;int&gt; col(n,m); map&lt;int,pair&lt;int,int&gt;&gt; mp; for(int i=0;i&lt;m;++i)&#123; for(int j=0;j&lt;n;++j)&#123; mp[mat[i][j]] = pair&lt;int, int&gt;(i,j); &#125; &#125; for(int i=0;i&lt;m*n;++i)&#123; int x = mp[arr[i]].first, y = mp[arr[i]].second; row[x]--; col[y]--; if (row[x]==0||col[y]==0) return i; &#125; return m*n-1; &#125;&#125;; 2023-12-02 é¢˜ç›®ä¼ é€é—¨ï¼š1094. æ‹¼è½¦ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“éå¸¸ç»å…¸çš„å·®åˆ†æ•°ç»„é¢˜ï¼Œå…ˆå¯¹ä¸Šä¸‹è½¦ç«™ç‚¹è¿›è¡Œæ’åºï¼Œç„¶åç»´æŠ¤ä¸€ä¸ªä»¥ç«™ç‚¹ä¸ºç´¢å¼•çš„å·®åˆ†æ•°ç»„ï¼Œå‰ç¼€å’Œä»£è¡¨è½¦åˆ°è¾¾å½“å‰ç«™ç‚¹æ—¶ï¼Œè½¦ä¸Šçš„ä¹˜å®¢æ•°ï¼Œä¹˜å®¢æ•°å¤§äºcapacityå³ä¸è¡Œï¼Œå¦åˆ™å°±å¯ä»¥ã€‚ 1234567891011121314151617181920212223class Solution &#123;public: bool carPooling(vector&lt;vector&lt;int&gt;&gt;&amp; trips, int capacity) &#123; vector&lt;int&gt; pass_now(1001,0); // è¿™é‡Œéœ€è¦æ’ä¸€ä¸ªåº sort(trips.begin(),trips.end(),[](vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b)&#123; if(a[1] == b[1])return a[2]&lt;b[2]; else return a[1]&lt;b[1]; &#125;); int max_dis = 0; for(auto &amp;trip:trips)&#123; pass_now[trip[1]] += trip[0]; pass_now[trip[2]] -= trip[0]; max_dis = max(max_dis,trip[2]); &#125; int now = 0; for(int i=0;i&lt;=max_dis;i++)&#123; now += pass_now[i]; if(now&gt;capacity)return false; &#125; return true; &#125;&#125;; 2023-12-03 é¢˜ç›®ä¼ é€é—¨ï¼š1423. å¯è·å¾—çš„æœ€å¤§ç‚¹æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è„‘ç­‹æ€¥è½¬å¼¯é¢˜ç›®ï¼Œæ—¢ç„¶è¦è®©æˆ‘ä»¬æ±‚ä¸¤è¾¹å–çš„æœ€å¤§ï¼Œé‚£ä¹ˆå°±æ˜¯è®©æˆ‘ä»¬åè¿‡æ¥å–ä¸­é—´çš„æœ€å°ã€‚è¿™æ ·å°±ä»å–ä¸è¿ç»­çš„æ•°å˜æˆå–è¿ç»­çš„äº†ã€‚ 123456789101112131415161718class Solution &#123;public: int maxScore(vector&lt;int&gt;&amp; cardPoints, int k) &#123; int sum_point = 0,n = cardPoints.size(); for(auto &amp;cardPoint:cardPoints)sum_point+=cardPoint; int res = n-k; int minn,capa=0,now=0; for(int i=0;i&lt;n;++i)&#123; if (capa&lt;res) now += cardPoints[i], capa += 1; else &#123; if(i == res) minn = now; now = now - cardPoints[i-res] + cardPoints[i]; minn = min(minn,now); &#125; &#125; return sum_point - minn; &#125;&#125;; 2023-12-04 é¢˜ç›®ä¼ é€é—¨ï¼š1038. ä»äºŒå‰æœç´¢æ ‘åˆ°æ›´å¤§å’Œæ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä»Šå¤©çš„é¢˜è¿˜æ˜¯æœ‰ç‚¹æ„æ€ï¼Œå€Ÿæœºå­¦ä¹ ä¸€ä¸‹C++æŒ‡é’ˆç‰ˆæœ¬çš„äºŒå‰æ ‘å¦‚ä½•ä¹¦å†™, é¢˜ç›®è¦æ±‚æˆ‘ä»¬å°†æ¯ä¸ªèŠ‚ç‚¹çš„å€¼æ›¿æ¢ä¸ºå€¼å¤§äºç­‰äºå½“å‰èŠ‚ç‚¹å€¼çš„å’Œï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™æˆ‘ä»¬å¯ä»¥ç¨å¾®æ€è€ƒä¸€ä¸‹äºŒå‰æ ‘çš„æ€§è´¨ï¼Œä¸éš¾å‘ç°ï¼Œæˆ‘ä»¬è¿›è¡Œåå‘ä¸­åºéå†æ—¶ï¼Œç”Ÿæˆçš„éå†åºåˆ—å°±æ˜¯ä»å¤§åˆ°å°çš„ä¸€ä¸ªæ’åºã€‚é‚£ä¹ˆæˆ‘ä»¬æŒ‰ç…§è¿™ä¸ªé¡ºåºæ›´æ–°æ¯ä¸€ä¸ªèŠ‚ç‚¹å³å¯ã€‚ 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int sumnow = 0; TreeNode* bstToGst(TreeNode* root) &#123; if (root!=nullptr) &#123; if (root-&gt;right!=nullptr) bstToGst(root-&gt;right); sumnow += root-&gt;val; root-&gt;val = sumnow; if (root-&gt;left!=nullptr) bstToGst(root-&gt;left); &#125; return root; &#125;&#125;; 2023-12-05 é¢˜ç›®ä¼ é€é—¨ï¼š2477. åˆ°è¾¾é¦–éƒ½çš„æœ€å°‘æ²¹è€— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä»Šå¤©çš„é¢˜ç›®è¿˜æ˜¯æœ‰ç‚¹æ„æ€ï¼Œæ„Ÿè§‰æ˜¯ä¹‹å‰ä¸€ä¸ªå‘¨èµ›æ²¡åšå‡ºæ¥çš„é¢˜ç›®ï¼Œå› ä¸ºé¢˜ç›®ä¸­è¿˜æ˜¯æœ‰ä¸€äº›ç»†èŠ‚éœ€è¦æ³¨æ„ï¼Œè¿™é‡Œå°±ç¨å¾®æ¢³ç†ä¸€ä¸‹ã€‚ é¦–å…ˆå­¦ä¹ äº†C++å†…åµŒå‡½æ•°çš„å†™æ³•ã€‚ æ¨¡æ¿å†™æ³•å¤§æ¦‚å¦‚ä¸‹æ‰€ç¤ºï¼š 1function&lt;int(int, int)&gt; dfs = [&amp;](int u,int fa) -&gt; int &#123; ä¸Šé¢çš„ä»£ç ï¼Œå®šä¹‰äº†ä¸€ä¸ªåä¸º dfs çš„å‡½æ•°ï¼Œå®ƒæ¥å—ä¸¤ä¸ªæ•´æ•°å‚æ•° u å’Œ faï¼Œè¿”å›ä¸€ä¸ªæ•´æ•°å€¼ã€‚è¿™ä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªåŒ¿åå‡½æ•°ï¼ˆå³æ²¡æœ‰åç§°çš„å‡½æ•°ï¼‰ï¼Œå®ƒæ˜¯ä¸€ä¸ªæ¨¡æ¿å‡½æ•°ï¼Œæ¨¡æ¿å‚æ•° int(int, int) è¡¨ç¤ºè¯¥å‡½æ•°æ¥å—ä¸¤ä¸ªæ•´æ•°å‚æ•°å¹¶è¿”å›ä¸€ä¸ªæ•´æ•°å€¼ã€‚ ä»£ç ä¸­çš„ -&gt; ç¬¦å·è¡¨ç¤ºå‡½æ•°çš„è¿”å›ç±»å‹ï¼Œå®ƒä½äºå‡½æ•°å®šä¹‰çš„æœ«å°¾ã€‚int(int, int) æ˜¯å‡½æ•°çš„å‚æ•°ç±»å‹ï¼Œint è¡¨ç¤ºè¿”å›å€¼ç±»å‹ï¼Œint å’Œ int åˆ†åˆ«è¡¨ç¤ºä¸¤ä¸ªå‚æ•°çš„ç±»å‹ã€‚ [&amp;](int u,int fa) -&gt; int è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªå·¦å€¼å¼•ç”¨æ•è·çš„åŒ¿åå‡½æ•°ï¼Œå®ƒæ•è·äº†å‡½æ•°å¤–éƒ¨çš„å˜é‡ u å’Œ fa çš„å¼•ç”¨ã€‚è¿™ä½¿å¾—åœ¨å‡½æ•°å†…éƒ¨å¯ä»¥ä¿®æ”¹è¿™äº›å˜é‡çš„å€¼ï¼Œè€Œä¸ä¼šå½±å“åˆ°å‡½æ•°å¤–çš„å˜é‡ã€‚ æ€»ä¹‹ï¼Œè¿™æ®µä»£ç å®šä¹‰äº†ä¸€ä¸ªåä¸º dfs çš„åŒ¿åå‡½æ•°ï¼Œå®ƒæ¥å—ä¸¤ä¸ªæ•´æ•°å‚æ•° u å’Œ faï¼Œè¿”å›ä¸€ä¸ªæ•´æ•°å€¼ã€‚è®°ä½ä»¥åéƒ½è¿™ä¹ˆå†™å°±å¯¹å•¦ã€‚(è¿˜æœ‰éœ€è¦æ³¨æ„çš„å°±æ˜¯ï¼Œæœ€å&#125;åéœ€è¦åŠ ;) æ¥ä¸‹æ¥å°±æ˜¯æœ¬é¢˜çš„ä¸€äº›è§£é¢˜æ„Ÿæƒ³äº†ï¼Œå› ä¸ºæ˜¯æ ‘å½¢ç»“æ„ï¼Œæ‰€ä»¥ä¸éš¾æƒ³åˆ°ä¼šç”¨é€’å½’è¿™ç§ç®—æ³•ï¼Œåœ¨æœ¬é¢˜ä¸­é€’å½’æˆ‘ä»¬å›æº¯çš„æ—¶å€™ä¼ é€’å­æ ‘å¤§å°ã€‚åŒæ—¶æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªå˜é‡ç”¨äºå­˜å‚¨æœ€ç»ˆçš„è€—æ²¹é‡ï¼Œ æœ¬é¢˜å¤§è‡´æ€è·¯å°±æ˜¯ï¼Œå¯¹äºå½“å‰èŠ‚ç‚¹åœ¨ä½¿ç”¨é€’å½’å·²çŸ¥å…¶å­æ ‘å¤§å°åï¼Œå†ç”¨è€—æ²¹é‡å˜é‡åŠ ä¸Šå½“å‰èŠ‚ç‚¹æŒ‡å‘å…¶çˆ¶äº²èŠ‚ç‚¹é‚£æ¡è¾¹ä¸Šçš„è€—æ²¹é‡ï¼Œè¯¥è€—æ²¹é‡è®¡ç®—æ–¹å¼å¦‚ä¸‹ï¼š oil=ceil((size+1)/seats)oil = ceil((size+1)/seats) oil=ceil((size+1)/seats) å…¶ä¸­sizeä¸ºå½“å‰èŠ‚ç‚¹å­æ ‘å¤§å°ï¼Œceilæ˜¯å‘ä¸Šå–æ•´æ“ä½œ æœ€åä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627class Solution &#123;public: long long minimumFuelCost(vector&lt;vector&lt;int&gt;&gt;&amp; roads, int seats) &#123; vector&lt;vector&lt;int&gt;&gt; edge(roads.size()+1); for(auto &amp;road:roads) &#123; int u = road[0],v = road[1]; edge[u].push_back(v); edge[v].push_back(u); &#125; long long ans = 0; function&lt;int(int, int)&gt; dfs = [&amp;](int u,int fa) -&gt; int &#123; if (edge[u].size()==1&amp;&amp;u!=0)&#123; ans += 1; return 1; &#125; int size = 0; for (auto &amp;v:edge[u])&#123; if (v == fa) continue; size += dfs(v,u); &#125; if (u!=0) ans += (size) / seats + 1; // ceil((size+1)/seats) return size+1; &#125;; dfs(0,-1); return ans; &#125;&#125;; 2023-12-06 é¢˜ç›®ä¼ é€é—¨ï¼š2646. æœ€å°åŒ–æ—…è¡Œçš„ä»·æ ¼æ€»å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä»Šå¤©çš„é¢˜ç›®è¿˜æ˜¯æœ‰ç‚¹æœ‰æ„æ€ï¼Œä¸€é“æ ‘å½¢DPè®°å½•ä¸€ä¸‹ã€‚é¦–å…ˆæˆ‘ä»¬éœ€è¦æŠ“ä½ä¸€ä¸ªè¦ç‚¹å°±æ˜¯ï¼Œå› ä¸ºæ˜¯åœ¨æ ‘ä¸Šï¼Œæ‰€ä»¥è·¯å¾„æ˜¯å”¯ä¸€çš„ã€‚æ‰€ä»¥è§£æœ¬é¢˜çš„ç¬¬ä¸€æ­¥æ˜¯ç»Ÿè®¡èµ°å®Œæ‰€æœ‰çš„tripæ—¶ï¼Œæ ‘ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹è¢«èµ°è¿‡å¤šå°‘æ¬¡ã€‚ç¬¬ä¸€æ­¥å°±æ˜¯ä¸€ä¸ªç®€å•çš„dfsæœç´¢ï¼Œå½“æœç´¢åˆ°æ­£ç¡®çš„è·¯å¾„åï¼Œå›æº¯æ—¶å°†è·¯å¾„ä¸Šæ¯ä¸ªèŠ‚ç‚¹ç»è¿‡çš„æ¬¡æ•°+1ã€‚ ç»è¿‡ç¬¬ä¸€æ­¥åï¼Œæˆ‘ä»¬å°±å¯ä»¥é‡æ–°è®¡ç®—æ¯ä¸ªç‚¹çš„ä»£ä»·ï¼Œå°±æ˜¯ç”¨åŸæ¥æ¯ä¸ªç‚¹çš„ä»·æ ¼ä¹˜ä¸Šæ¬¡æ•°ã€‚ç„¶åå°±è¿›å…¥ä¸€ä¸ªæ ‡å‡†çš„æ ‘å½¢DPæŸ“è‰²é—®é¢˜äº†ã€‚å®šä¹‰dpæ•°ç»„dp[i][j]å…¶ä¸­iä»£è¡¨çš„æ˜¯å½“å‰èŠ‚ç‚¹ï¼Œjå–å€¼èŒƒå›´æ˜¯0ï¼Œ1ã€‚0ä»£è¡¨çš„æ˜¯å½“å‰èŠ‚ç‚¹ä¸ä¼˜æƒ ï¼Œ1ä»£è¡¨çš„æ˜¯å½“å‰èŠ‚ç‚¹æŸ“è‰²ã€‚çŠ¶æ€è½¬ç§»æ–¹ç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š dp[u][0]=(âˆ‘min(dp[v][0],dp[v][1]))+cost[u]dp[u][0] = (\\sum min(dp[v][0],dp[v][1]))+ cost[u] dp[u][0]=(âˆ‘min(dp[v][0],dp[v][1]))+cost[u] dp[u][1]=(âˆ‘dp[v][0])+cost[u]/2dp[u][1] = (\\sum dp[v][0]) + cost[u]/2 dp[u][1]=(âˆ‘dp[v][0])+cost[u]/2 å…¶ä¸­væ˜¯uçš„å„¿å­ æ›´æ–°å°±æ˜¯å’Œä¼ ç»Ÿæ ‘å½¢DPä¸€æ ·æ˜¯åœ¨è¿›è¡Œé€’å½’åå›æº¯çš„æ—¶å€™æ›´æ–°ã€‚ æœ€ç»ˆä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int minimumTotalPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;int&gt;&amp; price, vector&lt;vector&lt;int&gt;&gt;&amp; trips) &#123; vector&lt;int&gt; nums(n+1,0); vector&lt;vector&lt;int&gt;&gt; edge(n+1); for(auto &amp;tmp:edges)&#123; int u = tmp[0], v = tmp[1]; edge[u].push_back(v); edge[v].push_back(u); &#125; function&lt;bool(int,int,int)&gt; dfs = [&amp;](int u,int fa,int tar) &#123; if (u == tar)&#123; nums[u]++; return true; &#125; for(auto &amp;v:edge[u])&#123; if (v==fa) continue; if (dfs(v,u,tar)) &#123; nums[u]+=1; return true; &#125; &#125; return false; &#125;; for(auto &amp;trip:trips) &#123; dfs(trip[0],-1,trip[1]); &#125; vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(2,0)); function &lt;void(int,int)&gt; dfs_dp = [&amp;](int u,int fa) &#123; dp[u][0] = price[u]*nums[u]; dp[u][1] = price[u]*nums[u]/2; for(auto &amp;v:edge[u])&#123; if (v==fa) continue; dfs_dp(v,u); dp[u][0] += min(dp[v][0],dp[v][1]); dp[u][1] += dp[v][0]; &#125; &#125;; dfs_dp(0,-1); return min(dp[0][0],dp[0][1]); &#125;&#125;; 2023-12-07 é¢˜ç›®ä¼ é€é—¨ï¼š1466. é‡æ–°è§„åˆ’è·¯çº¿ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ­¤é¢˜å°±æ˜¯ä¸€ä¸ªéå¸¸ç®€å•çš„æ ‘çš„éå†é¢˜ç›®ï¼Œæˆ‘ä»¬åªéœ€è¦åˆ¤æ–­éå†è¿‡ç¨‹ä¸­ï¼Œè¾¹çš„æ–¹å‘ï¼Œç„¶åå†³å®šæ˜¯å¦è¦åè½¬å³å¯ã€‚ æ³¨æ„æœ¬é¢˜ä¸­pairç›¸å…³çš„å†™æ³•ï¼Œå‹å…¥vectorçš„æ—¶å€™ä½¿ç”¨çš„æ˜¯{}ï¼Œforå¾ªç¯æå–å‡ºæ¥çš„æ—¶å€™ä½¿ç”¨çš„æ˜¯[] 123456789101112131415161718192021class Solution &#123;public: int minReorder(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) &#123; vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; edge(n+1); for(auto &amp;c:connections)&#123; int a = c[0], b = c[1]; edge[a].push_back(&#123;b,1&#125;); edge[b].push_back(&#123;a,0&#125;); &#125; int ans = 0; function&lt;void(int,int)&gt; dfs = [&amp;](int u,int fa)&#123; for(auto &amp;[v,type]:edge[u])&#123; if(v==fa) continue; ans += type; dfs(v,u); &#125; &#125;; dfs(0,-1); return ans; &#125;&#125;; 2023-12-08 é¢˜ç›®ä¼ é€é—¨ï¼š2008. å‡ºç§Ÿè½¦çš„æœ€å¤§ç›ˆåˆ© - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä»Šå¤©çš„è¿™é“é¢˜é¦–å…ˆè¯»å®Œé¢˜ç›®åå°±å¯ä»¥çŒœå‡ºåº”è¯¥æ˜¯ä¸€é“DPé¢˜ï¼Œç„¶åæˆ‘ä»¬åœ¨è§‚å¯Ÿæ•°æ®è§„æ¨¡ï¼Œè¡Œç¨‹æ•°é‡æœ€å¤§ä¸º3e4ï¼Œç«™ç‚¹å–å€¼èŒƒå›´ä¸º1e5ã€‚æ‰€ä»¥æˆ‘ä»¬è®¾è®¡çš„DPç®—æ³•çš„æ—¶é—´å¤æ‚åº¦åªèƒ½æ˜¯O(n)O(n)O(n)æˆ–O(nlogn)O(nlogn)O(nlogn) æ–¹æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’+äºŒåˆ†æŸ¥æ‰¾ å› ä¸ºè¿™é“é¢˜å¯¹é¡ºåºæœ‰ä¸€äº›è¦æ±‚ï¼Œæ‰€ä»¥ä¸éš¾æƒ³åˆ°å¯èƒ½ä¼šä½¿ç”¨æ’åºæˆ–è€…äºŒåˆ†è¿™ç±»ç®—æ³•ã€‚ å½“ç„¶æˆ‘ä»¬è¿˜æ˜¯å…ˆè®¾è®¡dpçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œæ–¹ç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š dp[i]=max(dp[iâˆ’1],dp[j]+val[i])dp[i] = max(dp[i-1],dp[j]+val[i]) dp[i]=max(dp[iâˆ’1],dp[j]+val[i]) å…¶ä¸­ç´¢å¼•å·ä»£è¡¨çš„æ˜¯æ¯ä¸ªäººçš„ç¼–å·ï¼ˆé‡æ–°æ’åºè¿‡çš„ï¼Œä¾ç»ˆç‚¹å¤§å°ä»å°åˆ°å¤§è¿›è¡Œæ’åºï¼‰ï¼Œval[i]val[i]val[i]ä»£è¡¨çš„æ˜¯å½“å‰åºå·ä¸ºiçš„äººèƒ½å¤Ÿèµšçš„é’±ã€‚ jjjçš„é€‰æ‹©æ˜¯é‡‡ç”¨äºŒåˆ†æŸ¥è¯¢ç»ˆç‚¹çš„æ–¹æ³•æ‰¾åˆ°æ¯”iiiçš„èµ·ç‚¹å°çš„æœ€å¤§çš„jjjçš„ç»ˆç‚¹ã€‚ï¼ˆå­¦ä¹ äº†upperboundçš„ä¹¦å†™æ–¹æ³•ï¼Œåœ¨C++æ•™ç¨‹åˆé›†ä¸­æœ‰è®°è½½ï¼‰ å› æ­¤è¿™é“é¢˜å°±æ¯”è¾ƒå¥½è§£å†³äº†ï¼š å…ˆæŒ‰ç…§ç»ˆç‚¹ä»å°åˆ°å¤§æ’åº éå†æ‰€æœ‰çš„äººï¼Œéµå¾ªä¸Šé¢çš„è½¬ç§»æ–¹ç¨‹è¿›è¡ŒçŠ¶æ€è½¬ç§» è½¬ç§»çš„è¿‡ç¨‹ä¸­ï¼Œè¿›è¡ŒäºŒåˆ†å¯»æ‰¾j æœ€ç»ˆä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718class Solution &#123;public: long long maxTaxiEarnings(int n, vector&lt;vector&lt;int&gt;&gt;&amp; rides) &#123; sort(rides.begin(),rides.end(), [](const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123; if(a[1]==b[1])return a[0] &lt; b[0]; return a[1] &lt; b[1]; &#125;); int p_num = rides.size(); vector&lt;long long&gt; dp(p_num+1); for(int i=0;i&lt;p_num;++i)&#123; int j = upper_bound(rides.begin(), rides.begin() + i, rides[i][0], [](int x, const vector&lt;int&gt; &amp;r)&#123; return x &lt; r[1]; &#125;) - rides.begin(); dp[i+1] = max(dp[i], dp[j]+rides[i][1]-rides[i][0]+rides[i][2]); &#125; return dp[p_num]; &#125;&#125;; æ–¹æ³•äºŒï¼šåŠ¨æ€è§„åˆ’+å“ˆå¸Œè¡¨ æ–¹æ³•ä¸€å¯èƒ½å­˜åœ¨ä¸ç›´è§‚ï¼ˆdpæ•°ç»„ç´¢å¼•æ˜¯äººï¼‰ä»¥åŠç®—æ³•æ—¶é—´å¤æ‚åº¦ç¨é«˜çš„é—®é¢˜ã€‚æˆ‘ä»¬å…¶å®ä½¿ç”¨åŠ¨æ€è§„åˆ’ç»“åˆå“ˆå¸Œè¡¨çš„æ–¹æ³•å¯ä»¥å°†ç®—æ³•æ—¶é—´å¤æ‚åº¦ä¼˜åŒ–åˆ°O(n)O(n)O(n)å¹¶ä¸”è½¬ç§»æ–¹ç¨‹ä¹Ÿä¼šæ˜¾å¾—æ›´åŠ ç›´è§‚ã€‚ æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨rideMap[end]ï¼Œè®°å½•ç»ˆç‚¹ä¸ºendçš„æ‰€æœ‰ä¹˜å®¢ä¿¡æ¯ï¼Œä¸åŒäºä¹‹å‰çš„æ–¹æ³•è¿™é‡Œdp[i]ä»£è¡¨åˆ°è¾¾ç¬¬iiiä¸ªåœ°ç‚¹æ—¶èƒ½è·å¾—çš„æœ€å¤§åˆ©æ¶¦ã€‚å› æ­¤åˆå§‹æƒ…å†µå°±æ˜¯dp[0]=0ã€‚å¯¹äºæ¯ä¸ªåœ°ç‚¹iæœ‰ä¸¤ç§å¯èƒ½çš„è½¬ç§»ï¼š iiiåœ°ç‚¹æ²¡äººä¸‹è½¦ï¼Œåˆ™dp[i]=dp[iâˆ’1]dp[i]=dp[i-1]dp[i]=dp[iâˆ’1] æœ‰äººä¸‹è½¦ï¼Œæœ€å¤§åˆ©æ¶¦ä¸ºdp[i]=max(dp[startj]+end[j]âˆ’start[j]+tip[j])dp[i]=max(dp[start_j]+end[j]-start[j]+tip[j])dp[i]=max(dp[startjâ€‹]+end[j]âˆ’start[j]+tip[j]) ç†è§£å®Œæ•´ä¸ªè¿‡ç¨‹æœ€ç»ˆçš„ä»£ç å°±æ˜¯ï¼š 1234567891011121314151617class Solution &#123;public: long long maxTaxiEarnings(int n, vector&lt;vector&lt;int&gt;&gt;&amp; rides) &#123; vector&lt;long long&gt; dp(n+1); unordered_map&lt;int, vector&lt;vector&lt;int&gt;&gt;&gt; rideMap; for(const auto &amp;ride: rides) &#123; rideMap[ride[1]].push_back(ride); &#125; for(int i = 1; i &lt;= n; ++i)&#123; dp[i] = dp[i-1]; for(const auto &amp;ride : rideMap[i]) &#123; dp[i] = max(dp[i], dp[ride[0]] + ride[1] - ride[0] + ride[2]); &#125; &#125; return dp[n]; &#125;&#125;; 2023-12-09 é¢˜ç›®ä¼ é€é—¨ï¼š2048. ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°å€¼å¹³è¡¡æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™ä¸ªé¢˜æ‰“ä¸€ä¸ªè¡¨ï¼Œç”¨ä¸€ä¸ªå¯çˆ±çš„äºŒåˆ†å°±å¯ä»¥è§£å†³ï¼Œï¼ˆäºŒåˆ†ç›´æ¥è°ƒç”¨upper_boundå‡½æ•°ï¼‰ 123456789101112131415161718192021222324class Solution &#123;public: const vector&lt;int&gt; balance &#123; 1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444 &#125;; int nextBeautifulNumber(int n) &#123; return *upper_bound(balance.begin(), balance.end(), n); &#125;&#125;; 2023-12-10 é¢˜ç›®ä¼ é€é—¨ï¼š70. çˆ¬æ¥¼æ¢¯ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åˆšå¥½å’ŒåŠ¨æ€è§„åˆ’ï¼ˆåŸºç¡€ç‰ˆï¼‰ç¬¬ä¸€é¢˜ä¸€æ ·ï¼Œç›´æ¥æŠ„è¿‡æ¥å³å¯ã€‚ è®°å¿†åŒ–æœç´¢ç‰ˆï¼š 12345678910111213class Solution &#123;public: int climbStairs(int n) &#123; vector&lt;int&gt; dp(n+1,-1); dp[0] = 1;dp[1] = 1; function&lt;int(int)&gt; dfs = [&amp;](int now)&#123; if (dp[now]!=-1) return dp[now]; dp[now-1] = dfs(now-1); dp[now-2] = dfs(now-2); return dp[now-1] + dp[now-2]; &#125;; return dfs(n); &#125;&#125;; é€’æ¨ç‰ˆï¼š 1234567891011class Solution &#123;public: int climbStairs(int n) &#123; vector&lt;int&gt; dp(n+1,0); dp[0] = 1;dp[1] = 1; for(int i=2;i&lt;=n;++i)&#123; dp[i] = dp[i-1]+dp[i-2]; &#125; return dp[n]; &#125;&#125;; 2023-12-11 é¢˜ç›®ä¼ é€é—¨ï¼š1631. æœ€å°ä½“åŠ›æ¶ˆè€—è·¯å¾„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™é“é¢˜æ³¨æ„é¢˜ç›®ä¸è¦è¯»é”™ï¼Œå…¶å®å°±æ˜¯ä¸€é“æœ€çŸ­è·¯æ¿å­é¢˜ï¼Œæ­£å¥½å€ŸåŠ©è¿™ä¸ªæœºä¼šç†Ÿæ‚‰ä¸€ä¸‹Dijkstraçš„C++å†™æ³•ã€‚ æœ€ç»ˆä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 123456789101112131415161718192021222324252627282930313233struct DIS &#123; int x, y, val; DIS(int _x,int _y, int _val): x(_x), y(_y), val(_val) &#123;&#125; bool operator&lt; (const DIS&amp; that) const&#123; return that.val &lt; val; &#125;&#125;;class Solution &#123;public: int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; heights) &#123; int m = heights.size(), n = heights[0].size(); vector&lt;vector&lt;bool&gt;&gt; vis(m,vector&lt;bool&gt;(n, false)); vector&lt;vector&lt;int&gt;&gt; dis(m, vector&lt;int&gt;(n, INT_MAX)); priority_queue&lt;DIS&gt; q; dis[0][0] = 0; q.emplace(0,0,0); vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;; while(!q.empty())&#123; auto [x,y,val] = q.top();q.pop(); if (vis[x][y]) continue; vis[x][y] = true; for(auto &amp;dir:dirs)&#123; int nx = x + dir[0], ny = y + dir[1]; if(nx&gt;=0 &amp;&amp; nx&lt;m &amp;&amp; ny&gt;=0 &amp;&amp; ny&lt;n &amp;&amp; dis[nx][ny] &gt; max(dis[x][y],abs(heights[x][y]-heights[nx][ny])))&#123; dis[nx][ny] = max(dis[x][y],abs(heights[x][y]-heights[nx][ny])); q.emplace(nx,ny,dis[nx][ny]); &#125; &#125; &#125; return dis[m-1][n-1]; &#125;&#125;; ä¸Šè¿°ä»£ç ä½¿ç”¨äº†structè¿™å°±ä¸æ˜¯å¾ˆæ­£ç»ŸC++ï¼Œæ‰€ä»¥æˆ‘ä»¬å½“ç„¶ä¹Ÿå¯ä»¥å†™æˆç±»çš„å½¢å¼ï¼š 12345678910111213141516171819202122232425262728293031323334353637class DIS &#123;public: int x, y, val; // é»˜è®¤ä¸ºç§æœ‰æˆå‘˜ // æ„é€ å‡½æ•° DIS(int _x, int _y, int _val) : x(_x), y(_y), val(_val) &#123;&#125; // æ¯”è¾ƒæ“ä½œç¬¦ bool operator&lt; (const DIS&amp; that) const &#123; return that.val &lt; val; &#125;&#125;;class Solution &#123;public: int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; heights) &#123; int m = heights.size(), n = heights[0].size(); vector&lt;vector&lt;bool&gt;&gt; vis(m,vector&lt;bool&gt;(n, false)); vector&lt;vector&lt;int&gt;&gt; dis(m, vector&lt;int&gt;(n, INT_MAX)); priority_queue&lt;DIS&gt; q; dis[0][0] = 0; q.emplace(0,0,0); vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;; while(!q.empty())&#123; auto [x,y,val] = q.top();q.pop(); if (vis[x][y]) continue; vis[x][y] = true; for(auto &amp;dir:dirs)&#123; int nx = x + dir[0], ny = y + dir[1]; if(nx&gt;=0 &amp;&amp; nx&lt;m &amp;&amp; ny&gt;=0 &amp;&amp; ny&lt;n &amp;&amp; dis[nx][ny] &gt; max(dis[x][y],abs(heights[x][y]-heights[nx][ny])))&#123; dis[nx][ny] = max(dis[x][y],abs(heights[x][y]-heights[nx][ny])); q.emplace(nx,ny,dis[nx][ny]); &#125; &#125; &#125; return dis[m-1][n-1]; &#125;&#125;; å½“ç„¶ä¸å‡ºæ„å¤–ï¼Œ è¿˜æ˜¯structçš„æ•ˆç‡ä¼šé«˜ä¸€äº›ï¼Œä¹Ÿå»ºè®®ä»¥åéƒ½å†™æˆstructï¼Œåœ¨é‡Œé¢é‡å®šä¹‰å°äºè¿ç®—ç¬¦ã€‚ å…¶ä»–æ³¨æ„äº‹é¡¹ autoå–topä¸­çš„ç»“æ„ä½“å€¼ 1auto [x,y,val] = q.top();q.pop(); é‡å®šä¹‰è¿ç®—ç¬¦ä¸¤ä¸ªconstéƒ½ä¸èƒ½çœç•¥ 123bool operator&lt; (const DIS&amp; that) const &#123;\treturn that.val &lt; val;&#125; intç±»å‹çš„æœ€å¤§å€¼å¯ä»¥ç›´æ¥å†™INT_MAX 2023-12-12â€» é¢˜ç›®ä¼ é€é—¨ï¼š2454. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  IV - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ­¤é¢˜éœ€è¦ç”¨åˆ°å•è°ƒæ ˆçš„ç›¸å…³å†…å®¹,å•è°ƒæ ˆåŸºç¡€è¯¦æƒ…è§ä¸“é¡¹è®­ç»ƒå•è°ƒæ ˆæ¨¡å—ã€‚ ä»¥ä¸‹å†…å®¹æ‘˜è‡ªçµç¥é¢˜è§£ï¼š é¦–å…ˆå›æƒ³ä¸€ä¸‹ï¼Œæ€ä¹ˆæ‰¾ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ ï¼Œå³å³ä¾§æœ€è¿‘çš„æ›´å¤§å…ƒç´ ã€‚ ä½¿ç”¨è§†é¢‘ä¸­è®²çš„ç¬¬äºŒç§åšæ³•ï¼Œä»å·¦åˆ°å³éå†æ•°ç»„ï¼Œç”¨ä¸€ä¸ªï¼ˆé€’å‡ï¼‰å•è°ƒæ ˆsssç»´æŠ¤éå†è¿‡çš„å…ƒç´ ï¼Œå¦‚æœå½“å‰å…ƒç´  xxx æ¯”æ ˆé¡¶å¤§ï¼Œé‚£ä¹ˆæ ˆé¡¶çš„ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ å°±æ˜¯ xxxï¼Œå¹¶å¼¹å‡ºæ ˆé¡¶ã€‚ åœ¨è¿™ä¸ªåšæ³•ä¸­ï¼Œæ ˆé¡¶å…ƒç´ å¼¹å‡ºåï¼Œå°±æ²¡æœ‰ç”¨äº†ã€‚ä½†å¯¹äºæœ¬é¢˜ï¼Œæˆ‘ä»¬éœ€è¦çš„æ­£æ˜¯å¼¹å‡ºå»çš„å…ƒç´ ï¼ å†ç”¨ä¸€ä¸ªï¼ˆé€’å‡ï¼‰å•è°ƒæ ˆ ttt è®°å½•ä» sss ä¸­å¼¹å‡ºå»çš„å…ƒç´ ã€‚ç»§ç»­å‘åéå†ï¼Œå¦‚æœåˆæ‰¾åˆ°ä¸€ä¸ªå…ƒç´  yyy æ¯” ttt çš„æ ˆé¡¶å¤§ï¼Œé‚£ä¹ˆæ ˆé¡¶çš„ä¸‹ä¸‹ä¸ªæ›´å¤§å…ƒç´ å°±æ˜¯ yyyï¼Œå¹¶å¼¹å‡ºæ ˆé¡¶ã€‚ 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; secondGreaterElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; ans(n, -1), s, t; for (int i = 0; i &lt; n; ++i) &#123; int x = nums[i]; while (!t.empty() &amp;&amp; nums[t.back()] &lt; x)&#123; ans[t.back()] = x; t.pop_back(); &#125; int j = s.size(); while(j &amp;&amp; nums[s[j-1]] &lt; x) j--; t.insert(t.end(), s.begin() + j, s.end()); // æŠŠä» s å¼¹å‡ºçš„è¿™ä¸€æ•´æ®µå…ƒç´ åŠ åˆ° t s.resize(j); // å¼¹å‡ºä¸€æ•´æ®µå…ƒç´  s.push_back(i); // å½“å‰å…ƒç´ ï¼ˆçš„ä¸‹æ ‡ï¼‰åŠ åˆ° s æ ˆé¡¶ &#125; return ans; &#125;&#125;; 2023-12-13 é¢˜ç›®ä¼ é€é—¨ï¼š2697. å­—å…¸åºæœ€å°å›æ–‡ä¸² - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åŒæŒ‡é’ˆç­¾åˆ°é¢˜ç›®ï¼Œä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘å­—ç¬¦ä¸²å¤´å°¾ï¼Œæ ‡è®°çš„æ˜¯å›æ–‡ä¸²ç›¸å¯¹åº”çš„ä½ç½®ï¼Œéå†çš„è¿‡ç¨‹ä¸­ï¼Œleftæ¯å‘å³ç§»åŠ¨ä¸€ä¸ªä½ç½®ï¼Œrightå°±å‘å·¦ç§»åŠ¨ä¸€ä¸ªä½ç½®ï¼Œè¿™æ ·ä¼šå‡ºç°ä¸¤ç§æƒ…å†µã€‚ å¦‚æœæŒ‡å‘çš„å­—ç¬¦ä¸€æ ·ï¼Œä¸åšä»»ä½•æ“ä½œ å¦‚æœæŒ‡å‘çš„å­—æ¯ä¸åŒï¼Œå°†ä»–ä»¬éƒ½å˜æˆè¿™ä¸¤ä¸ªå­æ¯ä¸­è¾ƒå°çš„é‚£ä¸ªå­—æ¯å³å¯ã€‚ æœ€åè¿”å›æ–°çš„å­—ç¬¦ä¸²ã€‚ æœ€ç»ˆä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910111213class Solution &#123;public: string makeSmallestPalindrome(string s) &#123; int n = s.length(); for(int i=0;i&lt;n/2;++i)&#123; if (s[i]!=s[n-1-i])&#123; if (s[i] &lt; s[n-1-i]) s[n-1-i] =s[i]; else s[i] = s[n-1-i]; &#125; &#125; return s; &#125;&#125;; 2023-12-14 ä»Šå¤©çš„è¿™é“é¢˜éå¸¸çš„æœ‰æ„æ€ï¼Œè¯»å®Œé¢˜ç›®åï¼Œå¤§æ¦‚å°±ä¼šæœ‰ä¸€ä¸ªåŸºæœ¬æ€è·¯ï¼Œå°±æ˜¯èƒ½æ”¾ä¸Šé‚®ç¥¨çš„åœ°æ–¹æˆ‘ä»¬å°½é‡æ”¾ä¸Šé‚®ç¥¨ï¼Œæœ€åæˆ‘ä»¬çœ‹æ•´ä¸ªçŸ©é˜µæœ‰æ²¡æœ‰ç©ºç™½çš„åœ°æ–¹ã€‚ å€Ÿç”¨çµç¥çš„æ€è·¯æ¦‚æ‹¬ä¸€ä¸‹ï¼š ç”±äºé‚®ç¥¨å¯ä»¥äº’ç›¸é‡å ï¼Œè´ªå¿ƒåœ°æƒ³ï¼Œèƒ½æ”¾é‚®ç¥¨å°±æ”¾é‚®ç¥¨ã€‚ éå†æ‰€æœ‰èƒ½æ”¾é‚®ç¥¨çš„ä½ç½®å»æ”¾é‚®ç¥¨ã€‚æ³¨æ„é‚®ç¥¨ä¸èƒ½è¦†ç›–è¢«å æ®çš„æ ¼å­ï¼Œä¹Ÿä¸èƒ½å‡ºç•Œã€‚ æ”¾é‚®ç¥¨çš„åŒæ—¶ï¼Œè®°å½•æ¯ä¸ªç©ºæ ¼å­è¢«å¤šå°‘å¼ é‚®ç¥¨è¦†ç›–ã€‚å¦‚æœå­˜åœ¨ä¸€ä¸ªç©ºæ ¼å­æ²¡è¢«é‚®ç¥¨è¦†ç›–ï¼Œåˆ™è¿”å› falseï¼Œå¦åˆ™è¿”å› trueã€‚ å…¶å®æŠŠä¸Šé¢çš„å¤§ä½“æ€è·¯æƒ³æ˜ç™½äº†ï¼Œæ ¹æ®ä¹‹å‰çš„åšé¢˜ç»éªŒï¼Œè¿™é“é¢˜ä½¿ç”¨å·®åˆ†ä¹Ÿæ¯”è¾ƒæ˜æ˜¾äº†ï¼Œå°±æ˜¯è¿˜æœ‰ä¸€äº›ç»†èŠ‚éœ€è¦æ³¨æ„ä¸€ä¸‹ã€‚ å› ä¸ºè¦ä½¿ç”¨å·®åˆ†ï¼Œæ‰€ä»¥æˆ‘ä»¬æ”¾é‚®ç¥¨ä»å³ä¸‹è§’å¼€å§‹æ”¾ï¼Œè¿™æ ·å¥½ä½¿ç”¨å·®åˆ†O(1)O(1)O(1)åˆ¤æ–­èƒ½å¦å°†é‚®ç¥¨æ”¾åœ¨è¿™é‡Œã€‚ æ”¾é‚®ç¥¨æˆ‘ä»¬ä¹Ÿæ˜¯é‡‡ç”¨ä¸€ä¸ªå·®åˆ†çŸ©é˜µæ¥è®°å½•ï¼Œæœ€åæ±‚äºŒç»´å‰ç¼€å’Œå°±å¯ä»¥è¿˜åŸæœ€ç»ˆçš„é‚®ç¥¨æ”¾ç½®æ–¹æ³•ã€‚ æ³¨æ„ï¼šä»¥åå†™è¿™ç§å·®åˆ†çš„é¢˜ç›®ï¼Œä¸‹æ ‡ä»£è¡¨çš„éƒ½æ˜¯ä»1å¼€å§‹ï¼Œå› ä¸ºå¿…é¡»è¦ç•™ä¸€ä¸ª0ä¿è¯æ±‚å‰ç¼€å’Œè¿™ç±»æ“ä½œçš„ç»Ÿä¸€æ€§ã€‚ æœ€ç»ˆä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: bool possibleToStamp(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int stampHeight, int stampWidth) &#123; int n = grid.size(), m = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; s(n+1,vector&lt;int&gt;(m+1,0)); for (int i=0; i&lt;n; ++i) &#123; for(int j=0; j&lt;m; ++j)&#123; s[i+1][j+1] = grid[i][j] + s[i][j+1] + s[i+1][j] - s[i][j]; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; cov(n+2,vector&lt;int&gt;(m+2,0)); for (int i=stampHeight; i&lt;=n; ++i) &#123; for(int j=stampWidth; j&lt;=m; ++j)&#123; int i1 = i - stampHeight + 1; int j1 = j - stampWidth + 1; if (s[i][j] - s[i][j1-1] - s[i1-1][j] + s[i1-1][j1-1] == 0)&#123; cov[i1][j1] ++; cov[i+1][j1] -- ; cov[i1][j+1] --; cov[i+1][j+1] ++; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; cov[i][j] += cov[i-1][j] + cov[i][j-1] - cov[i-1][j-1]; if (grid[i-1][j-1] == 0 &amp;&amp; cov[i][j] == 0) return false; &#125; &#125; return true; &#125;&#125;; 2023-12-15 é¢˜ç›®ä¼ é€é—¨ï¼š2415. åè½¬äºŒå‰æ ‘çš„å¥‡æ•°å±‚ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ­¤é¢˜è€ƒå¯Ÿçš„æ˜¯äºŒå‰æ ‘çš„å±‚åºéå†ï¼Œå…¶å®å°±æ˜¯ä¸€ç§bfså§ï¼Œé€šè¿‡æœ¬é¢˜å¯ä»¥æ›´ç†Ÿæ‚‰ä¸€ä¸‹C++ä¸­æŒ‡é’ˆå’Œvectorç›¸å…³å†…å®¹ã€‚ æœ€ç»ˆä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* reverseOddLevels(TreeNode* root) &#123; vector&lt;vector&lt;TreeNode*&gt;&gt; que(2); que[0].push_back(root); int now = 0; while (!que[now].empty())&#123; for(auto node:que[now])&#123; if(node-&gt;left) que[1-now].push_back(node-&gt;left); if(node-&gt;right) que[1-now].push_back(node-&gt;right); &#125; if (now) &#123; int siz = que[now].size(); for(int i=0;i&lt;siz/2;++i)&#123; int tmp = que[now][i]-&gt;val; que[now][i]-&gt;val = que[now][siz-1-i]-&gt;val; que[now][siz-1-i]-&gt;val = tmp; &#125; &#125; while(!que[now].empty()) que[now].pop_back(); now = 1-now; &#125; return root; &#125;&#125;; 2023-12-16 é¢˜ç›®ä¼ é€é—¨ï¼š2276. ç»Ÿè®¡åŒºé—´ä¸­çš„æ•´æ•°æ•°ç›® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿˜æ²¡å¤ªæ•´æ˜ç™½ï¼š 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; secondGreaterElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; ans(n, -1), s, t; for (int i = 0; i &lt; n; ++i) &#123; int x = nums[i]; while (!t.empty() &amp;&amp; nums[t.back()] &lt; x)&#123; ans[t.back()] = x; t.pop_back(); &#125; int j = s.size(); while(j &amp;&amp; nums[s[j-1]] &lt; x) j--; t.insert(t.end(), s.begin() + j, s.end()); // æŠŠä» s å¼¹å‡ºçš„è¿™ä¸€æ•´æ®µå…ƒç´ åŠ åˆ° t s.resize(j); // å¼¹å‡ºä¸€æ•´æ®µå…ƒç´  s.push_back(i); // å½“å‰å…ƒç´ ï¼ˆçš„ä¸‹æ ‡ï¼‰åŠ åˆ° s æ ˆé¡¶ &#125; return ans; &#125;&#125;; 2023-12-17 é¢˜ç›®ä¼ é€é—¨ï¼š746. ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“éå¸¸åŸºç¡€çš„DPé¢˜ç›®ï¼Œè¿™é‡Œå°±ä½¿ç”¨è®°å¿†åŒ–æœç´¢è§£å†³äº†ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯costæœ€åå‹å…¥ä¸€ä¸ª0ï¼Œæ¥ä¿è¯æ‰€æœ‰çš„æ“ä½œä¸€è‡´æ€§ï¼ˆä»£è¡¨å·²ç»åˆ°æœ€é«˜ç‚¹äº†ï¼Œå¾€ä¸Šèµ°çš„å¼€é”€ä¸º0ï¼‰ 12345678910111213141516class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int n = cost.size(); cost.emplace_back(0); vector&lt;int&gt; dp(n+1, -1); dp[0] = cost[0]; dp[1] = cost[1]; function&lt;int(int)&gt; dfs = [&amp;](int now)&#123; if (dp[now]!=-1) return dp[now]; int a = dfs(now-1), b = dfs(now-2); dp[now] = cost[now] + min(a,b); return dp[now]; &#125;; return dfs(n); &#125;&#125;; 2023-12-18 é¢˜ç›®ä¼ é€é—¨ï¼š162. å¯»æ‰¾å³°å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å› ä¸ºé¢˜ç›®è¦æ±‚å®ç°O(logâ¡n)O(\\log n)O(logn)æ—¶é—´å¤æ‚åº¦çš„ç®—æ³•ï¼Œæ‰€ä»¥ä¸éš¾æƒ³åˆ°éœ€è¦ä½¿ç”¨äºŒåˆ†ç®—æ³•ï¼ŒäºŒåˆ†çš„åŸºç¡€çŸ¥è¯†æˆ‘ä»¬å·²ç»åœ¨äºŒåˆ†ä¸“é¢˜æ¿å—è¿›è¡Œäº†è®²è§£ã€‚ æœ¬é¢˜äºŒåˆ†çš„æ€æƒ³å…¶å®å¾ˆç®€å•ï¼Œæˆ‘ä»¬éœ€è¦æ˜ç™½ä¸€ä¸ªé“ç†ï¼Œå°±æ˜¯å³°å€¼ä¸€å®šæ˜¯æ¯”è¾ƒå¤§çš„å€¼ï¼Œæ‰€ä»¥æ¯æ¬¡äºŒåˆ†çš„æ—¶å€™åˆ¤æ–­å½“å‰midä½ç½®ä¸ä»–å·¦å³ä½ç½®æ•°çš„å¤§å°å…³ç³»ï¼Œç„¶åå¾€å¤§çš„åœ°æ–¹æ›´æ–°åŒºé—´å³å¯ã€‚ ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718class Solution &#123;public: int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int l = 0, r = len-1; function&lt;long long(int)&gt; getitem = [&amp;](int i)&#123; if (i&lt;=-1||i&gt;=len) return 2*(long long)(INT_MIN); return (long long)(nums[i]); &#125;; while (l &lt;= r) &#123; int mid = l + (r-l)/2; if (getitem(mid)&gt;getitem(mid-1)&amp;&amp;getitem(mid)&gt;getitem(mid+1)) return mid; if (getitem(mid)&lt;getitem(mid+1)) l = mid+1; else r = mid-1; &#125; return -123123; &#125;&#125;; è¿™é‡Œä½¿ç”¨çš„æ˜¯é—­åŒºé—´äºŒåˆ†ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯0ä½ç½®çš„å·¦è¾¹ä»¥åŠlen-1ä½ç½®çš„å³è¾¹å®šä¹‰çš„å³°å€¼å¤§å°éƒ½æ˜¯2*INT_MIN,ä½¿ç”¨ä¸€ä¸ªgetitemå‡½æ•°æ¥å–å€¼ï¼Œå…¶ä¸­éœ€è¦è€ƒè™‘è¿™ç§è¶…å‡ºåŒºé—´èŒƒå›´çš„é—®é¢˜ã€‚ å…¶å®ä¸Šé¢çš„è¿™ç§å†™æ³•å¹¶ä¸æ˜¯å¾ˆäºŒåˆ†ï¼Œå¯ä»¥å†æ”¹è¿›ä¸€ä¸‹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼ˆå› ä¸ºæœ€åä¸€å®šæœ‰å³°é¡¶ï¼Œæ‰€ä»¥ç›´æ¥åˆ†ä¸ºä¸å¯èƒ½ä¸ºå³°é¡¶å’Œå¯èƒ½ä¸ºå³°é¡¶ä¸¤ç±»å°±å¯ä»¥åˆ¤æ–­å‡ºæ¥è°æ˜¯å³°é¡¶äº†ï¼‰ï¼š 123456789101112131415161718class Solution &#123;public: int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int l = 0, r = len-1; function&lt;long long(int)&gt; getitem = [&amp;](int i)&#123; if (i&lt;=-1||i&gt;=len) return 2*(long long)(INT_MIN); return (long long)(nums[i]); &#125;; while (l &lt;= r) &#123; int mid = l + (r-l)/2; // if (getitem(mid)&gt;getitem(mid-1)&amp;&amp;getitem(mid)&gt;getitem(mid+1)) return mid; if (getitem(mid)&lt;getitem(mid+1)) l = mid+1; else r = mid-1; &#125; return l; &#125;&#125;; å¯ä»¥ä»”ç»†ç†è§£ä¸€ä¸‹ä¸ºå•¥æŠŠä¸­é—´é‚£ä¸ªifæ³¨é‡Šæ‰ã€‚ æœ€åè¿”å›lllæ˜¯å› ä¸ºmidè¿˜æ˜¯æœ‰å¯èƒ½æ˜¯å³°é¡¶çš„ï¼Œæ‰€ä»¥åº”è¯¥è¿”å›r+1r+1r+1ï¼Œåˆå› ä¸ºæœ€åç»ˆæ­¢çš„æ—¶å€™r+1=lr+1=lr+1=lï¼Œæ‰€ä»¥è¿”å›lll 2023-12-19 é¢˜ç›®ä¼ é€é—¨ï¼š1901. å¯»æ‰¾å³°å€¼ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åŒæ ·ä¹Ÿæ˜¯äºŒåˆ†ï¼Œåªä¸è¿‡æ˜¯å¯¹æ¯è¡Œçš„æœ€å¤§å€¼è¿›è¡ŒäºŒåˆ†ï¼Œå¾€midå‰åè¡Œæ›´å¤§çš„æœ€å¤§å€¼çš„åœ°æ–¹æ›´æ–°åŒºé—´ã€‚æœ€ç»ˆä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 123456789101112131415161718class Solution &#123;public: int max_idx(vector&lt;int&gt; nums)&#123; return max_element(nums.begin(), nums.end()) - nums.begin(); &#125; vector&lt;int&gt; findPeakGrid(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123; int n = mat.size(); int l = 0, r = n-1; while(l&lt;r)&#123; int mid = l + (r-l)/2; int j = max_idx(mat[mid]); if (mat[mid][j] &gt; mat[mid+1][j]) r = mid; else l = mid+1; &#125; int ans = l; return vector&lt;int&gt;&#123;ans,max_idx(mat[ans])&#125;; &#125;&#125;; 2023-12-20 é¢˜ç›®ä¼ é€é—¨ï¼š2828. åˆ¤åˆ«é¦–å­—æ¯ç¼©ç•¥è¯ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ï¼Œç†Ÿæ‚‰stringçš„åŸºæœ¬ç”¨æ³• 12345678910class Solution &#123;public: bool isAcronym(vector&lt;string&gt;&amp; words, string s) &#123; if(words.size()!=s.size()) return false; for(int i=0;i&lt;words.size();++i)&#123; if (words[i][0]!=s[i]) return false; &#125; return true; &#125;&#125;; 2023-12-21 é¢˜ç›®ä¼ é€é—¨ï¼š2866. ç¾ä¸½å¡” II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 2023-12-22 é¢˜ç›®ä¼ é€é—¨ï¼š1671. å¾—åˆ°å±±å½¢æ•°ç»„çš„æœ€å°‘åˆ é™¤æ¬¡æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 2023-12-23 é¢˜ç›®ä¼ é€é—¨ï¼š1962. ç§»é™¤çŸ³å­ä½¿æ€»æ•°æœ€å° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“éå¸¸å®¹æ˜“æƒ³çš„è´ªå¿ƒé¢˜ç›®ï¼Œæ¯æ¬¡å–æœ€å¤§å‡åŠå³å¯ã€‚ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ç»´æŠ¤æœ€å¤§å€¼ã€‚ 12345678910111213141516171819class Solution &#123;public: int minStoneSum(vector&lt;int&gt;&amp; piles, int k) &#123; priority_queue&lt;int&gt; pq; int sum_pile = 0; for(auto &amp;pile:piles) &#123; pq.emplace(pile); sum_pile += pile; &#125; int ans = 0; for(int i=1;i&lt;=k;++i)&#123; int nw = pq.top(); ans += nw/2; pq.pop(); pq.emplace(nw-(nw/2)); &#125; return sum_pile - ans; &#125;&#125;; 2023-12-24 é¢˜ç›®ä¼ é€é—¨ï¼š1954. æ”¶é›†è¶³å¤Ÿè‹¹æœçš„æœ€å°èŠ±å›­å‘¨é•¿ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“éå¸¸æ˜æ˜¾çš„äºŒåˆ†é¢˜ç›®ï¼Œå°†ç»™å®šxè‹¹æœæ€»æ•°è®¡ç®—å…¬å¼æ¨å‡ºå³å¯ï¼Œä½¿ç”¨å·¦é—­å³å¼€äºŒåˆ†æŸ¥æ‰¾ï¼š 12345678910111213141516class Solution &#123;public: long long minimumPerimeter(long long neededApples) &#123; function&lt;long long(long long)&gt; getApple = [&amp;](long long x)&#123; return (x*2+1)*x*(x+1)*2; &#125;; long long l = 0, r = 100000; while(l&lt;r) &#123; long long mid = l + (r-l)/2; long long nwapple = getApple(mid); if (nwapple &gt;= neededApples) r=mid; else l=mid+1; &#125; return l*8; &#125;&#125;; 2023-12-25 é¢˜ç›®ä¼ é€é—¨ï¼š1276. ä¸æµªè´¹åŸæ–™çš„æ±‰å ¡åˆ¶ä½œæ–¹æ¡ˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å†æ¬¡å¤ä¹ ä¸€ä¸‹äºŒåˆ†é—­åŒºé—´å†™æ³•ã€‚ 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; numOfBurgers(int tomatoSlices, int cheeseSlices) &#123; function&lt;bool(int)&gt; search = [&amp;](int x)&#123; return x*4+(cheeseSlices-x) * 2 &gt;=tomatoSlices?true:false; &#125;; int l = 0, r = cheeseSlices; while(l &lt;= r)&#123; int mid = l+(r-l)/2; if (search(mid)) r = mid-1; else l = mid+1; &#125; return l*4+(cheeseSlices-l)*2 == tomatoSlices?vector&lt;int&gt;&#123;l,cheeseSlices-l&#125;:vector&lt;int&gt;&#123;&#125;; &#125;&#125;; 2023-12-26 é¢˜ç›®ä¼ é€é—¨ï¼š1349. å‚åŠ è€ƒè¯•çš„æœ€å¤§å­¦ç”Ÿæ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 2023-12-27 é¢˜ç›®ä¼ é€é—¨ï¼š2660. ä¿é¾„çƒæ¸¸æˆçš„è·èƒœè€… - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“éå¸¸ç®€å•çš„ç­¾åˆ°é¢˜ç›®ï¼š 12345678910111213141516class Solution &#123;public: int isWinner(vector&lt;int&gt;&amp; player1, vector&lt;int&gt;&amp; player2) &#123; int n = player1.size(); int p1_sum = player1[0], p2_sum = player2[0]; for(int i=1;i&lt;n;++i)&#123; if (player1[i-1]==10) p1_sum += player1[i]*2; else if (i&gt;1&amp;&amp;player1[i-2]==10) p1_sum += player1[i]*2; else p1_sum += player1[i]; if (player2[i-1]==10) p2_sum += player2[i]*2; else if (i&gt;1&amp;&amp;player2[i-2]==10) p2_sum += player2[i]*2; else p2_sum += player2[i]; &#125; return p1_sum == p2_sum?0:p1_sum&gt;p2_sum?1:2; &#125;&#125;; 2023-12-28 é¢˜ç›®ä¼ é€é—¨ï¼š2735. æ”¶é›†å·§å…‹åŠ› - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™é“é¢˜é¢˜ç›®æè¿°æœ‰ç‚¹æ­§ä¹‰ï¼Œéœ€è¦ç»“åˆæ ·ä¾‹ç†è§£é¢˜ç›®æ„æ€ï¼Œä½†æ˜¯è¿˜æ˜¯ä¸€é“æœ‰ç‚¹æœ‰æ„æ€çš„æšä¸¾ã€‚ ç†è§£æ¸…æ¥šé¢˜æ„åæˆ‘ä»¬ä¸éš¾å‘ç°ï¼Œæ“ä½œçš„æ¬¡æ•°æ˜¯æœ‰é™çš„ï¼Œæœ€å¤šæ˜¯ç­‰äºç§ç±»æ•°-1ï¼Œç„¶åæˆ‘ä»¬è§‚å¯Ÿæ•°æ®èŒƒå›´&lt;1000ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é‡‡ç”¨æšä¸¾æ“ä½œæ•°çš„æ–¹å¼è§£å†³è¿™é“é¢˜ç›®ï¼Œä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617class Solution &#123;public: long long minCost(vector&lt;int&gt;&amp; nums, int x) &#123; int len = nums.size(); vector&lt;int&gt;min_nw = nums; long long ans = 1000000000004; for(int i=0;i&lt;len;++i)&#123; long long tmp = (long long)i*x; for(int j=0;j&lt;len;++j)&#123; min_nw[j] = min(min_nw[j],nums[(j+i)%len]); tmp += min_nw[j]; &#125; ans = min(ans,tmp); &#125; return ans; &#125;&#125;; 2023-12-29 é¢˜ç›®ä¼ é€é—¨ï¼š2706. è´­ä¹°ä¸¤å—å·§å…‹åŠ› - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ï¼Œä»£ç å¦‚ä¸‹ï¼š 12345678class Solution &#123;public: int buyChoco(vector&lt;int&gt;&amp; prices, int money) &#123; sort(prices.begin(),prices.end()); int cost = prices[0] + prices[1]; return cost &gt; money?money:money-cost; &#125;&#125;; 2023-12-30 é¢˜ç›®ä¼ é€é—¨ï¼š1185. ä¸€å‘¨ä¸­çš„ç¬¬å‡ å¤© - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡æ‹Ÿé¢˜ï¼Œæ³¨æ„åˆ¤æ–­é—°å¹´ä»¥åŠé—°å¹´äºŒæœˆä»½çš„æ—¶å€™å³å¯ã€‚ 12345678910111213141516171819202122class Solution &#123;public: string dayOfTheWeek(int day, int month, int year) &#123; auto judge_year = [&amp;](int x)&#123; if(x % 400 == 0 || (x % 4 == 0 &amp;&amp; x % 100 != 0)) return true; return false; &#125;; vector&lt;string&gt; weekDay = &#123;&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;&#125;; vector&lt;int&gt; monthDay = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; int ans = day; // cal_year int del_year = year-1971; ans += (year-1971)*365; for(int i=1971;i&lt;year;++i)&#123; if (judge_year(i)) ans++; &#125; for(int i=1;i&lt;month;++i) ans += monthDay[i-1]; ans = (month&gt;2&amp;&amp;judge_year(year))?ans+1:ans; int week_day = (4+ans)%7; return weekDay[week_day]; &#125;&#125;; æ³¨æ„ä¸Šä¸€é¢˜Sundayå­˜çš„ä¸‹æ ‡ä¸º0ï¼Œå› ä¸ºè¿™æ ·å¤„ç†æ–¹ä¾¿ä¸€äº›ã€‚ 2023-12-31 é¢˜ç›®ä¼ é€é—¨ï¼š1154. ä¸€å¹´ä¸­çš„ç¬¬å‡ å¤© - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸Šä¸€é“é¢˜çš„ç®€å•ç‰ˆã€‚ 12345678910111213141516171819class Solution &#123;public: int dayOfYear(string date) &#123; int year = stoi(date.substr(0, 4)); int month = stoi(date.substr(5, 2)); int day = stoi(date.substr(8, 2)); auto judge_year = [&amp;](int x) &#123; if (x%400==0||(x%4==0&amp;&amp;x%100!=0)) return true; return false; &#125;; vector&lt;int&gt; months = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; int ans = day; for (int i=1;i&lt;month;++i) &#123; ans += months[i-1]; &#125; return (month&gt;2&amp;&amp;judge_year(year))?ans+1:ans; &#125;&#125;;"},{"title":"2024å¹´01æœˆæ¯æ—¥ä¸€é¢˜","path":"/wiki/LeetCode/æ¯æ—¥ä¸€é¢˜/2024å¹´01æœˆæ¯æ—¥ä¸€é¢˜.html","content":"2024-01-01 é¢˜ç›®ä¼ é€é—¨ï¼š1599. ç»è¥æ‘©å¤©è½®çš„æœ€å¤§åˆ©æ¶¦ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ–°å¹´å¿«ä¹ğŸ‡ğŸ‡ğŸ‡ï¼ï¼ï¼ï¼Œæ–°å¹´ç¬¬ä¸€é¢˜å°±æ˜¯ä¹‹å‰åšè¿‡çš„ï¼Œæ¨¡æ‹Ÿå³å¯ã€‚é¦–å…ˆå…ˆå¾ªç¯æ¯ä¸ªæ—¶é—´ç‚¹ï¼Œä½¿ç”¨ä¸€ä¸ªå˜é‡previè®°å½•è¯¥æ—¶é—´ç‚¹ä¸Šä¸€ä¸ªæ—¶é—´ç‚¹åè¿˜å‰©ä¸‹æ²¡ä¸Šæ‘©å¤©è½®çš„é¡¾å®¢æ•°é‡ï¼Œç„¶åå½“å‰æ—¶é—´ç‚¹çš„é¡¾å®¢æ•°å°±æ˜¯ä¹‹å‰å‰©ä¸‹çš„åŠ ä¸Šæ–°æ¥çš„ï¼Œè¿™é‡Œå¤§äº4è¿˜æ˜¯å°äºç­‰äº4åˆ†ç±»è®¨è®ºä¸€ä¸‹ã€‚æœ€åå¦‚æœæœ€åä¸€ä¸ªæ—¶é—´ç‚¹å·²ç»è¿‡äº†çš„è¯previè¿˜æœ‰å‰©ä½™ï¼Œåˆ™ç»§ç»­è½¬ç›´åˆ°å°†previè½¬ç©ºï¼Œä¸­é—´åˆ¤æ–­ä¸€ä¸‹è½¬å¤šå°‘æ¬¡çš„æ—¶å€™èƒ½å¤Ÿæœ‰æœ€å¤§åˆ©æ¶¦å³å¯ï¼š Pythonä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233class Solution: def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -&gt; int: res = 0 ans = [] serv = 0 for idx,customer in enumerate(customers): if customer + res &gt; 4: res += (customer-4) serv += 4 ans.append(serv * boardingCost - (idx+1) * runningCost) else: serv += (res+customer) res = 0 ans.append(serv * boardingCost - (idx+1) * runningCost) while res: idx += 1 if res &gt; 4: serv += 4 res -= 4 ans.append(serv * boardingCost - (idx+1) * runningCost) else: serv += res res = 0 ans.append(serv * boardingCost - (idx+1) * runningCost) now,loc = 0,-1 # return ans for i in range(len(ans)): if now &lt; ans[i]: now = ans[i] loc = i+1 return -1 if loc == -1 else loc C++ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public: int minOperationsMaxProfit(vector&lt;int&gt;&amp; customers, int boardingCost, int runningCost) &#123; int previ = 0; int ans = 0,nw = 0; int ans_cnt=-1,cnt=0; for (auto customer:customers) &#123; int tmp = customer + previ; cnt++; if (tmp &gt; 4) &#123; nw += 4*boardingCost - runningCost; previ = tmp - 4; if (nw &gt; ans) ans = nw,ans_cnt = cnt; ans = max(ans, nw); &#125; else &#123; nw += tmp*boardingCost - runningCost; previ = 0; if (nw &gt; ans) ans = nw,ans_cnt = cnt; &#125; &#125; while (previ) &#123; cnt++; if(previ &gt; 4) &#123; nw += 4*boardingCost - runningCost; previ -= 4; if (nw &gt; ans) ans = nw,ans_cnt = cnt; &#125; else &#123; nw += previ*boardingCost - runningCost; previ = 0; if (nw &gt; ans) ans = nw,ans_cnt = cnt; &#125; &#125; return ans_cnt; &#125; &#125;; 2024-01-02 é¢˜ç›®ä¼ é€é—¨ï¼š466. ç»Ÿè®¡é‡å¤ä¸ªæ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 2024-01-03 é¢˜ç›®ä¼ é€é—¨ï¼š2487. ä»é“¾è¡¨ä¸­ç§»é™¤èŠ‚ç‚¹ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“é“¾è¡¨çš„é¢˜ç›®ï¼Œå……åˆ†æš´éœ²äº†æˆ‘å¯¹C++ä¸€äº›ç‰¹æ€§ä»¥åŠæŒ‡é’ˆç›¸å…³å†…å®¹è¿˜ä¸æ˜¯éå¸¸çš„ç†Ÿç»ƒã€‚ 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNodes(ListNode* head) &#123; ListNode* nw = head; vector&lt;int&gt; arr = &#123;nw-&gt;val&#125;; while (nw-&gt;next) &#123; nw = nw-&gt;next; arr.push_back(nw-&gt;val); &#125; stack&lt;int&gt; ans_arr; int siz = arr.size(); for (int i=siz-1;i&gt;=0;--i) &#123; if (ans_arr.size()==0||arr[i] &gt;= ans_arr.top()) &#123; ans_arr.push(arr[i]); &#125; &#125; ListNode *hhead = new ListNode(), *now = new ListNode(); now = hhead; while (!ans_arr.empty()) &#123; ListNode *tmp = new ListNode(); int nw_val = ans_arr.top(); ans_arr.pop(); tmp-&gt;val = nw_val; now-&gt;next = tmp; now = tmp; &#125; return hhead-&gt;next; &#125;&#125;; æ³¨æ„éœ€è¦éå¸¸æ³¨æ„çš„å°±æ˜¯åœ¨åˆå§‹åŒ–æŒ‡é’ˆçš„æ—¶å€™ä¸€å®šè¦è¿™ä¹ˆå†™ListNode *hhead = new ListNode(), *now = new ListNode(); ä¸ºä»€ä¹ˆä¸èƒ½ListNode *tmp; è¿™é‡Œçš„tmpæ˜¯ä¸€ä¸ªæŒ‡å‘ListNodeç±»å‹çš„æŒ‡é’ˆã€‚ä½†æ˜¯ï¼Œè¿™ä¸ªæŒ‡é’ˆåœ¨ä½¿ç”¨ä¹‹å‰æ²¡æœ‰è¢«åˆ†é…ä»»ä½•å†…å­˜ã€‚è¿™æ„å‘³ç€tmpæŒ‡å‘çš„æ˜¯ä¸€ä¸ªæœªçŸ¥çš„ã€æœªåˆå§‹åŒ–çš„å†…å­˜ä½ç½®ã€‚å½“æ‚¨å°è¯•é€šè¿‡now-&gt;next = tmp;ç»™now-&gt;nextèµ‹å€¼æ—¶ï¼Œæ‚¨å®é™…ä¸Šæ˜¯åœ¨è®©now-&gt;nextæŒ‡å‘ä¸€ä¸ªä¸ç¡®å®šçš„å†…å­˜ä½ç½®ã€‚è¿™æ˜¯éå¸¸å±é™©çš„ï¼Œå› ä¸ºè¿™å—å†…å­˜å¯èƒ½æ˜¯ç©ºçš„ï¼Œæˆ–è€…å·²ç»è¢«å…¶ä»–æ•°æ®å ç”¨ï¼Œä»è€Œå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºæˆ–ç¨‹åºå´©æºƒã€‚ ä¸ºä»€ä¹ˆä¸èƒ½ListNode* tmp = nullptr; å¦‚æœæ‚¨å°†ListNode* tmp = nullptr;å¹¶åœ¨ä¹‹åçš„ä»£ç ä¸­å°è¯•é€šè¿‡tmpæŒ‡é’ˆè®¿é—®æˆ–ä¿®æ”¹æ•°æ®ï¼Œé‚£ä¹ˆè¿™åŒæ ·ä¼šå¯¼è‡´é”™è¯¯ã€‚åŸå› å¦‚ä¸‹ï¼š ç©ºæŒ‡é’ˆè§£å¼•ç”¨: å½“tmpè¢«è®¾ç½®ä¸ºnullptræ—¶ï¼Œå®ƒæŒ‡å‘çš„æ˜¯ç©ºåœ°å€ã€‚ä»»ä½•å°è¯•é€šè¿‡ç©ºæŒ‡é’ˆï¼ˆnullptrï¼‰è®¿é—®æˆ–ä¿®æ”¹æ•°æ®çš„è¡Œä¸ºéƒ½ä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯ï¼Œé€šå¸¸æ˜¯æ®µé”™è¯¯ï¼ˆsegmentation faultï¼‰ã€‚åœ¨æ‚¨çš„ä»£ç ä¸­ï¼Œå¦‚æœtmpæ˜¯nullptrï¼Œé‚£ä¹ˆåƒnow-&gt;next = tmp;è¿™æ ·çš„èµ‹å€¼æ“ä½œæ˜¯å®‰å…¨çš„ï¼Œä½†ä¹‹åçš„tmp-&gt;val = nw_val;å°è¯•è§£å¼•ç”¨nullptrï¼Œè¿™ä¼šå¯¼è‡´é”™è¯¯ã€‚ æœªåˆ†é…å®é™…çš„èŠ‚ç‚¹: åœ¨é“¾è¡¨æ“ä½œä¸­ï¼Œé€šå¸¸éœ€è¦åˆ›å»ºæ–°çš„èŠ‚ç‚¹æ¥å­˜å‚¨æ•°æ®ã€‚å¦‚æœtmpåªæ˜¯ä¸€ä¸ªç©ºæŒ‡é’ˆï¼Œé‚£ä¹ˆå®ƒä¸èƒ½ç”¨äºå­˜å‚¨ä»»ä½•å®é™…çš„æ•°æ®ã€‚æ‚¨éœ€è¦ä¸ºæ¯ä¸ªæ–°èŠ‚ç‚¹åˆ†é…å†…å­˜æ¥å­˜å‚¨æ•°æ®å’ŒæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚ æ€»ç»“ è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæ‚¨éœ€è¦åœ¨ä½¿ç”¨tmpä¹‹å‰ä¸ºå…¶åˆ†é…å†…å­˜ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š 1ListNode* tmp = new ListNode(); // åˆ†é…å†…å­˜å¹¶åˆå§‹åŒ– è¿™æ ·ï¼Œtmpä¸å†æ˜¯ä¸€ä¸ªç©ºæŒ‡é’ˆï¼Œè€Œæ˜¯æŒ‡å‘ä¸€ä¸ªæ–°åˆ†é…ä¸”å·²åˆå§‹åŒ–çš„ListNodeå¯¹è±¡ã€‚è¿™å…è®¸æ‚¨å®‰å…¨åœ°ä½¿ç”¨tmpæ¥å­˜å‚¨æ•°æ®å¹¶å°†å…¶åŠ å…¥åˆ°é“¾è¡¨ä¸­ã€‚ 2024-01-04 é¢˜ç›®ä¼ é€é—¨ï¼š2397. è¢«åˆ—è¦†ç›–çš„æœ€å¤šè¡Œæ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“æš´åŠ›æœç´¢æ¿å­é¢˜ç›®ã€‚ 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int maximumRows(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int numSelect) &#123; int ans = 0; int m = matrix.size(),n = matrix[0].size(); vector&lt;bool&gt; cols(n,false); auto judge = [&amp;](int x) &#123; int now_ans = 0; for(int i=0;i&lt;n;++i)&#123; if (matrix[x][i]==1 &amp;&amp; cols[i]==false) return false; &#125; return true; &#125;; function&lt;void(int,int)&gt; dfs = [&amp;](int idx,int pre) &#123; if (idx==numSelect) &#123; int nw = 0; for(int i=0;i&lt;m;++i)&#123; if (judge(i)) nw += 1; &#125; ans = max(ans,nw); return; &#125; for (int i=pre+1;i&lt;n;++i) &#123; cols[i] = true; dfs(idx+1, i); cols[i] = false; &#125; &#125;; dfs(0,-1); return ans; &#125;&#125;; 2024-01-05 é¢˜ç›®ä¼ é€é—¨ï¼š1944. é˜Ÿåˆ—ä¸­å¯ä»¥çœ‹åˆ°çš„äººæ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åœ¨è¯»å®Œé¢˜ç›®ä»¥åŠçœ‹å®Œæ•°æ®èŒƒå›´åä¸éš¾æƒ³åˆ°åº”è¯¥ç”¨å•è°ƒæ ˆçš„æ–¹æ³•è§£å†³è¿™é“é¢˜ï¼Œåå‘éå†æ•°ç»„ï¼Œå•è°ƒæ ˆç»´æŠ¤ä¸€ä¸ªé¡¶å°åº•å¤§çš„æ ˆï¼Œä»£è¡¨å½“å‰å…ƒç´ å¯èƒ½å¯ä»¥çœ‹è§çš„å³è¾¹çš„äººã€‚ æˆ‘ä»¬åªéœ€è¦åœ¨æ¯æ¬¡åœ¨åˆ¤æ–­å½“å‰å…ƒç´ æ—¶ï¼Œç»Ÿè®¡æˆ‘ä»¬è¦è¿›è¡Œå¤šå°‘æ¬¡å¼¹æ ˆæ“ä½œã€‚å°±æ˜¯æˆ‘ä»¬èƒ½å¤Ÿçœ‹åˆ°çš„äººçš„æ•°é‡ï¼Œä½†æ˜¯æœ€åè¿˜æœ‰ä¸€ä¸ªåœ°æ–¹éœ€è¦æ³¨æ„ä¸€ä¸‹ï¼Œè§ä¸‹é¢çº¢è‰²ã€‚ æ³¨æ„è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªç»†èŠ‚ï¼Œå¼¹å®Œæ ˆåï¼Œéœ€è¦åˆ¤æ–­å½“å‰æ ˆæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ä¸ºç©ºï¼Œæˆ‘ä»¬èƒ½çœ‹åˆ°çš„äººè¿˜è¦+1ï¼ˆè™½ç„¶æ¯”æˆ‘ä»¬é«˜ä½†æ˜¯èƒ½çœ‹åˆ°ï¼‰ 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; canSeePersonsCount(vector&lt;int&gt;&amp; heights) &#123; stack&lt;int&gt; stk; int n = heights.size(); vector&lt;int&gt; ans(n,0); for(int i=n-1;i&gt;=0;--i)&#123; int tmp = 0; while(!stk.empty() &amp;&amp; heights[stk.top()] &lt; heights[i]) &#123; stk.pop(); tmp++; &#125; if (stk.empty()) ans[i] = tmp; else ans[i] = tmp+1; stk.push(i); &#125; return ans; &#125;&#125;; 2024-01-06 é¢˜ç›®ä¼ é€é—¨ï¼š2807. åœ¨é“¾è¡¨ä¸­æ’å…¥æœ€å¤§å…¬çº¦æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“éå¸¸ç®€å•çš„ç­¾åˆ°é¢˜ï¼Œå¤ä¹ ä¸€ä¸‹é“¾è¡¨å†™æ³•å’Œgcdå†™æ³•ã€‚ 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* insertGreatestCommonDivisors(ListNode* head) &#123; function&lt;int(int,int)&gt; ggcd=[&amp;](int a,int b) &#123; return a%b==0?b:ggcd(b,a%b); &#125;; ListNode *nw = head; if (nw-&gt;next == nullptr) return head; ListNode *nwnxt = nw-&gt;next; while (nwnxt != nullptr) &#123; int val = ggcd(max(nw-&gt;val,nwnxt-&gt;val),min(nw-&gt;val,nwnxt-&gt;val)); ListNode *tmp = new ListNode(val, nwnxt); nw-&gt;next = tmp; nw = nwnxt; nwnxt = nwnxt-&gt;next; &#125; return head; &#125;&#125;; 2024-01-07 é¢˜ç›®ä¼ é€é—¨ï¼š383. èµé‡‘ä¿¡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å»ºç«‹26ä¸ªæ¡¶ï¼Œç»Ÿè®¡æ¯ä¸ªå­—ç¬¦ä¸ªæ•°å³å¯ã€‚ç­¾åˆ°é¢˜ï¼š 12345678910111213class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; if (ransomNote.size() &gt; magazine.size()) return false; vector&lt;int&gt; cnt(26,0); for(auto note:magazine) cnt[note-&#x27;a&#x27;]++; for(auto note:ransomNote)&#123; cnt[note-&#x27;a&#x27;]--; if (cnt[note-&#x27;a&#x27;] &lt; 0) return false; &#125; return true; &#125;&#125;; 2024-01-08 é¢˜ç›®ä¼ é€é—¨ï¼š447. å›æ—‹é•–çš„æ•°é‡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“unordered_mapå“ˆå¸Œé¢˜ï¼ŒO(n2)O(n^2)O(n2)å¤æ‚åº¦ï¼Œå¯¹äºæ¯ä¸ªä½ç½®ï¼Œéå†æ‰€æœ‰ä½ç½®ï¼Œä½¿ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨å­˜å‚¨ä¸è¯¥ä½ç½®ç›¸è·ç‰¹å®šè·ç¦»ä¸‹æœ‰å“ªäº›ä½ç½®ï¼ˆå“ˆå¸Œè¡¨ç´¢å¼•æ˜¯è·ç¦»ï¼‰ï¼Œæœ€åå°±å¯ä»¥æ ¹æ®è¿™ä¸ªå“ˆå¸Œè¡¨è®¡ç®—ä»¥è¯¥ç‚¹ä¸ºä¸­å¿ƒçš„å›æ—‹é•–æ•°é‡ã€‚ ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819class Solution &#123;public: int numberOfBoomerangs(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int ans = 0,n=points.size(); for(int i=0;i&lt;n;++i)&#123; unordered_map&lt;int,int&gt; cnt; for(int j=0;j&lt;n;++j)&#123; if (i == j) continue; int dis = (points[i][0]-points[j][0]) * (points[i][0]-points[j][0]) + (points[i][1]-points[j][1]) * (points[i][1]-points[j][1]); if(cnt.find(dis)==cnt.end()) cnt[dis] = 1; else cnt[dis] ++; &#125; for(auto ele:cnt) &#123; ans += ele.second * (ele.second-1); &#125; &#125; return ans; &#125;&#125;; 2024-01-09 é¢˜ç›®ä¼ é€é—¨ï¼š 2024-01-14 é¢˜ç›®ä¼ é€é—¨ï¼š83. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ é“¾è¡¨éå†ç­¾åˆ°é¢˜ç›®ï¼Œä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode *nw = head; while(nw!= nullptr&amp;&amp; nw-&gt;next!= nullptr)&#123; ListNode *nxt = nw-&gt;next; while(nxt!= nullptr&amp;&amp;nw-&gt;val == nxt-&gt;val) nxt = nxt-&gt;next; nw-&gt;next = nxt; nw = nw-&gt;next; &#125; return head; &#125;&#125;; 2024-01-15 é¢˜ç›®ä¼ é€é—¨ï¼š82. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ é“¾è¡¨éå†é¢˜ç›®ï¼Œæ˜¯æ˜¨å¤©é¢˜ç›®çš„åŠ å¼ºç‰ˆ,ä¸‹é¢ç»™å‡ºåªéå†ä¸€éçš„åšæ³•ï¼Œéœ€è¦æ³¨æ„çš„ç»†èŠ‚æ˜¯ï¼š å¤´èŠ‚ç‚¹ä¹Ÿå¯èƒ½è¢«åˆ é™¤ï¼Œæ‰€ä»¥è¦å¼€ä¸€ä¸ªheadä¹‹å‰çš„ç‚¹ã€‚ éœ€è¦åˆ¤æ–­ä¸‹ä¸€ä¸ªå’Œä¸‹ä¸‹ä¸ªèŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ï¼Œåªæœ‰éƒ½å­˜åœ¨æ‰å¯èƒ½å‡ºç°ç›¸ç­‰çš„æƒ…å†µã€‚ æœ€åä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode *headpre = new ListNode(0, head); ListNode *nw = headpre; while (nw-&gt;next &amp;&amp; nw-&gt;next-&gt;next) &#123; if (nw-&gt;next-&gt;val == nw-&gt;next-&gt;next-&gt;val) &#123; int x = nw-&gt;next-&gt;val; while (nw-&gt;next &amp;&amp; nw-&gt;next-&gt;val == x) &#123; nw-&gt;next = nw-&gt;next-&gt;next; &#125; &#125; else &#123; nw = nw-&gt;next; &#125; &#125; return headpre-&gt;next; &#125;&#125;; 2024-01-16 é¢˜ç›®ä¼ é€é—¨ï¼š2719. ç»Ÿè®¡æ•´æ•°æ•°ç›® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“æ•°ä½DPçš„é¢˜ç›® 2024-01-17 é¢˜ç›®ä¼ é€é—¨ï¼š2744. æœ€å¤§å­—ç¬¦ä¸²é…å¯¹æ•°ç›® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åŒé‡å¾ªç¯ç›´æ¥è§£å†³é—®é¢˜ã€‚ä»£ç å¦‚ä¸‹ï¼š 12345678910111213class Solution &#123;public: int maximumNumberOfStringPairs(vector&lt;string&gt;&amp; words) &#123; int n = words.size(); int ans = 0; for(int i=0;i&lt;n;++i)&#123; for(int j=i+1;j&lt;n;++j)&#123; if(words[i][0] == words[j][1] &amp;&amp; words[i][1] == words[j][0]) ans++; &#125; &#125; return ans; &#125;&#125;; 2024-01-20 é¢˜ç›®ä¼ é€é—¨ï¼š2788. æŒ‰åˆ†éš”ç¬¦æ‹†åˆ†å­—ç¬¦ä¸² - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ï¼ˆå¯¹äºPythonæ¥è¯´å“ˆå“ˆï¼‰ï¼ŒCçš„è¯ä¸»è¦å¯èƒ½éœ€è¦ä½¿ç”¨stringstreamä»¥åŠgetlineå‡½æ•°ï¼Œå…·ä½“è§æˆ‘çš„Cæ•´ç†ã€‚ æœ€ç»ˆä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516class Solution &#123;public: vector&lt;string&gt; splitWordsBySeparator(vector&lt;string&gt;&amp; words, char separator) &#123; vector&lt;string&gt; res; for (string &amp;word : words) &#123; stringstream ss(word); string sub; while (getline(ss, sub, separator)) &#123; if (!sub.empty()) &#123; res.push_back(sub); &#125; &#125; &#125; return res; &#125;&#125;; 2024-01-21 é¢˜ç›®ä¼ é€é—¨ï¼š410. åˆ†å‰²æ•°ç»„çš„æœ€å¤§å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“DPé¢˜ç›®ï¼Œè®¾ç½®dpäºŒç»´æ•°ç»„dp[n+1][k+1]dp[n+1][k+1]dp[n+1][k+1]å…¶ä¸­nnnè¡¨ç¤ºæ•°ç»„é•¿åº¦ï¼Œkkkè¡¨ç¤ºåˆ†å‰²æ¬¡æ•°ã€‚å®šä¹‰dp[i][j]dp[i][j]dp[i][j]çš„å«ä¹‰æ˜¯ä»ç¬¬1ä¸ªæ•°åˆ°ç¬¬iiiä¸ªæ•°åˆ†æˆkkkæ®µåçš„æœ€å¤§å€¼ã€‚é‚£ä¹ˆä¸éš¾æƒ³åˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹åº”è¯¥è¡¨ç¤ºä¸ºï¼š dp[j][i]=minâ¡(dp[j][i],maxâ¡(dp[kk][iâˆ’1],nums_sum[j]âˆ’nums_sum[kk]))dp[j][i] = \\min(dp[j][i],\\max(dp[kk][i-1], nums\\_sum[j]-nums\\_sum[kk])) dp[j][i]=min(dp[j][i],max(dp[kk][iâˆ’1],nums_sum[j]âˆ’nums_sum[kk])) å…¶ä¸­nums_sumnums\\_sumnums_sumæ˜¯å‰ç¼€å’Œæ•°ç»„, å› æ­¤nums_sum[j]nums\\_sum[j]nums_sum[j]è¡¨ç¤ºçš„æ˜¯å‰jjjä¸ªæ•°çš„å’Œã€‚ æ¥ä¸‹æ¥å°±æ˜¯dpé™åˆ¶æ¡ä»¶å’Œåˆå§‹çŠ¶æ€çš„å®šä¹‰äº†ï¼Œè§‚å¯Ÿä¸Šè¿°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œä¸éš¾å¾—çŸ¥æ–¹ç¨‹æƒ³è¦æ­£ç¡®è¿è¡Œéœ€è¦jâ‰¥ij\\geq ijâ‰¥iä¸”kkâ‰¥iâˆ’1kk\\geq i-1kkâ‰¥iâˆ’1 ä¸”j&gt;kkj &gt; kkj&gt;kkã€‚è¿™æ ·å¦‚æœé‡‡ç”¨é€’æ¨çš„æ–¹æ³•çš„è¯æˆ‘ä»¬å°±å¯ä»¥ç¡®å®šå¾ªç¯çš„é¡ºåºäº†ã€‚ 123for(int i=2; i&lt;=k; ++i)&#123;\tfor(int j=i; j&lt;=n; ++j)&#123; for(int kk=i-1; kk&lt;=j-1; ++kk) æœ€åå°±æ˜¯åˆå§‹æ¡ä»¶çš„ç¡®å®šäº†ï¼Œå…¶å®å°±æ˜¯åˆå§‹åŒ–dp[i][1]=nums_sum[i]dp[i][1] = nums\\_sum[i]dp[i][1]=nums_sum[i] ,ç„¶åå¾ªç¯å°±å¯ä»¥ä»ç¬¬äºŒä¸ªåˆ†å‰²å¼€å§‹å¾ªç¯äº†ã€‚ æ³¨æ„dpæ•°ç»„æœ€å¼€å§‹åˆå§‹åŒ–ä¸€å®šæ˜¯INT_MAX 123456789101112131415161718192021class Solution &#123;public: int splitArray(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(k+1, INT_MAX)); vector&lt;int&gt; nums_sum(n+1,0); dp[0][1] = 0; for(int i=0;i&lt;n;++i) &#123; dp[i+1][1] = dp[i][1] + nums[i]; nums_sum[i+1] = nums_sum[i] + nums[i]; &#125; for(int i=2; i&lt;=k; ++i)&#123; for(int j=i; j&lt;=n; ++j)&#123; for(int kk=i-1; kk&lt;=j-1; ++kk)&#123; dp[j][i] = min(dp[j][i],max(dp[kk][i-1], nums_sum[j]-nums_sum[kk])); &#125; &#125; &#125; return dp[n][k]; &#125;&#125;; è®°å¿†åŒ–æœç´¢åŒç†ï¼Œé€»è¾‘åè¿‡æ¥å°±è¡Œ,ä¼šæ›´ç®€å•æ˜“æ‡‚ä¸€äº›ï¼š 12345678910111213141516171819class Solution &#123;public: int splitArray(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(k + 1, INT_MAX)); dp[0][1] = 0; for (int i = 1; i &lt;= n; ++i) dp[i][1] = dp[i - 1][1] + nums[i - 1]; function&lt;int(int, int)&gt; dfs = [&amp;](int u, int v) &#123; if (v == 1) return dp[u][1]; if (dp[u][v] != INT_MAX) return dp[u][v]; int tmp = INT_MAX; for (int i = v - 1; i &lt; u; ++i) &#123; tmp = min(tmp, max(dfs(i, v - 1), dp[u][1] - dp[i][1])); &#125; return dp[u][v] = tmp; &#125;; return dfs(n, k); &#125;&#125;; è¿˜æ˜¯å»ºè®®ä½¿ç”¨é€’æ¨ï¼Œå› ä¸ºæ•ˆç‡æ›´é«˜ï¼ï¼ï¼ 2024-01-22 é¢˜ç›®ä¼ é€é—¨ï¼š670. æœ€å¤§äº¤æ¢ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™é“é¢˜è§£å†³æ–¹æ³•åº”è¯¥è¿˜æ˜¯å¾ˆå¤šçš„ï¼Œä½†æ˜¯å› ä¸ºä¹‹å‰åœ¨å­¦ä¹ å•è°ƒæ ˆï¼Œæ‰€ä»¥è¿™é‡Œç¬¬ä¸€æ—¶é—´æƒ³åˆ°çš„æ˜¯åŸºäºå•è°ƒæ ˆçš„è§£æ³•ã€‚ ä¸»ä½“æ€è·¯å¾ˆç®€å•ï¼Œå°±æ˜¯æˆ‘ä»¬å€’ç€æ‰«æè¿™ä¸ªæ•°çš„æ¯ä¸€ä½ï¼Œç»´æŠ¤ä¸€ä¸ªå•è°ƒæ ˆï¼Œè¿™æ ·æ¯æ¬¡æˆ‘ä»¬æ‰«æçš„æ—¶å€™å°±å¯ä»¥çŸ¥é“å½“å‰ç¬¬iä¸ªæ•°æ˜¯å¦æœ‰ä¸‹ä¸€ä¸ªæ¯”ä»–å¤§çš„æ•°ã€‚å¦‚æœæœ‰æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªæ•°ç»„ansè®°å½•æ¯”ä»–å¤§çš„æ•°çš„ç´¢å¼•ã€‚æœ€åæ­£ç€æ‰«ä¸€éæ•°ç»„ï¼Œå¦‚æœç¢°åˆ°ç¬¬ä¸€ä¸ªç¬¬iiiä¸ªæ•°çš„ans[i]ä¸­å­˜å‚¨äº†ç´¢å¼•ï¼Œåˆ™è¿›è¡Œäº¤æ¢æ“ä½œå³å¯ã€‚ æ³¨æ„åˆ¤æ–­å‡ºæ ˆçš„æ—¶å€™æ˜¯&gt;&gt;&gt;ä¸æ˜¯&gt;=&gt;=&gt;=ï¼Œè¿™æ˜¯å› ä¸ºå½“å€¼ä¸€æ ·æ—¶ï¼Œæ¢æ›´åé¢çš„æ˜¾ç„¶æ›´ä¼˜ï¼Œæœ€ååˆ¤æ–­å½“å‰æ•°å­˜ä¸å­˜ç´¢å¼•çš„æ—¶å€™ä¸€å®šè¦åˆ¤æ–­å½“å‰æ•°å’Œæ ˆåº•æ•°çš„å¤§å°å…³ç³»ï¼ˆå› ä¸ºæœ‰å¯èƒ½ä¸€æ ·å¤§ï¼Œè¿™æ—¶å°±ä¸éœ€è¦è¿›è¡Œäº¤æ¢ï¼‰ æœ€åä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223class Solution &#123;public: int maximumSwap(int num) &#123; string num_s = to_string(num); int n = num_s.size(); vector&lt;int&gt; stk; vector&lt;int&gt; ans(n,-1); for(int i=n-1;i&gt;=0;--i)&#123; while(!stk.empty() &amp;&amp; num_s[i]-&#x27;0&#x27; &gt; num_s[stk[stk.size()-1]] - &#x27;0&#x27;)stk.pop_back(); if (!stk.empty() &amp;&amp; num_s[i]-&#x27;0&#x27; &lt; num_s[stk[0]] - &#x27;0&#x27;) ans[i] = stk[0]; stk.emplace_back(i); &#125; for(int i=0;i&lt;n;++i)&#123; if (ans[i]!=-1) &#123; int tmp = num_s[ans[i]]-&#x27;0&#x27;; num_s[ans[i]] = num_s[i]; num_s[i] = tmp + &#x27;0&#x27;; break; &#125; &#125; return stoi(num_s); &#125;&#125;; 2023-01-23 é¢˜ç›®ä¼ é€é—¨ï¼š2765. æœ€é•¿äº¤æ›¿å­æ•°ç»„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ç›®ï¼Œä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223class Solution &#123;public: int alternatingSubarray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(),pre = nums[0]; int ans = -1; for(int i=1;i&lt;n;++i)&#123; if (nums[i] == pre+1) &#123; int tmp = 2; pre = nums[i]; int dir = -1; while (i+1&lt;n &amp;&amp; pre + dir == nums[i+1])&#123; dir *= -1; i += 1; pre = nums[i]; tmp ++; &#125; ans = max(ans,tmp); &#125; pre = nums[i]; &#125; return ans; &#125;&#125;; 2024-01-24 é¢˜ç›®ä¼ é€é—¨ï¼š2865. ç¾ä¸½å¡” I - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™é“é¢˜åŒæ ·ä¹Ÿæ˜¯ä¸€é“å•è°ƒæ ˆçš„é¢˜ç›®ï¼Œè¿˜æ˜¯æœ‰ç‚¹æ„æ€ã€‚ 1 2024-01-25 é¢˜ç›®ä¼ é€é—¨ï¼š2859. è®¡ç®— K ç½®ä½ä¸‹æ ‡å¯¹åº”å…ƒç´ çš„å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“ä½è¿ç®—ç­¾åˆ°é¢˜ç›®ï¼Œç»Ÿè®¡äºŒè¿›åˆ¶æ•°æœ‰å¤šå°‘ä¸ªç½®ä½ï¼Œåªéœ€è¦&amp;1å’Œå³ç§»å³å¯ã€‚ 123456789101112131415161718192021class Solution &#123;public: int sumIndicesWithKSetBits(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); function&lt;int(int)&gt;bitCount = [&amp;](int i)&#123; int nw = 0; while(i)&#123; nw += i&amp;1; i = i&gt;&gt;1; &#125; return nw; &#125;; int ans = 0; for(int i=0;i&lt;n;++i)&#123; if (bitCount(i)==k) &#123; ans += nums[i]; &#125; &#125; return ans; &#125;&#125;; 2024-01-26 é¢˜ç›®ä¼ é€é—¨ï¼š"},{"title":"2024å¹´03æœˆæ¯æ—¥ä¸€é¢˜","path":"/wiki/LeetCode/æ¯æ—¥ä¸€é¢˜/2024å¹´03æœˆæ¯æ—¥ä¸€é¢˜.html","content":"2024-03-01 é¢˜ç›®ä¼ é€é—¨ï¼š2369. æ£€æŸ¥æ•°ç»„æ˜¯å¦å­˜åœ¨æœ‰æ•ˆåˆ’åˆ† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ éå¸¸åŸºç¡€çš„DPï¼ŒDPæ–¹ç¨‹å¦‚ä¸‹ï¼š 123if (nums[i-1] == nums[i-2]) dp[i] = dp[i]||dp[i-2];if (nums[i-1] == nums[i-2]&amp;&amp;nums[i-2] == nums[i-3]) dp[i] = dp[i]||dp[i-3];if (nums[i-1] == nums[i-2]+1 &amp;&amp; nums[i-2] == nums[i-3]+1) dp[i] = dp[i]||dp[i-3]; å…¶ä¸­dp[i]ä»£è¡¨çš„æ˜¯åˆ°ç¬¬iä¸ªæ•°å‰é¢çš„æ•°èƒ½å¦è¢«åˆ’åˆ†ã€‚åˆå§‹æ¡ä»¶dp[0]=true;dp[1]=falseï¼Œç„¶ådp[2]çš„å–å€¼ï¼Œå–å†³äºç¬¬ä¸€ä¸ªå…ƒç´ å’Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯å¦ç›¸ç­‰ï¼Œä»3å¼€å§‹é€’æ¨ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516class Solution &#123;public: bool validPartition(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt; 2) return false; vector&lt;bool&gt; dp(n+1,false); dp[0] = true; dp[1] = false; if (nums[0]==nums[1]) dp[2] = true; for(int i=3; i&lt;=n; ++i) &#123; if (nums[i-1] == nums[i-2]) dp[i] = dp[i]||dp[i-2]; if (nums[i-1] == nums[i-2]&amp;&amp;nums[i-2] == nums[i-3]) dp[i] = dp[i]||dp[i-3]; if (nums[i-1] == nums[i-2]+1 &amp;&amp; nums[i-2] == nums[i-3]+1) dp[i] = dp[i]||dp[i-3]; &#125; return dp[n]; &#125;&#125;; 2024-03-02 é¢˜ç›®ä¼ é€é—¨ï¼š2368. å—é™æ¡ä»¶ä¸‹å¯åˆ°è¾¾èŠ‚ç‚¹çš„æ•°ç›® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ DFSæ·±æœï¼Œå¯¹äºæ¯ä¸ªèŠ‚ç‚¹è¿”å›ä»¥å½“å‰èŠ‚ç‚¹ä¸ºå­æ ‘å¯ä»¥è®¿é—®çš„èŠ‚ç‚¹æ•°é‡ã€‚ å®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021class Solution &#123;public: int reachableNodes(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;int&gt;&amp; restricted) &#123; vector&lt;bool&gt; vis(n, false); for(auto &amp;node:restricted) vis[node] = true; vector&lt;vector&lt;int&gt;&gt; es(n); for(auto &amp;edge:edges)&#123; es[edge[0]].push_back(edge[1]); es[edge[1]].push_back(edge[0]); &#125; function&lt;int(int,int)&gt; dfs = [&amp;](int u, int fa)&#123; int now = 1; for(auto &amp;v:es[u])&#123; if (vis[v]||v == fa) continue; now += dfs(v, u); &#125; return now; &#125;; return dfs(0, -1); &#125;&#125;; 2024-03-09 é¢˜ç›®ä¼ é€é—¨ï¼š2386. æ‰¾å‡ºæ•°ç»„çš„ç¬¬ K å¤§å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 2024-03-10 é¢˜ç›®ä¼ é€é—¨ï¼š299. çŒœæ•°å­—æ¸¸æˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ€è·¯æ¯”è¾ƒç®€å•çš„ä¸€é“é¢˜ï¼Œå…¶å®æˆ‘ä»¬åªéœ€è¦éå†ï¼Œå¯¹äºä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸åŒä½ç½®å¦‚æœä¸€è‡´ä¸ç”¨ç®¡ï¼Œä¸ä¸€æ ·ï¼Œåˆ†åˆ«å­˜å…¥å¯¹åº”çš„10ä¸ªæ¡¶ä¸­ï¼ˆåˆ†åˆ«ä»£è¡¨æ¯ä¸ªå­—ç¬¦ä¸²ä¸­0~9çš„ä¸ªæ•°ï¼‰ï¼Œæœ€åæ¯”è¾ƒå¯¹åº”ä½ç½®æ¡¶çš„å¤§å°å³å¯ã€‚ æ³¨æ„ï¼šC++å­—fwç¬¦å¸¸é‡ä½¿ç”¨''ï¼Œå­—ç¬¦ä¸²å¸¸é‡ä½¿ç”¨&quot;&quot; ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819class Solution &#123; public: string getHint(string secret, string guess) &#123; vector&lt;int&gt; buk_sec(10,0),buk_gue(10,0); int a = 0; for (int i=0;i&lt;secret.size();++i) &#123; if(secret[i]==guess[i]) a++; else &#123; buk_sec[secret[i]-&#x27;0&#x27;]++; buk_gue[guess[i]-&#x27;0&#x27;]++; &#125; &#125; int b = 0; for(int i=0;i&lt;10;++i)&#123; b += min(buk_sec[i],buk_gue[i]); &#125; return to_string(a)+&quot;A&quot;+to_string(b)+&quot;B&quot;; &#125; &#125;; 2024-03-11 é¢˜ç›®ä¼ é€é—¨ï¼š2129. å°†æ ‡é¢˜é¦–å­—æ¯å¤§å†™ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™é“é¢˜ä½œä¸ºä¸€é“åŸºç¡€æ¨¡æ‹Ÿé¢˜ï¼Œæ•´ä½“æ€è·¯å¹¶ä¸å¤æ‚ï¼Œæˆ‘å°†æ€è·¯åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µï¼Œç¬¬ä¸€é˜¶æ®µå°†æ¯ä¸ªå•è¯ç¬¬ä¸€ä¸ªå­—æ¯éƒ½å¤§å†™ï¼Œç„¶åå°†æ‰€æœ‰éé¦–å­—æ¯çš„éƒ¨åˆ†éƒ½å°å†™ã€‚ç¬¬äºŒé˜¶æ®µåˆ¤æ–­æ¯ä¸ªå•è¯çš„é•¿åº¦ï¼Œå¦‚æœé•¿åº¦å°äºç­‰äº2ï¼Œåˆ™å°†è¯¥å•è¯é¦–å­—æ¯å°å†™ã€‚ æ³¨æ„è¿™é‡Œè½¬æ¢å¤§å†™å’Œè½¬æ¢å°å†™å¯ä»¥ä½¿ç”¨toupperå’Œtolowerå‡½æ•° å› æ­¤æœ€ç»ˆä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 123456789101112131415161718192021222324252627282930class Solution &#123;public: string capitalizeTitle(string title) &#123; int n = title.size(); bool flag = true; // å…ˆå°†æ‰€æœ‰å•è¯çš„æ‰€æœ‰é¦–å­—æ¯å¤§å†™ for(auto &amp;let:title)&#123; if (let == &#x27; &#x27;) &#123; flag = true; continue; &#125; if(flag == true)&#123; flag = false; let=toupper(let); &#125; else &#123; let=tolower(let); &#125; &#125; int len = title.size(); // å†åˆ¤æ–­æ‰€æœ‰å•è¯æ˜¯å¦æ»¡è¶³å°äºç­‰äº2ï¼Œå¦‚æœæ»¡è¶³å°±å°†æœ€å‰é¢çš„å­—ç¬¦å˜ä¸ºå°å†™ for(int i=0;i&lt;len;++i)&#123; if (title[i] == &#x27; &#x27;) continue; int tmp = i; while(tmp&lt;len&amp;&amp;title[tmp]!=&#x27; &#x27;) tmp++; if(tmp-i&lt;=2) title[i] = tolower(title[i]); i = tmp; &#125; return title; &#125;&#125;;"},{"title":"2024å¹´05æœˆæ¯æ—¥ä¸€é¢˜","path":"/wiki/LeetCode/æ¯æ—¥ä¸€é¢˜/2024å¹´05æœˆæ¯æ—¥ä¸€é¢˜.html","content":"2024-05-05 é¢˜ç›®ä¼ é€é—¨ï¼š1652. æ‹†ç‚¸å¼¹ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡æ‹Ÿç­¾åˆ°é¢˜ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒC++è´Ÿæ•°å–æ¨¡è¿˜æ˜¯è´Ÿæ•°ï¼ï¼ï¼ï¼ï¼ï¼ï¼ æ‰€ä»¥éœ€è¦å…ˆè½¬æˆæ­£æ•°å†å–æ¨¡ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; decrypt(vector&lt;int&gt;&amp; code, int k) &#123; int n = code.size(); vector&lt;int&gt; ans(n,0); if (k==0) return ans; for(int i=0;i&lt;n;++i)&#123; for(int j=1;j&lt;=abs(k);++j)&#123; int nw = i+(k/abs(k))*j; while(nw &lt; 0) nw += n; ans[i] += code[nw%n]; &#125; &#125; return ans; &#125;&#125;; 2024-05-10 é¢˜ç›®ä¼ é€é—¨ï¼š2960. ç»Ÿè®¡å·²æµ‹è¯•è®¾å¤‡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡æ‹Ÿç­¾åˆ°é¢˜ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314class Solution &#123;public: int countTestedDevices(vector&lt;int&gt;&amp; batteryPercentages) &#123; int n = batteryPercentages.size(); int ans = 0; for(int i=0;i&lt;n;++i)&#123; if (batteryPercentages[i]) &#123; ans ++; for(int j=i+1;j&lt;n;++j) batteryPercentages[j] = max(batteryPercentages[j]-1,0); &#125; &#125; return ans; &#125;&#125;; 2024-05-24 é¢˜ç›®ä¼ é€é—¨ï¼š1673. æ‰¾å‡ºæœ€å…·ç«äº‰åŠ›çš„å­åºåˆ— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å•è°ƒæ ˆé¢˜ç›®ï¼Œæ ¹æ®é¢˜ç›®å¯¹ç«äº‰åŠ›çš„å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°è¶Šå°çš„æ•°å­—æ”¾ç½®çš„ä½ç½®è¶Šå‰ï¼Œå¯¹åº”çš„å­åºåˆ—è¶Šå…·ç«äº‰åŠ›ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ç±»ä¼¼å•è°ƒæ ˆçš„æ€æƒ³å°½é‡å°†æ›´å°çš„å…ƒç´ æ”¾åˆ°å­åºåˆ—çš„å‰é¢ï¼Œä»¤ numsnumsnums çš„å¤§å°ä¸º nnnï¼Œéå†æ•°ç»„nums\\textit{nums}numsï¼Œå‡è®¾å½“å‰è®¿é—®çš„ä¸‹æ ‡ä¸º iiiï¼Œå¯¹æ•°å­— nums[i]\\textit{nums}[i]nums[i] æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š è®°æ ˆä¸­çš„å…ƒç´ æ•°ç›®ä¸º mmmï¼Œæˆ‘ä»¬ä¸æ–­åœ°è¿›è¡Œæ“ä½œç›´åˆ°ä¸æ»¡è¶³æ¡ä»¶ï¼šå¦‚æœ m&gt;0m&gt;0m&gt;0 ä¸” m+nâˆ’i&gt;km+nâˆ’i&gt;km+nâˆ’i&gt;k ä¸”å•è°ƒæ ˆçš„æ ˆé¡¶å…ƒç´ å¤§äº nums[i]\\textit{nums}[i]nums[i]ï¼Œé‚£ä¹ˆè¯´æ˜æ ˆé¡¶å…ƒç´ å¯ä»¥è¢«å½“å‰æ•°å­— nums[i]\\textit{nums}[i]nums[i] æ›¿æ¢ï¼Œå¼¹å‡ºå•è°ƒæ ˆçš„æ ˆé¡¶å…ƒç´ ã€‚ å°†nums[i]nums[i]nums[i]å‹å…¥æ ˆä¸­ã€‚ æœ€åè¿”å›æ ˆä¸­è‡ªä¸‹è€Œä¸Šçš„å‰Â kkk ä¸ªå…ƒç´ ä¸ºç»“æœã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213class Solution &#123;public: vector&lt;int&gt; mostCompetitive(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; stk; int n = nums.size(); for(int i=0; i&lt;n; ++i) &#123; while (!stk.empty() &amp;&amp; n-i+stk.size() &gt; k &amp;&amp; stk.back() &gt; nums[i]) stk.pop_back(); stk.push_back(nums[i]); &#125; stk.resize(k); return stk; &#125;&#125;; 2024-05-25 é¢˜ç›®ä¼ é€é—¨ï¼š2903. æ‰¾å‡ºæ»¡è¶³å·®å€¼æ¡ä»¶çš„ä¸‹æ ‡ I - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ç›®ï¼Œä¸¤ä¸ªå¾ªç¯ç»“æŸæˆ˜æ–—ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789class Solution &#123; public: vector&lt;int&gt; findIndices(vector&lt;int&gt;&amp; nums, int indexDifference, int valueDifference) &#123; int n = nums.size(); for(int i=0; i&lt;n;++i)&#123; for(int j=i;j&lt;n;++j)&#123; if (j-i&gt;=indexDifference &amp;&amp; abs(nums[j]-nums[i])&gt;=valueDifference) return vector&lt;int&gt;&#123;i, j&#125;; &#125; &#125; return vector&lt;int&gt;&#123;-1,-1&#125;; &#125;&#125;; 2024-05-26 é¢˜ç›®ä¼ é€é—¨ï¼š1738. æ‰¾å‡ºç¬¬ K å¤§çš„å¼‚æˆ–åæ ‡å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å‰ç¼€å’Œ+æ’åºå³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526class Solution &#123;public: int kthLargestValue(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; int n = matrix.size(), m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; xor_all(n+1,vector&lt;int&gt;(m+1)); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; xor_all[i][j] = xor_all[i][j-1] ^ matrix[i-1][j-1]; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; xor_all[i][j] = xor_all[i-1][j] ^ xor_all[i][j]; &#125; &#125; vector&lt;int&gt; nw; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; nw.push_back(xor_all[i][j]); &#125; &#125; sort(nw.begin(), nw.end()); int nn = nw.size(); return nw[nn-k]; &#125;&#125;; 2024-05-27 é¢˜ç›®ä¼ é€é—¨ï¼š2028. æ‰¾å‡ºç¼ºå¤±çš„è§‚æµ‹æ•°æ® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡æ‹Ÿç­¾åˆ°é¢˜ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; missingRolls(vector&lt;int&gt;&amp; rolls, int mean, int n) &#123; int nn = rolls.size(); int N = n + nn; int all_sum = mean*N; for(auto roll:rolls) &#123; all_sum -= roll; &#125; int nw_mean = all_sum / n; vector&lt;int&gt; ans; if (nw_mean &lt; 1 || nw_mean &gt; 6) return ans; int nw_rest = all_sum - (n*nw_mean); if (nw_rest &amp;&amp; nw_mean+1&gt;6) return ans; for(int i=1;i&lt;=n;++i) &#123; if(nw_rest)ans.push_back(nw_mean+1),nw_rest--; else ans.push_back(nw_mean); &#125; return ans; &#125;&#125;; 2024-05-28 é¢˜ç›®ä¼ é€é—¨ï¼š2951. æ‰¾å‡ºå³°å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ éå†ç­¾åˆ°é¢˜ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011class Solution &#123;public: vector&lt;int&gt; findPeaks(vector&lt;int&gt;&amp; mountain) &#123; vector&lt;int&gt; ans; int n = mountain.size(); for(int i=1;i&lt;n-1;++i)&#123; if(mountain[i] &gt; mountain[i-1] &amp;&amp; mountain[i] &gt; mountain[i+1]) ans.push_back(i); &#125; return ans; &#125;&#125;; 2024-05-31 é¢˜ç›®ä¼ é€é—¨ï¼š2965. æ‰¾å‡ºç¼ºå¤±å’Œé‡å¤çš„æ•°å­— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; findMissingAndRepeatedValues(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n = grid.size(); int ans1,ans2; vector&lt;int&gt; buk(3000,0); for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;n;++j)&#123; int tmp = grid[i][j]; buk[tmp]++; if (buk[tmp] == 2) ans2 = tmp; &#125; &#125; for(int i=1;i&lt;=n*n;++i)&#123; if (!buk[i]) ans1 = i; &#125; return vector&lt;int&gt;&#123;ans2, ans1&#125;; &#125;&#125;;"},{"title":"2024å¹´04æœˆæ¯æ—¥ä¸€é¢˜","path":"/wiki/LeetCode/æ¯æ—¥ä¸€é¢˜/2024å¹´04æœˆæ¯æ—¥ä¸€é¢˜.html","content":"2024-04-01 é¢˜ç›®ä¼ é€é—¨ï¼š2810. æ•…éšœé”®ç›˜ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“åŒç«¯é˜Ÿåˆ—æ•°æ®ç»“æ„é¢˜ï¼Œæˆ‘ä»¬æ¢ä¸€ç§æ€è·¯æ¥æƒ³ï¼Œå¦‚æœé‡ä¸Šå­—ç¬¦iï¼Œæ—‹è½¬ä¹‹å‰çš„æ‰€æœ‰å­—ç¬¦ç›¸å½“äºæ¢ä¸€ä¸ªæ–¹å‘è¿›è¡Œæ’å…¥æ“ä½œï¼Œå› æ­¤æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—æ¥æ¨¡æ‹Ÿè¿™ä¸ªæ“ä½œã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617class Solution &#123;public: string finalString(string s) &#123; deque&lt;char&gt; q; bool head = false; for (auto ch:s)&#123; if(ch!=&#x27;i&#x27;)&#123; if (head) q.push_front(ch); else q.push_back(ch); &#125; else &#123; head = !head; &#125; &#125; string ans = (head ? string&#123;q.rbegin(), q.rend()&#125; : string&#123;q.begin(), q.end()&#125;); return ans; &#125;&#125;; 2024-04-02 é¢˜ç›®ä¼ é€é—¨ï¼š894. æ‰€æœ‰å¯èƒ½çš„çœŸäºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™é“é¢˜æš´éœ²å‡ºè‡ªå·±å¯¹äºåˆ†æ²»ç®—æ³•è¿˜æ˜¯æœ‰ä¸€äº›é—å¿˜ï¼Œéœ€è¦å¤šåŠ ç»ƒä¹ ã€‚æ•´ä½“æ€è·¯æ¯”è¾ƒç®€å•ï¼Œåœ¨æ¯å±‚é€’å½’ä¸­ï¼Œå¦‚æœå½“å‰ä¸å‰©ä½™èŠ‚ç‚¹ï¼Œåˆ™è¿”å›ç©ºæ•°ç»„ï¼ˆå…¶å®è¿™ä¸ªåˆ¤æ–­åªä¼šåœ¨ç¬¬ä¸€æ¬¡è¿›è¡Œï¼Œåé¢ä¿è¯å·¦å³èŠ‚ç‚¹åˆ†åˆ°çš„ä¸ªæ•°éƒ½ä¸ºå¥‡æ•°ï¼Œå› ä¸ºå¶æ•°è‚¯å®šä¸æ»¡è¶³æ¡ä»¶ï¼‰ï¼Œå¦‚æœåªå‰©1ä¸ªï¼Œåˆ™è‡ªå·±å½“å¶å­èŠ‚ç‚¹ï¼Œå¦åˆ™æšä¸¾å·¦å³ä¸¤è¾¹èŠ‚ç‚¹æ•°é‡ã€‚ç„¶åè¿›è¡Œä¸‹ä¸€è½®é€’å½’ã€‚ä¸‹ä¸€å±‚é€’å½’ä¼šè¿”å›ä¸€ä¸ªvectorï¼Œä»£è¡¨ä¸åŒçš„å·¦å³å­æ ‘ã€‚ç„¶ååªéœ€æ’åˆ—ç»„ä¼šä¸€ä¸‹ä¾¿å¯å¾—åˆ°è¿™ä¸€å±‚çš„æ‰€æœ‰å­æ ‘å½¢çŠ¶ï¼Œå°è£…æˆvectorå¾€ä¸Šè¿”å›å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;TreeNode*&gt; allPossibleFBT(int n) &#123; vector&lt;TreeNode*&gt; ans; if (n % 2 == 0) return ans; if (n == 1) &#123; ans = &#123;new TreeNode(0)&#125;; return ans; &#125; for(int i=1; i&lt;n; i+=2)&#123; vector&lt;TreeNode*&gt; left_ans = allPossibleFBT(i); vector&lt;TreeNode*&gt; right_ans = allPossibleFBT(n-1-i); for(TreeNode* lnode:left_ans)&#123; for(TreeNode* rnode:right_ans)&#123; TreeNode *root = new TreeNode(0, lnode, rnode); ans.push_back(root); &#125; &#125; &#125; return ans; &#125;&#125;; 2024-04-03 é¢˜ç›®ä¼ é€é—¨ï¼š1379. æ‰¾å‡ºå…‹éš†äºŒå‰æ ‘ä¸­çš„ç›¸åŒèŠ‚ç‚¹ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“ç®€å•çš„éå†é¢˜ç›®ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨é€’å½’éå†çš„æ—¶å€™è®©å…‹éš†æ ‘æ‰§è¡Œå’ŒåŸæ ‘ä¸€æ ·çš„æ“ä½œå³å¯ã€‚åœæ­¢æ¡ä»¶å°±æ˜¯å½“å…‹éš†æ ‘èŠ‚ç‚¹å¯¹åº”çš„åŸæ ‘ä½ç½®çš„èŠ‚ç‚¹ç­‰äºç›®æ ‡èŠ‚ç‚¹æ—¶è¿”å›å…‹éš†æ ‘èŠ‚ç‚¹æŒ‡é’ˆã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) &#123; if (target==original) return cloned; if (original-&gt;left!=nullptr)&#123; TreeNode* tmp = getTargetCopy(original-&gt;left,cloned-&gt;left, target); if(tmp != nullptr) return tmp; &#125; if (cloned-&gt;right!=nullptr)&#123; TreeNode* tmp = getTargetCopy(original-&gt;right,cloned-&gt;right, target); if(tmp != nullptr) return tmp; &#125; return static_cast&lt;TreeNode*&gt;(nullptr); &#125;&#125;; 2024-04-04 é¢˜ç›®ä¼ é€é—¨ï¼š2192. æœ‰å‘æ— ç¯å›¾ä¸­ä¸€ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰ç¥–å…ˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“è¾ƒä¸ºæ˜æ˜¾çš„æ‹“æ‰‘æ’åºæ¿å­é¢˜ç›®ï¼Œè¿™é‡Œåœ¨åˆå¹¶ç¥–å…ˆçš„æ—¶å€™ä½¿ç”¨äº†vectorçš„insertæ–¹æ³•ã€‚è¯¦æƒ…ç”¨æ³•å¯è§C++-&gt;vector-&gt;insertéƒ¨åˆ†çš„ä»‹ç»ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; getAncestors(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; vector&lt;int&gt; in(n,0); vector&lt;vector&lt;int&gt;&gt; anc(n); vector&lt;vector&lt;int&gt;&gt; e(n); for(auto &amp; edge:edges)&#123; in[edge[1]]++; e[edge[0]].push_back(edge[1]); &#125; queue&lt;int&gt; que; for(int i=0;i&lt;n;++i)&#123; if (in[i]==0) que.push(i); &#125; while (!que.empty()) &#123; int u = que.front(); que.pop(); for(auto &amp;v:e[u])&#123; anc[v].push_back(u); anc[v].insert(anc[v].end(),anc[u].begin(),anc[u].end()); sort(anc[v].begin(),anc[v].end()); auto nwend = unique(anc[v].begin(),anc[v].end()); anc[v].erase(nwend, anc[v].end()); in[v]--; if (in[v]==0) que.push(v); &#125; &#125; return anc; &#125;&#125;; 2024-04-05 é¢˜ç›®ä¼ é€é—¨ï¼š1026. èŠ‚ç‚¹ä¸å…¶ç¥–å…ˆä¹‹é—´çš„æœ€å¤§å·®å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‡ªåº•å‘ä¸Šè¿›è¡ŒDFSï¼Œå¯¹äºå½“å‰èŠ‚ç‚¹ï¼Œè°ƒç”¨dfsåè¿”å›ä»¥æ‰€æœ‰å„¿å­ä¸ºæ ¹çš„å­æ ‘çš„æœ€å¤§å€¼å’Œæœ€å°å€¼ï¼Œç„¶åæ›´æ–°ä»¥å½“å‰èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘çš„æœ€å¤§å€¼å’Œæœ€å°å€¼ã€‚åœ¨é€’å½’çš„è¿‡ç¨‹ä¸­ï¼Œç»´æŠ¤æœ€å¤§å·®å€¼ã€‚æœ€å¤§å·®å€¼ansansanså¯ä»¥è¡¨è¿°ä¸ºï¼š ans=maxâ¡(maxx,ans)ans = \\max(maxx,ans) ans=max(maxx,ans) maxx=maxâ¡(abs(å½“å‰èŠ‚ç‚¹å€¼âˆ’å½“å‰èŠ‚ç‚¹ä¸ºæ ¹å­æ ‘æœ€å¤§å€¼),abs(å½“å‰èŠ‚ç‚¹å€¼âˆ’å½“å‰èŠ‚ç‚¹ä¸ºæ ¹å­æ ‘æœ€å°å€¼))maxx = \\max(abs(å½“å‰èŠ‚ç‚¹å€¼-å½“å‰èŠ‚ç‚¹ä¸ºæ ¹å­æ ‘æœ€å¤§å€¼),abs(å½“å‰èŠ‚ç‚¹å€¼-å½“å‰èŠ‚ç‚¹ä¸ºæ ¹å­æ ‘æœ€å°å€¼)) maxx=max(abs(å½“å‰èŠ‚ç‚¹å€¼âˆ’å½“å‰èŠ‚ç‚¹ä¸ºæ ¹å­æ ‘æœ€å¤§å€¼),abs(å½“å‰èŠ‚ç‚¹å€¼âˆ’å½“å‰èŠ‚ç‚¹ä¸ºæ ¹å­æ ‘æœ€å°å€¼)) å…¶ä¸­maxxä»£è¡¨æ¯ä¸ªèŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘çš„æœ€å¤§å·®å€¼ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int maxAncestorDiff(TreeNode* root) &#123; int maxx = 0; function&lt;pair&lt;int,int&gt;(TreeNode*)&gt; dfs = [&amp;](TreeNode* u) &#123; pair&lt;int,int&gt; tmp = make_pair(u-&gt;val,u-&gt;val); if (u-&gt;left!=nullptr) &#123; pair&lt;int,int&gt; temp = dfs(u-&gt;left); tmp.first = min(min(temp.first, temp.second), tmp.first); tmp.second= max(max(temp.first, temp.second),tmp.second); &#125; if (u-&gt;right!=nullptr) &#123; pair&lt;int,int&gt; temp = dfs(u-&gt;right); tmp.first = min(min(temp.first, temp.second), tmp.first); tmp.second= max(max(temp.first, temp.second),tmp.second); &#125; maxx = max(maxx,max(abs(tmp.first - u-&gt;val),abs(tmp.second - u-&gt;val))); return tmp; &#125;; dfs(root); return maxx; &#125;&#125;; 2024-04-06 é¢˜ç›®ä¼ é€é—¨ï¼š1483. æ ‘èŠ‚ç‚¹çš„ç¬¬ K ä¸ªç¥–å…ˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æœ¬é¢˜ç›®æ˜¯ä¸€é“ä½¿ç”¨å€å¢æ€æƒ³çš„DPé¢˜ç›®ã€‚å®šä¹‰ancs[i][j]ä»£è¡¨ièŠ‚ç‚¹çš„ç¬¬2j2^j2jä¸ªç¥–å…ˆï¼Œç„¶åè¿›è¡Œåˆ·è¡¨å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334class TreeAncestor &#123;public: vector&lt;vector&lt;int&gt;&gt; ancs; constexpr static int LOG = 16; TreeAncestor(int n, vector&lt;int&gt;&amp; parent) &#123; ancs = vector&lt;vector&lt;int&gt;&gt;(n,vector&lt;int&gt;(LOG, -1)); for (int i=0; i&lt;n; ++i) &#123; ancs[i][0] = parent[i]; &#125; for (int i=1;i&lt;LOG;++i) &#123; for (int j=0; j&lt;n; ++j)&#123; if (ancs[j][i-1] != -1)&#123; ancs[j][i] = ancs[ancs[j][i-1]][i-1]; &#125; &#125; &#125; &#125; int getKthAncestor(int node, int k) &#123; for(int i=LOG; i&gt;=0; --i)&#123; if ((k&gt;&gt;i)&amp;1) &#123; node = ancs[node][i]; if (node==-1) return -1; &#125; &#125; return node; &#125;&#125;;/** * Your TreeAncestor object will be instantiated and called as such: * TreeAncestor* obj = new TreeAncestor(n, parent); * int param_1 = obj-&gt;getKthAncestor(node,k); */ 2024-04-07 é¢˜ç›®ä¼ é€é—¨ï¼š1600. ç‹ä½ç»§æ‰¿é¡ºåº - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™é“é¢˜å…¶å®å°±æ˜¯ä¸€ä¸ªå¤šå‰æ ‘çš„å‰åºéå†ï¼Œä½†æ˜¯å› ä¸ºä½¿ç”¨çš„æ˜¯å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥éœ€è¦ä½¿ç”¨åˆ°unordered_setä»¥åŠunordered_mapç­‰ç›¸å…³STLï¼ˆä½¿ç”¨æ–¹æ³•è§C++æ–‡æ¡£ï¼‰: æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041class ThroneInheritance &#123;private: unordered_map&lt;string, vector&lt;string&gt;&gt; edges; unordered_set&lt;string&gt; dead; string king;public: ThroneInheritance(string kingName) &#123; king = kingName; &#125; void birth(string parentName, string childName) &#123; edges[parentName].push_back(childName); &#125; void death(string name) &#123; dead.insert(name); &#125; vector&lt;string&gt; getInheritanceOrder() &#123; vector&lt;string&gt; ans; function&lt;void(string)&gt; dfs = [&amp;](string u) &#123; if (!dead.count(u)) ans.push_back(u); if (edges.count(u)) &#123; for (auto v:edges[u])&#123; dfs(v); &#125; &#125; &#125;; dfs(king); return ans; &#125;&#125;;/** * Your ThroneInheritance object will be instantiated and called as such: * ThroneInheritance* obj = new ThroneInheritance(kingName); * obj-&gt;birth(parentName,childName); * obj-&gt;death(name); * vector&lt;string&gt; param_3 = obj-&gt;getInheritanceOrder(); */ 2024-04-08 é¢˜ç›®ä¼ é€é—¨ï¼š2009. ä½¿æ•°ç»„è¿ç»­çš„æœ€å°‘æ“ä½œæ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å‡è®¾xxxæ˜¯ä¿®æ”¹åçš„è¿ç»­æ•°å­—çš„æœ€å¤§å€¼ï¼Œåˆ™ä¿®æ”¹åçš„è¿ç»­æ•°å­—çš„èŒƒå›´ä¸ºé—­åŒºé—´ [xâˆ’n+1,x][xâˆ’n+1,x][xâˆ’n+1,x]ï¼Œå…¶ä¸­ nnn æ˜¯ nums çš„é•¿åº¦ã€‚åœ¨ä¿®æ”¹å‰ï¼Œå¯¹äºå·²ç»åœ¨ [xâˆ’n+1,x][xâˆ’n+1,x][xâˆ’n+1,x] ä¸­çš„æ•°ï¼Œæˆ‘ä»¬æ— éœ€ä¿®æ”¹ã€‚é‚£ä¹ˆï¼Œxxx å–å¤šå°‘ï¼Œå¯ä»¥ä½¿æ— éœ€ä¿®æ”¹çš„æ•°æœ€å¤šå‘¢ï¼Ÿ ç”±äºå…ƒç´ çš„ä½ç½®ä¸å½±å“ç­”æ¡ˆï¼Œä¸”è¦æ±‚æ‰€æœ‰å…ƒç´ äº’ä¸ç›¸åŒï¼Œæˆ‘ä»¬å¯ä»¥å°† nums ä»å°åˆ°å¤§æ’åºï¼Œå¹¶å»æ‰é‡å¤å…ƒç´ ã€‚è®¾ a ä¸ºnums æ’åºå»é‡åçš„æ•°ç»„ã€‚å°† a[i] ç”»åœ¨ä¸€æ¡æ•°è½´ä¸Šï¼Œæœ¬é¢˜ç›¸å½“äºæœ‰ä¸€ä¸ªé•¿åº¦ä¸º n çš„æ»‘åŠ¨çª—å£ï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—çª—å£å†…æœ€å¤šå¯ä»¥åŒ…å«å¤šå°‘ä¸ªæ•°è½´ä¸Šçš„ç‚¹ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314class Solution &#123;public: int minOperations(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); int n = nums.size(); int now_n = unique(nums.begin(), nums.end()) - nums.begin(); int ans = 0, r = 0; for (int l=0; l&lt;now_n; ++l) &#123; while (r&lt;now_n &amp;&amp; nums[r]-nums[l] &lt; n) r++; ans = max(r-l, ans); &#125; return n - ans; &#125;&#125;; 2024-04-09 é¢˜ç›®ä¼ é€é—¨ï¼š2529. æ­£æ•´æ•°å’Œè´Ÿæ•´æ•°çš„æœ€å¤§è®¡æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ çº¯ç­¾åˆ°é¢˜ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011class Solution &#123;public: int maximumCount(vector&lt;int&gt;&amp; nums) &#123; int a = 0,b = 0; for(auto&amp;num:nums)&#123; if (num&gt;0) a++; if (num&lt;0) b++; &#125; return max(a, b); &#125;&#125;; 2024-04-10 é¢˜ç›®ä¼ é€é—¨ï¼š1702. ä¿®æ”¹åçš„æœ€å¤§äºŒè¿›åˆ¶å­—ç¬¦ä¸² - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™é“é¢˜é¢˜è§£å»ºè®®çœ‹çµç¥çš„æ¨ç†æ–¹æ³•ï¼Œè®²è§£çš„ååˆ†é€å½»ã€‚ é¢˜è§£ä¼ é€é—¨ï¼šè´ªå¿ƒï¼Œç®€æ´å†™æ³•ï¼ˆPython/Java/C++/Go/JS/Rustï¼‰ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920class Solution &#123;public: string maximumBinaryString(string binary) &#123; int n = binary.size(); int j = 0; for (int i = 0; i &lt; n; i++) &#123; if (binary[i] == &#x27;0&#x27;) &#123; while (j &lt;= i || (j &lt; n &amp;&amp; binary[j] == &#x27;1&#x27;)) &#123; j++; &#125; if (j &lt; n) &#123; binary[j] = &#x27;1&#x27;; binary[i] = &#x27;1&#x27;; binary[i + 1] = &#x27;0&#x27;; &#125; &#125; &#125; return binary; &#125;&#125;; 2024-04-11 é¢˜ç›®ä¼ é€é—¨ï¼š1766. äº’è´¨æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™é“é¢˜å°±æ˜¯ä¸€é“DFSé¢˜ç›®ï¼Œå› ä¸ºå–å€¼éå¸¸å°ï¼Œæ‰€ä»¥å¯ä»¥å…ˆè¿›è¡Œé¢„å¤„ç†ï¼Œå…ˆæŠŠ50ä»¥å†…æ‰€æœ‰äº’è´¨çš„æ•°é¢„å¤„ç†å‡ºæ¥ã€‚ç”±äºæ ¹èŠ‚ç‚¹åˆ°ä»»æ„èŠ‚ç‚¹çš„æœç´¢è·¯å¾„å°±æ˜¯è¯¥èŠ‚ç‚¹çš„ç¥–å…ˆèŠ‚ç‚¹çš„é›†åˆï¼Œæ‰€ä»¥æœç´¢è·¯å¾„ä¸Šæœ€è¿‘çš„ä¸å…¶äº’è´¨çš„å°±æ˜¯ç­”æ¡ˆã€‚åœ¨æœç´¢éå†æ ‘å¤„ç†ç­”æ¡ˆçš„æ—¶å€™ï¼Œæœ‰è®¸å¤šä¿¡æ¯å¯ä»¥å¤ç”¨ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;private: vector&lt;vector&lt;int&gt;&gt; gcds; vector&lt;vector&lt;int&gt;&gt; tmp; vector&lt;vector&lt;int&gt;&gt; g; vector&lt;int&gt; dep; vector&lt;int&gt; ans;public: void dfs(vector&lt;int&gt; &amp;nums, int x, int depth) &#123; dep[x] = depth; for (int val : gcds[nums[x]]) &#123; if (tmp[val].empty()) &#123; continue; &#125; int las = tmp[val].back(); if (ans[x] == -1 || dep[las] &gt; dep[ans[x]]) &#123; ans[x] = las; &#125; &#125; tmp[nums[x]].push_back(x); for(int val : g[x]) &#123; if (dep[val] == -1) &#123; // è¢«è®¿é—®è¿‡çš„ç‚¹depä¸ä¸º-1 dfs(nums, val, depth + 1); &#125; &#125; tmp[nums[x]].pop_back(); &#125; vector&lt;int&gt; getCoprimes(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; int n = nums.size(); // åˆå§‹åŒ– gcds.resize(51); tmp.resize(51); ans.resize(n, -1); dep.resize(n, -1); g.resize(n); for (int i = 1; i &lt;= 50; i++) &#123; for (int j = 1; j &lt;= 50; j++) &#123; if (gcd(i, j) == 1) &#123; gcds[i].push_back(j); &#125; &#125; &#125; for (const auto &amp;val : edges) &#123; g[val[0]].push_back(val[1]); g[val[1]].push_back(val[0]); &#125; dfs(nums, 0, 1); return ans; &#125;&#125;; 2024-04-12 é¢˜ç›®ä¼ é€é—¨ï¼š2923. æ‰¾åˆ°å† å†› I - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æœ‰ç‚¹åƒæ‹“æ‰‘æ’åºç¬¬ä¸€æ­¥ï¼Œç»Ÿè®¡æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦ã€‚è¿™é‡Œæˆ‘ä»¬è®¾å®šAæ¯”Bå¼ºï¼Œè¡¨ç¤ºæœ‰ä¸€æ¡è¾¹ç”±AæŒ‡å‘Bã€‚æœ€åæˆ‘ä»¬è¿”å›å…¥åº¦ä¸º0çš„èŠ‚ç‚¹å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718class Solution &#123;public: int findChampion(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n = grid.size(); vector&lt;int&gt; rank(n,0); for(int i=0; i&lt;n; ++i)&#123; for(int j=0; j&lt;n; ++j)&#123; if (grid[i][j] == 1) &#123; rank[j] ++; &#125; &#125; &#125; for (int i=0; i&lt;n; ++i)&#123; if (rank[i]==0) return i; &#125; return -1; &#125;&#125;; 2024-04-13 é¢˜ç›®ä¼ é€é—¨ï¼š2924. æ‰¾åˆ°å† å†› II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸æ˜¨å¤©çš„é¢˜ç›®æ€è·¯å®Œå…¨ä¸€æ ·ï¼Œæœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415class Solution &#123;public: int findChampion(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; vector&lt;int&gt; ins(n, 0); for(auto &amp;edge:edges) &#123; ins[edge[1]]++; &#125; int cnt = 0, ans = -1; for(int i=0;i&lt;n;++i) &#123; if (ins[i]==0) cnt++,ans=i; &#125; if (cnt == 1) return ans; return -1; &#125;&#125;; 2024-04-14 é¢˜ç›®ä¼ é€é—¨ï¼š705. è®¾è®¡å“ˆå¸Œé›†åˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ STLÂ unordered_setÂ ç»ƒä¹ é¢˜ï¼Œæœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617class MyHashSet &#123;private: unordered_set&lt;int&gt; myset;public: MyHashSet() &#123;&#125; void add(int key) &#123;myset.insert(key);&#125; void remove(int key) &#123;myset.erase(key);&#125; bool contains(int key) &#123;return myset.find(key) != myset.end();&#125;&#125;;/** * Your MyHashSet object will be instantiated and called as such: * MyHashSet* obj = new MyHashSet(); * obj-&gt;add(key); * obj-&gt;remove(key); * bool param_3 = obj-&gt;contains(key); */ 2024-04-15 é¢˜ç›®ä¼ é€é—¨ï¼š706. è®¾è®¡å“ˆå¸Œæ˜ å°„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ STLÂ unordered_mapÂ ç»ƒä¹ é¢˜ï¼Œæœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920class MyHashMap &#123;private: unordered_map&lt;int, int&gt; mp;public: void put(int key, int value) &#123;mp[key] = value;&#125; int get(int key) &#123; if (mp.find(key)!=mp.end()) return mp[key]; return -1; &#125; void remove(int key) &#123;mp.erase(key);&#125;&#125;;/** * Your MyHashMap object will be instantiated and called as such: * MyHashMap* obj = new MyHashMap(); * obj-&gt;put(key,value); * int param_2 = obj-&gt;get(key); * obj-&gt;remove(key); */ 2024-04-16 é¢˜ç›®ä¼ é€é—¨ï¼š924. å°½é‡å‡å°‘æ¶æ„è½¯ä»¶çš„ä¼ æ’­ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“ç»†èŠ‚è¾ƒå¤šçš„DFS/å¹¶æŸ¥é›†é¢˜ç›®ï¼Œå…¶å®å°±æ˜¯æ‰¾initä¸­å­˜åœ¨çš„æœ€å¤§è¿é€šå—ï¼ˆç¬¬ä¸€æ¬¡è¯»é¢˜éƒ½å¿«äº†ä»¥ä¸ºæ˜¯æ‰¾å›¾ä¸­çš„å‰²ç‚¹ï¼‰ï¼Œåªä¸è¿‡æ‰¾åˆ°äº†éœ€è¦æ³¨æ„ï¼š å¦‚æœä¸€ä¸ªè¿é€šå—ä¸­ï¼Œåªæœ‰ä¸€ä¸ªinitialä¸­çš„èŠ‚ç‚¹è¢«æ„ŸæŸ“ï¼Œåˆ™å°†ä»–ç§»é™¤è¿™ä¸ªè¿é€šå—ä¸ä¼šæ„ŸæŸ“ã€‚ä½†æ˜¯å¦‚æœæœ‰2ä¸ªåŠä»¥ä¸Šçš„èŠ‚ç‚¹è¢«æ„ŸæŸ“ï¼Œåˆ™åˆ æ‰ä¸€ä¸ªä»¥åè¿™ä¸ªè¿é€šå—ä»ç„¶ä¼šè¢«æ„ŸæŸ“ã€‚æ‰€ä»¥å…·ä½“æ¥è¯´æˆ‘ä»¬éœ€è¦æ‰¾çš„æ˜¯åªæœ‰ä¸€ä¸ªinitialèŠ‚ç‚¹åœ¨è¿é€šå—ä¸­çš„æœ€å¤§è¿é€šå—ã€‚ï¼ˆåˆ¤æ–­ä¸¤ä¸ªç‚¹æ˜¯å¦åœ¨ä¸€ä¸ªè¿é€šå—ä¸­å¯ä»¥é€šè¿‡å¹¶æŸ¥é›†æˆ–è€…unordered_setï¼‰ è¿˜æœ‰éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå­˜åœ¨ç‰¹æ®Šæƒ…å†µæ‰¾ä¸åˆ°ä¸€ä¸ªç‚¹åœ¨ä¸€ä¸ªè¿é€šå—ä¸­ï¼ˆæ¯ä¸ªè¿é€šå—éƒ½å­˜åœ¨2ä¸ªåŠä»¥ä¸Šçš„initialä¸­çš„ç‚¹ï¼‰ï¼Œæ­¤æ—¶è¿”å›ä¸‹æ ‡æœ€å°çš„initialç‚¹å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int minMalwareSpread(vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;int&gt;&amp; initial) &#123; int n = graph.size(), m = initial.size(); sort(initial.begin(),initial.end()); // æ’åºæ–¹ä¾¿é€‰æœ€å°ï¼Œè¿™æ ·å¦‚æœéƒ½åœ¨ä¸€ä¸ªè¿é€šå—ä¸­ä¹Ÿå¯å¾ˆå¿«é€‰å‡ºæœ€å°çš„ vector&lt;bool&gt; vis(n, false); unordered_set&lt;int&gt; se; for (auto init:initial) se.insert(init); function&lt;pair&lt;int, bool&gt;(int)&gt; dfs = [&amp;](int u)&#123; int num = 1; bool flag = false; for(int i=0;i&lt;n;++i)&#123; if (graph[u][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if (se.find(i)!=se.end()) flag = true; pair&lt;int,bool&gt; tmp = dfs(i); num += tmp.first; flag |= tmp.second; &#125; &#125; return make_pair(num, flag); &#125;; int ans=initial[0],nw=0; for (auto init:initial) &#123; if (vis[init]) continue; vis[init] = true; pair&lt;int,bool&gt; tmp = dfs(init); if (tmp.second!=true &amp;&amp; (tmp.first &gt; nw || (tmp.first == nw &amp;&amp; init &lt; ans))) nw=tmp.first, ans=init; &#125; return ans; &#125;&#125;; 2024-04-17 é¢˜ç›®ä¼ é€é—¨ï¼š928. å°½é‡å‡å°‘æ¶æ„è½¯ä»¶çš„ä¼ æ’­ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ­¤é¢˜ä¸ºä¸Šä¸€é“é¢˜ç›®çš„è¡ç”Ÿç‰ˆæœ¬ï¼Œæœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617class Solution &#123;public: int minMalwareSpread(vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;int&gt;&amp; initial) &#123; int n = graph.size(); vector&lt;int&gt; init_size(n); for (auto init:initial) init_size[init] = 1; vector&lt;int&gt; ufa(n); iota(ufa.begin(), ufa.end(), 0); for (int u=0; u&lt;n; ++u)&#123; if(init_size[u]==1) continue; for(int v=0; v&lt;n; ++v)&#123; if(init_size[v]==1) continue; if (graph[u][v] == 1) &#123;merge(uf, u, v);&#125; &#125; &#125; &#125;&#125;; 2024-04-18 é¢˜ç›®ä¼ é€é—¨ï¼š2007. ä»åŒå€æ•°ç»„ä¸­è¿˜åŸåŸæ•°ç»„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ STL mapä½¿ç”¨é¢˜ï¼Œä½¿ç”¨ä¸€ä¸ªmapè®°å½•å½“å‰é”®å€¼ä»¥åŠå½“å‰é”®å€¼æ‰€å‡ºç°çš„æ¬¡æ•°ï¼Œéå†mapæ˜¯æŒ‰ç…§é”®å€¼ä»å°åˆ°å¤§é¡ºåºçš„ï¼Œå¯¹äºå½“å‰é”®å€¼ï¼Œå¦‚æœ*2åçš„é”®å€¼å‡ºç°æ¬¡æ•°å¤§äºç­‰äºå½“å‰é”®å€¼æ•°é‡ï¼Œåˆ™å°†å½“å‰é”®å€¼åŠ å…¥ç­”æ¡ˆé˜Ÿåˆ—ä¸­ï¼ˆæ•°é‡ä¿æŒä¸€è‡´ï¼‰ï¼Œå¦åˆ™åˆ™è¯æ˜ä¸å­˜åœ¨è¿™ä¸ªæ•°åˆ—ï¼Œè¿”å›ç©ºã€‚æ³¨æ„0è¿›è¡Œç‰¹æ®Šåˆ¤å®šä¸€ä¸‹ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; findOriginalArray(vector&lt;int&gt;&amp; changed) &#123; sort(changed.begin(), changed.end()); map&lt;int, int&gt; mp; vector&lt;int&gt; ans=&#123;&#125;; for(auto &amp;i:changed) &#123; if (mp.find(i)==mp.end()) mp[i] = 1; else mp[i]++; &#125; for(auto it = mp.begin();it != mp.end(); ++it)&#123; if (it-&gt;first == 0 &amp;&amp; it-&gt;second%2) return vector&lt;int&gt;&#123;&#125;; if (it-&gt;second == 0) continue; auto it2 = mp.find(it-&gt;first*2); if (it2!=mp.end() &amp;&amp; it2-&gt;second &gt;= it-&gt;second) &#123; if (it-&gt;first == 0)it-&gt;second /= 2; for(int i=1;i&lt;=it-&gt;second;++i) ans.push_back(it-&gt;first); it2-&gt;second -= it-&gt;second; it-&gt;second = 0; &#125; else &#123; return vector&lt;int&gt;&#123;&#125;; &#125; &#125; return ans; &#125;&#125;; 2024-04-19 é¢˜ç›®ä¼ é€é—¨ï¼š1883. å‡†æ—¶æŠµè¾¾ä¼šè®®ç°åœºçš„æœ€å°è·³è¿‡ä¼‘æ¯æ¬¡æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¯»å®Œé¢˜ç›®åï¼Œè§‚å¯Ÿæ•°æ®èŒƒå›´ä¸éš¾åˆ¤æ–­æ­¤é¢˜åº”è¯¥æ˜¯ä¸€é“dpï¼Œè®¾dp[i][j]ä»£è¡¨åˆ°è¾¾ç¬¬iä¸ªåœ°æ–¹ä½¿ç”¨jæ¬¡è·³è¿‡æ‰€éœ€è¦çš„æœ€å°æ—¶é—´ï¼ˆi&gt;jï¼‰ã€‚å¯ä»¥éå¸¸ç®€å•å†™å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š 12double tmp_t = (double)dist[i-1]/speed;dp[i][j] = min(ceil(dp[i-1][j]) + tmp_t, dp[i-1][j-1]+tmp_t) ä¸‹é¢å†æ¥è®¨è®ºä¸€ä¸‹è¾¹ç•Œä»¥åŠåˆå§‹åŒ–æ¡ä»¶ï¼Œé¦–å…ˆä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œå°†æ‰€æœ‰dpæ•°ç»„åˆå§‹åŒ–æˆä¸€ä¸ªéå¸¸å¤§çš„intå€¼ï¼Œdp[0][0] = 0, å½“j=0æ—¶ï¼Œä¸èƒ½ä½¿ç”¨ä¸Šé¢çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹(å­˜åœ¨j-1)é¡¹ï¼Œå› æ­¤å¯ä»¥å†™ä¸º 1dp[i][0] = ceil(dp[i-1][0]-EPS)+tmp_t; ä»¥ä¸Šä¾¿æ˜¯è¿™é“DPçš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œä½†æ˜¯å½“æˆ‘æäº¤åå‘ç°ä¸€ç›´è¿‡ä¸äº†ã€‚è¿™æ˜¯å› ä¸ºï¼š æµ®ç‚¹æ•°è¿ç®—çš„ç»†èŠ‚ï¼ˆæ‘˜è‡ªLeetCodeå®˜æ–¹é¢˜è§£ï¼‰ æ ¹æ® IEEE 754 æ ‡å‡†ï¼Œæµ®ç‚¹æ•°åœ¨è®¡ç®—æœºä¸­å­˜å‚¨çš„ç²¾åº¦æ˜¯æœ‰é™çš„ï¼Œè€Œæœ¬é¢˜ä¸­æˆ‘ä»¬ä¸å¯é¿å…çš„ä¼šä½¿ç”¨ã€Œæµ®ç‚¹æ•°è¿ç®—ã€ä»¥åŠã€Œå‘ä¸Šå–æ•´ã€è¿ç®—ï¼Œå¦‚æœå¼ºè¡Œå¿½ç•¥äº§ç”Ÿçš„è®¡ç®—è¯¯å·®ï¼Œä¼šå¾—åˆ°é”™è¯¯çš„ç»“æœã€‚ ä¸¾ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œå‡è®¾ä½¿ç”¨çš„è¯­è¨€ä¸­ã€Œå‘ä¸Šå–æ•´ã€è¿ç®—çš„å‡½æ•°ä¸º ceilï¼Œä¸‹é¢çš„è¿ç®—ï¼š 1ceil(8.0Â +Â 1.0Â /Â 3Â +Â 1.0Â /Â 3Â +Â 1.0Â /Â 3) åº”å½“æ˜¯Â 9ï¼Œè€Œè®¡ç®—æœºä¼šç»™å‡ºÂ 10ã€‚è¿™æ˜¯å› ä¸ºæµ®ç‚¹æ•°è¯¯å·®å¯¼è‡´ï¼š 18.0Â +Â 1.0Â /Â 3Â +Â 1.0Â /Â 3Â +Â 1.0Â /Â 3 è®¡ç®—å‡ºçš„ç»“æœçº¦ä¸ºï¼š 19.000000000000002 å‘ä¸Šå–æ•´åä¼šå¾—åˆ°Â 10ï¼Œäº§ç”Ÿäº†é”™è¯¯çš„ç­”æ¡ˆã€‚ å› æ­¤æˆ‘ä»¬å¼•å…¥å¸¸é‡ EPS è¡¨ç¤ºä¸€ä¸ªæå°å€¼ï¼Œä¾‹å¦‚ 10âˆ’710^{-7}10âˆ’7 ã€‚åœ¨è¿›è¡Œã€Œå‘ä¸Šå–æ•´ã€è¿ç®—å‰ï¼Œæˆ‘ä»¬å°†å¾…å–æ•´çš„æµ®ç‚¹æ•°å‡å» EPS å†è¿›è¡Œå–æ•´ï¼Œå°±å¯ä»¥é¿å…ä¸Šè¿°çš„è¯¯å·®ã€‚ åŒæ—¶ï¼Œæˆ‘ä»¬éœ€è¦è¯´æ˜ EPS ä¸ä¼šå¼•å…¥å…¶å®ƒçš„é—®é¢˜ã€‚åœ¨æœ¬é¢˜ä¸­é€Ÿåº¦æœ€å¤§ä¸º 10610^{6}106ï¼Œæ—¶é—´ä¸é€Ÿåº¦æˆåæ¯”ï¼Œé‚£ä¹ˆ EPS çš„ç²’åº¦åªéœ€è¦é«˜äºæ—¶é—´çš„ç²¾åº¦10âˆ’610^{-6}10âˆ’6å³å¯ï¼Œå–10âˆ’710^{-7}10âˆ’7æˆ– 110âˆ’810^{-8}10âˆ’8éƒ½æ˜¯å¯è¡Œçš„ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122class Solution &#123;private: // å¯å¿½ç•¥è¯¯å·® static constexpr double EPS = 1e-7;public: int minSkips(vector&lt;int&gt;&amp; dist, int speed, int hoursBefore) &#123; int n = dist.size(); vector&lt;vector&lt;double&gt;&gt; dp(1002,vector&lt;double&gt;(1002,1e8+7)); dp[0][0] = 0; for(int i=1;i&lt;=n;++i)&#123; double tmp_t = (double)dist[i-1]/speed; dp[i][0] = ceil(dp[i-1][0]-EPS)+tmp_t; for(int j=1;j&lt;i;++j)&#123; dp[i][j] = min(ceil(dp[i-1][j]-EPS)+tmp_t,dp[i-1][j-1]+tmp_t); &#125; &#125; for(int i=0;i&lt;n;++i)&#123; if (dp[n][i] &lt;= hoursBefore) return i; &#125; return -1; &#125;&#125;; å°±æ˜¯å› ä¸ºåŠ äº†EPSæ‰ACäº†ï¼Œæˆ‘ä»¬C++çœŸæ˜¯å¤ªç¥å¥‡è¾£ï¼ï¼ï¼ 2024-04-20 é¢˜ç›®ä¼ é€é—¨ï¼š39. ç»„åˆæ€»å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ‰“æš´æœå³å¯ï¼Œè¶…è¿‡targetè¿›è¡Œå‰ªæã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; tmp; int n = candidates.size(); function&lt;void(int,int)&gt; dfs = [&amp;](int loc, int nw_sum) &#123; if (nw_sum &gt; target) return; if (nw_sum == target) &#123; ans.push_back(tmp); return; &#125; for(int i=loc;i&lt;n;++i)&#123; tmp.push_back(candidates[i]); dfs(i, nw_sum+candidates[i]); tmp.pop_back(); &#125; &#125;; dfs(0, 0); return ans; &#125;&#125;; 2024-04-21 é¢˜ç›®ä¼ é€é—¨ï¼š216. ç»„åˆæ€»å’Œ III - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å’Œæ˜¨å¤©é¢˜ç›®å·®ä¸å¤šå¤§æš´æœï¼Œå¤šäº†ä¸€ä¸ªå‰ªææ¡ä»¶åŠ ä¸Šå³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; tmp; function&lt;void(int,int,int)&gt; dfs = [&amp;](int cnt,int loc,int nw_sum) &#123; if (nw_sum &gt; n || cnt &gt; k) return; if (nw_sum == n &amp;&amp; cnt == k)&#123; ans.push_back(tmp);return; &#125; for(int i=loc;i&lt;=9;++i)&#123; tmp.push_back(i); dfs(cnt+1,i+1,nw_sum+i); tmp.pop_back(); &#125; &#125;; dfs(0,1,0); return ans; &#125;&#125;; 2024-04-22 é¢˜ç›®ä¼ é€é—¨ï¼š377. ç»„åˆæ€»å’Œ â…£ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åˆšçœ‹åˆ°è¿™ä¸ªé¢˜è¿˜æ²¡ååº”è¿‡æ¥æ˜¯DPï¼Œç›´æ¥ä¸€å‘æš´æœï¼Œä½†æ˜¯è¶…æ—¶äº†ï¼Œè®©æˆ‘ä»”ç»†æ€è€ƒäº†ä¸€ä¸‹ï¼Œå‘ç°å…¶å®å°±æ˜¯ä¸€ä¸ªå’Œçˆ¬æ¥¼æ¢¯ä¸€æ ·çš„ç®€å•DPã€‚ ä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¯èƒ½ä¼šå­˜åœ¨æº¢å‡ºçš„æƒ…å†µï¼Œæ‰€ä»¥æˆ‘ä»¬çš„dpæ•°ç»„å¼€æˆunsignedç±»å‹ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415class Solution &#123;public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;unsigned&gt; dp(target+3,0); dp[0] = 1; for(int i=1;i&lt;=target;++i)&#123; for(auto num:nums)&#123; if (num &lt;= i)&#123; dp[i] += dp[i-num]; &#125; &#125; &#125; return dp[target]; &#125;&#125;; 2024-04-23 é¢˜ç›®ä¼ é€é—¨ï¼š1052. çˆ±ç”Ÿæ°”çš„ä¹¦åº—è€æ¿ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ»‘åŠ¨çª—å£ä¸€ä¸‹ï¼Œå¾ˆç®€å•çš„å•¦ï¼ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516class Solution &#123;public: int maxSatisfied(vector&lt;int&gt;&amp; customers, vector&lt;int&gt;&amp; grumpy, int minutes) &#123; int init=0,n=customers.size(); for(int i=0; i&lt;n; ++i) if (!grumpy[i]) init += customers[i]; int tmp = 0; for(int i=0; i&lt;minutes; ++i) if(grumpy[i]) tmp += customers[i]; int ans = tmp; for(int i=1;i&lt;=n-minutes;++i)&#123; if (grumpy[i-1]) tmp -= customers[i-1]; if (grumpy[i-1+minutes]) tmp += customers[i-1+minutes]; if (tmp &gt; ans) ans = tmp; &#125; return init + ans; &#125;&#125;; 2024-04-24 é¢˜ç›®ä¼ é€é—¨ï¼š2385. æ„ŸæŸ“äºŒå‰æ ‘éœ€è¦çš„æ€»æ—¶é—´ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æˆ‘é¦–å…ˆæƒ³åˆ°çš„åŠæ³•æ˜¯åšä¸¤æ¬¡DFSï¼Œç¬¬ä¸€éå»ºå›¾ï¼Œç¬¬äºŒéä»¥ç»™å®šèŠ‚ç‚¹ä¸ºæ ¹ï¼Œç®—æœ€é•¿æ—¶é—´ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123; public: int amountOfTime(TreeNode* root, int start) &#123; vector&lt;vector&lt;int&gt;&gt; edges(100003); function&lt;void(TreeNode*)&gt; dfs = [&amp;](TreeNode* u) &#123; if(u-&gt;left!=nullptr)&#123; edges[u-&gt;val].emplace_back(u-&gt;left-&gt;val); edges[u-&gt;left-&gt;val].emplace_back(u-&gt;val); dfs(u-&gt;left); &#125; if(u-&gt;right!=nullptr)&#123; edges[u-&gt;val].emplace_back(u-&gt;right-&gt;val); edges[u-&gt;right-&gt;val].emplace_back(u-&gt;val); dfs(u-&gt;right); &#125; &#125;; dfs(root); function&lt;int(int,int)&gt; dfs2 = [&amp;](int u,int fa)&#123; int tmp=0; for (auto v:edges[u]) &#123; if (v==fa) continue; tmp = max(tmp, dfs2(v,u)); &#125; return 1+tmp; &#125;; return dfs2(start,-1)-1; &#125;&#125;; ä½†æ˜¯ä¸Šé¢è¿™ä¸ªä»£ç å¤ªæé™äº†ï¼Œå¡ç€æ—¶é™äº¤äº†ä¸‰æ¬¡è¯„æµ‹æœºè¿‡äº†ä¸€æ¬¡ï¼ˆç¬‘ï¼‰ï¼š äºæ˜¯éœ€è¦å†æƒ³æƒ³æœ‰æ²¡æœ‰æ”¹è¿›æ–¹æ³•ã€‚ 2024-04-25 é¢˜ç›®ä¼ é€é—¨ï¼š2739. æ€»è¡Œé©¶è·ç¦» - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ç›®ï¼Œæœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011class Solution &#123;public: int distanceTraveled(int mainTank, int additionalTank) &#123; int ans = 0; while (mainTank &gt;=5 ) &#123; ans += 50; mainTank -= 5; if (additionalTank) mainTank++,additionalTank--; &#125; return ans + mainTank*10; &#125;&#125;; 2024-04-26 é¢˜ç›®ä¼ é€é—¨ï¼š1146. å¿«ç…§æ•°ç»„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ­¤é¢˜å¦‚æœæƒ³åˆ°äº†æ˜¯äºŒåˆ†+å“ˆå¸Œè¡¨å°±æ¯”è¾ƒå®¹æ˜“äº†ï¼ŒäºŒåˆ†è¿˜æ˜¯æ¯”è¾ƒå¥½æƒ³ï¼Œè§‚å¯Ÿæ•°æ®èŒƒå›´ä¸º50000ï¼Œä¾¿å¯çŸ¥æ¯æ¬¡è¿›è¡Œsnapæ“ä½œï¼Œå¯¹æ•´ä¸ªæ•°ç»„è¿›è¡Œå¤åˆ¶æ˜¯ä¸ç°å®çš„ã€‚ å¯¹äºæ­¤é¢˜ï¼Œå¯ä»¥é‡‡ç”¨unordered_setå¯¹å†å²ä¿®æ”¹è¿›è¡Œç»´æŠ¤ï¼š 1unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; history; å…¶ä¸­ï¼Œmapçš„ç´¢å¼•ä»£è¡¨çš„æ˜¯ä½ç½®ï¼Œpairçš„ç¬¬ä¸€ä¸ªå€¼è®°å½•å¯¹å½“å‰ä½ç½®è¿›è¡Œä¿®æ”¹æ—¶çš„snap_id,ç¬¬äºŒä¸ªå€¼è®°å½•å¯¹å½“å‰ä½ç½®ä¿®æ”¹æ—¶ï¼Œæ›´æ”¹çš„å€¼valã€‚åç»­è¿›è¡Œgetæ“ä½œæ—¶ï¼Œåªéœ€è¦å¯¹pairç¬¬ä¸€ä¸ªè¿›è¡ŒäºŒåˆ†å³å¯ï¼ˆæ‰¾å°äºç­‰äºç»™å®šsnap_idçš„æœ€åä¸€ä¸ªæ›´æ”¹å€¼ï¼‰ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435class SnapshotArray &#123;private: int cnt = 0; unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; history; public: SnapshotArray(int length) &#123;&#125; void set(int index, int val) &#123; history[index].emplace_back(cnt, val); &#125; int snap() &#123; return cnt++; &#125; int get(int index, int snap_id) &#123; auto&amp; tmp = history[index]; int l = 0, r = tmp.size(); while (l &lt; r) &#123; int mid = l + ((r-l)&gt;&gt;1); if (tmp[mid].first &gt; snap_id) r = mid; else l = mid+1; &#125; if ((l-1)&lt;0) return 0; return tmp[l-1].second; &#125;&#125;;/** * Your SnapshotArray object will be instantiated and called as such: * SnapshotArray* obj = new SnapshotArray(length); * obj-&gt;set(index,val); * int param_2 = obj-&gt;snap(); * int param_3 = obj-&gt;get(index,snap_id); */ 2024-04-27 é¢˜ç›®ä¼ é€é—¨ï¼š2639. æŸ¥è¯¢ç½‘æ ¼å›¾ä¸­æ¯ä¸€åˆ—çš„å®½åº¦ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ç›®ï¼Œæœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; findColumnWidth(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n = grid.size(), m = grid[0].size(); vector&lt;int&gt; res(m); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; int x = grid[i][j]; int length = 0; if (x &lt;= 0) &#123; length = 1; &#125; while (x != 0) &#123; length += 1; x /= 10; &#125; res[j] = max(res[j], length); &#125; &#125; return res; &#125;&#125;; 2024-04-28 é¢˜ç›®ä¼ é€é—¨ï¼š1017. è´ŸäºŒè¿›åˆ¶è½¬æ¢ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™é‡Œéœ€è¦ä½¿ç”¨åˆ°æˆ‘ä»¬å°å­¦æ‰€å­¦è¿›åˆ¶è½¬æ¢çš„çŸ¥è¯†ï¼Œè®©æˆ‘ä»¬æ¥å›é¡¾ä¸€ä¸‹ï¼š è´ŸäºŒè¿›åˆ¶è¡¨ç¤ºçš„å®šä¹‰ è´ŸäºŒè¿›åˆ¶æ•°è¡¨ç¤ºå½¢å¼ä½¿ç”¨åŸºæ•° -2ã€‚å¯¹äºä¸€ä¸ªæ•´æ•° nnnï¼Œæˆ‘ä»¬å¸Œæœ›å°†å…¶è¡¨ç¤ºä¸ºè´ŸäºŒè¿›åˆ¶å½¢å¼ï¼š n=a0â‹…(âˆ’2)0+a1â‹…(âˆ’2)1+a2â‹…(âˆ’2)2+â€¦n = a_0 \\cdot (-2)^0 + a_1 \\cdot (-2)^1 + a_2 \\cdot (-2)^2 + \\ldots n=a0â€‹â‹…(âˆ’2)0+a1â€‹â‹…(âˆ’2)1+a2â€‹â‹…(âˆ’2)2+â€¦ å…¶ä¸­ aia_iaiâ€‹ æ˜¯äºŒè¿›åˆ¶ä½ï¼Œå–å€¼åªèƒ½ä¸º0æˆ–1ã€‚ å–æ¨¡çš„æ„ä¹‰ å½“æˆ‘ä»¬è¯´å¯¹2å–æ¨¡æ—¶ï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯æ‰¾åˆ°å½“å‰ä½ aia_iaiâ€‹ çš„å€¼ï¼Œå¹¶è°ƒæ•´ nnn ä»¥ç»§ç»­å¤„ç†ä¸‹ä¸€ä½ã€‚ è½¬æ¢è¿‡ç¨‹ å‡è®¾æˆ‘ä»¬åœ¨æŸä¸€æ­¥è®¡ç®—ä¸­ï¼Œå½“å‰çš„å€¼ä¸º nnnã€‚ ç¡®å®šå½“å‰ä½çš„å€¼ï¼š ai=nmod 2a_i = n \\mod 2 aiâ€‹=nmod2 ç„¶è€Œï¼Œå¯¹äºè´Ÿæ•°å–æ¨¡ï¼Œå¯èƒ½ä¼šå¾—åˆ°è´Ÿæ•°ç»“æœã€‚ä¸ºç¡®ä¿ aia_iaiâ€‹ æ˜¯0æˆ–1ï¼Œæˆ‘ä»¬ä½¿ç”¨å¦‚ä¸‹å…¬å¼ï¼š ai=(nmod 2+2)mod 2a_i = (n\\mod 2 + 2) \\mod 2 aiâ€‹=(nmod2+2)mod2 è¿™ä¸ªå…¬å¼ç¡®ä¿äº† aia_iaiâ€‹ ç»“æœä¸º0æˆ–1ï¼Œæ— è®º nnn æ˜¯æ­£æ•°è¿˜æ˜¯è´Ÿæ•°ã€‚ï¼ˆéå¸¸é‡è¦ï¼ï¼ï¼ï¼‰ è°ƒæ•´nnnçš„å€¼ï¼š ç”±äºæˆ‘ä»¬å·²ç»ç¡®å®šäº†å½“å‰ä½ aia_iaiâ€‹ çš„å€¼ï¼Œæˆ‘ä»¬éœ€è¦è°ƒæ•´ nnn ä»¥ä¾¿å¤„ç†ä¸‹ä¸€ä½ã€‚è°ƒæ•´æ–¹æ³•æ˜¯ï¼š n=nâˆ’ain = n - a_i n=nâˆ’aiâ€‹ è¿™ä¸€æ­¥ç¡®ä¿æˆ‘ä»¬å·²ç»æ‰£é™¤äº†å½“å‰ä½çš„å½±å“ã€‚ å¤„ç†ä¸‹ä¸€ä½ï¼š æˆ‘ä»¬éœ€è¦å°† nnn é™¤ä»¥åŸºæ•° -2ï¼Œä»¥ç»§ç»­å¤„ç†ä¸‹ä¸€ä½ï¼š n=nâˆ’2n = \\frac{n}{-2} n=âˆ’2nâ€‹ é€šè¿‡è¿™ç§æ–¹å¼ï¼Œè°ƒæ•´åçš„ nnn å‡†å¤‡å¥½å¤„ç†ä¸‹ä¸€ä½ã€‚ æ•°å­¦è§£é‡Š å‡è®¾æˆ‘ä»¬åœ¨ç¬¬ kkk æ­¥ï¼Œæœ‰å½“å‰å€¼ nkn_knkâ€‹ï¼š nk=akâ‹…(âˆ’2)k+ak+1â‹…(âˆ’2)k+1+ak+2â‹…(âˆ’2)k+2+â€¦n_k = a_k \\cdot (-2)^k + a_{k+1} \\cdot (-2)^{k+1} + a_{k+2} \\cdot (-2)^{k+2} + \\ldots nkâ€‹=akâ€‹â‹…(âˆ’2)k+ak+1â€‹â‹…(âˆ’2)k+1+ak+2â€‹â‹…(âˆ’2)k+2+â€¦ é€šè¿‡ä¸Šè¿°æ­¥éª¤ï¼Œæˆ‘ä»¬ç¡®å®šå½“å‰ä½ aka_kakâ€‹ï¼š ak=(nkmod 2+2)mod 2a_k = (n_k \\mod 2 + 2) \\mod 2 akâ€‹=(nkâ€‹mod2+2)mod2 ç„¶åï¼Œæˆ‘ä»¬è°ƒæ•´ nnn ä»¥æ‰£é™¤å½“å‰ä½ï¼š nkâ€²=nkâˆ’akn_k&#x27; = n_k - a_k nkâ€²â€‹=nkâ€‹âˆ’akâ€‹ æœ€åï¼Œæˆ‘ä»¬å°†è°ƒæ•´åçš„ nkâ€²n_k&#x27;nkâ€²â€‹ é™¤ä»¥ -2ï¼Œä»¥ç»§ç»­å¤„ç†ä¸‹ä¸€ä½ï¼š nk+1=nkâ€²âˆ’2n_{k+1} = \\frac{n_k&#x27;}{-2} nk+1â€‹=âˆ’2nkâ€²â€‹â€‹ ä»£ç ä¸­çš„ä½“ç° å°†ä¸Šè¿°é€»è¾‘è¡¨ç¤ºä¸ºä»£ç ,æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415class Solution &#123;public: string baseNeg2(int n) &#123; if (n == 0 || n == 1) return to_string(n); string res; while (n != 0) &#123; int rem = (n % 2 + 2) % 2; // ç¡®å®šå½“å‰ä½çš„å€¼ res.push_back(&#x27;0&#x27; + rem); // å°†å½“å‰ä½æ·»åŠ åˆ°ç»“æœå­—ç¬¦ä¸² n -= rem; // è°ƒæ•´ n çš„å€¼ n /= -2; // å‡†å¤‡å¤„ç†ä¸‹ä¸€ä½ &#125; reverse(res.begin(), res.end()); // åè½¬ç»“æœå­—ç¬¦ä¸² return res; &#125;&#125;; æ€»ç»“ é€šè¿‡å¯¹2å–æ¨¡å¹¶è¿›è¡Œè°ƒæ•´ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®ä¿æ¯ä¸€ä½ aia_iaiâ€‹ æ˜¯0æˆ–1ï¼Œå¹¶ä¸”é€šè¿‡é™¤ä»¥-2ç»§ç»­å¤„ç†ä¸‹ä¸€ä½ã€‚è¿™ç§æ–¹æ³•åˆ©ç”¨äº†æ•°å­¦ä¸Šçš„å–æ¨¡å’Œè°ƒæ•´ï¼Œä½¿å¾—è´ŸäºŒè¿›åˆ¶è½¬æ¢è¿‡ç¨‹ç®€æ´è€Œé«˜æ•ˆã€‚ 2024-04-29 é¢˜ç›®ä¼ é€é—¨ï¼š1329. å°†çŸ©é˜µæŒ‰å¯¹è§’çº¿æ’åº - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡æ‹Ÿä¸€ä¸‹ï¼Œå¯¹æ¯ä¸ªå¯¹è§’çº¿éƒ½æ¥æ’ä¸ªåºå°±å¯ä»¥äº†ï¼Œéå¸¸çš„ç®€å•ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; diagonalSort(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123; int n = mat.size(), m = mat[0].size(); vector&lt;int&gt; tmp; for(int i=0;i&lt;n;++i)&#123; int cnt = 0; while(i+cnt &lt; n &amp;&amp; cnt &lt; m) tmp.emplace_back(mat[i+cnt][cnt]),cnt++; sort(tmp.begin(),tmp.end()); cnt -= 1; while(cnt &gt;= 0) mat[i+cnt][cnt] = tmp[cnt],cnt--,tmp.pop_back(); &#125; for(int i=0;i&lt;m;++i)&#123; int cnt = 0; while(cnt &lt; n &amp;&amp; cnt+i &lt; m) tmp.emplace_back(mat[cnt][cnt+i]),cnt++; sort(tmp.begin(),tmp.end()); cnt -= 1; while(cnt &gt;= 0) mat[cnt][cnt+i] = tmp[cnt],cnt--,tmp.pop_back();; &#125; return mat; &#125;&#125;; 2024-04-30 é¢˜ç›®ä¼ é€é—¨ï¼š2798. æ»¡è¶³ç›®æ ‡å·¥ä½œæ—¶é•¿çš„å‘˜å·¥æ•°ç›® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ç›®ï¼Œå¾ªç¯ä¸€éæ¯”å¤§å°å³å¯ï¼Œæœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112class Solution &#123;public: int numberOfEmployeesWhoMetTarget(vector&lt;int&gt;&amp; hours, int target) &#123; int ans = 0; for (int i = 0; i &lt; hours.size(); i++) &#123; if (hours[i] &gt;= target) &#123; ans++; &#125; &#125; return ans; &#125;&#125;;"},{"title":"2024å¹´06æœˆæ¯æ—¥ä¸€é¢˜","path":"/wiki/LeetCode/æ¯æ—¥ä¸€é¢˜/2024å¹´06æœˆæ¯æ—¥ä¸€é¢˜.html","content":"2024-06-01 é¢˜ç›®ä¼ é€é—¨ï¼š2928. ç»™å°æœ‹å‹ä»¬åˆ†ç³–æœ I - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ç›®ï¼Œä½¿ç”¨æš´æœå³å¯ï¼ˆåæ¥å‘ç°åªæœ‰ä¸‰ä¸ªäººï¼Œç›´æ¥ä¸¤ä¸ªå¾ªç¯åµŒå¥—ä¹Ÿå¯ä»¥å“ˆå“ˆï¼‰ã€‚ å…­ä¸€å„¿ç«¥èŠ‚å¿«ä¹ğŸ‡ğŸ‰ğŸ˜Š æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021class Solution &#123;public: int distributeCandies(int n, int limit) &#123; int ans = 0; function&lt;void(int, int)&gt; dfs =[&amp;](int cnt,int res) &#123; if(cnt == 3 &amp;&amp; res == 0) &#123; ans ++; return; &#125; if(cnt == 2)&#123; if(res&lt;=limit) dfs(cnt+1,0); &#125; else &#123; int tmp = min(res,limit); for(int i=0;i&lt;=tmp;++i)&#123; dfs(cnt+1,res-i); &#125; &#125; &#125;; dfs(0,n); return ans; &#125;&#125;; 2024-06-02 é¢˜ç›®ä¼ é€é—¨ï¼š575. åˆ†ç³–æœ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ç›®ï¼Œä¸å†èµ˜è¿°ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213class Solution &#123;public: int distributeCandies(vector&lt;int&gt;&amp; candyType) &#123; sort(candyType.begin(), candyType.end()); int n = candyType.size(); int m = 1; for(int i=1; i&lt;n; ++i) &#123; if (candyType[i] == candyType[i-1]) continue; m++; &#125; return min(m, n/2); &#125;&#125;; 2024-06-03 é¢˜ç›®ä¼ é€é—¨ï¼š1103. åˆ†ç³–æœ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ç›®ï¼Œç›´æ¥å¤§æ¨¡æ‹Ÿæˆ–è€…äºŒåˆ†æ±‚å‡ºæ¯æ¬¡æœ€å¤§åˆ†é…å€¼ä»¥åå†æ¨¡æ‹Ÿéƒ½å¯ä»¥ï¼Œè¿™é‡Œæˆ‘é€‰æ‹©ä½¿ç”¨äºŒåˆ†ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;int&gt; distributeCandies(int candies, int num_people) &#123; function&lt;bool(int,int)&gt; addup = [&amp;](int x,int tar)&#123; int xx = 0; for(int i=1;i&lt;=x;++i)&#123; xx += i; if (xx &gt; tar) return false; &#125; return true; &#125;; int l=1, r=candies/num_people+1000; while (l&lt;r) &#123; int mid = l + ((r-l)&gt;&gt;1); if (addup(mid,candies)) l = mid+1; else r = mid; &#125; l -= 1; int res=0; for(int i=1;i&lt;=l;++i)&#123; res += i; &#125; res = candies - res; vector&lt;int&gt; ans; for(int i=1;i&lt;=num_people;++i)&#123; int tmp = i; int nans = 0; while(tmp&lt;=l) &#123; nans += tmp; tmp += num_people; &#125; if (tmp == l+1) nans += res; ans.push_back(nans); &#125; return ans; &#125;&#125;; 2024-06-04 é¢˜ç›®ä¼ é€é—¨ï¼š3067. åœ¨å¸¦æƒæ ‘ç½‘ç»œä¸­ç»Ÿè®¡å¯è¿æ¥æœåŠ¡å™¨å¯¹æ•°ç›® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™é“é¢˜æ˜¯ä¸€é“è¾ƒä¸ºå…¸å‹çš„æœç´¢å›æº¯çš„é¢˜ç›®ï¼Œé€’å½’å‡½æ•°æ¯æ¬¡è¿”å›å½“å‰èŠ‚ç‚¹ä¸‹ï¼ˆåŒ…å«å½“å‰èŠ‚ç‚¹ï¼‰æ»¡è¶³è·ç¦»æ•´é™¤signalSpeedçš„èŠ‚ç‚¹æ•°é‡ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨å›æº¯çš„æ—¶å€™æœ€ååˆ¤æ–­ä¸€ä¸‹å½“å‰é€’å½’å‡½æ•°ï¼Œæ˜¯ä¸æ˜¯åœ¨é€’å½’æ ¹èŠ‚ç‚¹å°±å¯ä»¥äº†ï¼ˆæœ€åä¸€æ­¥æ“ä½œå’Œå…¶ä½™èŠ‚ç‚¹çš„æ“ä½œä¸å¤ªä¸€æ ·ï¼‰ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;int&gt; countPairsOfConnectableServers(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int signalSpeed) &#123; int n = edges.size()+1; vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt;es(n); for(auto &amp;edge : edges) &#123; es[edge[0]].emplace_back(edge[1],edge[2]); es[edge[1]].emplace_back(edge[0],edge[2]); &#125; vector&lt;int&gt; final_ans; function&lt;int(int, int, int)&gt; dfs = [&amp;](int u, int fa, int nw_dis) &#123; int nw = 0; if (fa != -1) &#123; if (nw_dis%signalSpeed==0) nw += 1; for (auto &amp;tmp : es[u]) &#123; if (tmp.first == fa) continue; nw += dfs(tmp.first,u,nw_dis+tmp.second); &#125; &#125; else &#123; vector&lt;int&gt; ans; for (auto &amp;tmp : es[u]) &#123; if (tmp.first == fa) continue; ans.push_back(dfs(tmp.first,u,nw_dis+tmp.second)); &#125; int nn = ans.size(); for(int i=0;i&lt;nn;++i)&#123; for(int j=i+1;j&lt;nn;++j)&#123; nw += ans[i] * ans[j]; &#125; &#125; &#125; return nw; &#125;; for (int i=0;i&lt;n;++i) &#123; final_ans.push_back(dfs(i,-1,0)); &#125; return final_ans; &#125;&#125;; 2024-06-05 é¢˜ç›®ä¼ é€é—¨ï¼š3072. å°†å…ƒç´ åˆ†é…åˆ°ä¸¤ä¸ªæ•°ç»„ä¸­ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç¦»æ•£åŒ–+æ ‘çŠ¶æ•°ç»„ é¦–å…ˆå¯¹é˜Ÿåˆ—ä¸­çš„å€¼è¿›è¡Œä¸€ä¸ªç¦»æ•£åŒ–æ“ä½œ(ä½¿ç”¨unordered_map),ç„¶ååˆ†åˆ«å¯¹ä¸¤ä¸ªé˜Ÿåˆ—ç»´æŠ¤ä¸¤ä¸ªæ ‘çŠ¶æ•°ç»„è¿›è¡ŒæŸ¥è¯¢å’Œæ›´æ–°å³å¯ï¼ˆå‰ç¼€å’ŒæŸ¥è¯¢+å•ç‚¹æ›´æ–°ï¼‰ æ³¨æ„ï¼šéœ€è¦æ³¨æ„çš„æ˜¯é¢˜ç›®è¦æ±‚åˆ¤æ–­çš„æ˜¯ä¸¥æ ¼å¤§äºï¼Œå› æ­¤éœ€è¦è¿›è¡Œä¸€å®šçš„æ“ä½œå°†åç¼€å’Œè½¬åŒ–ä¸ºå‰ç¼€å’Œï¼›è¿˜æœ‰å°±æ˜¯æ ‘çŠ¶æ•°ç»„çš„ä¸‹æ ‡ä»1å¼€å§‹ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: vector&lt;int&gt; resultArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); function&lt;int(int)&gt; lowbit = [&amp;](int x)&#123; return x &amp; (-x); &#125;; function&lt;void(vector&lt;int&gt;&amp;,int)&gt; updateBIT = [&amp;](vector&lt;int&gt;&amp; bit, int a)&#123; int n = bit.size(); while(a&lt;n)&#123; bit[a]++; a += lowbit(a); &#125; &#125;; function&lt;int(vector&lt;int&gt;&amp;,int)&gt; queryBIT = [&amp;](vector&lt;int&gt;&amp; bit,int a)&#123; int sum = 0; while(a&gt;0)&#123; sum += bit[a]; a -= lowbit(a); &#125; return sum; &#125;; vector&lt;int&gt; bit1(100002, 0), bit2(100002, 0); vector&lt;int&gt; arr1, arr2, ans, nnums = nums; unordered_map&lt;int,int&gt; mp; sort(nnums.begin(), nnums.end()); int cnt = 0, prev = -1; for(auto num : nnums) &#123; if (num != prev) cnt++; mp[num] = cnt; prev = num; &#125; arr1.push_back(0); updateBIT(bit1, cnt+1-mp[nums[0]]); arr2.push_back(1); updateBIT(bit2, cnt+1-mp[nums[1]]); for(int i=2;i&lt;n;++i)&#123; int q1 = queryBIT(bit1, cnt-mp[nums[i]]); int q2 = queryBIT(bit2, cnt-mp[nums[i]]); if (q1 &gt; q2) updateBIT(bit1, cnt+1-mp[nums[i]]),arr1.push_back(i); else if (q1 &lt; q2) updateBIT(bit2, cnt+1-mp[nums[i]]),arr2.push_back(i); else &#123; if (arr1.size() &lt;= arr2.size()) updateBIT(bit1, cnt+1-mp[nums[i]]),arr1.push_back(i); else updateBIT(bit2, cnt+1-mp[nums[i]]),arr2.push_back(i); &#125; &#125; for(int arr:arr1)&#123;ans.push_back(nums[arr]);&#125; for(int arr:arr2)&#123;ans.push_back(nums[arr]);&#125; return ans; &#125;&#125;; 2024-06-06 é¢˜ç›®ä¼ é€é—¨ï¼š2938. åŒºåˆ†é»‘çƒä¸ç™½çƒ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ­¤é¢˜å¯ä»¥ç®€å•çš„æŠ½è±¡ä¸ºä¸€é“è´ªå¿ƒé¢˜ç›®ï¼Œã€Œå°†æ‰€æœ‰çš„é»‘çƒéƒ½ç§»åŠ¨åˆ°å³ä¾§ï¼Œå°†æ‰€æœ‰çš„ç™½çƒéƒ½ç§»åŠ¨åˆ°å·¦ä¾§ã€ï¼Œå³0éƒ½åœ¨1çš„å·¦ä¾§ã€‚ä¸éš¾æƒ³åˆ°ï¼Œå¯¹äºæ¯ä¸ªç™½çƒéœ€è¦ç§»åŠ¨å¤šå°‘æ¬¡ï¼Œå–å†³äºä»–å‰é¢æœ‰å¤šå°‘ä¸ªé»‘çƒã€‚å› æ­¤éå†é˜Ÿåˆ—è¿›è¡Œè´ªå¿ƒå³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213class Solution &#123;public: long long minimumSteps(string s) &#123; int n = s.size(); long long ans=0; int tmp_blk = 0; for(int i=0;i&lt;n;++i)&#123; if(s[i]==&#x27;0&#x27;) ans += tmp_blk; else tmp_blk++; &#125; return ans; &#125;&#125;; 2024-06-07 é¢˜ç›®ä¼ é€é—¨ï¼š3038. ç›¸åŒåˆ†æ•°çš„æœ€å¤§æ“ä½œæ•°ç›® I - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°éå†é¢˜ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314class Solution &#123;public: int maxOperations(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(),poi = 0,pre=-1,ans=0; while(poi+2&lt;=nums.size())&#123; int tmp = nums[poi] + nums[poi+1]; if(poi==0) pre = tmp,ans++; else if(pre == tmp) ans++; else break; poi += 2; &#125; return ans; &#125;&#125;; 2024-06-08 é¢˜ç›®ä¼ é€é—¨ï¼š3040. ç›¸åŒåˆ†æ•°çš„æœ€å¤§æ“ä½œæ•°ç›® II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åˆšåšæ²¡æœ‰ä»”ç»†çœ‹é¢˜ç›®ï¼Œä»¥ä¸ºæ˜¯ä¸€ä¸ªå¤§æš´æœï¼Œç„¶åæ¯«æ— æ„å¤–çš„TLEäº†ï¼š 123456789101112131415class Solution &#123;public: int maxOperations(vector&lt;int&gt;&amp; nums) &#123; int ans = 0, n = nums.size(); function&lt;void(int,int,int,int)&gt; dfs = [&amp;](int l, int r, int sum_num, int tmp_ans) &#123; ans = max(ans, tmp_ans); if (r-l+1&lt;2) return; if (nums[l]+nums[l+1] == sum_num || (l == 0 &amp;&amp; r == n-1)) dfs(l+2, r, nums[l]+nums[l+1], tmp_ans+1); if (nums[r]+nums[r-1] == sum_num || (l == 0 &amp;&amp; r == n-1)) dfs(l, r-2, nums[r]+nums[r-1], tmp_ans+1); if (nums[l] + nums[r] == sum_num || (l == 0 &amp;&amp; r == n-1)) dfs(l+1,r-1,nums[r]+nums[l], tmp_ans+1); &#125;; dfs(0,n-1,-1,0); return ans; &#125;&#125;; ä»”ç»†æ€è€ƒåï¼Œå‘ç°å…¶å®targetåªä¼šå­˜åœ¨ä¸‰ç§æƒ…å†µï¼š nums[0] + nums[1] nums[0] + nums[n-1] nums[n-2] + nums[n-1] æšä¸¾è¿™ä¸‰ç§æƒ…å†µå³å¯ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨è®°å¿†åŒ–æœç´¢è§£å†³ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324class Solution &#123;public: int maxOperations(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), ans = 0; vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(n, -1)); function&lt;int(int,int,int)&gt; dfs = [&amp;](int l, int r, int sum_num)&#123; // ans = max(ans, tmp_ans); if (r-l+1&lt;2) return 0; if (dp[l][r]!=-1) return dp[l][r]; int tmp = 0; if (nums[l]+nums[r]==sum_num) tmp = max(tmp, 1+dfs(l+1, r-1, sum_num)); if (nums[l]+nums[l+1]==sum_num) tmp = max(tmp, 1+dfs(l+2, r, sum_num)); if (nums[r]+nums[r-1]==sum_num) tmp = max(tmp, 1+dfs(l, r-2, sum_num)); dp[l][r] = tmp; return dp[l][r]; &#125;; ans = max(ans, 1+dfs(2, n-1, nums[0]+nums[1])); dp = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n, -1)); ans = max(ans, 1+dfs(1, n-2, nums[0]+nums[n-1])); dp = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n, -1)); ans = max(ans, 1+dfs(0, n-3, nums[n-2]+nums[n-1])); return ans; &#125;&#125;; 2024-06-09 é¢˜ç›®ä¼ é€é—¨ï¼š312. æˆ³æ°”çƒ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1 2024-06-10 é¢˜ç›®ä¼ é€é—¨ï¼š881. æ•‘ç”Ÿè‰‡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è´ªå¿ƒï¼Œå› ä¸ºæ¯æ¡èˆ¹æœ€å¤šåšä¸¤ä¸ªäººï¼Œæ‰€ä»¥æœ€ä¼˜ç­–ç•¥æ˜¯çœ‹èƒ½å¦å°†å½“å‰å‰©ä½™äººç¾¤ä¸­æœ€é‡çš„äººå’Œæœ€è½»çš„äººå¡å…¥ä¸€æ¡èˆ¹ä¸­ï¼Œå¦‚æœä¸è¡Œåˆ™æœ€é‡çš„äººéœ€è¦å•ç‹¬ä¸€æ¡èˆ¹ï¼Œå¯¹é˜Ÿåˆ—æ’åºåè¿›è¡ŒåŒæŒ‡é’ˆæ±‚è§£å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516class Solution &#123;public: int numRescueBoats(vector&lt;int&gt;&amp; people, int limit) &#123; int n = people.size(); sort(people.begin(), people.end()); int l = 0, r=n-1, ans = 0; while (l&lt;=r) &#123; if (people[l]+people[r] &lt;= limit) &#123; l ++; &#125; r -- ; ans ++; &#125; return ans; &#125;&#125;; 2024-06-11 é¢˜ç›®ä¼ é€é—¨ï¼š419. ç”²æ¿ä¸Šçš„æˆ˜èˆ° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ éå†æ‰«æï¼Œå› ä¸ºæˆ˜èˆ°åªèƒ½æ°´å¹³æˆ–ç«–ç›´æ”¾ç½®ï¼ŒæŒ‰ç…§ä»å·¦åˆ°å³ä»ä¸Šåˆ°ä¸‹çš„é¡ºåºï¼Œç»Ÿè®¡æˆ˜èˆ°æœ€å·¦ç«¯å’Œæœ€ä¸Šç«¯éƒ¨åˆ†çš„ä¸ªæ•°å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819class Solution &#123;public: int countBattleships(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int m = board.size(), n = board[0].size(); int ans = 0; function&lt;bool(int,int)&gt; judge = [&amp;](int x,int y)&#123; if (board[x][y]!=&#x27;X&#x27;) return false; if (x-1&gt;=0 &amp;&amp; board[x-1][y]==&#x27;X&#x27;) return false; if (y-1&gt;=0 &amp;&amp; board[x][y-1]==&#x27;X&#x27;) return false; return true; &#125;; for(int i=0;i&lt;m;++i)&#123; for(int j=0;j&lt;n;++j)&#123; if (judge(i, j)) ans++; &#125; &#125; return ans; &#125;&#125;; 2024-06-12 é¢˜ç›®ä¼ é€é—¨ï¼š2806. å–æ•´è´­ä¹°åçš„è´¦æˆ·ä½™é¢ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ifè¯­å¥ç­¾åˆ°é¢˜ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678class Solution &#123;public: int accountBalanceAfterPurchase(int purchaseAmount) &#123; int cost = purchaseAmount / 10 * 10; if (purchaseAmount % 10 &gt;= 5) cost += 10; return 100 - cost; &#125;&#125;; 2024-06-13 é¢˜ç›®ä¼ é€é—¨ï¼š æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1 2024-06-14 é¢˜ç›®ä¼ é€é—¨ï¼š2786. è®¿é—®æ•°ç»„ä¸­çš„ä½ç½®ä½¿åˆ†æ•°æœ€å¤§ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç®€å•çš„åŠ¨æ€è§„åˆ’ï¼ŒçŠ¶æ€è½¬ç§»æ˜¯å¯¹å½“å‰çš„ä¸‹æ ‡iï¼š é€‰æ‹©ä¸€ä¸ªä¹‹å‰çš„å­åºåˆ—ï¼Œæœ€åä¸€ä¸ªæ•°å’Œå½“å‰ä¸‹æ ‡iå¥‡å¶æ€§ç›¸åŒ é€‰æ‹©ä¸€ä¸ªä¹‹å‰çš„å­åºåˆ—ï¼Œæœ€åä¸€ä¸ªæ•°å’Œå½“å‰ä¸‹æ ‡iå¥‡å¶æ€§ä¸åŒ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼ˆä½¿ç”¨å †ä¼˜åŒ–ï¼Œå› ä¸ºæˆ‘å®šä¹‰çš„dpæ•°ç»„æ˜¯ä»¥å½“å‰æ•°ä¸ºç»“å°¾ï¼ˆå¿…é¡»é€‰å½“å‰æ•°ï¼‰æœ€å¤§çš„å­åºåˆ—ï¼‰ï¼š 1234567891011121314151617181920212223class Solution &#123;public: long long maxScore(vector&lt;int&gt;&amp; nums, int x) &#123; long long n = nums.size(); vector&lt;long long&gt; dp(n+1,0); dp[0] = nums[0]; priority_queue&lt;long long&gt; pq[2]; pq[nums[0]%2].push(nums[0]); for (long long i=1;i&lt;n;++i) &#123; long long tmp_mod = nums[i] % 2; long long ans1 = -1e7, ans2 = -1e7; if (!pq[tmp_mod].empty()) ans1 = pq[tmp_mod].top() ; if (!pq[1-tmp_mod].empty()) ans2 = pq[1-tmp_mod].top(); dp[i] = max(ans1, ans2-x) + nums[i]; pq[tmp_mod].push(dp[i]); &#125; long long ans = dp[0]; for(long long i=1;i&lt;n;++i) &#123; ans = max(ans, dp[i]); &#125; return ans; &#125;&#125;; 2024-06-15 é¢˜ç›®ä¼ é€é—¨ï¼š2779. æ•°ç»„çš„æœ€å¤§ç¾ä¸½å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å·®åˆ†æ•°ç»„ï¼Œæ­¤é¢˜ç›¸å½“äºé—®ç»™å®šnä¸ªåŒºé—´ï¼Œè¢«è¦†ç›–æœ€å¤šå…ƒç´ çš„æ¬¡æ•°æ˜¯å¤šå°‘ï¼Œåˆå§‹åŒ–ä¸€ä¸ªå…¨0çš„å·®åˆ†æ•°ç»„ï¼Œå¯¹äºæ¯ä¸€ä¸ªåŒºé—´ï¼ŒåŒºé—´æœ€å¼€å§‹çš„å…ƒç´ å¯¹åº”ä½ç½®åœ¨å·®åˆ†æ•°ç»„ä¸­+1ï¼Œæœ€åå…ƒç´ å¯¹åº”ä½ç½®çš„ä¸‹ä¸€ä¸ªä½ç½®åœ¨å·®åˆ†æ•°ç»„ä¸­-1ã€‚æœ€åå¯¹å·®åˆ†æ•°ç»„æ±‚å‰ç¼€å’Œå°±å¯çŸ¥æ¯ä¸ªå…ƒç´ è¢«è¦†ç›–çš„æ¬¡æ•°äº†ï¼Œæ‰¾å‡ºæœ€å¤§å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617class Solution &#123;public: int maximumBeauty(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; cnts(200003,0); for (auto &amp;num : nums) &#123; cnts[max(0,num-k)]++; cnts[num+k+1]--; &#125; int max_ele = *max_element(nums.begin(),nums.end()); int ans = cnts[0], nw = cnts[0]; for(int i=1; i&lt;=max_ele+k; ++i) &#123; nw += cnts[i]; ans = max(ans,nw); &#125; return ans; &#125;&#125;; 2024-06-16 é¢˜ç›®ä¼ é€é—¨ï¼š521. æœ€é•¿ç‰¹æ®Šåºåˆ— â…  - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä»Šå¤©çš„ç­¾åˆ°é¢˜è¿˜æœ‰ç‚¹æ„æ€ï¼Œæœ‰ç‚¹è„‘ç­‹æ€¥è½¬å¼¯çš„æ„Ÿè§‰ï¼Œé¢˜é¢æè¿°é‚£ä¹ˆå¤šï¼Œå…¶å®åªéœ€è¦åˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯ä¸æ˜¯ç›¸åŒå³å¯ã€‚ç›¸åŒè¿”å›-1ï¼Œä¸ç›¸åŒè¿”å›æœ€é•¿å­—ç¬¦ä¸²é•¿åº¦å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789class Solution &#123;public: int findLUSlength(string a, string b) &#123; if (a.compare(b) == 0) &#123; return -1; &#125; return max(a.size(), b.size()); &#125;&#125;; 2024-06-17 é¢˜ç›®ä¼ é€é—¨ï¼š522. æœ€é•¿ç‰¹æ®Šåºåˆ— II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1 2024-06-18 é¢˜ç›®ä¼ é€é—¨ï¼š2288. ä»·æ ¼å‡å… - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡æ‹Ÿé¢˜ï¼Œå…ˆä½¿ç”¨ç©ºæ ¼å¯¹å­—ç¬¦ä¸²è¿›è¡Œåˆ’åˆ†ï¼Œç„¶åå†åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­é™¤äº†$å…¶ä½™æ˜¯å¦éƒ½æ˜¯æ•°å­—ï¼Œå¦‚æœæ˜¯è½¬ä¸ºintè¿›è¡Œè®¡ç®—åï¼ŒåŠ å…¥ç­”æ¡ˆä¸­å»ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021class Solution &#123;public: string discountPrices(string sentence, int discount) &#123; double dis = 1 - (discount / 100.0); stringstream ss(sentence); string ans, w; while (ss &gt;&gt; w)&#123; // æŒ‰ç…§ç©ºæ ¼è¿›è¡Œåˆ†å‰² if(!ans.empty()) &#123; ans += &#x27; &#x27;; &#125; if (w.length() &gt; 1 &amp;&amp; w[0] == &#x27;$&#x27; &amp;&amp; all_of(w.begin()+1, w.end(), ::isdigit)) &#123; stringstream s; s &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; &#x27;$&#x27; &lt;&lt; stoll(w.substr(1)) * dis; ans += s.str(); &#125; else &#123; ans += w; &#125; &#125; return ans; &#125;&#125;; 2024-06-19 é¢˜ç›®ä¼ é€é—¨ï¼š2713. çŸ©é˜µä¸­ä¸¥æ ¼é€’å¢çš„å•å…ƒæ ¼æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ­¤é¢˜å¥½åƒåœ¨è“æ¡¥æ¯ä¸Šé‡è§è¿‡ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1 2024-06-20 é¢˜ç›®ä¼ é€é—¨ï¼š2748. ç¾ä¸½ä¸‹æ ‡å¯¹çš„æ•°ç›® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ éå†ç­¾åˆ°é¢˜ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223class Solution &#123;public: int countBeautifulPairs(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); function&lt;int(int, int)&gt; gcd = [&amp;](int a,int b)&#123; if (a%b==0) return b; return gcd(b, a%b); &#125;; function&lt;int(int)&gt; rnum = [&amp;](int x)&#123; while(x&gt;9) x /= 10; return x; &#125;; int ans = 0; for(int i=0;i&lt;n;++i)&#123; for(int j=i+1;j&lt;n;++j)&#123; int maxx = max(rnum(nums[i]), nums[j]%10); int minn = min(rnum(nums[i]), nums[j]%10); if (gcd(maxx, minn)==1) ans++; &#125; &#125; return ans; &#125;&#125;; 2024-06-21 é¢˜ç›®ä¼ é€é—¨ï¼šLCP 61. æ°”æ¸©å˜åŒ–è¶‹åŠ¿ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ï¼Œéå†å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516class Solution &#123;public: int temperatureTrend(vector&lt;int&gt;&amp; temperatureA, vector&lt;int&gt;&amp; temperatureB) &#123; int ans=0, n=temperatureA.size(),tmp=0; for(int i=1; i&lt;n; ++i) &#123; if (((temperatureA[i]&gt;temperatureA[i-1])&amp;&amp;(temperatureB[i]&gt;temperatureB[i-1]))|| ((temperatureA[i]&lt;temperatureA[i-1])&amp;&amp;(temperatureB[i]&lt;temperatureB[i-1]))|| ((temperatureA[i]==temperatureA[i-1])&amp;&amp;(temperatureB[i]==temperatureB[i-1])))&#123; tmp++; ans = max(ans, tmp); &#125; else &#123; tmp = 0; &#125; &#125; return ans; &#125;&#125;; 2024-06-22 é¢˜ç›®ä¼ é€é—¨ï¼š2663. å­—å…¸åºæœ€å°çš„ç¾ä¸½å­—ç¬¦ä¸² - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡æ‹Ÿ+è´ªå¿ƒï¼Œä¸ºäº†å­—å…¸åºå°½å¯èƒ½çš„å°ï¼Œåº”å½“ä»æœ€å³è¾¹å¼€å§‹æ£€æŸ¥å½“å‰å­—ç¬¦èƒ½å¦æ›´æ”¹ï¼Œè‹¥èƒ½å¤Ÿæ›´æ”¹åˆ™æ¥ç€å¡«å……åç»­å­—ç¬¦ï¼Œå¦‚æœèƒ½å¡«å……å®Œæ¯•åˆ™æˆåŠŸï¼Œè¿”å›æœ€ç»ˆçš„å­—ç¬¦ä¸²ï¼Œå¦åˆ™ç»§ç»­æœç´¢ã€‚ é—®é¢˜ï¼š æ›´æ”¹å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦ï¼Œæ˜¯ä¸æ˜¯åªå¾€ä¸ŠåŠ ä¸€ä¸ªå°±è¡Œäº†ã€‚ æ˜¯ï¼Œæ ¹æ®è´ªå¿ƒç®—æ³•ï¼Œå¯ä»¥è¯æ˜ï¼ŒåªåŠ ä¸€ä¸ªå…·æœ‰æœ€ä¼˜è§£ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829class Solution &#123; public: string smallestBeautifulString(string s, int k) &#123; int n = s.size(); function&lt;char(int)&gt; judge = [&amp;](int loc)&#123; for (int i=s[loc]-&#x27;a&#x27;+2;i&lt;=k;++i) &#123; if (loc==0) return char(i-1+&#x27;a&#x27;); if (loc==1&amp;&amp;s[loc-1]!=i+&#x27;a&#x27;-1) return char(i-1+&#x27;a&#x27;); if (loc&gt;=2&amp;&amp;s[loc-1]!=i+&#x27;a&#x27;-1&amp;&amp;s[loc-2]!=i+&#x27;a&#x27;-1) return char(i-1+&#x27;a&#x27;); &#125; return &#x27;!&#x27;; &#125;; string ans = &quot;&quot;; for (int i=n-1;i&gt;=0;--i) &#123; char nw = judge(i); if (nw != &#x27;!&#x27;) &#123; string tmp = s.substr(0, i); tmp += nw; bool flag=true; for(int j=i+1; j&lt;n; ++j)&#123; bool nw_flag = false; for(int c=1;c&lt;=k;++c)&#123; if (c==tmp[j-1]-&#x27;a&#x27;+1) continue; if(j-2&gt;=0&amp;&amp;tmp[j-2]-&#x27;a&#x27;+1==c) continue; tmp += char(c-1+&#x27;a&#x27;); nw_flag = true; break; &#125; if (!nw_flag) &#123;flag=false;break;&#125; &#125; if (flag) return tmp; &#125; &#125; return &quot;&quot;; &#125;&#125;; 2024-06-23 é¢˜ç›®ä¼ é€é—¨ï¼š520. æ£€æµ‹å¤§å†™å­—æ¯ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€è¡Œä»£ç è§£å†³æˆ˜æ–—ï¼ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456class Solution &#123;public: bool detectCapitalUse(string word) &#123; return (all_of(word.begin(), word.end(), [](unsigned char c) &#123;return islower(c);&#125;)) || (all_of(word.begin(), word.end(), [](unsigned char c) &#123;return isupper(c);&#125;)) || (isupper(word[0]) &amp;&amp; all_of(word.begin()+1, word.end(), [](unsigned char c) &#123;return islower(c);&#125;)); &#125;&#125;; 2024-06-24 é¢˜ç›®ä¼ é€é—¨ï¼š503. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å•è°ƒæ ˆï¼Œæ³¨æ„ï¼Œç”±äºé˜Ÿåˆ—é¦–ä½ç›¸æ¥ï¼Œå¯ä»¥é€šè¿‡å°†é˜Ÿåˆ—å¤åˆ¶ä¸€ä»½ï¼Œä½¿å…¶é•¿åº¦åŠ å€ã€‚è¿™æ ·å¯¹äºå‰ä¸€ä»½é˜Ÿåˆ—ä¾¿å¯ä»¥å’Œè‡ªå·±ä¹‹å‰çš„å…ƒç´ è¿›è¡Œæ¯”è¾ƒï¼Œè¿‘ä¼¼å®ç°äº†é˜Ÿåˆ—é¦–ä½ç›¸æ¥çš„åŠŸèƒ½ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; int max_ele = *max_element(nums.begin(), nums.end()); int n = nums.size(); vector&lt;int&gt; ans(n,-1); vector&lt;pair&lt;int,int&gt;&gt; stk; for(int i=0;i&lt;n*2-1;++i)&#123; int nw = nums[i%n]; int tmp_n = stk.size(); while (!stk.empty() &amp;&amp; stk[tmp_n-1].second &lt; nw &amp;&amp; ans[stk[tmp_n-1].first] == -1)&#123; ans[stk[tmp_n-1].first] = nw; stk.pop_back(); tmp_n--; &#125; if (i &lt; n &amp;&amp; max_ele!=nums[i]) stk.emplace_back(i, nums[i]); &#125; return ans; &#125;&#125;; 2024-06-25 é¢˜ç›®ä¼ é€é—¨ï¼š2732. æ‰¾åˆ°çŸ©é˜µä¸­çš„å¥½å­é›† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å¯ä»¥é€šè¿‡ä¸¥æ ¼è¯æ˜å¾—çŸ¥ï¼Œåœ¨n&lt;=5çš„æƒ…å†µä¸‹ï¼Œåªéœ€è¦è€ƒè™‘1ï¼Œ2è¡Œçš„æƒ…å†µã€‚ ä¸¥æ ¼è¯æ˜è¿‡ç¨‹è§ï¼šä¸¥æ ¼è¯æ˜+ä¸‰ç§è®¡ç®—æ–¹æ³•ï¼ˆPython/Java/C++/Goï¼‰ å¾—çŸ¥ä¸Šè¿°æ€§è´¨åï¼Œå“ˆå¸Œè¡¨è§£å†³å³å¯ã€‚ï¼ˆå› ä¸ºæœ€å¤šäº”åˆ—ï¼Œæ‰€ä»¥å“ˆå¸Œè¡¨ä¹Ÿä¸å¤§ï¼‰ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; goodSubsetofBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;int&gt; ans; unordered_map&lt;int, int&gt; mp; int m = grid.size(); int n = grid[0].size(); for(int i=0; i&lt;m; ++i)&#123; int st = 0; for(int j=0; j&lt;n; ++j)&#123; st |= (grid[i][j] &lt;&lt; j); &#125; mp[st] = i; &#125; if (mp.count(0)) &#123; ans.push_back(mp[0]); return ans; &#125; for (auto [x, i]: mp) &#123; for (auto [y, j]: mp) &#123; if (!(x &amp; y)) &#123; return &#123;min(i, j), max(i, j)&#125;; &#125; &#125; &#125; return ans; &#125;&#125;; 2024-06-26 é¢˜ç›®ä¼ é€é—¨ï¼š2741. ç‰¹åˆ«çš„æ’åˆ— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ çŠ¶å‹DPæ¿å­é¢˜ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯vectorä¸è¦ä¸€ä¸Šæ¥å°±å¼€çš„å¾ˆå¤§ï¼Œä¼šæŠ¥é”™ğŸ˜­ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829class Solution &#123;public: int specialPerm(vector&lt;int&gt;&amp; nums) &#123; // sort(nums.begin(), nums.end()); int n = nums.size(); int maxx = pow(2, n); vector&lt;vector&lt;int&gt;&gt; dp(maxx,vector&lt;int&gt;(n,0)); int MOD = 1e9 + 7; for(int i=0;i&lt;n;++i) dp[1&lt;&lt;i][i] = 1; for(int i=1;i&lt;maxx;++i)&#123; for(int j=0;j&lt;n;++j)&#123; if (!(i&gt;&gt;j)&amp;1) continue; for(int k=0;k&lt;n;++k)&#123; if (j==k) continue; if(!(1&amp;(i&gt;&gt;k))) continue; if (max(nums[j],nums[k]) % min(nums[j],nums[k])) continue; int ii = i ^ (1&lt;&lt;j); dp[i][j] = (dp[i][j] + dp[ii][k]) % MOD; &#125; &#125; &#125; int ans = 0; for(int i=0;i&lt;n;++i) ans = (ans + dp[maxx-1][i]) % MOD; return ans; &#125;&#125;; 2024-06-27 é¢˜ç›®ä¼ é€é—¨ï¼š2734. æ‰§è¡Œå­ä¸²æ“ä½œåçš„å­—å…¸åºæœ€å°å­—ç¬¦ä¸² - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è´ªå¿ƒï¼Œä»å·¦åˆ°å³éå†ï¼Œå¦‚æœä¸æ˜¯aå°±è®©ä»–å˜å°ï¼Œè¿™æ ·è¿ç»­çš„æ”¹ä¸€ä¸²å°±å¯ä»¥ã€‚éœ€è¦æ³¨æ„çš„ç‰¹æ®Šæƒ…å†µæ˜¯ï¼Œå¦‚æœå­—ç¬¦ä¸²ä¸ºå…¨aï¼Œæ­¤æ—¶å°†æœ€åä¸€ä¸ªå­—ç¬¦æ”¹ä¸ºzå³å¯ã€‚è¿™ç§ç‰¹æ®Šæƒ…å†µç‰¹åˆ¤ä¸€ä¸‹å°±å¥½ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112class Solution &#123;public: string smallestString(string s) &#123; int n = s.size(); int cnt = 0; bool flag = false; while(cnt&lt;n&amp;&amp;s[cnt] == &#x27;a&#x27;) cnt++; while(cnt&lt;n&amp;&amp;s[cnt]!=&#x27;a&#x27;) flag=true,s[cnt]=s[cnt]-1,cnt++; if (!flag) s[n-1] = &#x27;z&#x27;; return s; &#125;&#125;; 2024-06-28 é¢˜ç›®ä¼ é€é—¨ï¼š2742. ç»™å¢™å£åˆ·æ²¹æ¼† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ­¤é¢˜ä¸º01èƒŒåŒ…é—®é¢˜çš„è‡³å°‘å˜å½¢ï¼Œ è¯¦ç»†è®²è§£è§OI-KnowledgeèƒŒåŒ…é—®é¢˜éƒ¨åˆ†æœ€åçš„å˜å½¢3ç« èŠ‚ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415class Solution &#123;public: int paintWalls(vector&lt;int&gt; &amp;cost, vector&lt;int&gt; &amp;time) &#123; int n = cost.size(); vector&lt;int&gt; dp(n + 1, INT_MAX / 2); // é˜²æ­¢åŠ æ³•æº¢å‡º dp[0] = 0; for (int i = 0; i &lt; n; i++) &#123; int nw_cost = cost[i], nw_time = time[i]+1; for(int j=n;j&gt;=0;--j)&#123; dp[j] = min(dp[j], dp[max(0, j-nw_time)]+nw_cost); &#125; &#125; return dp[n]; &#125;&#125;; 2024-06-29 é¢˜ç›®ä¼ é€é—¨ï¼š2710. ç§»é™¤å­—ç¬¦ä¸²ä¸­çš„å°¾éšé›¶ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ C++ stringä¸­substrç»ƒä¹ é¢˜ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011class Solution &#123;public: string removeTrailingZeros(string num) &#123; int n = num.size(); int i = 0; while (num[n-1-i]==&#x27;0&#x27;) &#123; i++; &#125; return num.substr(0,n-i); &#125;&#125;; 2024-06-30 é¢˜ç›®ä¼ é€é—¨ï¼š494. ç›®æ ‡å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ 01èƒŒåŒ…å˜ä½“ï¼Œé¢˜ç›®è¦æ±‚åœ¨æ¯ä¸ªæ•°å‰é¢æ·»åŠ +æˆ–è€…-å·ï¼Œå…¶å®å¯ä»¥çœ‹ä½œæ˜¯åˆå§‹éƒ½æ˜¯å‡å·ï¼Œé€‰å‡ºä¸€äº›æ•°å˜ä¸º+å·ï¼Œè¿™å°±æ˜¯01èƒŒåŒ…çš„æ€æƒ³äº†ã€‚åªä¸è¿‡æœ€åè¦æ±‚ä¸åƒ01èƒŒåŒ…æ˜¯è‡³å¤šè€Œæ˜¯æ°å¥½éœ€è¦æ³¨æ„ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123; if (target &lt; 0) target = -target; int sum_nums = 0; for(auto num : nums) sum_nums += num; if ((sum_nums+target)%2) return 0; int nw_target = (sum_nums+target)/2; vector&lt;int&gt; dp(nw_target+1, 0); dp[0] = 1; for(auto num : nums)&#123; for(int i=nw_target;i&gt;=0;--i)&#123; if(i&gt;=num) dp[i] += dp[i-num]; &#125; &#125; return dp[nw_target]; &#125;&#125;;"},{"title":"2024å¹´08æœˆæ¯æ—¥ä¸€é¢˜","path":"/wiki/LeetCode/æ¯æ—¥ä¸€é¢˜/2024å¹´08æœˆæ¯æ—¥ä¸€é¢˜.html","content":"2024-08-08 é¢˜ç›®ä¼ é€é—¨ï¼š3131. æ‰¾å‡ºä¸æ•°ç»„ç›¸åŠ çš„æ•´æ•° I - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ï¼Œæ’åºåç¬¬ä¸€ä¸ªç›¸å‡å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678class Solution &#123;public: int addedInteger(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); return nums2[0] - nums1[0]; &#125;&#125;; 2024-08-09 é¢˜ç›®ä¼ é€é—¨ï¼š3132. æ‰¾å‡ºä¸æ•°ç»„ç›¸åŠ çš„æ•´æ•° II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸Šä¸€é¢˜çš„éš¾åº¦å¢å¼ºç‰ˆï¼Œä½†æ˜¯ç”±äºæ•°ç»„é•¿åº¦è¾ƒå°ï¼Œç›´æ¥æšä¸¾è¢«åˆ é™¤çš„æ•°å³å¯ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627class Solution &#123;public: int minimumAddedInteger(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); int n = nums2.size(); function&lt;int(int,int)&gt; judge = [&amp;](int ex1,int ex2)&#123; int nw = 0; while(nw==ex1||nw==ex2) nw++; int x = nums2[0] - nums1[nw]; for(int i=0;i&lt;n;++i)&#123; while (i+nw==ex1||i+nw==ex2) nw++; if(nums2[i]-nums1[nw+i]!=x) return 12312312; &#125; return x; &#125;; int ans = INT_MAX; for(int i=0;i&lt;n+2;++i)&#123; for(int j=i+1;j&lt;n+2;++j)&#123; int x = judge(i,j); if (x!=12312312) ans = min(ans, x); &#125; &#125; return ans; &#125;&#125;;"},{"title":"2024å¹´07æœˆæ¯æ—¥ä¸€é¢˜","path":"/wiki/LeetCode/æ¯æ—¥ä¸€é¢˜/2024å¹´07æœˆæ¯æ—¥ä¸€é¢˜.html","content":"2024-07-01 é¢˜ç›®ä¼ é€é—¨ï¼š2065. æœ€å¤§åŒ–ä¸€å¼ å›¾ä¸­çš„è·¯å¾„ä»·å€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™é“é¢˜çœ‹ä¸Šå»éå¸¸çš„å“äººï¼Œä½†æ˜¯æˆ‘ä»¬æ³¨æ„ä¸€ä¸‹æ•°æ®èŒƒå›´ä¾¿å¯ä»¥å‘ç°ï¼Œç”±äºæ¯æ¡è¾¹çš„æ—¶é—´ä»¥åŠæ€»çš„æ—¶é—´é™åˆ¶æœ€å°ä¸º10æœ€å¤§ä¸º100ï¼Œè¿™è¯´æ˜æˆ‘ä»¬è‡³å¤šåªä¼šç»è¿‡å›¾ä¸Šçš„Â 10Â æ¡è¾¹ã€‚å¹¶ä¸”ç”±äºå›¾ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„åº¦æ•°éƒ½ä¸è¶…è¿‡Â 4ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æšä¸¾ï¼ˆæš´æœï¼‰æ‰€æœ‰ä»èŠ‚ç‚¹Â 0Â å¼€å§‹çš„è·¯å¾„ã€‚æš´æœç»ˆæ­¢æ¡ä»¶å°±æ˜¯è¶…æ—¶äº†ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int maximalPathQuality(vector&lt;int&gt;&amp; values, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxTime) &#123; int n = values.size(); vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; g(n); for (auto edge : edges) &#123; g[edge[0]].emplace_back(edge[1], edge[2]); g[edge[1]].emplace_back(edge[0], edge[2]); &#125; vector&lt;bool&gt; vis(n, false); vis[0] = true; int ans = 0; function&lt;void(int, int, int)&gt; dfs = [&amp;](int u, int time, int value)&#123; if(u == 0) &#123; ans = max(ans, value); &#125; for(auto [v, dist]:g[u])&#123; if (time + dist &lt;= maxTime) &#123; if(!vis[v]) &#123; vis[v] = true; dfs(v, time+dist, value+values[v]); vis[v] = false; &#125; else &#123; dfs(v, time+dist,value); &#125; &#125; &#125; &#125;; dfs(0, 0, values[0]); return ans; &#125;&#125;; 2024-07-02 é¢˜ç›®ä¼ é€é—¨ï¼š3115. è´¨æ•°çš„æœ€å¤§è·ç¦» - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ­£å¥½å€Ÿæ­¤é¢˜å¤ä¹ ä¸€ä¸‹æ¬§æ‹‰ç­›ã€‚å› ä¸ºæ•°çš„èŒƒå›´æœ€å¤§åªåˆ°100ï¼Œå› æ­¤é¢„å¤„ç†ä¸€ä¸‹100å†…çš„è´¨æ•°ç„¶ååˆ†åˆ«æ‰¾å‡ºé˜Ÿåˆ—å·¦è¾¹ç¬¬ä¸€ä¸ªè´¨æ•°çš„ä¸‹æ ‡å’Œå³è¾¹ç¬¬ä¸€ä¸ªè´¨æ•°çš„ä¸‹æ ‡å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021class Solution &#123;public: int maximumPrimeDifference(vector&lt;int&gt;&amp; nums) &#123; int MAX=100, n = nums.size(); vector&lt;bool&gt; vis(101, false); vector&lt;int&gt; primes; for(int i=2;i&lt;=MAX;++i)&#123; if (!vis[i]) primes.push_back(i); for(auto prime : primes)&#123; if (i * prime &gt; MAX) break; vis[i * prime] = true; if (i % prime == 0) break; &#125; &#125; vis[0] = true; vis[1] = true; int i=0,j=n-1; while(vis[nums[i]]) i++; while(vis[nums[j]]) j--; return j-i; &#125;&#125;; 2024-07-03 é¢˜ç›®ä¼ é€é—¨ï¼š3099. å“ˆæ²™å¾·æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å¿«ä¹ç­¾åˆ°é¢˜ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678class Solution &#123;public: int sumOfTheDigitsOfHarshadNumber(int x) &#123; int ans = 0, xx = x; while (x) ans += x%10, x /= 10; return xx%ans==0?ans:-1; &#125;&#125;; 2024-07-04 é¢˜ç›®ä¼ é€é—¨ï¼š3086. æ‹¾èµ· K ä¸ª 1 éœ€è¦çš„æœ€å°‘è¡ŒåŠ¨æ¬¡æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è´ªå¿ƒ+äºŒåˆ† æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1 2024-07-05 é¢˜ç›®ä¼ é€é—¨ï¼š3033. ä¿®æ”¹çŸ©é˜µ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜å–œåŠ ä¸€ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; modifiedMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt;col_max = matrix[0]; for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;m;++j)&#123; col_max[i] = max(col_max[i], matrix[j][i]); &#125; &#125; for(int i=0;i&lt;m;++i)&#123; for(int j=0;j&lt;n;++j)&#123; if(matrix[i][j]==-1) matrix[i][j] = col_max[j]; &#125; &#125; return matrix; &#125;&#125;; 2024-07-06 é¢˜ç›®ä¼ é€é—¨ï¼š3101. äº¤æ›¿å­æ•°ç»„è®¡æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å¯ä»¥æŠŠä»–å½“æˆä¸€ä¸ªDPæ¥å¤„ç†ï¼Œå¼€ä¸€ä¸ªå’Œæ•°ç»„ä¸€æ ·é•¿çš„DPæ•°ç»„ï¼Œdpæ¯ä¸€é¡¹è®°å½•ä»¥è¯¥é¡¹ç»“å°¾èƒ½æ„æˆçš„å­æ•°ç»„æ•°ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415class Solution &#123;public: long long countAlternatingSubarrays(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;long long&gt;dp(n+2, 0); dp[1] = 1; for(int i=2;i&lt;=n;++i)&#123; if (nums[i-1] ^ nums[i-2]) dp[i] = 1 + dp[i-1]; else dp[i] = 1; &#125; long long ans=0; for(int i=1;i&lt;=n;++i) ans += dp[i]; return ans; &#125;&#125;; ä»”ç»†è§‚å¯Ÿä¸Šè¿°ä»£ç ï¼Œæˆ‘ä»¬å‘ç°dpæ•°ç»„ä¹Ÿå¯ä»¥è¢«æˆ‘ä»¬ä¼˜åŒ–æ‰ï¼š ä¼˜åŒ–åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213class Solution &#123;public: long long countAlternatingSubarrays(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); long long cnt = 0, ans = 0; for(int i=1;i&lt;=n;++i)&#123; if (i!=1&amp;&amp;nums[i-1] ^ nums[i-2]) cnt++; else cnt = 1; ans += cnt; &#125; return ans; &#125;&#125;; å…¶å®å°±æ˜¯ä¸€é“éå†é¢˜ 2024-07-07 é¢˜ç›®ä¼ é€é—¨ï¼š1958. æ£€æŸ¥æ“ä½œæ˜¯å¦åˆæ³• - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å¤§æ¨¡æ‹Ÿé¢˜ç›®ï¼Œéå†8ä¸ªæ–¹å‘ï¼Œåªæœ‰ç¬¬ä¸€ä¸ªå’Œå½“å‰é¢œè‰²ä¸åŒåœ¨ç»§ç»­åˆ¤æ–­ï¼Œæœ€åè®°å¾—åˆ¤æ–­æœ€åä¸€ä¸ªå—çš„é¢œè‰²å’Œä¼ å…¥é¢œè‰²æ˜¯å¦ç›¸åŒå³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728class Solution &#123;public: bool checkMove(vector&lt;vector&lt;char&gt;&gt;&amp; board, int rMove, int cMove, char color) &#123; int n = board.size(), m = board[0].size(); function&lt;bool(int, int)&gt; judge = [&amp;](int x,int y)&#123; if (x&lt;0||y&lt;0||x&gt;=n||y&gt;=m) return false; return true; &#125;; function&lt;bool(char, int)&gt; judge_col = [&amp;](char nw_color,int rev)&#123; if (rev&amp;&amp;(nw_color!=color)) &#123; if (nw_color==&#x27;B&#x27;&amp;&amp;color==&#x27;W&#x27;) return true; if (nw_color==&#x27;W&#x27;&amp;&amp;color==&#x27;B&#x27;) return true; return false; &#125; if (!rev&amp;&amp;(nw_color==color)) return true; return false; &#125;; vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;-1,1&#125;,&#123;1,-1&#125;&#125;; for (auto dir : dirs)&#123; if(judge(rMove+dir[0],cMove+dir[1])&amp;&amp;judge_col(board[rMove+dir[0]][cMove+dir[1]],1))&#123; int cnt = 1; while(judge(rMove+dir[0]*cnt,cMove+dir[1]*cnt)&amp;&amp;judge_col(board[rMove+dir[0]*cnt][cMove+dir[1]*cnt],1)) cnt++; if (judge(rMove+dir[0]*cnt,cMove+dir[1]*cnt)&amp;&amp;judge_col(board[rMove+dir[0]*cnt][cMove+dir[1]*cnt],0)) return true; &#125; &#125; return false; &#125;&#125;; 2024-07-08 é¢˜ç›®ä¼ é€é—¨ï¼š724. å¯»æ‰¾æ•°ç»„çš„ä¸­å¿ƒä¸‹æ ‡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å¿«ä¹ç­¾åˆ°é¢˜ï¼Œéå†ä¸€éå³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213class Solution &#123;public: int pivotIndex(vector&lt;int&gt;&amp; nums) &#123; int sum_all = 0, n = nums.size(); for(int i=0;i&lt;n;++i) sum_all += nums[i]; int sum_now=0; for(int i=0; i&lt;n; ++i) &#123; if (sum_now == sum_all-nums[i]-sum_now) return i; sum_now += nums[i]; &#125; return -1; &#125;&#125;; 2024-07-09 é¢˜ç›®ä¼ é€é—¨ï¼š3102. æœ€å°åŒ–æ›¼å“ˆé¡¿è·ç¦» - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ éœ€è¦ä½¿ç”¨æŠ€å·§ï¼šæ›¼å“ˆé¡¿è·ç¦»è½¬åˆ‡æ¯”é›ªå¤«è·ç¦»ï¼Œè¯¦æƒ…å¯è§çµç¥çš„é¢˜è§£ï¼šã€å›¾è§£ã€‘æ›¼å“ˆé¡¿è·ç¦»è½¬åˆ‡æ¯”é›ªå¤«è·ç¦»ï¼ˆPython/Java/C++/Goï¼‰ è½¬æ¢å…¬å¼å¦‚ä¸‹ï¼š âˆ£x1âˆ’x2âˆ£+âˆ£y1âˆ’y2âˆ£=maxâ¡(âˆ£x1â€²âˆ’x2â€²âˆ£,âˆ£y1â€²âˆ’y2â€²âˆ£)\\left| x_1 - x_2 \\right| + \\left| y_1 - y_2 \\right| = \\max \\left( \\left| x_1&#x27; - x_2&#x27; \\right|, \\left| y_1&#x27; - y_2&#x27; \\right| \\right) âˆ£x1â€‹âˆ’x2â€‹âˆ£+âˆ£y1â€‹âˆ’y2â€‹âˆ£=max(âˆ£x1â€²â€‹âˆ’x2â€²â€‹âˆ£,âˆ£y1â€²â€‹âˆ’y2â€²â€‹âˆ£) å…¶ä¸­å·¦ä¾§ä¸ºæ›¼å“ˆé¡¿è·ç¦»ï¼Œå³ä¾§ä¸ºåˆ‡æ¯”é›ªå¤«è·ç¦»ï¼Œåæ ‡å˜æ¢å…³ç³»å¦‚ä¸‹æ‰€ç¤ºï¼š (xâ€²,yâ€²)=(x+y,yâˆ’x)\\left( x&#x27;, y&#x27; \\right) = \\left( x + y, y - x \\right) (xâ€²,yâ€²)=(x+y,yâˆ’x) åšäº†ä¸Šé¢çš„å˜æ¢åï¼Œæˆ‘ä»¬çš„ä»»åŠ¡å°±å¾ˆç®€å•äº†ã€‚å¯ä»¥å®šä¹‰ä¸¤ä¸ªæœ‰åºé›†åˆï¼Œåˆ†åˆ«ç»´æŠ¤nä¸ªæ•°è½¬æ¢åæ¨ªåæ ‡å’Œçºµåæ ‡çš„æœ‰åºæ’åˆ—ï¼Œç„¶åæšä¸¾è¢«åˆ é™¤çš„æ•°ï¼Œä»é›†åˆä¸­å…ˆåˆ é™¤ä»–ä»¬çš„æ¨ªçºµåæ ‡åï¼Œè®¡ç®—æœ€å¤§çš„è·ç¦»ï¼Œç„¶åå†å¤åŸã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526class Solution &#123;public: int minimumDistance(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; multiset&lt;int&gt; xs, ys; for (auto&amp; p : points) &#123; xs.insert(p[0] + p[1]); ys.insert(p[1] - p[0]); &#125; int ans = INT_MAX; // æšä¸¾è¢«ç§»é™¤çš„ç‚¹ for (auto&amp; p : points) &#123; int x = p[0] + p[1], y = p[1] - p[0]; xs.erase(xs.find(x)); // ç§»é™¤ä¸€ä¸ª x ys.erase(ys.find(y)); // ç§»é™¤ä¸€ä¸ª y int dx = *xs.rbegin() - *xs.begin(); // æœ€å¤§x-æœ€å°x int dy = *ys.rbegin() - *ys.begin(); // æœ€å¤§y-æœ€å°y ans = min(ans, max(dx, dy)); xs.insert(x); ys.insert(y); &#125; return ans; &#125;&#125;; è¿™ç§æ–¹æ³•å†™æ³•ä¸Šæœ€ä¸ºç®€å•ï¼Œå½“ç„¶æˆ‘ä»¬ä¹Ÿå¯ä»¥ç»´æŠ¤æ¯ä¸ªåæ ‡çš„æœ€å¤§æ¬¡å¤§ä»¥åŠæœ€å°æ¬¡å°å€¼ï¼Œä¸€å…±8ä¸ªå€¼ã€‚ 2024-07-10 é¢˜ç›®ä¼ é€é—¨ï¼š2970. ç»Ÿè®¡ç§»é™¤é€’å¢å­æ•°ç»„çš„æ•°ç›® I - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å’‹ä¸€çœ‹ä»¥ä¸ºå¾ˆéš¾ï¼Œä½†æ˜¯çœ‹åˆ°æ•°æ®èŒƒå›´æ˜¯50ï¼Œæœæ–­è¿›è¡Œæšä¸¾å­æ•°ç»„çš„åˆå§‹å’Œç»“æŸç«¯ç‚¹å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122class Solution &#123;public: int incremovableSubarrayCount(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); function&lt;bool(int, int)&gt; judge = [&amp;](int x,int y)&#123; int prev = 0; for(int i=0;i&lt;n;++i)&#123; if (i&gt;=x&amp;&amp;i&lt;=y) continue; if (nums[i] &lt;= prev) return false; prev = nums[i]; &#125; return true; &#125;; int ans = 0; for(int i=0;i&lt;n;++i)&#123; for(int j=i;j&lt;n;++j)&#123; ans = judge(i,j)?ans+1:ans; &#125; &#125; return ans; &#125;&#125;; 2024-07-11 é¢˜ç›®ä¼ é€é—¨ï¼š2972. ç»Ÿè®¡ç§»é™¤é€’å¢å­æ•°ç»„çš„æ•°ç›® II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“éå¸¸æœ‰æ„æ€çš„åŒæŒ‡é’ˆé¢˜ç›®ï¼Œé¦–å…ˆæˆ‘ä»¬å…ˆæ‰¾åˆ°èƒ½è¢«åˆ æ‰çš„æœ€çŸ­åç¼€ï¼Œåˆ æ‰ä¸€ä¸ªå­æ•°ç»„ç›¸å½“äºï¼Œå°†åŸæ•°åˆ—åˆ†ä¸ºäº†ä¸€ä¸ªå‰ç¼€å’Œåç¼€ï¼Œå®šä¹‰lä¸ºå‰©ä½™å‰ç¼€çš„æœ€åä¸€ä¸ªæ•°,jä¸ºå‰©ä½™åç¼€å¼€å§‹çš„ç¬¬ä¸€ä¸ªæ•°ã€‚ ç”±äºæˆ‘ä»¬å·²ç»æ‰¾åˆ°äº†æœ€çŸ­åç¼€ï¼Œå› æ­¤lå‰é¢çš„æ•°æ˜¯å…·æœ‰ä¸€å®šå•è°ƒæ€§è´¨çš„ã€‚è€Œå¯¹äºjï¼ˆæœ€å¼€å§‹å°±æ˜¯æœ€åä¸€ä¸ªæ•°ï¼‰ä»–çš„åœæ­¢æ¡ä»¶æ˜¯å¦‚æœå½“å‰jå¤§äºj+1ï¼Œå› æ­¤jä¹Ÿæœ‰ä¸€å®šçš„å•è°ƒæ€§ï¼Œæˆ‘ä»¬éå†jçš„æ—¶å€™,åªéœ€æ¯”è¾ƒjä½ç½®çš„æ•°æ˜¯å¦å¤§äºlä½ç½®çš„æ•°ï¼Œå¦‚æœä¸æ˜¯åˆ™å°†l--ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªå°äºjä½ç½®çš„lï¼Œé‚£ä¹ˆlå‰é¢çš„æ‰€æœ‰å‰ç¼€è‚¯å®šéƒ½æ»¡è¶³æ¡ä»¶ï¼Œç­”æ¡ˆåŠ ä¸Šç°ç›®å‰å‰ç¼€æ•°æ€»å’Œ(l+2)å³å¯ã€‚å› ä¸ºjä¹Ÿæœ‰å•è°ƒæ€§çš„ç¼˜æ•…ï¼Œå€’ç€éå†jæ—¶ä¹‹å‰è¢«æ›´æ–°l--æ‰çš„åœ°æ–¹å°±ä¸ç”¨çœ‹äº†ã€‚è‚¯å®šä¸æ»¡è¶³å½“å‰jçš„æ¡ä»¶ã€‚ æœ¬äººè¯­æ–‡æ°´å¹³æœ‰é™ï¼Œæ›´ä¸ºæ¸…æ™°çš„é¢˜è§£è¯·çœ‹ï¼šçµèŒ¶å±±è‰¾åºœï¼šåŒæŒ‡é’ˆï¼ŒO(n) æ—¶é—´ O(1) ç©ºé—´ï¼ˆPython/Java/C++/C/Go/JS/Rustï¼‰ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920class Solution &#123;public: long long incremovableSubarrayCount(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int l=0; for(int i=1;i&lt;n;++i)&#123; if (nums[i] &gt; nums[i-1])&#123; l++; &#125; else break; &#125; if(l==n-1) return (long long) n*(n+1)/2; long long ans = l+2; for(int j=n-1;j &gt;= 0&amp;&amp;(j == n - 1|| nums[j] &lt; nums[j + 1]);--j)&#123; // æšä¸¾åç¼€å¼€å§‹çš„ç¬¬ä¸€ä¸ªæ•° while( l&gt;=0 &amp;&amp; nums[l]&gt;= nums[j]) l--; ans += l+2; &#125; return ans; &#125;&#125;; 2024-07-12 é¢˜ç›®ä¼ é€é—¨ï¼š2974. æœ€å°æ•°å­—æ¸¸æˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ï¼Œæ¨¡æ‹Ÿé¢˜ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213class Solution &#123;public: vector&lt;int&gt; numberGame(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); sort(nums.begin(), nums.end()); vector&lt;int&gt; arr; for(int i=0;i&lt;n/2;++i)&#123; arr.push_back(nums[i*2+1]); arr.push_back(nums[i*2]); &#125; return arr; &#125;&#125;; 2024-07-13 é¢˜ç›®ä¼ é€é—¨ï¼š3011. åˆ¤æ–­ä¸€ä¸ªæ•°ç»„æ˜¯å¦å¯ä»¥å˜ä¸ºæœ‰åº - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡æ‹Ÿé¢˜ï¼Œæ ¹æ®1çš„ä¸ªæ•°å°†æ•°ç»„åˆ’åˆ†ä¸ºå‡ æ®µåŒºé—´ï¼Œç„¶åç»´æŠ¤æ¯ä¸€ä¸ªåŒºé—´çš„æœ€å¤§æœ€å°å€¼ï¼Œå¦‚æœæ¯ä¸¤ä¸ªç›¸é‚»åŒºé—´éƒ½æ˜¯ä¸‹ä¸€ä¸ªåŒºé—´çš„æœ€å°å€¼å¤§äºä¸Šä¸€ä¸ªåŒºé—´çš„æœ€å¤§å€¼åˆ™æ»¡è¶³æ¡ä»¶è¿”å›trueï¼Œå¦åˆ™ä¸æ»¡è¶³æ¡ä»¶è¿”å›falseã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool canSortArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); function&lt;int(int)&gt; judge = [&amp;](int u)&#123; int cnt = 0; while(u)&#123; cnt += (u&amp;1); u = u&gt;&gt;1; &#125; return cnt; &#125;; vector&lt;int&gt; arr; for(int i=0;i&lt;n;++i) arr.push_back(judge(nums[i])); vector&lt;pair&lt;int,int&gt;&gt; pairs; int prev = -1,minn,maxx; for(int i=0;i&lt;n;++i) &#123; if(prev == arr[i])&#123; maxx = max(nums[i],maxx); minn = min(nums[i],minn); &#125; else &#123; if(i!=0) pairs.emplace_back(minn,maxx); prev = arr[i]; maxx = nums[i]; minn = nums[i]; &#125; &#125; pairs.emplace_back(minn,maxx); int m = pairs.size(); for(int i=1;i&lt;m;++i)&#123; if (pairs[i-1].second &gt; pairs[i].first) return false; &#125; return true; &#125;&#125;; 2024-07-14 é¢˜ç›®ä¼ é€é—¨ï¼š807. ä¿æŒåŸå¸‚å¤©é™…çº¿ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç»´æŠ¤æ¯è¡Œæ¯åˆ—çš„æœ€å¤§å€¼å°±å¯ä»¥äº†ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021class Solution &#123;public: int maxIncreaseKeepingSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n = grid.size(), m = grid[0].size(); vector&lt;int&gt; rows(n,0); vector&lt;int&gt; cols(m,0); for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;m;++j)&#123; rows[i] = max(rows[i],grid[i][j]); cols[j] = max(cols[j],grid[i][j]); &#125; &#125; int ans = 0; for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;m;++j)&#123; ans += min(rows[i],cols[j]) - grid[i][j]; &#125; &#125; return ans; &#125;&#125;; 2024-07-15 é¢˜ç›®ä¼ é€é—¨ï¼š721. è´¦æˆ·åˆå¹¶ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æœ¬è´¨è¿™é“é¢˜å¯ä»¥çœ‹æˆä¸€ä¸ªè¿é€šå—é—®é¢˜ï¼ˆæ±‚æœ‰å¤šå°‘è¿é€šæ°´æ´¼ï¼‰ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨dfsè§£å†³é—®é¢˜ã€‚è¿™é“é¢˜ä¸»è¦éš¾ç‚¹åœ¨äºä½¿ç”¨å“ˆå¸Œè¡¨å°†å­—ç¬¦ä¸²æ˜ å°„æˆintç±»å‹å¯¹é—®é¢˜è¿›è¡Œç®€åŒ–ï¼Œç»†èŠ‚æ“ä½œè§ä¸‹é¢çš„ä»£ç å®ç°ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; accountsMerge(vector&lt;vector&lt;string&gt;&gt;&amp; accounts) &#123; int n = accounts.size(); unordered_map&lt;string, vector&lt;int&gt;&gt; accounts_idx; for(int i=0;i&lt;n;++i)&#123; for(int j=1;j&lt;accounts[i].size();++j)&#123; accounts_idx[accounts[i][j]].push_back(i); &#125; &#125; vector&lt;bool&gt; vis(n,false); unordered_set&lt;string&gt; email_set; function&lt;void(int)&gt; dfs = [&amp;](int i)&#123; vis[i] = true; for(int k = 1;k &lt; accounts[i].size();++k)&#123; string email = accounts[i][k]; if (email_set.contains(email)) continue; email_set.insert(email); for (int j : accounts_idx[email]) &#123; // éå†æ‰€æœ‰åŒ…å«è¯¥é‚®ç®±åœ°å€çš„è´¦æˆ·ä¸‹æ ‡ j if (!vis[j]) &#123; // j æ²¡æœ‰è®¿é—®è¿‡ dfs(j); &#125; &#125; &#125; &#125;; vector&lt;vector&lt;string&gt;&gt; ans; for(int i=0; i&lt;vis.size(); ++i)&#123; if (vis[i]) continue; email_set.clear(); dfs(i); vector&lt;string&gt; res = &#123;accounts[i][0]&#125;; res.insert(res.end(), email_set.begin(), email_set.end()); sort(res.begin()+1, res.end()); ans.push_back(res); &#125; return ans; &#125;&#125;; 2024-07-16 é¢˜ç›®ä¼ é€é—¨ï¼š2956. æ‰¾åˆ°ä¸¤ä¸ªæ•°ç»„ä¸­çš„å…¬å…±å…ƒç´  - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç­¾åˆ°é¢˜ï¼Œä½†æ˜¯å¯ä»¥å­¦ä¹ ä¸€ä¸‹å¦‚ä½•ä½¿ç”¨vectoråˆå§‹åŒ–unordered_setç±»å‹çš„å˜é‡ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415class Solution &#123;public: vector&lt;int&gt; findIntersectionValues(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_set&lt;int&gt; nums1_set(nums1.begin(), nums1.end()); unordered_set&lt;int&gt; nums2_set(nums2.begin(), nums2.end()); int ans1 = 0,ans2 = 0; for(const int &amp;num : nums1)&#123; if (nums2_set.find(num)!=nums2_set.end())ans1++; &#125; for(const int &amp;num : nums2)&#123; if (nums1_set.find(num)!=nums1_set.end())ans2++; &#125; return vector&lt;int&gt;&#123;ans1,ans2&#125;; &#125;&#125;; 2024-07-17 é¢˜ç›®ä¼ é€é—¨ï¼š2959. å…³é—­åˆ†éƒ¨çš„å¯è¡Œé›†åˆæ•°ç›® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç”±äºæ•°æ®èŒƒå›´éå¸¸å°ï¼Œå¯ä»¥æšä¸¾æ‰€æœ‰å…³é—­åˆ†éƒ¨çš„æƒ…å†µï¼Œç„¶åå¯¹äºæ¯ç§å…³é—­æ–¹æ¡ˆï¼Œä½¿ç”¨Floydç®—æ³•æ¯æ¬¡è·å¾—å…¨å±€æœ€çŸ­è·¯ä¿¡æ¯ï¼Œåˆ¤æ–­æ˜¯å¦æ»¡è¶³æ¡ä»¶å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: int numberOfSets(int n, int maxDistance, vector&lt;vector&lt;int&gt;&gt;&amp; roads) &#123; int max_stats = 1&lt;&lt;n, ans = 0; vector&lt;vector&lt;int&gt;&gt; dis(n,vector&lt;int&gt;(n, 1e9)); for(int stat=0;stat&lt;max_stats;++stat)&#123; for(int i=0;i&lt;n;++i) dis[i][i] = 0; for(auto road : roads) &#123; if (((stat&gt;&gt;road[0])&amp;1)==0||((stat&gt;&gt;road[1])&amp;1)==0) continue; dis[road[0]][road[1]] = min(dis[road[0]][road[1]], road[2]); dis[road[1]][road[0]] = min(dis[road[1]][road[0]], road[2]); &#125; // Floyd for(int k=0;k&lt;n;++k)&#123; if ((stat&gt;&gt;k)&amp;1==0) continue; for(int i=0;i&lt;n;++i)&#123; if ((stat&gt;&gt;i)&amp;1==0) continue; for(int j=0;j&lt;n;++j)&#123; if ((stat&gt;&gt;j)&amp;1==0) continue; dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]); &#125; &#125; &#125; bool flag = true; for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;n;++j)&#123; if(dis[i][j] &gt; maxDistance &amp;&amp; (stat&gt;&gt;i)&amp;1 &amp;&amp; (stat&gt;&gt;j)&amp;1)&#123; flag = false; break; &#125; &#125; if (!flag) break; &#125; if (flag) ans++; &#125; return ans; &#125;&#125;; ä½†æ˜¯ç”±äºæ¯æ¬¡åœ¨æ¯ç§æƒ…å†µä¸­è¿›è¡Œæ•°ç»„çš„åˆå§‹åŒ–å®åœ¨æ˜¯å¤ªæµªè´¹æ—¶é—´äº†ï¼Œæ‰€ä»¥è¿›è¡Œå¦‚ä¸‹ä¼˜åŒ–ï¼Œåœ¨å¤–é¢å…ˆåˆ›å»ºå¥½ä¸€ä¸ªæ•°ç»„ï¼Œ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: int numberOfSets(int n, int maxDistance, vector&lt;vector&lt;int&gt;&gt;&amp; roads) &#123; vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, INT_MAX / 2)); // é˜²æ­¢åŠ æ³•æº¢å‡º for (int i = 0; i &lt; n; i++) &#123; g[i][i] = 0; // ä¹Ÿå¯ä»¥ä¸å†™ï¼Œä¸‹é¢åˆ¤æ–­ maxDistance æ—¶è¦ä¿è¯ j != i &#125; for (auto&amp; e: roads) &#123; int x = e[0], y = e[1], wt = e[2]; g[x][y] = min(g[x][y], wt); g[y][x] = min(g[y][x], wt); &#125; vector&lt;vector&lt;int&gt;&gt; f(n); auto check = [&amp;](int s) -&gt; bool &#123; for (int i = 0; i &lt; n; i++) &#123; if ((s &gt;&gt; i) &amp; 1) &#123; f[i] = g[i]; &#125; &#125; // Floyd ç®—æ³•ï¼ˆåªè€ƒè™‘åœ¨ s ä¸­çš„èŠ‚ç‚¹ï¼‰ for (int k = 0; k &lt; n; k++) &#123; if (((s &gt;&gt; k) &amp; 1) == 0) continue; for (int i = 0; i &lt; n; i++) &#123; if (((s &gt;&gt; i) &amp; 1) == 0) continue; for (int j = 0; j &lt; n; j++) &#123; f[i][j] = min(f[i][j], f[i][k] + f[k][j]); &#125; &#125; &#125; // åˆ¤æ–­ä¿ç•™çš„èŠ‚ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯æ˜¯å¦å‡ä¸è¶…è¿‡ maxDistance for (int i = 0; i &lt; n; i++) &#123; if (((s &gt;&gt; i) &amp; 1) == 0) continue; for (int j = 0; j &lt; n; j++) &#123; if ((s &gt;&gt; j) &amp; 1 &amp;&amp; f[i][j] &gt; maxDistance) &#123; return false; &#125; &#125; &#125; return true; &#125;; int ans = 0; for (int s = 0; s &lt; (1 &lt;&lt; n); s++) &#123; // æšä¸¾å­é›† ans += check(s); &#125; return ans; &#125;&#125;; 2024-07-18 é¢˜ç›®ä¼ é€é—¨ï¼š3112. è®¿é—®æ¶ˆå¤±èŠ‚ç‚¹çš„æœ€å°‘æ—¶é—´ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ Dijkstraæ¿å­é¢˜ï¼Œæ­£å¥½é‡æ–°è¿›è¡Œå¤ä¹ ä¸€ä¸‹ï¼Œåªéœ€è¦åœ¨æ›´æ–°çš„æ—¶å€™åˆ¤æ–­ä¸€ä¸‹å½“å‰æ›´æ–°æ–¹æ¡ˆæ˜¯å¦åˆæ³•ï¼ˆæœ‰å¯èƒ½éœ€è¦æ›´æ–°çš„ç‚¹å·²ç»æ¶ˆå¤±äº†ï¼Œæ­¤æ—¶å°±ä¸ç”¨æ›´æ–°ï¼‰ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;int&gt; minimumTime(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;int&gt;&amp; disappear) &#123; vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; g(n); for(auto edge: edges)&#123; g[edge[0]].emplace_back(edge[1],edge[2]); g[edge[1]].emplace_back(edge[0],edge[2]); &#125; vector&lt;int&gt; dis(n,INT_MAX/2); priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, greater&lt;&gt;&gt; pq; vector&lt;bool&gt; vis(n, false); dis[0] = 0; pq.push(make_pair(dis[0],0)); while (!pq.empty()) &#123; int u = pq.top().second; pq.pop(); if (vis[u]) continue; vis[u] = true; // if (dis[u] &gt; disappear[u]) continue; for(auto tmp : g[u])&#123; int val = tmp.second, v = tmp.first; if (dis[v] &gt; dis[u] + val &amp;&amp; disappear[v] &gt; dis[u]+val) &#123; dis[v] = dis[u]+val; pq.push(make_pair(dis[v],v)); &#125; &#125; &#125; for(int i=0;i&lt;n;++i)&#123; if (dis[i]==INT_MAX/2) dis[i] = -1; &#125; return dis; &#125;&#125;; 2024-07-19 é¢˜ç›®ä¼ é€é—¨ï¼š3096. å¾—åˆ°æ›´å¤šåˆ†æ•°çš„æœ€å°‘å…³å¡æ•°ç›® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡æ‹Ÿé¢˜å§ï¼Œå…ˆç®—å‡ºè·èƒœæ¡ä»¶çš„é˜ˆå€¼ï¼Œç„¶åä»ç¬¬ä¸€ä½å¼€å§‹å¾€åéå†ï¼Œè¿‡ç¨‹ä¸­ç»Ÿè®¡Aliceçš„å¾—åˆ†ï¼Œå¤§äºç­‰äºé˜ˆå€¼è¿”å›å½“å‰æ˜¯ç¬¬å‡ è½®æ¸¸æˆï¼Œå¦‚æœæ•°ç»„éå†å®Œäº†ä¾ç„¶ä¸æ»¡è¶³æ¡ä»¶è¿”å›-1è¡¨ç¤ºæ— æ³•è·èƒœã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021class Solution &#123;public: int minimumLevels(vector&lt;int&gt;&amp; possible) &#123; int n = possible.size(),sumpos=0; for(int i=0;i&lt;n;++i) &#123; if (possible[i]==0) sumpos -= 1; else sumpos += 1; &#125; int thre; if (sumpos &gt;= 0) thre = sumpos / 2 + 1; else thre = (sumpos-1) / 2 + 1; int tmp = possible[0]==1?1:-1, ans = 1; for(int i=1;i&lt;n;++i)&#123; if (tmp&gt;=thre) return ans; ans++; tmp += possible[i]==1?1:-1; &#125; return -1; &#125;&#125;; 2024-07-20 é¢˜ç›®ä¼ é€é—¨ï¼š2850. å°†çŸ³å¤´åˆ†æ•£åˆ°ç½‘æ ¼å›¾çš„æœ€å°‘ç§»åŠ¨æ¬¡æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç”±äºæ•°æ®èŒƒå›´å¾ˆå°ï¼Œå¯ä»¥ä½¿ç”¨æšä¸¾æ³•è§£å†³æ­¤é¢˜ï¼Œé¦–å…ˆå…ˆéå†æ‰€æœ‰æ ¼å­ï¼Œå¯¹äºä¸º0çš„åœ°æ–¹ï¼Œå°†æ ¼å­åæ ‡å­˜å…¥lessæ•°ç»„ï¼Œå¯¹äºå¤§äº1çš„åœ°æ–¹ï¼Œå°†æ ¼å­åæ ‡å­˜å…¥moreæ•°ç»„ï¼Œæ¯è¶…è¿‡1ä¸€æ¬¡å°±å­˜ä¸€æ¬¡åæ ‡è¿›å»ï¼ˆæ¯”å¦‚å½“å‰ä½ç½®æ˜¯3ï¼Œåˆ™å­˜ä¸¤æ¬¡è¯¥ä½ç½®çš„åæ ‡åˆ°moreæ•°ç»„ä¸­ï¼‰ã€‚æœ€ç»ˆæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªé•¿åº¦ç›¸åŒçš„moreå’Œlessæ•°ç»„ã€‚ ç„¶åæ­¤æ—¶æˆ‘ä»¬åªéœ€è¦æšä¸¾å…¶ä¸­ä¸€ä¸ªæ•°ç»„çš„å…¨æ’åˆ—ï¼Œè®¡ç®—ä¸åŒæ–¹æ¡ˆæ‰€ä½¿ç”¨çš„æ­¥æ•°ï¼Œè¿”å›æœ€å°æ­¥æ•°å³å¯ã€‚Cä¸­å¯¹vectoræ•°ç»„æšä¸¾å…¨æ’åˆ—çš„å‡½æ•°æ˜¯next_permutation,å…·ä½“å…³äºè¯¥å‡½æ•°çš„ä»‹ç»è§Cä¸“æ ä¸­çš„next_permutationéƒ¨åˆ†ã€‚ æœ¬é¢˜æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526class Solution &#123;public: int minimumMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;pair&lt;int,int&gt;&gt; less, more; for(int i=0;i&lt;3;++i)&#123; for(int j=0;j&lt;3;++j)&#123; if (grid[i][j]&gt;1) &#123; for(int k=2; k&lt;=grid[i][j]; ++k)&#123; more.emplace_back(i, j); &#125; &#125; else if (grid[i][j] == 0) &#123; less.emplace_back(i, j); &#125; &#125; &#125; int ans = INT_MAX; do &#123; int steps = 0; for(int i=0;i&lt;more.size();++i)&#123; steps += abs(more[i].first - less[i].first) + abs(more[i].second - less[i].second); &#125; ans = min(ans, steps); &#125; while (next_permutation(more.begin(), more.end())); return ans; &#125;&#125;; 2024-07-21 é¢˜ç›®ä¼ é€é—¨ï¼š1186. åˆ é™¤ä¸€æ¬¡å¾—åˆ°å­æ•°ç»„æœ€å¤§å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¯¥é¢˜ç›®ä¸ºç»å¸¸ç»ƒä¹ çš„åŠ¨æ€è§„åˆ’ä¸­çš„æœ€å¤§å­æ•°ç»„å’Œï¼ˆæœ€å¤§å­æ®µå’Œï¼‰ ç±»é¢˜ç›®ï¼Œç›¸æ¯”å°±æ˜¯è¯»äº†ä¸€ä¸ªé€‰æ‹©å‡ºæ¥å­æ•°ç»„åå¯ä»¥ä»ä¸­åˆ é™¤ä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥åœ¨æœ€å¤§å­æ•°ç»„å’Œï¼ˆæœ€å¤§å­æ®µå’Œï¼‰ çš„å¸¸è§„è§£æ”¾ä¸Šå¤šä¸€ä¸ªçŠ¶æ€ç»´åº¦ï¼Œè®¾è®¡DPæ•°ç»„dp[n][2]å«ä¹‰å¦‚ä¸‹ï¼Œdp[i][0]è¡¨ç¤ºä»¥å½“å‰ä½ç½®içš„æ•°ç»“å°¾ä¸”æœªåˆ é™¤ä»»ä½•æ•°å¯ä»¥è¾¾åˆ°çš„æœ€å¤§å­æ•°ç»„å’Œã€‚dp[i][1]è¡¨ç¤ºä»¥å½“å‰ä½ç½®içš„æ•°ç»“å°¾ä¸”åˆ é™¤1ä¸ªæ•°å¯ä»¥è¾¾åˆ°çš„æœ€å¤§å­æ•°ç»„å’Œã€‚è¿™æ ·å®šä¹‰åä¸éš¾å†™å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹å¦‚ä¸‹ï¼š 12dp[i][0] = max(0, dp[i-1][0]) + arr[i-1];dp[i][1] = max(0, max(dp[i-1][1], dp[i-2][0])) + arr[i-1]; ä»i=2å¼€å§‹å¾ªç¯ åˆå§‹æ¡ä»¶å°±æ˜¯dp[1][0] = arr[0]; dp[1][1] = arr[0]; æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415class Solution &#123;public: int maximumSum(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(2,0)); dp[1][0] = arr[0]; dp[1][1] = arr[0]; for(int i=2;i&lt;=n;++i)&#123; dp[i][0] = max(0, dp[i-1][0]) + arr[i-1]; dp[i][1] = max(0, max(dp[i-1][1], dp[i-2][0])) + arr[i-1]; &#125; int ans = dp[1][0]; for(int i=1;i&lt;=n;++i) ans = max(ans, max(dp[i][0], dp[i][1])); return ans; &#125;&#125;; 2024-07-22 é¢˜ç›®ä¼ é€é—¨ï¼š2101. å¼•çˆ†æœ€å¤šçš„ç‚¸å¼¹ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ é¦–å…ˆæ ¹æ®ç‚¸å¼¹çˆ†ç‚¸åŠå¾„å»ºç«‹ä¸€ä¸ªæœ‰å‘å›¾ï¼Œç„¶åå¯¹äºæ¯ä¸ªç‚¹éƒ½DFSä¸€éï¼Œæ‰¾åˆ°ä»¥å½“å‰ç‚¹èµ·çˆ†èƒ½å¼•çˆ†çš„æœ€å¤§ç‚¸å¼¹æ•°ï¼Œæœ€åè¿”å›æœ€å¤§å¼•çˆ†æ•°å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int maximumDetonation(vector&lt;vector&lt;int&gt;&gt;&amp; bombs) &#123; int n = bombs.size(); vector&lt;vector&lt;int&gt;&gt; edges(n); for(int i=0;i&lt;n;++i) &#123; int xi = bombs[i][0], yi = bombs[i][1], vali = bombs[i][2]; for(int j=0;j&lt;n;++j)&#123; if(i==j) continue; int xj = bombs[j][0], yj = bombs[j][1]; if (sqrt(double(xi-xj)*double(xi-xj)+double(yi-yj)*double(yi-yj)) &lt;= (double)vali) &#123; edges[i].push_back(j); &#125; &#125; &#125; int ans = 1; vector&lt;bool&gt; vis(n); function&lt;int(int)&gt; dfs = [&amp;](int u)&#123; int tmp=1; vis[u] = true; for(auto v : edges[u]) &#123; if(!vis[v]) tmp += dfs(v); &#125; return tmp; &#125;; for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;n;++j) vis[j]=false; ans = max(ans, dfs(i)); &#125; return ans; &#125;&#125;; 2024-07-23 é¢˜ç›®ä¼ é€é—¨ï¼š æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1 2024-07-24 é¢˜ç›®ä¼ é€é—¨ï¼š2766. é‡æ–°æ”¾ç½®çŸ³å— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä¸€é“éå¸¸æ ‡å‡†çš„C++ set é¢˜ï¼Œä¸»è¦è€ƒå¯Ÿï¼š setåˆå§‹åŒ– setä¸vectoräº’ç›¸è½¬åŒ– setåŸºç¡€æ“ä½œï¼ˆå¢åˆ æŸ¥ï¼‰ è¯¦ç»†çŸ¥è¯†ç‚¹è§C++ä¸“é¢˜ï¼Œè¿™é‡Œä¸å†èµ˜è¿° æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112class Solution &#123;public: vector&lt;int&gt; relocateMarbles(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; moveFrom, vector&lt;int&gt;&amp; moveTo) &#123; set&lt;int&gt; se(nums.begin(), nums.end()); int n = moveFrom.size(); for(int i=0;i&lt;n;++i)&#123; if (se.find(moveFrom[i])==se.end()) continue; se.erase(moveFrom[i]); se.insert(moveTo[i]); &#125; return vector&lt;int&gt;(se.begin(),se.end()); &#125;&#125;; 2024-07-25 é¢˜ç›®ä¼ é€é—¨ï¼š2844. ç”Ÿæˆç‰¹æ®Šæ•°å­—çš„æœ€å°‘æ“ä½œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è§‚å¯Ÿæ•°æ®èŒƒå›´å¯ä»¥çœ‹åˆ°æ•°å­—æœ€é•¿ä¸º100ä½ï¼Œæ‰€ä»¥æ­¤é¢˜ç®€å•è´ªå¿ƒå³å¯ã€‚ä»æœ€åä¸€ä½å€’ç€éå†ï¼Œç¢°åˆ°5å°±æ‰¾æœ€è¿‘çš„2ï¼Œ7ï¼›ç¢°åˆ°0å°±æ‰¾æœ€è¿‘çš„0ï¼Œ5ã€‚åœ¨éå†çš„è¿‡ç¨‹ä¸­ç»´æŠ¤æ“ä½œæœ€å°å€¼å³å¯ã€‚ æ³¨æ„ï¼šä¸€ä¸ª0ä¹Ÿæ˜¯èƒ½å¤Ÿè¢«25æ•´é™¤çš„ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425class Solution &#123;public: int minimumOperations(string num) &#123; int n = num.size(); int ans = n; bool flag0 = false; for(int i=n-1;i&gt;=0;--i)&#123; if (num[i]==&#x27;0&#x27;) &#123; flag0 = true; int tmp = n-1-i; int j=i-1; while (j&gt;=0 &amp;&amp; num[j]!=&#x27;0&#x27; &amp;&amp; num[j]!=&#x27;5&#x27;)j--; if (j!=-1) &#123;tmp += (i-1-j); ans = min(ans, tmp);&#125; &#125; if (num[i]==&#x27;5&#x27;) &#123; int tmp = n-1-i; int j=i-1; while (j&gt;=0 &amp;&amp; num[j]!=&#x27;2&#x27; &amp;&amp; num[j]!=&#x27;7&#x27;)j--; if (j!=-1) &#123;tmp += (i-1-j); ans = min(ans, tmp);&#125; &#125; &#125; if (ans == n &amp;&amp; flag0) ans--; return ans; &#125;&#125;; 2024-07-26 é¢˜ç›®ä¼ é€é—¨ï¼š2740. æ‰¾å‡ºåˆ†åŒºå€¼ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¯»å®Œé¢˜åï¼Œä»”ç»†ç†è§£ä¸€ä¸‹ä¸éš¾å‘ç°å°±æ˜¯æ‰¾æ’åºåç›¸é‚»å…ƒç´ ä¹‹é—´å·®å€¼çš„æœ€å°ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789class Solution &#123;public: int findValueOfPartition(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int ans = nums[1] - nums[0], n = nums.size(); for(int i=1;i&lt;n;++i) ans = min(ans, nums[i]-nums[i-1]); return ans; &#125;&#125;; 2024-07-27 é¢˜ç›®ä¼ é€é—¨ï¼š3106. æ»¡è¶³è·ç¦»çº¦æŸä¸”å­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸² - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è´ªå¿ƒï¼Œä»æœ€å‰é¢å¼€å§‹å˜ï¼Œå°½é‡è®©å‰é¢çš„å­—ç¬¦æ¥è¿‘aã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122class Solution &#123;public: string getSmallestString(string s, int k) &#123; function&lt;int(char, char)&gt; dist = [&amp;](char a, char b)&#123; int dis = abs(a-b); return min(dis,26-dis); &#125;; for(char&amp; c : s)&#123; if (dist(c,&#x27;a&#x27;) &lt;=k ) &#123; k -= dist(c,&#x27;a&#x27;); c = &#x27;a&#x27;; &#125; else &#123; char b = &#x27;a&#x27;; while(dist(c,b) &gt; k) b++; c = char(b); break; &#125; &#125; return s; &#125;&#125;; 2024-07-28 é¢˜ç›®ä¼ é€é—¨ï¼š699. æ‰è½çš„æ–¹å— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç”±äºæ–¹å—æ•°é‡æœ¬èº«å¾ˆå°‘ï¼Œæ‰€ä»¥å¯ä»¥é‡‡ç”¨æšä¸¾çš„æ–¹å¼è¿›è¡Œæœ€å¤§é«˜åº¦æ›´æ–°ï¼Œæ¯æ¬¡æšä¸¾åˆ°ç¬¬iä¸ªæ–¹å—ï¼Œå°±éå†ä»–å‰é¢i-1ä¸ªæ–¹å—ï¼Œçœ‹å½“å‰æ–¹å—æ˜¯å¦è½åœ¨å‰é¢æ–¹å—ä¸Šé¢ï¼Œå¦‚æœæ˜¯åˆ™æ›´æ–°æœ€å¤§é«˜åº¦ã€‚ä¾æ¬¡éå†å®Œæ‰€æœ‰çš„æ–¹å—å¯å¾—æœ€ç»ˆç­”æ¡ˆï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(n2)O(n^2)O(n2)ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; fallingSquares(vector&lt;vector&lt;int&gt;&gt;&amp; positions) &#123; int n = positions.size(); vector&lt;int&gt; heights(n); for(int i=0;i&lt;n;++i)&#123; int left1 = positions[i][0], right1 = positions[i][0] + positions[i][1] - 1; heights[i] = positions[i][1]; for(int j=0;j&lt;i;++j)&#123; int left2 = positions[j][0], right2 = positions[j][0] + positions[j][1] - 1; if (right1 &gt;= left2 &amp;&amp; right2 &gt;= left1) heights[i] = max(heights[i], heights[j] + positions[i][1]); &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; heights[i] = max(heights[i], heights[i - 1]); &#125; return heights; &#125;&#125;; 2024-07-29 é¢˜ç›®ä¼ é€é—¨ï¼š682. æ£’çƒæ¯”èµ› - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡æ‹Ÿé¢˜ï¼ŒCéœ€è¦ä½¿ç”¨stoiç”¨äºå­—ç¬¦ä¸²è½¬æ•´å‹ï¼Œå…·ä½“ç”¨æ³•è¯¦è§Cä¸“é¢˜ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516class Solution &#123;public: int calPoints(vector&lt;string&gt;&amp; operations) &#123; vector&lt;int&gt; que; int n = 0; for(string operation : operations)&#123; if (operation == &quot;C&quot;) que.pop_back(),n--; else if (operation == &quot;D&quot;) que.push_back(que[n-1]*2),n++; else if (operation == &quot;+&quot;) que.push_back(que[n-1]+que[n-2]),n++; else que.push_back(stoi(operation)),n++; &#125; int ans = 0; for(int i=0;i&lt;n;++i) ans += que[i]; return ans; &#125;&#125;; 2024-07-30 é¢˜ç›®ä¼ é€é—¨ï¼š2961. åŒæ¨¡å¹‚è¿ç®— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å¿«é€Ÿå¹‚æ¿å­é¢˜ï¼Œå¿«é€Ÿå¹‚ç®—æ³•è¯¦è§£è§OI-Knowledgeä¸“é¢˜æ•°å­¦ç« èŠ‚ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; getGoodIndices(vector&lt;vector&lt;int&gt;&gt;&amp; variables, int target) &#123; function&lt;int(int,int,int)&gt; ksm = [&amp;](int a,int b,int m)&#123; if (b == 0) return 1; int nw = ksm(a,b/2,m)%m; if (b%2) return nw*nw%m*a%m; return nw*nw%m; &#125;; int n = variables.size(); vector&lt;int&gt; ans; for(int i=0;i&lt;n;++i)&#123; if (ksm(ksm(variables[i][0],variables[i][1],10),variables[i][2],variables[i][3])==target) ans.push_back(i); &#125; return ans; &#125;&#125;; 2024-07-31 é¢˜ç›®ä¼ é€é—¨ï¼š3111. è¦†ç›–æ‰€æœ‰ç‚¹çš„æœ€å°‘çŸ©å½¢æ•°ç›® - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è´ªå¿ƒï¼Œæ’åºåä»å°åˆ°å¤§è¿›è¡Œè¦†ç›–å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213class Solution &#123;public: int minRectanglesToCoverPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, int w) &#123; sort(points.begin(), points.end()); int ans = 0, n = points.size(); int prev = points[0][0]-1; for(int i=0;i&lt;n;++i)&#123; if (points[i][0]&lt;=prev) continue; ans+=1; prev = points[i][0]+w; &#125; return ans; &#125;&#125;;"},{"title":"2024å¹´10æœˆæ¯æ—¥ä¸€é¢˜","path":"/wiki/LeetCode/æ¯æ—¥ä¸€é¢˜/2024å¹´10æœˆæ¯æ—¥ä¸€é¢˜.html","content":"2024-10-01 é¢˜ç›®ä¼ é€é—¨ï¼š æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1 2024-10-02 é¢˜ç›®ä¼ é€é—¨ï¼š1928. è§„å®šæ—¶é—´å†…åˆ°è¾¾ç»ˆç‚¹çš„æœ€å°èŠ±è´¹ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1"},{"title":"2024å¹´11æœˆæ¯æ—¥ä¸€é¢˜","path":"/wiki/LeetCode/æ¯æ—¥ä¸€é¢˜/2024å¹´11æœˆæ¯æ—¥ä¸€é¢˜.html","content":"2024-11-06 é¢˜ç›®ä¼ é€é—¨ï¼š3254. é•¿åº¦ä¸º K çš„å­æ•°ç»„çš„èƒ½é‡å€¼ I - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1"},{"title":"2025å¹´01æœˆæ¯æ—¥ä¸€é¢˜","path":"/wiki/LeetCode/æ¯æ—¥ä¸€é¢˜/2025å¹´01æœˆæ¯æ—¥ä¸€é¢˜.html","content":"2025-01-01 é¢˜ç›®ä¼ é€é—¨ï¼š3280. å°†æ—¥æœŸè½¬æ¢ä¸ºäºŒè¿›åˆ¶è¡¨ç¤º - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡æ‹Ÿé¢˜ï¼Œä½¿ç”¨Pythonè§£å†³ä¼šæ›´åŠ æ–¹ä¾¿ä¸€äº›ï¼Œå…ˆå°†å¯¹åº”ä½ç½®çš„å­—ç¬¦ä¸²è½¬æˆintï¼Œç„¶åå†åšè½¬äºŒè¿›åˆ¶çš„æ“ä½œï¼Œæœ€ååœ¨å°†å…¶è½¬æˆstringç±»å‹ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819class Solution &#123;public: string binary(int x) &#123; string s; while (x) &#123; s.push_back(&#x27;0&#x27; + (x &amp; 1)); x &gt;&gt;= 1; &#125; reverse(s.begin(), s.end()); return s; &#125; string convertDateToBinary(string date) &#123; int year = stoi(date.substr(0, 4)); int month = stoi(date.substr(5, 2)); int day = stoi(date.substr(8, 2)); return binary(year) + &quot;-&quot; + binary(month) + &quot;-&quot; + binary(day); &#125;&#125;; 2025-01-02 é¢˜ç›®ä¼ é€é—¨ï¼š æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1"},{"title":"2025å¹´02æœˆæ¯æ—¥ä¸€é¢˜","path":"/wiki/LeetCode/æ¯æ—¥ä¸€é¢˜/2025å¹´02æœˆæ¯æ—¥ä¸€é¢˜.html","content":"2025-02-01 é¢˜ç›®ä¼ é€é—¨ï¼š81. æœç´¢æ—‹è½¬æ’åºæ•°ç»„ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ è¿™é“é¢˜ä¸­ï¼Œæ•°ç»„æœ¬èº«ä¸æ˜¯æœ‰åºçš„ï¼Œè¿›è¡Œæ—‹è½¬ååªä¿è¯äº†æ•°ç»„çš„å±€éƒ¨æ˜¯æœ‰åºçš„ï¼Œè¿™è¿˜èƒ½è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾å—ï¼Ÿç­”æ¡ˆæ˜¯å¯ä»¥çš„ã€‚ å¯ä»¥å‘ç°çš„æ˜¯ï¼Œæˆ‘ä»¬å°†æ•°ç»„ä»ä¸­é—´åˆ†å¼€æˆå·¦å³ä¸¤éƒ¨åˆ†çš„æ—¶å€™ï¼Œä¸€å®šæœ‰ä¸€éƒ¨åˆ†çš„æ•°ç»„æ˜¯æœ‰åºçš„ã€‚æ‹¿ç¤ºä¾‹æ¥çœ‹ï¼Œæˆ‘ä»¬ä» 6 è¿™ä¸ªä½ç½®åˆ†å¼€ä»¥åæ•°ç»„å˜æˆäº† [4,5,6][4, 5, 6][4,5,6] å’Œ [7,0,1,2][7, 0, 1, 2][7,0,1,2] ä¸¤ä¸ªéƒ¨åˆ†ï¼Œå…¶ä¸­å·¦è¾¹ [4,5,6][4, 5, 6][4,5,6] è¿™ä¸ªéƒ¨åˆ†çš„æ•°ç»„æ˜¯æœ‰åºçš„ï¼Œå…¶ä»–ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ è¿™å¯ç¤ºæˆ‘ä»¬å¯ä»¥åœ¨å¸¸è§„äºŒåˆ†æŸ¥æ‰¾çš„æ—¶å€™æŸ¥çœ‹å½“å‰ mid ä¸ºåˆ†å‰²ä½ç½®åˆ†å‰²å‡ºæ¥çš„ä¸¤ä¸ªéƒ¨åˆ† [l,mid][l, mid][l,mid] å’Œ [mid+1,r][mid + 1, r][mid+1,r] å“ªä¸ªéƒ¨åˆ†æ˜¯æœ‰åºçš„ï¼Œå¹¶æ ¹æ®æœ‰åºçš„é‚£ä¸ªéƒ¨åˆ†ç¡®å®šæˆ‘ä»¬è¯¥å¦‚ä½•æ”¹å˜äºŒåˆ†æŸ¥æ‰¾çš„ä¸Šä¸‹ç•Œï¼Œå› ä¸ºæˆ‘ä»¬èƒ½å¤Ÿæ ¹æ®æœ‰åºçš„é‚£éƒ¨åˆ†åˆ¤æ–­å‡º target åœ¨ä¸åœ¨è¿™ä¸ªéƒ¨åˆ†ï¼š å¯¹äºæ•°ç»„ä¸­æœ‰é‡å¤å…ƒç´ çš„æƒ…å†µï¼ŒäºŒåˆ†æŸ¥æ‰¾æ—¶å¯èƒ½ä¼šæœ‰Â a[l]=a[mid]=a[r]a[l]=a[mid]=a[r]a[l]=a[mid]=a[r]ï¼Œæ­¤æ—¶æ— æ³•åˆ¤æ–­åŒºé—´Â [l,mid][l,mid][l,mid]Â å’ŒåŒºé—´Â [mid+1,r][mid+1,r][mid+1,r]Â å“ªä¸ªæ˜¯æœ‰åºçš„ã€‚ ä¾‹å¦‚ nums=[3,1,2,3,3,3,3]nums=[3,1,2,3,3,3,3]nums=[3,1,2,3,3,3,3]ï¼Œtarget=2target=2target=2ï¼Œé¦–æ¬¡äºŒåˆ†æ—¶æ— æ³•åˆ¤æ–­åŒºé—´ [0,3][0,3][0,3] å’ŒåŒºé—´ [4,6][4,6][4,6] å“ªä¸ªæ˜¯æœ‰åºçš„ã€‚ å¯¹äºè¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬åªèƒ½å°†å½“å‰äºŒåˆ†åŒºé—´çš„å·¦è¾¹ç•ŒåŠ ä¸€ï¼Œå³è¾¹ç•Œå‡ä¸€ï¼Œç„¶ååœ¨æ–°åŒºé—´ä¸Šç»§ç»­äºŒåˆ†æŸ¥æ‰¾ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool search(vector&lt;int&gt; &amp;nums, int target) &#123; int n = nums.size(); if (n == 0) &#123; return false; &#125; if (n == 1) &#123; return nums[0] == target; &#125; int l = 0, r = n - 1; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (nums[mid] == target) &#123; return true; &#125; if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) &#123; ++l; --r; &#125; else if (nums[l] &lt;= nums[mid]) &#123; if (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; else &#123; if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - 1]) &#123; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; &#125; return false; &#125;&#125;; 2025-02-02 é¢˜ç›®ä¼ é€é—¨ï¼š598. åŒºé—´åŠ æ³• II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å°±æ˜¯æ‰¾æ‰€æœ‰æ“ä½œä¸­çš„æœ€å°è¡Œå·å’Œæœ€å°åˆ—å·ç›¸ä¹˜å°±å¯ä»¥äº†ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112class Solution &#123;public: int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) &#123; if (ops.size()==0) return m*n; int minR = ops[0][0], minC = ops[0][1]; for (auto &amp; op : ops) &#123; minR = min(minR, op[0]); minC = min(minC, op[1]); &#125; return minR * minC; &#125;&#125;; 2025-02-03 é¢˜ç›®ä¼ é€é—¨ï¼š680. éªŒè¯å›æ–‡ä¸² II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åŒæŒ‡é’ˆå³å¯ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425class Solution &#123;public: bool checkPalindrome(const string&amp; s, int low, int high) &#123; for (int i = low, j = high; i &lt; j; ++i, --j) &#123; if (s[i] != s[j]) &#123; return false; &#125; &#125; return true; &#125; bool validPalindrome(string s) &#123; int low = 0, high = s.size() - 1; while (low &lt; high) &#123; char c1 = s[low], c2 = s[high]; if (c1 == c2) &#123; ++low; --high; &#125; else &#123; return checkPalindrome(s, low, high - 1) || checkPalindrome(s, low + 1, high); &#125; &#125; return true; &#125;&#125;; 2025-02-04 é¢˜ç›®ä¼ é€é—¨ï¼š922. æŒ‰å¥‡å¶æ’åºæ•°ç»„ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åˆ†ç±»æ’åºå®Œæˆåï¼Œå†åˆå¹¶å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; odd, even; for (auto &amp;num : nums) &#123; if (num % 2) odd.emplace_back(num); else even.emplace_back(num); &#125; vector&lt;int&gt; ans; for(int i=0;i&lt;odd.size();++i)&#123; ans.emplace_back(even[i]); ans.emplace_back(odd[i]); &#125; return ans; &#125;&#125;; 2025-02-05 é¢˜ç›®ä¼ é€é—¨ï¼š90. å­é›† II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æš´æœ+é›†åˆsetç†Ÿç»ƒè¿ç”¨ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); set&lt;vector&lt;int&gt;&gt; se; for(int i=0;i&lt;(1&lt;&lt;n);++i)&#123; vector&lt;int&gt; tmp; int nw = i; for(int j=0;j&lt;n;++j)&#123; if ((nw&gt;&gt;j)&amp;1) tmp.push_back(nums[j]); &#125; sort(tmp.begin(), tmp.end()); se.insert(tmp); &#125; vector&lt;vector&lt;int&gt;&gt; ans; for(auto &amp; itm : se)&#123; ans.push_back(itm); &#125; return ans; &#125;&#125;; 2025-02-06 é¢˜ç›®ä¼ é€é—¨ï¼š47. å…¨æ’åˆ— II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åŒä¸Šï¼Œæš´æœ+é›†åˆsetç†Ÿç»ƒè¿ç”¨ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; set&lt;vector&lt;int&gt;&gt; se; int n = nums.size(); vector&lt;bool&gt; flag(n,false); vector&lt;int&gt; tmp; function&lt;void(int)&gt; func = [&amp;](int cnt)&#123; if (cnt == n) &#123; se.insert(tmp); return; &#125; for(int i=0;i&lt;n;++i)&#123; if (!flag[i]) &#123; tmp.push_back(nums[i]); flag[i] = true; func(cnt+1); tmp.pop_back(); flag[i] = false; &#125; &#125; &#125;; func(0); vector&lt;vector&lt;int&gt;&gt; ans; for (auto &amp; itm : se) &#123; ans.push_back(itm); &#125; return ans; &#125;&#125;; ä½†æ˜¯ä¸Šé¢è¿™ç§åšæ³•æ•ˆç‡ä¼šéå¸¸ä½ã€‚ 2025-02-07 é¢˜ç›®ä¼ é€é—¨ï¼š59. èºæ—‹çŸ©é˜µ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å¤§æ¨¡æ‹Ÿ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; int maxNum = n * n; int curNum = 1; vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n)); int row = 0, column = 0; vector&lt;vector&lt;int&gt;&gt; directions = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; // å³ä¸‹å·¦ä¸Š int directionIndex = 0; while (curNum &lt;= maxNum) &#123; matrix[row][column] = curNum; curNum++; int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1]; if (nextRow &lt; 0 || nextRow &gt;= n || nextColumn &lt; 0 || nextColumn &gt;= n || matrix[nextRow][nextColumn] != 0) &#123; directionIndex = (directionIndex + 1) % 4; // é¡ºæ—¶é’ˆæ—‹è½¬è‡³ä¸‹ä¸€ä¸ªæ–¹å‘ &#125; row = row + directions[directionIndex][0]; column = column + directions[directionIndex][1]; &#125; return matrix; &#125;&#125;; 2025-02-08 é¢˜ç›®ä¼ é€é—¨ï¼š63. ä¸åŒè·¯å¾„ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ ç®€å•çš„åŠ¨æ€è§„åˆ’é—®é¢˜ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int n = obstacleGrid.size(), m = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1,0)); // if (obstacleGrid[0][0]) return 0; dp[1][1] = obstacleGrid[0][0]==0?1:0; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; if (obstacleGrid[i-1][j-1]) continue; dp[i][j] += dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[n][m]; &#125;&#125;; 2025-02-09 é¢˜ç›®ä¼ é€é—¨ï¼š80. åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹ II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ åŒæŒ‡é’ˆå³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt;= 2) &#123; return n; &#125; int slow = 2, fast = 2; while (fast &lt; n) &#123; if (nums[slow - 2] != nums[fast]) &#123; nums[slow] = nums[fast]; ++slow; &#125; ++fast; &#125; return slow; &#125;&#125;; 2025-02-10 é¢˜ç›®ä¼ é€é—¨ï¼š æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1 2025-02-11 é¢˜ç›®ä¼ é€é—¨ï¼š æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1 2025-02-12 é¢˜ç›®ä¼ é€é—¨ï¼š1760. è¢‹å­é‡Œæœ€å°‘æ•°ç›®çš„çƒ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ äºŒåˆ†ä¸€ä¸‹å°±å¯ä»¥å•¦ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819class Solution &#123;public: int minimumSize(vector&lt;int&gt;&amp; nums, int maxOperations) &#123; function&lt;bool(int)&gt; judge = [&amp;](int ball)&#123; int nw = 0; for(auto num : nums)&#123; nw += (num-1) / ball; &#125; return nw &lt;= maxOperations ? true : false; &#125;; int l = 1, r=1e9+1; while(l&lt;r)&#123; int mid = (r-l)/2 + l; if (judge(mid)) r = mid; else l = mid+1; &#125; return l; &#125;&#125;; 2025-02-13 é¢˜ç›®ä¼ é€é—¨ï¼š1742. ç›’å­ä¸­å°çƒçš„æœ€å¤§æ•°é‡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡æ‹Ÿé¢˜ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920class Solution &#123;public: int countBalls(int lowLimit, int highLimit) &#123; function&lt;int(int)&gt; func = [&amp;](int cnt)&#123; int ans = 0; while(cnt)&#123; ans += (cnt%10); cnt /= 10; &#125; return ans; &#125;; vector&lt;int&gt; buk(100,0); for(int i=lowLimit;i&lt;=highLimit;++i)&#123; buk[func(i)]++; &#125; int ans = buk[func(lowLimit)]; for(int i=0;i&lt;99;++i) ans = max(ans,buk[i]); return ans; &#125;&#125;; 2025-02-14 é¢˜ç›®ä¼ é€é—¨ï¼š1552. ä¸¤çƒä¹‹é—´çš„ç£åŠ› - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ äºŒåˆ†ä¸€ä¸‹å•¦ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223class Solution &#123;public: int maxDistance(vector&lt;int&gt;&amp; position, int m) &#123; sort(position.begin(), position.end()); function&lt;bool(int)&gt; judge = [&amp;](int interval)&#123; int pre = position[0], cnt = 1; for(int i = 1; i &lt; position.size(); ++i) &#123; if (position[i] - pre &gt;= interval) &#123; pre = position[i]; cnt += 1; &#125; &#125; return cnt &gt;= m; &#125;; int l = 1, r = 1e9+1; while (l &lt; r) &#123; int mid = l + (r - l) / 2; if (judge(mid)) l =mid+1; else r = mid; &#125; return l-1; &#125;&#125;; 2025-02-15 é¢˜ç›®ä¼ é€é—¨ï¼š1706. çƒä¼šè½ä½•å¤„ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡æ‹Ÿé¢˜ï¼Œç®€å•æ¨¡æ‹Ÿä¸‹å°±å¥½ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: vector&lt;int&gt; findBall(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n = grid.size(), m = grid[0].size(); vector&lt;int&gt; ans; for(int i=0; i&lt;m; ++i)&#123; int nw = i; bool flag = false; for(int j=0;j&lt;n;++j)&#123; if(grid[j][nw]==1)&#123; // å¦‚æœå½“å‰å—æ˜¯æœå³ if (nw!=m-1) &#123; if (grid[j][nw+1]==1)&#123; nw++; &#125; else &#123; flag = true;break; // if(j!=n-1) &#123;flag = true;break;&#125; // nw++; &#125; &#125; else &#123; // å¦‚æœæ˜¯æœ€åä¸€åˆ— flag = true;break; // if(j!=n-1) &#123;flag = true;break;&#125; // nw++; &#125; &#125; else &#123; if (nw!=0) &#123; if (grid[j][nw-1]==-1)&#123; nw--; &#125; else &#123; flag = true;break; // if(j!=n-1) &#123;flag=true; break;&#125; // nw--; &#125; &#125; else &#123; flag = true;break; // if(j!=n-1) &#123;flag=true; break;&#125; // nw--; &#125; &#125; &#125; if (!flag) ans.push_back(nw); else ans.push_back(-1); &#125; return ans; &#125;&#125;; 2025-02-16 é¢˜ç›®ä¼ é€é—¨ï¼š1299. å°†æ¯ä¸ªå…ƒç´ æ›¿æ¢ä¸ºå³ä¾§æœ€å¤§å…ƒç´  - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡æ‹Ÿç®€å•é¢˜å•¦ï¼Œéå†ä¸€éå³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011class Solution &#123;public: vector&lt;int&gt; replaceElements(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); vector&lt;int&gt; ans(n,-1); for(int i=n-2;i&gt;=0;--i)&#123; ans[i] = max(arr[i+1],ans[i+1]); &#125; return ans; &#125;&#125;; 2025-02-17 é¢˜ç›®ä¼ é€é—¨ï¼š1287. æœ‰åºæ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡25%çš„å…ƒç´  - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ’åºåï¼Œè®¡æ•°åˆ¤æ–­å³å¯ï½ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920class Solution &#123;public: int findSpecialInteger(vector&lt;int&gt;&amp; arr) &#123; sort(arr.begin(), arr.end()); int n = arr.size(); int prev = -1; int cnt = 1; for(int i=0; i&lt;n; ++i)&#123; if (arr[i]!=prev) &#123; cnt = 1; prev = arr[i]; &#125; else &#123; cnt++; &#125; if (cnt*4 &gt; n) return prev; &#125; return -1; &#125;&#125;; 2025-02-18 é¢˜ç›®ä¼ é€é—¨ï¼š2080. åŒºé—´å†…æŸ¥è¯¢æ•°å­—çš„é¢‘ç‡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å“ˆå¸Œè¡¨+äºŒåˆ†æŸ¥æ‰¾ï¼Œå¯¹äºæ¯ä¸ªå€¼éƒ½å»ºç«‹ä¸€ä¸ªåˆ—è¡¨ï¼ŒæŒ‰ç…§é¡ºåºç»´æŠ¤ä»–å‡ºç°çš„ä½ç½®ï¼Œç„¶åå¯¹è¿™ä¸ªåˆ—è¡¨è¿›è¡Œupper_bound-lower_boundå³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021class RangeFreqQuery &#123;public: unordered_map&lt;int,vector&lt;int&gt;&gt; mp; RangeFreqQuery(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); for (int i=0;i&lt;n;++i)&#123; mp[arr[i]].push_back(i); &#125; &#125; int query(int left, int right, int value) &#123; vector&lt;int&gt;&amp; tmp = mp[value]; return upper_bound(tmp.begin(),tmp.end(),right) - lower_bound(tmp.begin(),tmp.end(),left); &#125;&#125;;/** * Your RangeFreqQuery object will be instantiated and called as such: * RangeFreqQuery* obj = new RangeFreqQuery(arr); * int param_1 = obj-&gt;query(left,right,value); */ 2025-02-19 é¢˜ç›®ä¼ é€é—¨ï¼š624. æ•°ç»„åˆ—è¡¨ä¸­çš„æœ€å¤§è·ç¦» - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ å¯¹äºæ¯ä¸ªæ•°ç»„ï¼Œç»´æŠ¤ä¸€ä¸ªæœ€å¤§å€¼åˆ—è¡¨å’Œæœ€å°å€¼åˆ—è¡¨ï¼ˆç”¨åˆ—è¡¨å½¢å¼å­˜å‚¨æ¯ä¸ªæ•°ç»„ä¸­çš„æœ€å¤§å€¼å’Œæœ€å°å€¼ï¼‰ã€‚ ç„¶åæ‰¾å‡ºè¿™ä¸ªåˆ—è¡¨ä¸­çš„æœ€å¤§å€¼ã€æ¬¡å¤§å€¼ä»¥åŠæœ€å°å€¼ã€æ¬¡å°å€¼ã€‚ å¦‚æœæœ€å¤§å€¼å’Œæœ€å°å€¼ä¸åœ¨ä¸€ä¸ªæ•°ç»„ä¸­çš„è¯ï¼Œè¿”å›ä»–ä»¬ä¸¤ä¸ªçš„å·®ã€‚ å¦‚æœåœ¨çš„è¯ï¼Œå°±è¿”å›max(æœ€å¤§å€¼-æ¬¡å°å€¼ï¼Œæ¬¡å¤§å€¼-æœ€å°å€¼) æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425class Solution &#123;public: int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; arrays) &#123; int n = arrays.size(); vector&lt;int&gt; maxx, minn; for (auto arr : arrays) &#123; int nn = arr.size(); minn.push_back(arr[ 0 ]); maxx.push_back(arr[nn-1]); &#125; int max_num1=maxx[0],max_loc1=0,max_num2=maxx[0],max_loc2=0; int min_num1=minn[0],min_loc1=0,min_num2=minn[0],min_loc2=0; for( int i = 0; i &lt; n ; ++ i ) &#123; if (maxx[i] &gt; max_num1) max_num1 = maxx[i], max_loc1 = i; if (minn[i] &lt; min_num1) min_num1 = minn[i], min_loc1 = i; &#125; if (max_loc1 == 0 &amp;&amp; n &gt; 1) max_loc2 = 1, max_num2 = maxx[1]; if (min_loc1 == 0 &amp;&amp; n &gt; 1) min_loc2 = 1, min_num2 = minn[1]; for( int i = 0; i &lt; n ; ++ i ) &#123; if (maxx[i] &gt; max_num2 &amp;&amp; i != max_loc1) max_num2 = maxx[i], max_loc2 = i; if (minn[i] &lt; min_num2 &amp;&amp; i != min_loc1) min_num2 = minn[i], min_loc2 = i; &#125; return max_loc1 != min_loc1 ? max_num1-min_num1 : max(max_num1-min_num2, max_num2-min_num1); &#125;&#125;; 2025-02-20 é¢˜ç›®ä¼ é€é—¨ï¼š2595. å¥‡å¶ä½æ•° - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ¨¡2é™¤2ï¼Œåšç»Ÿè®¡å³å¯ã€‚ æœ€åå®ç°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213class Solution &#123;public: vector&lt;int&gt; evenOddBit(int n) &#123; vector&lt;int&gt; ans(2,0); int cnt = 0; while ( n ) &#123; ans[cnt%2] += n%2; n /= 2; cnt++; &#125; return ans; &#125;&#125;;"},{"title":"Katexå…¬å¼é…ç½®","path":"/wiki/Others/Stellar/Katexå…¬å¼é…ç½®.html","content":"æƒ³åœ¨Stellarä¸»é¢˜ä¸­ä½¿ç”¨katexä¹¦å†™å…¬å¼ï¼Œå°±éœ€è¦æ›´æ”¹æ¸²æŸ“å™¨ï¼Œä½¿ç”¨å¦‚ä¸‹ä»£ç å¸è½½åšå®¢ä¸­åŸç”Ÿçš„æ¸²æŸ“å™¨hexo-renderer-markedï¼Œä¸‹è½½æ–°æ¸²æŸ“å™¨hexo-renderer-markdown-itä»¥åŠkatexæ”¯æŒ@traptitech/markdown-it-katexï¼š 123npm un hexo-renderer-marked --save npm i hexo-renderer-markdown-it --savenpm i @traptitech/markdown-it-katex --save ä½†æ˜¯æ›´æ”¹æ¸²æŸ“å™¨åä¼šå‡ºç°headerlinkæ— æ³•æ¸²æŸ“å‡ºæ¥çš„é—®é¢˜ï¼Œæ­¤æ—¶éœ€è¦å®‰è£…ä¸€ä¸ªåŒ…markdown-it-anchorç”¨äºheaderlinkçš„æ¸²æŸ“ã€‚ 1npm install markdown-it-anchor --save ä¸‹è½½å®Œæˆååœ¨_config.ymlä¸­æ·»åŠ å¦‚ä¸‹è®¾ç½®ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031markdown: preset: &#x27;default&#x27; render: html: true xhtmlOut: true breaks: true langPrefix: &#x27;language-&#x27; linkify: true typographer: true quotes: &#x27;â€œâ€â€˜â€™&#x27; plugins: - &#x27;markdown-it-footnote&#x27; # è§’æ ‡ - &#x27;markdown-it-ins&#x27; # ä¸‹åˆ’çº¿ - &#x27;markdown-it-mark&#x27; # é«˜äº® - &#x27;markdown-it-sub&#x27; # åˆ†å­å¼ - &#x27;markdown-it-sup&#x27; # ä¸Šè§’æ ‡ - plugin: name: &#x27;@traptitech/markdown-it-katex&#x27; options: # see https://katex.org/docs/options.html blockClass: &quot;math-block&quot; strict: false throwOnError: false errorColor: &quot;#cc0000&quot; - markdown-it-anchor anchors: level: 2 collisionSuffix: &#x27;&#x27; permalink: true permalinkClass: &#x27;headerlink&#x27; permalinkBefore: true permalinkSymbol: &#x27;&#x27; åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶_config.stellar.ymlä¸­æ·»åŠ å¦‚ä¸‹ä»£ç ï¼š 1234567plugins: katex: enable: true min_css: &lt;link rel=&quot;stylesheet&quot; href=&quot;https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css&quot; integrity=&quot;sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0&quot; crossorigin=&quot;anonymous&quot;&gt; min_js: &lt;script defer src=&quot;https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js&quot; integrity=&quot;sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; auto_render_min_js: &lt;script defer src=&quot;https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js&quot; integrity=&quot;sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05&quot; crossorigin=&quot;anonymous&quot;onload=&quot;renderMathInElement(document.body);&quot;&gt;&lt;/script&gt; æ­¤æ—¶å…¬å¼ä¸headerlinkä¾¿èƒ½å¤Ÿæ­£å¸¸æ˜¾ç¤ºäº†ã€‚"},{"title":"å®ç°åšå®¢ä¸“æ /ä¸“é¢˜","path":"/wiki/Others/Stellar/topic.html","content":"å¦‚æœä½ ä½¿ç”¨è¿‡ Stellar çš„ wiki ç³»ç»Ÿï¼Œé‚£ä¹ˆä¸“æ å°±éå¸¸å®¹æ˜“äº†ï¼Œç›¸å½“äºä¸€ä¸ªç®€åŒ–ç‰ˆçš„ wiki ç³»ç»Ÿï¼ŒåŒºåˆ«æ˜¯ï¼š æ— éœ€ã€Œä¸Šæ¶ã€åŠ¨ä½œ æ–‡ç« åˆ›å»ºäº blog/source/_posts æ–‡ä»¶å¤¹å†… æŒ‰ç…§æ—¶é—´æ’åºï¼Œé»˜è®¤æœ€æ–°çš„æ’æœ€ä¸Šé¢ é¡µé¢å¸ƒå±€ç±»ä¼¼äºæ™®é€šæ–‡ç«  åŸºæœ¬æµç¨‹ 1. åˆ›å»ºä¸€ä¸ªä¸“æ  åœ¨ blog/source/_data/ æ–‡ä»¶å¤¹ä¸­åˆ›å»ºä¸€ä¸ª topic æ–‡ä»¶å¤¹ï¼Œåœ¨å…¶ä¸­æ”¾å…¥å„ä¸ªä¸“æ çš„æè¿°æ–‡ä»¶ï¼Œæ–‡ä»¶åå°±æ˜¯é¡¹ç›®çš„ idï¼š blog/source/_data/topic/id.yml1234name: Stellar # åœ¨é¢åŒ…å±‘å¯¼èˆªä¸Šä¼šæ˜¾ç¤ºè¾ƒçŸ­çš„åå­—title: Stellar - æ¯ä¸ªäººçš„ç‹¬ç«‹åšå®¢ # åœ¨åˆ—è¡¨é¡µä¼šæ˜¾ç¤ºå®Œæ•´çš„ä¸“æ æ ‡é¢˜description: å…³äºæ­å»ºç‹¬ç«‹åšå®¢ç›¸å…³çš„çŸ¥è¯†å’Œç»éªŒåˆ†äº«ï¼Œä»¥åŠ Stellar çš„é«˜çº§ç”¨æ³•ã€ç‰ˆæœ¬æ›´æ–°ç›¸å…³çš„æ³¨æ„äº‹é¡¹ã€‚order_by: -date # é»˜è®¤æ˜¯æŒ‰å‘å¸ƒæ—¥æœŸå€’åºæ’åº 2. å‘å¸ƒæ–‡ç«  åœ¨æ­¤ä¸“æ æ–‡ç« çš„ md æ–‡ä»¶çš„ front-matter éƒ¨åˆ†æŒ‡å®šæ‰€å±çš„ä¸“æ  id ï¼ˆå³ä¸Šä¸€æ­¥åˆ›å»ºçš„æ–‡ä»¶å id.ymlï¼‰ blog/source/_posts/20240114.md123456---title: è¿™æ˜¯æ–‡ç« æ ‡é¢˜topic: id # è¿™æ˜¯ä¸“æ idï¼Œå¯¹åº” blog/source/_data/topic/id.yml---æ–‡ç« æ­£æ–‡ è¿™ä¸ªåŠŸèƒ½çš„å®šä½æ˜¯ä»€ä¹ˆï¼Ÿ ç›¸æ¯”åˆ†ç±»åŠŸèƒ½ï¼Œå®ƒæ›´åå‘äºä¸€ä¸ªæ›´åŠ æœ‰å‰åå…³ç³»çš„æ–‡ç« é›†åˆï¼Œç±»ä¼¼äºæ–‡æ¡£çš„åˆ†é¡µï¼Œä½†æ˜¯ç›¸æ¯”æ–‡æ¡£ï¼Œå®ƒåˆåƒæ–‡ç« ä¸€æ ·æŒç»­å¢åŠ æ–°é¡µé¢ï¼Œä¸€èˆ¬ä»¥æ—¶é—´ä¸ºæ’åºä¾æ®ã€‚æ¯”åˆ†ç±»æ›´åŠ ç»“æ„åŒ–ï¼Œæ¯”æ–‡æ¡£æ›´åŠ è‡ªåŠ¨åŒ–ï¼Œå¯ä»¥æ ¹æ®è‡ªå·±çš„éœ€æ±‚é€‰æ‹©ä½¿ç”¨ä¸åŒçš„åŠŸèƒ½ã€‚ https://xaoxuu.com/blog/20240203/https://xaoxuu.com/blog/20240203/"},{"title":"å¦‚ä½•ä½¿ç”¨æ–‡æ¡£ç³»ç»Ÿ","path":"/wiki/Others/Stellar/å¦‚ä½•ä½¿ç”¨æ–‡æ¡£ç³»ç»Ÿ.html","content":"Stellar ç‹¬åˆ›äº†å…¶å®ƒ Hexo ä¸»é¢˜æ‰€æ²¡æœ‰çš„ Wiki æ–‡æ¡£ç³»ç»Ÿï¼Œå¯ä»¥è‡ªåŠ¨æ‰¾åˆ°ä¸€ä¸ªé¡¹ç›®çš„æ‰€æœ‰æ–‡æ¡£åˆ†é¡µï¼Œç”Ÿæˆä¸€ä¸ªç›®å½•æ ‘ï¼Œè¿˜å¯ä»¥æ‰‹åŠ¨æŒ‡å®šé¡ºåºã€æ ‡é¢˜ã€åˆ†ç»„ï¼Œè€Œéä¾èµ–æ–‡ä»¶è·¯å¾„ã€æ–‡ä»¶åæ¥æ’åºå’Œæ˜¾ç¤ºã€‚ åŸºæœ¬æµç¨‹ 1/3 åˆ›å»ºé¡¹ç›®æè¿°æ–‡ä»¶åœ¨ blog/source/_data/ æ–‡ä»¶å¤¹ä¸­åˆ›å»ºä¸€ä¸ª wiki æ–‡ä»¶å¤¹ï¼Œåœ¨å…¶ä¸­æ”¾å…¥å„ä¸ªé¡¹ç›®çš„æ–‡æ¡£ã€‚ä»¥ Stellar é¡¹ç›®ä¸ºä¾‹ï¼Œæ–‡ä»¶åå°±æ˜¯é¡¹ç›®çš„ idï¼šblog/source/_data/wiki/hexo-stellar.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748name: Stellartitle: Stellar - æ¯ä¸ªäººçš„ç‹¬ç«‹åšå®¢subtitle: &#x27;æ¯ä¸ªäººçš„ç‹¬ç«‹åšå®¢ | Designed by xaoxuu&#x27;tags: åšå®¢ä¸»é¢˜icon: /assets/wiki/stellar/icon.svgcover: /assets/wiki/stellar/icon.svgdescription: Stellar æ˜¯ä¸€ä¸ªå†…ç½®æ–‡æ¡£ç³»ç»Ÿçš„ç®€çº¦å•†åŠ¡é£ Hexo ä¸»é¢˜ï¼Œæ”¯æŒä¸°å¯Œçš„æ ‡ç­¾å’ŒåŠ¨æ€æ•°æ®ç»„ä»¶ã€‚repo: xaoxuu/hexo-theme-stellarsearch: filter: /wiki/stellar/ placeholder: åœ¨ Stellar ä¸­æœç´¢...leftbar: - tree - timeline_stellar_releases - relatedcomment_title: &#x27;è¯„è®ºåŒºä»…ä¾›äº¤æµï¼Œæœ‰é—®é¢˜è¯·æ [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues) åé¦ˆã€‚&#x27;comments: service: giscus giscus: data-repo: xaoxuu/hexo-theme-stellar data-mapping: number data-term: 226base_dir: /wiki/stellar/tree: &#x27;å¿«é€Ÿå¼€å§‹&#x27;: - index - examples - releases &#x27;åŸºæœ¬ä½¿ç”¨&#x27;: - theme-settings - pages - sidebar - tag-plugins - tag-plugins/express - tag-plugins/data - tag-plugins/container - comments &#x27;æ–‡æ¡£ç³»ç»Ÿ&#x27;: - wiki-settings &#x27;è¿›é˜¶ç©æ³•&#x27;: - widgets - advanced-settings - notes - fcircle &#x27;æŠ€æœ¯æ”¯æŒ&#x27;: - articles - todo - contributors2/3 è®¾ç½®å¸ƒå±€æ¨¡æ¿å’Œé¡¹ç›®åç§°åœ¨æ­¤æ–‡æ¡£é¡¹ç›®çš„ md æ–‡ä»¶çš„ front-matter éƒ¨åˆ†æŒ‡å®šæ‰€å±çš„é¡¹ç›® id ï¼ˆå³ä¸Šä¸€æ­¥åˆ›å»ºçš„æ–‡ä»¶å id.ymlï¼‰blog/source/wiki/stellar/index.md1234---wiki: hexo-stellar # è¿™æ˜¯é¡¹ç›®idï¼Œå¯¹åº” /data/wiki/hexo-stellar.ymltitle: è¿™æ˜¯åˆ†é¡µæ ‡é¢˜---3/3 å°†æ­¤é¡¹ç›®ã€Œä¸Šæ¶ã€åœ¨ blog/source/_data/ æ–‡ä»¶å¤¹ä¸­åˆ›å»ºä¸€ä¸ª wiki.yml æ–‡ä»¶ï¼Œåœ¨å…¶ä¸­å†™å…¥éœ€è¦æ˜¾ç¤ºçš„é¡¹ç›® idï¼šblog/source/_data/wiki.yml12- hexo-stellar- å…¶å®ƒé¡¹ç›®è¿™æ ·åœ¨é¡¹ç›®åˆ—è¡¨ï¼ˆwikiï¼‰é¡µé¢å°±å¯ä»¥çœ‹åˆ°åˆšåˆšåˆ›å»ºçš„é¡¹ç›®äº†ã€‚ é¡¹ç›®åˆ†é¡µç´¢å¼• æŒ‡å®šé¡¹ç›®æ‰€åœ¨æ–‡ä»¶å¤¹å’Œç›®å½•æ ‘ï¼š blog/source/_data/wiki/hexo-stellar.yml1234567891011121314151617181920212223242526base_dir: /wiki/stellar/tree: &#x27;å¿«é€Ÿå¼€å§‹&#x27;: - index # ä¼šè¢«å…³è”åˆ° /wiki/stellar/index.md - examples # ä¼šè¢«å…³è”åˆ° /wiki/stellar/examples.md - releases &#x27;åŸºæœ¬ä½¿ç”¨&#x27;: - theme-settings - pages - sidebar - tag-plugins - tag-plugins/express - tag-plugins/data - tag-plugins/container - comments &#x27;æ–‡æ¡£ç³»ç»Ÿ&#x27;: - wiki-settings &#x27;è¿›é˜¶ç©æ³•&#x27;: - widgets - advanced-settings - notes - fcircle &#x27;æŠ€æœ¯æ”¯æŒ&#x27;: - articles - todo - contributors å¦‚æœç›®å½•æ ‘ä¸éœ€è¦åˆ†ç»„ï¼Œå¯ä»¥è¿™æ ·å†™ï¼š blog/source/_data/wiki/hexo-stellar.yml12345base_dir: /wiki/stellar/tree: - index # ä¼šè¢«å…³è”åˆ° /wiki/stellar/index.md - examples # ä¼šè¢«å…³è”åˆ° /wiki/stellar/examples.md - ... æ˜¯å¦æ˜¾ç¤ºå°é¢ é¡¹ç›®å¯ä»¥æ˜¾ç¤ºä¸€ä¸ªå…¨å±å°é¢ï¼Œå°é¢å æ®ä¸€ä¸ªå±å¹•çš„é«˜åº¦ï¼Œä¼šå±…ä¸­ä¾æ¬¡æ˜¾ç¤ºé¡¹ç›®çš„ logoã€æ ‡é¢˜ã€æè¿°ã€‚å¼€å¯é¡¹ç›®å°é¢æ–¹æ³•å¦‚ä¸‹ï¼š blog/source/_data/wiki/hexo-stellar.yml12cover: /assets/wiki/stellar/icon.svgcoverpage: true # é»˜è®¤æ˜¯ true å¦‚æœ logo ä¸­å·²ç»åŒ…å«äº†é¡¹ç›®æ ‡é¢˜ï¼Œå¯ä»¥è¿™æ ·è®¾ç½®ä¸æ˜¾ç¤ºé¡¹ç›®æ ‡é¢˜ï¼š blog/source/_data/wiki/hexo-stellar.yml1coverpage: [logo, description] é¡¹ç›®æ–‡æ¡£æ ‡ç­¾ å¦‚æœæ‚¨æœ‰å¾ˆå¤šé¡¹ç›®ï¼Œæœ‰äº›é¡¹ç›®æ˜¯æœ‰ç›¸å…³æ€§çš„ï¼Œå¯ä»¥ç›¸åŒçš„ tags å€¼ï¼š blog/source/_data/wiki/hexo-stellar.yml1tags: åšå®¢ä¸»é¢˜ ä¹Ÿå¯ä»¥è®¾ç½®å¤šä¸ª tags å€¼ï¼š blog/source/_data/wiki/hexo-stellar.yml1tags: [åšå®¢ä¸»é¢˜, å¼€æºé¡¹ç›®] é¡¹ç›®çš„ GitHub ä»“åº“ä¿¡æ¯ è®¾ç½®äº† repo å€¼å°±ä¼šåœ¨å³ä¸Šè§’æ˜¾ç¤ºé¡¹ç›®ä»“åº“çš„ç›¸å…³é“¾æ¥ï¼š blog/source/_data/wiki/hexo-stellar.yml1repo: xaoxuu/hexo-theme-stellar é¡¹ç›®è¯„è®ºè®¾ç½® å¦‚æœå¸Œæœ›é¡¹ç›®çš„æ‰€æœ‰åˆ†é¡µä½¿ç”¨ç›¸åŒçš„è¯„è®ºæ•°æ®ï¼Œå¯ä»¥åœ¨è¿™é‡Œè¦†ç›–è¯„è®ºé…ç½®ï¼š blog/source/_data/wiki/hexo-stellar.yml123456comment_title: &#x27;è¯„è®ºåŒºä»…ä¾›äº¤æµï¼Œæœ‰é—®é¢˜è¯·æ [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues) åé¦ˆã€‚&#x27;comments: giscus: data-repo: xaoxuu/hexo-theme-stellar data-mapping: number data-term: 226 ä¾§è¾¹æ ç»„ä»¶ å¦‚æœæ‚¨å¸Œæœ›è‡ªå®šä¹‰æŸä¸ªé¡¹ç›®çš„ä¾§è¾¹æ ç»„ä»¶ï¼Œå¯ä»¥è®¾ç½® sidebar å€¼ï¼š å¯ä»¥è¦†ç›–ç»„ä»¶ï¼š blog/source/_data/wiki/hexo-stellar.yml1234leftbar: - tree - timeline_stellar_releases - related todo åœ¨ç›®å½•æ ‘ä¸­éšè—æŸç¯‡æ–‡ç«  å¯ä»¥åœ¨ front-matter ä¸­ä¸è®¾ç½® title æ ‡é¢˜ï¼Œæˆ–è€…å°† title æ”¹ä¸º seo_titleï¼š blog/source/xxx/xxx.md1title: åŸæœ¬çš„æ ‡é¢˜ todo æ˜¾ç¤ºè®¸å¯åè®® æ²¿ç”¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­è®¾ç½®çš„ï¼š blog/source/_data/wiki/hexo-stellar.yml1license: true ä¹Ÿå¯ä»¥æŒ‡å®šåè®®å†…å®¹ï¼š blog/source/_data/wiki/hexo-stellar.yml1license: &#x27;æœ¬æ–‡é‡‡ç”¨ [ç½²å-éå•†ä¸šæ€§ä½¿ç”¨-ç›¸åŒæ–¹å¼å…±äº« 4.0 å›½é™…](https://creativecommons.org/licenses/by-nc-sa/4.0/) è®¸å¯åè®®ï¼Œè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚&#x27; æ˜¾ç¤ºåˆ†äº« blog/source/_data/wiki/hexo-stellar.yml1share: true ä¿®æ”¹ wiki è·¯å¾„ ä¿®æ”¹å¦‚ä¸‹é…ç½®ï¼š blog/_config.stellar.yml123site_tree: wiki: base_dir: wiki # books / products ..."},{"title":"ç¼–å†™æ–‡ç« ä»¥åŠç‹¬ç«‹é¡µé¢","path":"/wiki/Others/Stellar/ç¼–å†™æ–‡ç« ä»¥åŠç‹¬ç«‹é¡µé¢.html","content":"æ–‡ç« ç±»å‹ æ–‡ç« ç±»å‹å†³å®šå¸ƒå±€é£æ ¼ï¼Œæœ‰ä¸¤ç§é£æ ¼å¯é€‰ï¼Œtech: é»˜è®¤æŠ€æœ¯ç±»æ–‡ç« , story: å›¾æ–‡ç±»æ–‡ç« ï¼Œæ–‡å­—å’Œæ®µè½é—´å¢è·å¤§ã€‚ blog/_config.stellar.yml12article: type: tech # tech/story å¯ä»¥åœ¨ front-matter/topic/wiki ä¸­è¦†ç›–æ­¤å‚æ•°ã€‚ æ–‡ç« å°é¢ åœ¨æ–‡ç« åˆ—è¡¨é¡µé¢æˆ–è€…å…¶ä»–ä½ç½®æ˜¾ç¤ºçš„æ–‡ç« æ‘˜è¦å¡ç‰‡ä¸Šé¢çš„å›¾ç‰‡ç§°ä¹‹ä¸ºã€Œæ–‡ç« å°é¢ã€ è‡ªåŠ¨ç”Ÿæˆå°é¢ æ ¹æ® tags ä½œä¸ºå…³é”®è¯ä¸ºæ¯ä¸€ç¯‡æ–‡ç« åœ¨çº¿æœç´¢å°é¢ï¼š blog/_config.stellar.yml12article: auto_cover: true å¼•ç”¨å¤–éƒ¨å›¾ç‰‡ åœ¨æ–‡ç« çš„ front-matter ä¸­å†™ä¸Š cover: xxx å³å¯ã€‚ä¾‹å¦‚ï¼š blog/source/_posts/xxx.md12345---# æœ¬åœ°å›¾ç‰‡è·¯å¾„ä¸º blog/source/assets/xaoxuu/blog/2020-0927a@1x.svg# ä¹Ÿå¯ä»¥ç›´æ¥å¼•ç”¨å›¾ç‰‡ç›´é“¾ https://xxx.jpgcover: /assets/xaoxuu/blog/2020-0927a@1x.svg--- æ˜¾ç¤ºæ•ˆæœ ä¸Šé¢è¿™ç§æ–¹å¼ä¼šæ˜¾ç¤ºtitleä¸descriptionæˆ–è€…æ‘˜è¦ï¼Œè‹¥ä½ æƒ³è¦å›¾ç‰‡å…¨æ˜¾ç¤ºï¼Œå¯ä»¥åŠ å…¥å¦‚ä¸‹å‚æ•°ï¼š blog/source/_posts/xxx.md12345678---cover: /assets/xaoxuu/blog/2020-0927a@1x.svg # å¿…é€‰poster: # æµ·æŠ¥ï¼ˆå¯é€‰ï¼Œå…¨å›¾å°é¢å¡ç‰‡ï¼‰ topic: æ ‡é¢˜ä¸Šæ–¹çš„å°å­— # å¯é€‰ headline: å¤§æ ‡é¢˜ # å¿…é€‰ caption: æ ‡é¢˜ä¸‹æ–¹çš„å°å­— # å¯é€‰ color: æ ‡é¢˜é¢œè‰² # å¯é€‰ï¼Œé»˜è®¤ä¸ºè·Ÿéšä¸»é¢˜çš„åŠ¨æ€é¢œè‰² # white,red...--- Stellar v1.14.0 æ›´æ¢ cover-title cover-cat cover-subtitle cover-text-color ä¸º poster ä¸ºäº†æ˜¾ç¤ºç¾è§‚ï¼Œå»ºè®® topic å’Œ caption é€‰æ‹©å…¶ä¸€ä¸ headline æ­é…ä½¿ç”¨ã€‚ æ˜¾ç¤ºæ•ˆæœå¡«å†™ topic ä¸ headline æ—¶å¤§æ ‡é¢˜ä½äºä¸Šæ–¹åªå¡«å†™ headline æˆ–å¡«å†™ headline ä¸ caption æ—¶å¤§æ ‡é¢˜ä½äºä¸‹æ–¹ å¦‚æœæ‚¨æƒ³ä½¿ç”¨ Unsplash æœç´¢å›¾ç‰‡ä½œä¸ºå°é¢ï¼Œå¯ä»¥åœ¨ cover è®¾ç½®æœç´¢å…³é”®è¯ï¼ˆç”¨è‹±æ–‡é€—å·éš”å¼€ï¼‰ï¼š blog/source/_posts/xxx.md123---cover: workout,strava--- å†…å®¹æ‘˜è¦ è‡ªåŠ¨ç”Ÿæˆæ‘˜è¦ å»ºè®®æ‚¨é€šè¿‡ description æˆ–è€… excerpt æ–¹å¼ç”Ÿæˆæ‘˜è¦ï¼Œä½†å¦‚æœæ‚¨å¸Œæœ›è‡ªåŠ¨ä»æ–‡ç« å†…å®¹æˆªå–ä¸€å®šå­—æ•°çš„æ–‡å­—ä½œä¸ºæ‘˜è¦ï¼Œå¯ä»¥è¿™æ ·è®¾ç½®ï¼š blog/_config.stellar.yml12article: auto_excerpt: 200 æ‰‹åŠ¨è®¾ç½®æ‘˜è¦ ä¸€ç¯‡æ–‡ç« å¼€å¤´ä¸€æ®µæ–‡å­—æè¿°å°±æ˜¯æ‘˜è¦ï¼Œæ‘˜è¦å’Œæ­£æ–‡ç”¨ &lt;!-- more --&gt; éš”å¼€ï¼Œå‰åä¸€å®šè¦æœ‰ç©ºè¡Œã€‚ä¾‹å¦‚ï¼š blog/source/_posts/xxx.md123456789---cover: /assets/xaoxuu/blog/2020-0927a@1x.svg---åœ¨å¿ƒç‡ç®¡å®¶é»˜é»˜æ— é—»åœ°ä¸Šçº¿äº†ä¸€å¹´å¤šä¹‹åï¼Œç°åœ¨ç»ˆäºæ‰“ç®—æ¥å¥½å¥½èŠèŠå…³äºæ‰‹æœºæ‘„åƒå¤´æµ‹é‡å¿ƒç‡çš„é‚£äº›äº‹ã€‚æœ¬æ–‡å‚è€ƒäº†å¾ˆå¤šå‰è¾ˆçš„æ–‡ç« ï¼Œå°†åœ¨æ–‡æœ«åˆ—å‡ºã€‚&lt;!-- more --&gt;åé¢æ˜¯æ­£æ–‡éƒ¨åˆ†ï¼Œåœ¨ä¸»é¡µçœ‹ä¸åˆ°ã€‚ AIæ‘˜è¦ åŸºäº tianli_gpt å‰ç«¯é¡¹ç›® Post-Summary-AI _config.stellar.yml123456789101112131415161718# AI æ‘˜è¦# https://github.com/qxchuckle/Post-Summary-AItianli_gpt: enable: #true js: https://jsd.onmicrosoft.cn/gh/qxchuckle/Post-Summary-AI@6.0/chuckle-post-ai.min.js field: post # all, post, wiki key: 5Q5mpqRK5DkwT1X9Gi5e # tianli_gpt key total_length: 1000 # è®¾ç½®æäº¤çš„å­—æ•°é™åˆ¶ï¼Œé»˜è®¤ä¸º1000å­—ï¼Œä¸Šé™ä¸º5000ï¼Œè¶…è¿‡5000å­—ç¬¦å°†è¢«æˆªæ–­ typewriter: true # æ‰“å­—æœºåŠ¨ç”» summary_directly: true # æ˜¯å¦ç›´æ¥æ˜¾ç¤ºæ‘˜è¦ï¼Œå¦åˆ™æ˜¾ç¤º AI ç®€ä»‹ rec_method: all # all, web # æ–‡ç« æ¨èæ–¹å¼ï¼Œallï¼šåŒ¹é…æ•°æ®åº“å†…æ‰€æœ‰æ–‡ç« è¿›è¡Œæ¨èï¼Œwebï¼šä»…å½“å‰ç«™å†…çš„æ–‡ç« ï¼Œé»˜è®¤all hide_shuttle: true # æ˜¯å¦éšè—çŸ©é˜µç©¿æ¢­ summary_toggle: false # æ˜¯å¦å¼€å¯åˆ‡æ¢ç®€ä»‹åŠŸèƒ½ï¼Œç»è¿‡ä¸€äº›å¤„ç†åï¼Œé‡æ–°ç”Ÿæˆä¸€ä»½ç®€ä»‹ï¼Œè¿™å°†æ¶ˆè€—keyå­—æ•° interface: # AI ä¿¡æ¯å±•ç¤º name: AIæ‘˜è¦ introduce: &#x27;æˆ‘æ˜¯æ–‡ç« è¾…åŠ©AI: QX-AIï¼Œç‚¹å‡»ä¸‹æ–¹çš„æŒ‰é’®ï¼Œè®©æˆ‘ç”Ÿæˆæœ¬æ–‡ç®€ä»‹ã€æ¨èç›¸å…³æ–‡ç« ç­‰ã€‚&#x27; version: TianliGPT button: [&quot;ä»‹ç»è‡ªå·±&quot;, &quot;æ¨èæ–‡ç« &quot;, &quot;ç”Ÿæˆæ‘˜è¦&quot;, &quot;çŸ©é˜µç©¿æ¢­&quot;] # åº•éƒ¨æŒ‰é’®æ–‡å­— å¦‚ä½•è·å– tianliGPT_keyï¼šåˆ° çˆ±å‘ç”µ ä¸­è´­ä¹°ï¼Œè´­ä¹°å®Œæˆåï¼Œè¿›å…¥ ç½‘é¡µåå°ç®¡ç† ç»‘å®škeyå¹¶æ·»åŠ è‡ªå·±çš„ç«™ç‚¹ keyä¸åšå®¢åœ°å€ä¸ºç»‘å®šçŠ¶æ€ï¼Œæ‰€ä»¥æœ¬åœ°è°ƒè¯•æ—¶æ˜¯æ— æ³•æ¥æ”¶åˆ°æ•°æ®çš„ã€‚ æ–‡ç« æ¨¡æ¿ ä½¿ç”¨ Hexo è‡ªå¸¦æ¨¡æ¿å®ç°å‘½ä»¤è¡Œåˆ›å»ºæ–°æ–‡ç« æ—¶è‡ªåŠ¨ç”Ÿæˆç›¸å…³ä¿¡æ¯ã€‚ æ ¹ç›®å½•ä¸‹ scaffolds æ–‡ä»¶å¤¹ä¸­ç¼–è¾‘ post.md çš„ font-matter ï¼Œæ ¹æ®è‡ªå·±çš„éœ€è¦å¢åŠ ä½ æƒ³è¦é…ç½®çš„å†…å®¹ blog/scaffolds/post.md1234567891011121314151617181920212223242526272829303132---# åŸºæœ¬ä¿¡æ¯title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: []categories: []description: # excerpt ä¹Ÿå¯ # å°é¢cover: banner: poster: # æµ·æŠ¥ï¼ˆå¯é€‰ï¼Œå…¨å›¾å°é¢å¡ç‰‡ï¼‰ topic: æ ‡é¢˜ä¸Šæ–¹çš„å°å­— # å¯é€‰ headline: å¤§æ ‡é¢˜ # å¿…é€‰ caption: æ ‡é¢˜ä¸‹æ–¹çš„å°å­— # å¯é€‰ color: æ ‡é¢˜é¢œè‰² # å¯é€‰# æ’ä»¶sticky: # æ•°å­—è¶Šå¤§è¶Šé å‰mermaid:katex: mathjax: # å¯é€‰topic: # ä¸“æ  idauthor: references:comments: # è®¾ç½® false ç¦æ­¢è¯„è®ºindexing: # è®¾ç½® false é¿å…è¢«æœç´¢breadcrumb: # è®¾ç½® false éšè—é¢åŒ…å±‘å¯¼èˆªleftbar: rightbar:h1: # è®¾ç½®ä¸º &#x27;&#x27; éšè—æ ‡é¢˜type: # tech/story--- æ–‡ç« é¡µ æ¨ªå¹…å›¾ç‰‡ æ–‡ç« é¡µé¢é¡¶éƒ¨åŒºåŸŸå¯ä»¥æ˜¾ç¤ºé•¿é•¿çš„æ¨ªå¹…å›¾ç‰‡ï¼Œè®¾ç½®æ–¹æ³•å¦‚ä¸‹ï¼š blog/source/_posts/xxx.md1banner: /assets/xaoxuu/blog/2020-0927a@1x.svg å¦‚æœæ‚¨æƒ³ä½¿ç”¨ Unsplash æœç´¢å›¾ç‰‡ä½œä¸ºæ¨ªå¹…ï¼Œå¯ä»¥åœ¨ banner ä¸­è®¾ç½®æœç´¢å…³é”®è¯ï¼ˆç”¨è‹±æ–‡é€—å·éš”å¼€ï¼‰ï¼š blog/source/_posts/xxx.md123---banner: workout,strava--- æŒ‡å®šä¸€çº§æ ‡é¢˜ é»˜è®¤çš„ä¸€çº§æ ‡é¢˜æ˜¯æ–‡ç« çš„ titleï¼Œå¦‚æœå¸Œæœ›ä½¿ç”¨åˆ«çš„æ–‡å­—ä½œä¸ºä¸€çº§æ ‡é¢˜ï¼Œå¯ä»¥æŒ‡å®š h1ï¼Œä¾‹å¦‚ï¼š blog/source/_posts/xxx.md123---h1: å¿«é€Ÿå¼€å§‹--- éšè—æ–‡ç« æ ‡é¢˜ åŒä¸Šè¿°æ“ä½œï¼Œä½†æ˜¯ h1 è®¾ç½®ä¸ºç©ºå­—ç¬¦ä¸²å³å¯ï¼š blog/source/_posts/xxx.md123---h1: &#x27;&#x27;--- æ–‡ç« ç´¢å¼•ä¸æ¨è æ–‡ç« å¦‚æœæœ‰åˆ†ç±»å’Œæ ‡ç­¾å°±ä¼šè‡ªåŠ¨åœ¨ä¸»é¡µå‡ºç°ã€Œåˆ†ç±»ã€ã€ã€Œæ ‡ç­¾ã€é€‰é¡¹å¡å®ç°åˆ†ç±»æµè§ˆï¼Œä¸éœ€è¦æ‰‹åŠ¨æ·»åŠ é¡µé¢ã€‚ æ–‡ç« åˆ†ç±» åœ¨æ–‡ç« åˆ—è¡¨é¡µé¢ä¼šæ˜¾ç¤ºæ–‡ç« æ‰€å±çš„ç¬¬ä¸€çº§åˆ†ç±»ï¼Œä¾‹å¦‚ï¼š blog/source/_posts/xxx.md123---categories: [è®¾è®¡å¼€å‘, iOSå¼€å‘]--- è¿™æ ·å†™å°±åªä¼šæ˜¾ç¤ºã€Œè®¾è®¡å¼€å‘ã€ä¸€çº§åˆ†ç±»ï¼Œè€Œåœ¨æ–‡ç« é¡µé¢é¡¶éƒ¨åˆ™ä¼šæ˜¾ç¤ºå®Œæ•´çš„é¢åŒ…å±‘å¯¼èˆªã€‚ æ–‡ç« æ ‡ç­¾ æ–‡ç« æ ‡ç­¾ç›®å‰ä¸å¯è§ï¼Œç”¨äºå…³é”®è¯ã€æœç´¢ã€æŒ‰æ ‡ç­¾æ£€ç´¢ã€ç›¸å…³æ–‡ç« æ¨èç­‰åŠŸèƒ½ï¼Œä¾‹å¦‚ï¼š blog/source/_posts/xxx.md123---tags: [iOS, å¿ƒç‡]--- ç›¸å…³æ–‡ç« æ¨è è¦å®ç°ç›¸å…³æ–‡ç« æ¨èåŠŸèƒ½ï¼Œæ‚¨éœ€è¦å®‰è£…æ’ä»¶ï¼š ç„¶ååœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­å¼€å¯ï¼š blog/_config.stellar.yml12345article: # npm i hexo-related-popular-posts related_posts: enable: true title: æ‚¨å¯èƒ½æ„Ÿå…´è¶£çš„æ–‡ç«  å¼€å¯åä¼šåœ¨æ¯ç¯‡æ–‡ç« çš„ä¸‹æ–¹æ¨èç›¸åŒç±»å‹çš„æ–‡ç« ã€‚ å‚è€ƒèµ„æ–™ ç”¨ markdown æ ¼å¼å¡«å†™å¼•ç”¨çš„æ–‡ç« ï¼Œæ³¨æ„è¦å†™åœ¨å¼•å·ä¸­ï¼š blog/source/_posts/xxx.md123456---references: - &#x27;[å¿ƒè·³ä¹‹æ—…â€”ğŸ’—â€”iOSç”¨æ‰‹æœºæ‘„åƒå¤´æ£€æµ‹å¿ƒç‡(PPG)](https://punmy.cn/2016/07/28/15231176397746.html)&#x27; - &#x27;[PPGå…‰ç”µå®¹ç§¯è„‰ææ³¢æè®°æ³•æŠ€æœ¯æ¦‚å†µ](https://www.jianshu.com/p/695c131abfa5)&#x27; ...--- æ•ˆæœè§è¿™ç¯‡æ–‡ç« ï¼š https://xaoxuu.com/blog/20200927/#referenceshttps://xaoxuu.com/blog/20200927/#references è®¸å¯åè®® ä½ å¯ä»¥æ›´æ”¹åè®®å†…å®¹æˆ–è€…è‡ªå®šä¹‰å…¶ä»–é€‰é¡¹ï¼Œæ”¯æŒ MarkDown è¯­æ³•ã€‚ blog/_config.stellar.yml12article: license: &#x27;æœ¬æ–‡é‡‡ç”¨ [ç½²å-éå•†ä¸šæ€§ä½¿ç”¨-ç›¸åŒæ–¹å¼å…±äº« 4.0 å›½é™…](https://creativecommons.org/licenses/by-nc-sa/4.0/) è®¸å¯åè®®ï¼Œè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚&#x27; è‹¥ä½ é…ç½®äº†ä½œè€…æ•°æ® _data/authors.yml å’Œæ–‡ç« ä½œè€…ï¼Œå¯ä»¥åœ¨ license ä¸­ä½¿ç”¨ &#123;author.name&#125; æ¥è‡ªåŠ¨æ›¿æ¢ä¸ºå½“å‰æ–‡ç« ä½œè€…åå­—ã€‚ blog/_config.stellar.yml12article: license: &#x27;æœ¬æ–‡ç”±&#123;author.name&#125;ç¼–å†™ï¼Œé‡‡ç”¨...&#x27; åˆ†äº«é“¾æ¥ åˆ†äº«è‡³å¾®ä¿¡ä¼šç”Ÿæˆå¯¹åº”çš„é¡µé¢äºŒç»´ç ï¼Œweibo å’Œ email ä¼šè‡ªåŠ¨è·³è½¬åˆ°å¯¹åº”è½¯ä»¶æˆ–ç½‘é¡µï¼Œlink ä¼šæ‹·è´å½“å‰é¡µé¢é“¾æ¥è‡³å‰ªåˆ‡æ¿ã€‚ blog/_config.stellar.yml12article: share: # [wechat, weibo, email, link] è¦†ç›– OpenGraph å¦‚æœåˆ†äº«åˆ°ç¤¾äº¤å¹³å°çš„ç¼©ç•¥å›¾ä¸ç†æƒ³ï¼Œå¯ä»¥é€šè¿‡è¿™ä¸ªç‰¹æ€§è¦†ç›–ä¸ºè‡ªå·±æƒ³è¦çš„ï¼š blog/source/_posts/xxx.md12open_graph: image: /assets/xaoxuu/blog/2022-1029a@2x.webp æ›´å¤šçš„ç‹¬ç«‹é¡µé¢ Stellar åŒæ—¶å…·æœ‰åšå®¢å’Œ Wiki ä¸¤ä¸ªå¤§æ¨¡å—ï¼Œä¸ºäº†èƒ½å¤Ÿæ­£ç¡®è¿›è¡Œå¯¼èˆªæ é«˜äº®ï¼Œå¼•å…¥äº† menu_id æ¥è¿›è¡ŒåŒºåˆ†ï¼Œå¯ä»¥åœ¨ front-matter ä¸­æŒ‡å®š menu_id æ¥ä½¿æŸä¸ªèœå•æŒ‰é’®å¤„äºé€‰ä¸­çŠ¶æ€ã€‚ ä¾‹å¦‚æ‚¨æœ‰å…³äºã€å‹é“¾ä¸¤ä¸ªé¡µé¢ï¼Œéƒ½å¸Œæœ›é«˜äº®ã€Œæ›´å¤šã€æŒ‰é’®ï¼š blog/source/about/index.md1234---menu_id: moretitle: å…³äº--- blog/source/friends/index.md1234---menu_id: moretitle: å‹é“¾--- åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­è®¾ç½®å¯¼èˆªæ ï¼š blog/_config.stellar.yml123456789menubar: columns: 4 # ä¸€è¡Œå¤šå°‘ä¸ª items: # å¯æŒ‰ç…§è‡ªå·±éœ€æ±‚å¢åŠ ï¼Œç¬¦åˆä»¥ä¸‹æ ¼å¼å³å¯ ... - id: more theme: &#x27;&#x27; title: æ›´å¤š icon: &#x27;&#x27; url: /more/ å‹é“¾é¡µé¢ å‹é“¾è¢«è®¾è®¡æˆæ ‡ç­¾ï¼Œæ‚¨å¯ä»¥åœ¨ä»»ä½•é¡µé¢ä»»ä½•ä½ç½®æ’å…¥å‹é“¾ï¼Œè¯¦è§ï¼š #å‹é“¾æ ‡ç­¾https://xaoxuu.com/wiki/stellar/tag-plugins/#å‹é“¾æ ‡ç­¾ å…³äºé¡µé¢ æ²¡æœ‰å•ç‹¬çš„å…³äºé¡µé¢å¸ƒå±€ï¼Œæ‚¨å¯ä»¥è‡ªç”±ç»„åˆä¸°å¯Œçš„æ ‡ç­¾æ¥å®ç°ä¸ªæ€§åŒ–çš„å…³äºé¡µé¢ï¼Œä¾‹å¦‚ï¼šaboutã€tabsã€navbarã€quotã€timeline æ ‡ç­¾ã€‚"},{"title":"Windows11 é‡è£…ç³»ç»Ÿé‚£äº›äº‹","path":"/wiki/Others/Windows/Windows11 é‡è£…ç³»ç»Ÿé‚£äº›äº‹.html","content":"æ¯æ¬¡ç”µè„‘å‡ºé—®é¢˜åé‡è£…ç³»ç»Ÿéƒ½æ˜¯ä¸€ä»¶éå¸¸æŠ˜ç£¨çš„äº‹æƒ…ï¼Œæ•…å¼€æ­¤ä¸“é¢˜è®°å½•æ‰€è¸©è¿‡çš„å‘ï¼Œä¸ºä»¥åçš„è‡ªå·±èŠ‚çº¦æ—¶é—´ğŸ™ğŸ™ğŸ™ è£…ç³»ç»Ÿè¿‡ç¨‹ä¸­ æœ‰ä¸€é¡µè®©é€‰ä¸€äº›æœåŠ¡ï¼Œåªéœ€è¦å°†ä½ç½®å‹¾ä¸Šå°±è¡Œäº† OneDrive å¦‚æœä¸ä½¿ç”¨çš„è¯ï¼Œè£…å¥½ç³»ç»Ÿåå…ˆå°†è´¦å·å’Œå½“å‰ç”µè„‘è§£é™¤å…³è”ï¼Œåç»­çœ‹æƒ…å†µè¦ä¸è¦å¸è½½ã€‚ è‹±æ–‡ç³»ç»Ÿä¸­æ–‡å­—ä½“æ˜¾ç¤ºé—®é¢˜ è½¬è½½è‡ªï¼šWindows æ˜¾ç¤ºè¯­è¨€è®¾ç½®ä¸ºè‹±æ–‡æ—¶ç®€ä½“ä¸­æ–‡ä»¥æ—¥æ–‡æˆ–ç¹ä½“ä¸­æ–‡å­—å½¢æ˜¾ç¤ºçš„è§£å†³åŠæ³• - çŸ¥ä¹ (zhihu.com) å¤‡ä»½æ³¨å†Œè¡¨ Computer\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts åˆ é™¤ Microsoft JhengHei ï¼ˆç¹ä¸­ï¼‰å¼€å¤´çš„3ä¸ªé”®ã€Malgunï¼ˆéŸ©æ–‡ï¼‰å¼€å¤´çš„3ä¸ªé”®å’Œ Yu Gothicï¼ˆæ—¥æ–‡ï¼‰ å¼€å¤´çš„4ä¸ªé”® é‡å¯ Windows Terminal è¡Œè·é—®é¢˜ ç¬¬9è¡ŒåŠ ä¸€ä¸‹cellHeightå°±å¯ä»¥ 12345678910111213141516171819202122232425262728293031323334&quot;profiles&quot;: &#123; &quot;defaults&quot;: &#123; &quot;colorScheme&quot;: &quot;One Half Dark&quot;, &quot;font&quot;: &#123; &quot;face&quot;: &quot;DejaVuSansM Nerd Font Mono&quot;, &quot;cellHeight&quot;: &quot;1.5&quot; &#125;, &quot;opacity&quot;: 80 &#125;, &quot;list&quot;: [ &#123; &quot;commandline&quot;: &quot;%SystemRoot%\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe&quot;, &quot;guid&quot;: &quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;Windows PowerShell&quot; &#125;, &#123; &quot;commandline&quot;: &quot;%SystemRoot%\\\\System32\\\\cmd.exe&quot;, &quot;guid&quot;: &quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;Command Prompt&quot; &#125;, &#123; &quot;guid&quot;: &quot;&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;Azure Cloud Shell&quot;, &quot;source&quot;: &quot;Windows.Terminal.Azure&quot; &#125; ] &#125;, gitæœ€å°åŒ–å®‰è£…åŠé…ç½® æœ€å°åŒ–å®‰è£… å¦‚æœç›´æ¥å®‰è£…git installerçš„è¯ï¼Œä»–ä¼šè£…ä¸€äº›GUIï¼ŒBashä»€ä¹ˆçš„ï¼Œå…¶å®åæ¥å‘ç°éƒ½æ²¡å•¥ç”¨ï¼Œæ‰€ä»¥å¯ä»¥é‡‡ç”¨æœ€å°åŒ–å®‰è£…æ¥é¿å…å®‰è£…è¿™äº›è½¯ä»¶ã€‚ åœ¨GitHub - git-for-windows/git: A fork of Git containing Windows-specific patches.é¡¹ç›®ä¸­å®‰è£…MinGitå‹ç¼©åŒ…ï¼Œè§£å‹ååœ¨ç³»ç»Ÿç¯å¢ƒå˜é‡Pathä¸­åŠ å…¥è¯¥æ–‡ä»¶å¤¹ä¸­cmdæ–‡ä»¶å¤¹è·¯å¾„å³å¯ã€‚ åœ¨ Git ä¸­é…ç½®é‚®ç®±ã€ç”¨æˆ·åä»¥åŠä»£ç†éœ€è¦ä»¥ä¸‹å‡ æ­¥ï¼š é…ç½®é‚®ç®±å’Œç”¨æˆ·å é…ç½®å…¨å±€ç”¨æˆ·åå’Œé‚®ç®±ï¼š 12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;your.email@example.com&quot; é…ç½®ç‰¹å®šä»“åº“çš„ç”¨æˆ·åå’Œé‚®ç®±ï¼š è¿›å…¥ä½ çš„ä»“åº“ç›®å½•ï¼Œç„¶åæ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼š 12git config user.name &quot;Your Name&quot;git config user.email &quot;your.email@example.com&quot; é…ç½®ä»£ç† HTTP ä»£ç†ï¼š 1git config --global http.proxy http://proxyuser:proxypassword@proxy.server.com:port HTTPS ä»£ç†ï¼š 1git config --global https.proxy https://proxyuser:proxypassword@proxy.server.com:port å–æ¶ˆä»£ç†é…ç½®ï¼š 12git config --global --unset http.proxygit config --global --unset https.proxy æŸ¥çœ‹å½“å‰é…ç½® æŸ¥çœ‹å…¨å±€é…ç½®ï¼š 1git config --global --list æŸ¥çœ‹å½“å‰ä»“åº“é…ç½®ï¼š 1git config --list é€šè¿‡ä¸Šè¿°æ­¥éª¤ï¼Œä½ å¯ä»¥åœ¨ Git ä¸­é…ç½®ä½ çš„é‚®ç®±ã€ç”¨æˆ·åä»¥åŠä»£ç†ã€‚ Node.js é…ç½® ä¹‹å‰Node.jsä¸‹åœ¨Dç›˜ï¼Œç³»ç»Ÿé‡ç½®æ²¡æœ‰åˆ é™¤æœ¬ä½“æ–‡ä»¶ï¼Œå› æ­¤åªéœ€è¦é…ç½®ç¯å¢ƒå˜é‡å°±å¯æ­£ç¡®ä½¿ç”¨Node.js æœ¬ä½“ç¯å¢ƒå˜é‡é…ç½® é¦–å…ˆé…ç½®æœ¬ä½“ç¯å¢ƒå˜é‡ï¼Œè¿™æ ·æ‰å¯ä»¥åœ¨ç³»ç»Ÿå…¨å±€ä¸­ä½¿ç”¨npmå‘½ä»¤ã€‚ è¯¦æƒ…è§åšå®¢Node.js ç¯å¢ƒå˜é‡é…ç½®-è…¾è®¯äº‘å¼€å‘è€…ç¤¾åŒº-è…¾è®¯äº‘ (tencent.com) æœ€åå¯ä»¥ä½¿ç”¨node,npmå‘½ä»¤éªŒè¯æ˜¯å¦é…ç½®æˆåŠŸ å…¨å±€node_moduleé…ç½® é…ç½®å®Œä¸Šä¸€æ¡å…¶å®nodeå·²ç»å¯ä»¥ä½¿ç”¨äº†ã€‚ä½†æ˜¯ï¼Œè‹¥ä¸è¿›è¡Œç¯å¢ƒå˜é‡é…ç½®ï¼Œé‚£ä¹ˆåœ¨ä½¿ç”¨å‘½ä»¤å®‰è£…Â Node.jså…¨å±€æ¨¡å—Â ï¼ˆå¦‚ï¼šnpm install -g vueï¼‰æ—¶ï¼Œä¼šé»˜è®¤å®‰è£…åˆ°Cç›˜çš„è·¯å¾„ (C:\\Users\\xxx\\AppData\\Roaming pm) ä¸­ï¼Œè§£å†³è¿™ä¸ªé—®é¢˜éœ€è¦é…ç½®node_moduleå…¨å±€çš„å®‰è£…å˜é‡ã€‚ è§åšå®¢Node.js çš„å®‰è£…åŠé…ç½®ç¯å¢ƒå˜é‡_Node.jsé…ç½®ç¯å¢ƒå˜é‡-CSDNåšå®¢ æœ€åå¯ä»¥å®‰è£…ä¸€ä¸ªå…¨å±€æ¨¡å—å¦‚hexoæˆ–è€…vueé€šè¿‡å®‰è£…ä½ç½®æ¥éªŒè¯æ˜¯å¦é…ç½®æˆåŠŸã€‚ npmé•œåƒé…ç½® é…ç½® npm ä½¿ç”¨æ·˜å®é•œåƒå¯ä»¥æ˜¾è‘—æé«˜åœ¨å›½å†…ä¸‹è½½ npm åŒ…çš„é€Ÿåº¦ï¼ˆæ¨èä½¿ç”¨æ–¹æ¡ˆ2ï¼‰ã€‚ä»¥ä¸‹æ˜¯é…ç½®æ–¹æ³•ï¼š æ–¹æ³• 1: ä¸´æ—¶ä½¿ç”¨æ·˜å®é•œåƒ å¦‚æœä½ åªæƒ³ä¸´æ—¶ä½¿ç”¨æ·˜å®é•œåƒï¼Œå¯ä»¥åœ¨å‘½ä»¤å‰åŠ ä¸Š --registry å‚æ•°ï¼š 1npm install --registry=https://registry.npmmirror.com æ–¹æ³• 2: æ°¸ä¹…é…ç½®æ·˜å®é•œåƒ é€šè¿‡å‘½ä»¤é…ç½® ä½ å¯ä»¥é€šè¿‡å‘½ä»¤è¡Œå°†æ·˜å®é•œåƒè®¾ç½®ä¸ºé»˜è®¤çš„ npm é•œåƒï¼š 1npm config set registry https://registry.npmmirror.com é€šè¿‡é…ç½®æ–‡ä»¶é…ç½® ä½ ä¹Ÿå¯ä»¥ç›´æ¥ç¼–è¾‘ npm çš„é…ç½®æ–‡ä»¶æ¥è®¾ç½®æ·˜å®é•œåƒã€‚åœ¨ä½ çš„ä¸»ç›®å½•ä¸‹æ‰¾åˆ°æˆ–åˆ›å»ºä¸€ä¸ª .npmrc æ–‡ä»¶ï¼Œå¹¶æ·»åŠ ä»¥ä¸‹å†…å®¹ï¼š 1registry=https://registry.npmmirror.com æ–¹æ³• 3: ä½¿ç”¨ nrm ç®¡ç†å¤šä¸ªé•œåƒæº nrm æ˜¯ä¸€ä¸ª npm çš„é•œåƒæºç®¡ç†å·¥å…·ï¼Œå¯ä»¥æ–¹ä¾¿åœ°åœ¨å¤šä¸ªé•œåƒæºä¹‹é—´åˆ‡æ¢ã€‚ å®‰è£… nrm 1npm install -g nrm æŸ¥çœ‹å¯ç”¨é•œåƒæº 1nrm ls ä½¿ç”¨æ·˜å®é•œåƒ 1nrm use taobao éªŒè¯é•œåƒé…ç½® ä½ å¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤éªŒè¯é•œåƒæ˜¯å¦é…ç½®æˆåŠŸï¼š 1npm config get registry è¾“å‡ºåº”ä¸º https://registry.npmmirror.comï¼š 1https://registry.npmmirror.com/ è¿™æ ·ï¼Œnpm å°±ä¼šä½¿ç”¨æ·˜å®é•œåƒæ¥ä¸‹è½½åŒ…äº†ã€‚é€šè¿‡ä»¥ä¸Šæ–¹æ³•ï¼Œä½ å¯ä»¥æ ¹æ®éœ€è¦çµæ´»é…ç½® npm çš„é•œåƒæºï¼Œæé«˜ä¸‹è½½é€Ÿåº¦ã€‚ PicGo é…ç½® è¿™é‡Œä¸»è¦ä»‹ç»PicGO-Coreçš„å®‰è£…å’Œé…ç½® å› ä¸ºä¸Šé¢å·²ç»é…ç½®å¥½npmçš„ç¼˜æ•…ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥ä½¿ç”¨npmè¿›è¡Œå®‰è£…ï¼š 1npm install picgo -g é…ç½®çš„è¯ï¼Œæˆ‘ä½¿ç”¨çš„æ˜¯è…¾è®¯äº‘ï¼Œéœ€è¦ä½¿ç”¨ä»–ä¸¤ä¸ªäº‘æœåŠ¡å¯¹è±¡å­˜å‚¨å’Œè®¿é—®ç®¡ç†ï¼Œå…·ä½“çš„æ•™ç¨‹è§ä¸‹é¢ä¸¤ä¸ªé“¾æ¥ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ã€‚ PicGo-Core è…¾è®¯äº‘COSå¯¹è±¡å­˜å‚¨+PicGoæ­å»ºå›¾åºŠæ•™ç¨‹-è…¾è®¯äº‘å¼€å‘è€…ç¤¾åŒº-è…¾è®¯äº‘ (tencent.com) PowerShell æ— æ³•ä½¿ç”¨yarnï¼Œhexoå‘½ä»¤é—®é¢˜ è¿™äº›å‘½ä»¤éƒ½æ˜¯ä½¿ç”¨npmå…¨å±€å®‰è£…çš„å‘½ä»¤ï¼ŒæŒ‰ç…§ä¸‹é¢çš„æ­¥éª¤è§£å†³é—®é¢˜ï¼š ä»¥ç®¡ç†å‘˜èº«ä»½æ‰“å¼€PowerShell è¾“å…¥å‘½ä»¤set-ExecutionPolicy RemoteSigned å…¨éƒ¨é€‰æ‹©Yå³å¯ã€‚ MinGW é…ç½® å°†mingwä¸­çš„binæ–‡ä»¶å¤¹æ·»åŠ åˆ°ç¯å¢ƒå˜é‡å³å¯ã€‚ Typora æ”¹ä¸»é¢˜æ ‡é¢˜å¤§å° ä½¿ç”¨çš„æ˜¯ladderä¸»é¢˜ï¼Œæ”¹é…ç½®æ–‡ä»¶ä¸­çš„font-sizeå³å¯ï¼š 12345678h4 &#123; color: var(--tw-prose-headings); font-size: 1.55rem; font-weight: 600; margin-top: 1.8em; margin-bottom: 1.5rem; line-height: 1.375rem;&#125; anaconda ç¯å¢ƒé…ç½® Windows Defender æ™ºèƒ½åº”ç”¨æ§åˆ¶ï¼ˆSmart App Controlï¼‰å…³é—­ï¼ˆä¸ç„¶Zoteroèƒ½ç»™ä½ å¯åŠ¨20sï¼‰ Device Securityä¸­çš„å†…æ ¸éš”ç¦»ï¼ˆcore isolationï¼‰æˆ‘æ˜¯å…³é—­çš„ï¼Œä¸çŸ¥é“ä¼šæœ‰ä»€ä¹ˆå½±å“ï¼Œä»¥åå†è¯´å§"},{"title":"mklinkæŒ‡ä»¤","path":"/wiki/Others/Windows/mklinkæŒ‡ä»¤.html","content":"åŸºæœ¬ä»‹ç» mklink æ˜¯ Windows ä¸­ç”¨äºåˆ›å»ºç¬¦å·é“¾æ¥ï¼ˆsymlinkï¼‰ã€ç¡¬é“¾æ¥ï¼ˆhard linkï¼‰å’Œç›®å½•è”æ¥ï¼ˆdirectory junctionï¼‰çš„å‘½ä»¤ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸ç”¨çš„ mklink å‘½ä»¤ä»¥åŠå¦‚ä½•ä½¿ç”¨å®ƒä»¬åˆ›å»ºæ–‡ä»¶å¤¹é“¾æ¥çš„ä»‹ç»ã€‚ åŸºæœ¬è¯­æ³• 1mklink [options] &lt;Link&gt; &lt;Target&gt; &lt;Link&gt; æ˜¯è¦åˆ›å»ºçš„é“¾æ¥çš„åç§°ã€‚ &lt;Target&gt; æ˜¯é“¾æ¥æ‰€æŒ‡å‘çš„ç›®æ ‡æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹ã€‚ å¸¸ç”¨é€‰é¡¹ /D - åˆ›å»ºä¸€ä¸ªç›®å½•ç¬¦å·é“¾æ¥ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œmklink åˆ›å»ºçš„æ˜¯æ–‡ä»¶ç¬¦å·é“¾æ¥ï¼Œæ‰€ä»¥å¦‚æœè¦åˆ›å»ºä¸€ä¸ªæŒ‡å‘ç›®å½•çš„ç¬¦å·é“¾æ¥ï¼Œéœ€è¦ä½¿ç”¨è¿™ä¸ªé€‰é¡¹ã€‚ /H - åˆ›å»ºä¸€ä¸ªç¡¬é“¾æ¥ï¼Œè€Œä¸æ˜¯ç¬¦å·é“¾æ¥ã€‚ç¡¬é“¾æ¥åªèƒ½æŒ‡å‘åŒä¸€åˆ†åŒºä¸Šçš„æ–‡ä»¶ã€‚ /J - åˆ›å»ºä¸€ä¸ªç›®å½•è”æ¥ã€‚è¿™æ˜¯ä¸€ä¸ªç‰¹æ®Šç±»å‹çš„ç¬¦å·é“¾æ¥ï¼Œä¸“é—¨ç”¨äºç›®å½•ã€‚ åˆ›å»ºæ–‡ä»¶å¤¹ç¬¦å·é“¾æ¥ å‡è®¾æœ‰ä¸€ä¸ªç›®æ ‡æ–‡ä»¶å¤¹ C:\\OriginalFolderï¼Œå¦‚æœæƒ³åœ¨ C:\\NewFolderLink ä½ç½®åˆ›å»ºä¸€ä¸ªæŒ‡å‘å®ƒçš„ç¬¦å·é“¾æ¥ï¼Œä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š 1mklink /D C:\\NewFolderLink C:\\OriginalFolder åˆ›å»ºæ–‡ä»¶å¤¹ç¡¬é“¾æ¥ ç¡¬é“¾æ¥ä¸èƒ½ç”¨äºç›®å½•ï¼Œåªèƒ½ç”¨äºæ–‡ä»¶ã€‚æ‰€ä»¥å¦‚æœéœ€è¦åˆ›å»ºç›®å½•çš„é“¾æ¥ï¼Œå»ºè®®ä½¿ç”¨ç¬¦å·é“¾æ¥æˆ–ç›®å½•è”æ¥ã€‚ åˆ›å»ºç›®å½•è”æ¥ å¦‚æœå¸Œæœ›åˆ›å»ºä¸€ä¸ªç›®å½•è”æ¥ï¼Œä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š 1mklink /J C:\\NewFolderLink C:\\OriginalFolder ç¤ºä¾‹ åˆ›å»ºæŒ‡å‘ç›®å½• C:\\Users\\YourName\\Documents\\MyFolder çš„ç¬¦å·é“¾æ¥ï¼š 1mklink /D C:\\LinkToMyFolder C:\\Users\\YourName\\Documents\\MyFolder åˆ›å»ºæŒ‡å‘ç›®å½• D:\\Data\\Projects çš„ç›®å½•è”æ¥ï¼š 1mklink /J C:\\ProjectsLink D:\\Data\\Projects æ³¨æ„äº‹é¡¹ ç¡®ä¿åœ¨å‘½ä»¤æç¤ºç¬¦ï¼ˆcmdï¼‰ä¸­ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œ mklink å‘½ä»¤ï¼Œå› ä¸ºåˆ›å»ºç¬¦å·é“¾æ¥éœ€è¦ç®¡ç†å‘˜æƒé™ã€‚ ä½¿ç”¨ç¬¦å·é“¾æ¥å’Œç›®å½•è”æ¥æ—¶ï¼Œè¯·æ³¨æ„ç›®æ ‡è·¯å¾„çš„æœ‰æ•ˆæ€§ã€‚å¦‚æœç›®æ ‡è·¯å¾„ä¸å­˜åœ¨æˆ–ä¸å¯è®¿é—®ï¼Œé“¾æ¥å°†æ— æ³•æ­£å¸¸å·¥ä½œã€‚ é€šè¿‡ mklink å‘½ä»¤ï¼Œå¯ä»¥æ–¹ä¾¿åœ°åœ¨ä¸åŒç›®å½•ä¹‹é—´åˆ›å»ºå¿«æ·æ–¹å¼ï¼Œç®€åŒ–æ–‡ä»¶å’Œç›®å½•çš„ç®¡ç†ã€‚ \\Då’Œ\\Jçš„åŒºåˆ« /D å’Œ /J æ˜¯ mklink å‘½ä»¤ä¸­ç”¨äºåˆ›å»ºä¸åŒç±»å‹ç›®å½•é“¾æ¥çš„é€‰é¡¹ï¼Œå®ƒä»¬çš„ä¸»è¦åŒºåˆ«å¦‚ä¸‹ï¼š /D - åˆ›å»ºç›®å½•ç¬¦å·é“¾æ¥ (Symbolic Link) ç¬¦å·é“¾æ¥ï¼ˆsymlinkï¼‰æ˜¯ä¸€ä¸ªå¼•ç”¨æŒ‡å‘å¦ä¸€ä¸ªæ–‡ä»¶æˆ–ç›®å½•çš„è·¯å¾„ã€‚ ç¬¦å·é“¾æ¥å¯ä»¥è·¨ä¸åŒçš„æ–‡ä»¶ç³»ç»Ÿåˆ†åŒºä½¿ç”¨ï¼Œä¹Ÿå¯ä»¥æŒ‡å‘ç½‘ç»œè·¯å¾„ã€‚ ç¬¦å·é“¾æ¥å¯ä»¥æŒ‡å‘ä¸å­˜åœ¨çš„ç›®æ ‡ï¼ˆå½“ç›®æ ‡è·¯å¾„å­˜åœ¨æ—¶é“¾æ¥æ‰ä¼šæœ‰æ•ˆï¼‰ã€‚ åˆ é™¤ç¬¦å·é“¾æ¥ä¸ä¼šå½±å“ç›®æ ‡æ–‡ä»¶æˆ–ç›®å½•ã€‚ ç¤ºä¾‹ï¼š 1mklink /D C:\\LinkToFolder C:\\OriginalFolder è¿™ä¸ªå‘½ä»¤åˆ›å»ºä¸€ä¸ªç¬¦å·é“¾æ¥ C:\\LinkToFolderï¼Œå®ƒæŒ‡å‘ C:\\OriginalFolderã€‚ /J - åˆ›å»ºç›®å½•è”æ¥ (Directory Junction) ç›®å½•è”æ¥ï¼ˆjunctionï¼‰æ˜¯ Windows çš„ NTFS æ–‡ä»¶ç³»ç»Ÿä¸­çš„ä¸€ç§ç‰¹æ®Šç±»å‹çš„ç¬¦å·é“¾æ¥ã€‚ ç›®å½•è”æ¥åªèƒ½ç”¨äºæœ¬åœ°ç›®å½•ï¼Œä¸èƒ½ç”¨äºç½‘ç»œè·¯å¾„ã€‚ ç›®å½•è”æ¥ä»…é€‚ç”¨äºç›®å½•ï¼Œä¸é€‚ç”¨äºå•ä¸ªæ–‡ä»¶ã€‚ ç›®å½•è”æ¥é€šå¸¸æ¯”ç¬¦å·é“¾æ¥æ›´å…¼å®¹ä¸€äº›æ—§çš„ Windows åº”ç”¨ç¨‹åºã€‚ åˆ é™¤ç›®å½•è”æ¥ä¸ä¼šå½±å“ç›®æ ‡ç›®å½•ä¸­çš„æ–‡ä»¶ã€‚ ç¤ºä¾‹ï¼š 1mklink /J C:\\JunctionToFolder C:\\OriginalFolder è¿™ä¸ªå‘½ä»¤åˆ›å»ºä¸€ä¸ªç›®å½•è”æ¥ C:\\JunctionToFolderï¼Œå®ƒæŒ‡å‘ C:\\OriginalFolderã€‚ æ€»ç»“ ç¬¦å·é“¾æ¥ï¼ˆä½¿ç”¨ /Dï¼‰æ›´çµæ´»ï¼Œå¯ä»¥æŒ‡å‘ä»»æ„æ–‡ä»¶æˆ–ç›®å½•ï¼Œå¹¶ä¸”å¯ä»¥è·¨åˆ†åŒºå’Œç½‘ç»œä½¿ç”¨ã€‚ ç›®å½•è”æ¥ï¼ˆä½¿ç”¨ /Jï¼‰æ›´å±€é™ï¼Œåªèƒ½ç”¨äºæœ¬åœ°ç›®å½•ï¼Œä½†å¯èƒ½åœ¨ä¸€äº›åœºæ™¯ä¸‹æœ‰æ›´å¥½çš„å…¼å®¹æ€§ã€‚ é€‰æ‹©ä½¿ç”¨ /D è¿˜æ˜¯ /J å–å†³äºå…·ä½“éœ€æ±‚ã€‚å¦‚æœéœ€è¦æ›´é«˜çš„çµæ´»æ€§å’Œè·¨åˆ†åŒºæ”¯æŒï¼Œé€‰æ‹© /Dï¼›å¦‚æœä¸»è¦åœ¨æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿä¸­æ“ä½œç›®å½•å¹¶ä¸”éœ€è¦å…¼å®¹ä¸€äº›æ—§åº”ç”¨ç¨‹åºï¼Œé€‰æ‹© /Jã€‚ æŸ¥çœ‹æ–‡ä»¶/æ–‡ä»¶å¤¹é“¾æ¥ç±»å‹ è¦æŸ¥çœ‹ä¸€ä¸ªé“¾æ¥çš„ç±»å‹æ˜¯ /Dï¼ˆç¬¦å·é“¾æ¥ï¼‰è¿˜æ˜¯ /Jï¼ˆç›®å½•è”æ¥ï¼‰ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹å‡ ç§æ–¹æ³•æ¥è¿›è¡Œæ£€æŸ¥ï¼š ä½¿ç”¨ dir å‘½ä»¤ æ‰“å¼€å‘½ä»¤æç¤ºç¬¦ï¼ˆcmdï¼‰ã€‚ å¯¼èˆªåˆ°åŒ…å«é“¾æ¥çš„ç›®å½•ã€‚ è¾“å…¥ dir å‘½ä»¤ã€‚ åœ¨ dir å‘½ä»¤çš„è¾“å‡ºä¸­ï¼š ç¬¦å·é“¾æ¥ä¼šæ˜¾ç¤ºä¸º &lt;SYMLINKD&gt;ã€‚ ç›®å½•è”æ¥ä¼šæ˜¾ç¤ºä¸º &lt;JUNCTION&gt;ã€‚ ç¤ºä¾‹ï¼š 1C:\\&gt; dir è¾“å‡ºå¯èƒ½ç±»ä¼¼äºï¼š 12342024-05-30 10:30 AM &lt;DIR&gt; .2024-05-30 10:30 AM &lt;DIR&gt; ..2024-05-30 10:31 AM &lt;SYMLINKD&gt; LinkToFolder [C:\\OriginalFolder]2024-05-30 10:32 AM &lt;JUNCTION&gt; JunctionToFolder [C:\\OriginalFolder] åœ¨è¿™é‡Œï¼ŒLinkToFolder æ˜¯ç¬¦å·é“¾æ¥ï¼ŒJunctionToFolder æ˜¯ç›®å½•è”æ¥ã€‚ ä½¿ç”¨ fsutil å‘½ä»¤ æ‰“å¼€å‘½ä»¤æç¤ºç¬¦ï¼ˆcmdï¼‰ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œã€‚ ä½¿ç”¨ fsutil reparsepoint query å‘½ä»¤ã€‚ ç¤ºä¾‹ï¼š 1fsutil reparsepoint query C:\\LinkToFolder å¦‚æœè¿™æ˜¯ä¸€ä¸ªç¬¦å·é“¾æ¥ï¼Œè¾“å‡ºä¼šåŒ…å«ç±»ä¼¼ Reparse Tag Value: 0xA000000C çš„ä¿¡æ¯ã€‚ å¦‚æœè¿™æ˜¯ä¸€ä¸ªç›®å½•è”æ¥ï¼Œè¾“å‡ºä¼šåŒ…å«ç±»ä¼¼ Reparse Tag Value: 0xA0000003 çš„ä¿¡æ¯ã€‚ ä½¿ç”¨ PowerShell æ‰“å¼€ PowerShellã€‚ å¯¼èˆªåˆ°åŒ…å«é“¾æ¥çš„ç›®å½•ã€‚ ä½¿ç”¨ Get-Item cmdletã€‚ ç¤ºä¾‹ï¼š 12(Get-Item C:\\LinkToFolder).LinkType(Get-Item C:\\JunctionToFolder).LinkType è¾“å‡ºä¼šæ˜¾ç¤º SymbolicLink æˆ– Junctionï¼Œåˆ†åˆ«è¡¨ç¤ºç¬¦å·é“¾æ¥å’Œç›®å½•è”æ¥ã€‚ ç¤ºä¾‹ç»¼åˆ å‡è®¾æœ‰ä¸¤ä¸ªé“¾æ¥ï¼šC:\\LinkToFolder å’Œ C:\\JunctionToFolderã€‚ä½¿ç”¨ä¸Šè¿°æ–¹æ³•ï¼Œå¯ä»¥è½»æ¾åœ°ç¡®å®šå®ƒä»¬çš„ç±»å‹ã€‚ åœ¨å‘½ä»¤æç¤ºç¬¦ä¸­è¿è¡Œ dir å‘½ä»¤ï¼Œå¯ä»¥çœ‹åˆ° LinkToFolder æ˜¯ç¬¦å·é“¾æ¥ (&lt;SYMLINKD&gt;)ï¼Œè€Œ JunctionToFolder æ˜¯ç›®å½•è”æ¥ (&lt;JUNCTION&gt;ï¼‰ã€‚ ä½¿ç”¨ fsutil reparsepoint query å‘½ä»¤å¯ä»¥è¿›ä¸€æ­¥ç¡®è®¤å®ƒä»¬çš„ç±»å‹ã€‚ åœ¨ PowerShell ä¸­ä½¿ç”¨ Get-Item cmdlet ä¹Ÿå¯ä»¥æŸ¥çœ‹é“¾æ¥çš„ç±»å‹ã€‚ é€šè¿‡è¿™äº›æ–¹æ³•ï¼Œå¯ä»¥å‡†ç¡®åœ°ç¡®å®šä¸€ä¸ªé“¾æ¥æ˜¯ç¬¦å·é“¾æ¥è¿˜æ˜¯ç›®å½•è”æ¥ã€‚"},{"title":"æœ€çŸ­è·¯â€”â€”Floydç®—æ³•","path":"/wiki/OI-Knowledge/å›¾è®º/æœ€çŸ­è·¯/Floydç®—æ³•.html","content":"åœ¨å›¾è®ºä¸­ï¼Œå¯»æ‰¾æ‰€æœ‰é¡¶ç‚¹å¯¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„æ˜¯ä¸€ä¸ªå¸¸è§é—®é¢˜ã€‚Floyd-Warshall ç®—æ³•æ˜¯ä¸€ç§è§£å†³è¿™ä¸ªé—®é¢˜çš„æœ‰æ•ˆæ–¹æ³•ã€‚æœ¬æ–‡å°†ä»‹ç» Floyd-Warshall ç®—æ³•çš„åŸºæœ¬æ¦‚å¿µã€å·¥ä½œåŸç†ï¼Œå¹¶æä¾›ç›¸åº”çš„ C++ å®ç°ä»£ç ã€‚ ä»€ä¹ˆæ˜¯ Floyd-Warshall ç®—æ³•ï¼Ÿ Floyd-Warshall ç®—æ³•æ˜¯ä¸€ç§ç”¨äºå¯»æ‰¾åŠ æƒå›¾ä¸­æ‰€æœ‰é¡¶ç‚¹å¯¹ä¹‹é—´æœ€çŸ­è·¯å¾„çš„åŠ¨æ€è§„åˆ’ç®—æ³•ã€‚è¯¥ç®—æ³•çš„ä¸»è¦æ€æƒ³æ˜¯é€šè¿‡ä¸­é—´é¡¶ç‚¹è¿­ä»£æ›´æ–°æœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œä»è€Œé€æ­¥ä¼˜åŒ–è·¯å¾„ã€‚ ç®—æ³•æ­¥éª¤ åˆå§‹åŒ–ï¼šåˆ›å»ºä¸€ä¸ªè·ç¦»çŸ©é˜µ distï¼Œå…¶ä¸­ dist[i][j] è¡¨ç¤ºé¡¶ç‚¹ i åˆ°é¡¶ç‚¹ j çš„åˆå§‹è·ç¦»ã€‚å¦‚æœä¸¤é¡¶ç‚¹ä¹‹é—´æ²¡æœ‰è¾¹ï¼Œåˆ™è·ç¦»è®¾ä¸ºæ— ç©·å¤§ï¼ˆé€šå¸¸ç”¨ä¸€ä¸ªå¤§æ•°è¡¨ç¤ºï¼‰ã€‚ è¿­ä»£æ›´æ–°ï¼šå¯¹äºæ¯ä¸ªä¸­é—´é¡¶ç‚¹ kï¼Œæ›´æ–°æ‰€æœ‰é¡¶ç‚¹å¯¹ (i, j) çš„è·ç¦»ã€‚å¦‚æœé€šè¿‡é¡¶ç‚¹ k çš„è·¯å¾„æ¯”å½“å‰å·²çŸ¥è·¯å¾„æ›´çŸ­ï¼Œåˆ™æ›´æ–° dist[i][j] çš„å€¼ã€‚ ç»“æœè¾“å‡ºï¼šæœ€ç»ˆçš„è·ç¦»çŸ©é˜µ dist å³ä¸ºæ‰€æœ‰é¡¶ç‚¹å¯¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„é•¿åº¦ã€‚ ç®—æ³•å¤æ‚åº¦ Floyd-Warshall ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(V^3)ï¼Œå…¶ä¸­ V æ˜¯å›¾ä¸­çš„é¡¶ç‚¹æ•°ã€‚å°½ç®¡æ—¶é—´å¤æ‚åº¦è¾ƒé«˜ï¼Œä½†è¯¥ç®—æ³•åœ¨ç¨ å¯†å›¾ï¼ˆè¾¹æ•°æ¥è¿‘äºé¡¶ç‚¹æ•°å¹³æ–¹ï¼‰ä¸­è¡¨ç°è‰¯å¥½ã€‚ ä»£ç å®ç° ä»¥ä¸‹æ˜¯ Floyd-Warshall ç®—æ³•çš„ C++ å®ç°ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;limits&gt;const int INF = std::numeric_limits&lt;int&gt;::max();// Floyd-Warshallç®—æ³•å®ç°void floydWarshall(std::vector&lt;std::vector&lt;int&gt;&gt;&amp; graph) &#123; int V = graph.size(); std::vector&lt;std::vector&lt;int&gt;&gt; dist = graph; // ä¸‰é‡å¾ªç¯ï¼Œæ›´æ–°è·ç¦»çŸ©é˜µ for (int k = 0; k &lt; V; ++k) &#123; for (int i = 0; i &lt; V; ++i) &#123; for (int j = 0; j &lt; V; ++j) &#123; if (dist[i][k] != INF &amp;&amp; dist[k][j] != INF &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123; dist[i][j] = dist[i][k] + dist[k][j]; &#125; &#125; &#125; &#125; // è¾“å‡ºæœ€ç»ˆçš„è·ç¦»çŸ©é˜µ for (int i = 0; i &lt; V; ++i) &#123; for (int j = 0; j &lt; V; ++j) &#123; if (dist[i][j] == INF) &#123; std::cout &lt;&lt; &quot;INF &quot;; &#125; else &#123; std::cout &lt;&lt; dist[i][j] &lt;&lt; &quot; &quot;; &#125; &#125; std::cout &lt;&lt; std::endl; &#125;&#125;int main() &#123; std::vector&lt;std::vector&lt;int&gt;&gt; graph = &#123; &#123;0, 3, INF, 7&#125;, &#123;8, 0, 2, INF&#125;, &#123;5, INF, 0, 1&#125;, &#123;2, INF, INF, 0&#125; &#125;; floydWarshall(graph); return 0;&#125; ä»£ç è§£æ å®šä¹‰å¸¸é‡ INFï¼šç”¨äºè¡¨ç¤ºæ— ç©·å¤§ã€‚ åˆå§‹åŒ–å›¾çš„é‚»æ¥çŸ©é˜µ graphï¼šæ¯ä¸ªå…ƒç´ è¡¨ç¤ºé¡¶ç‚¹ä¹‹é—´çš„è·ç¦»ã€‚å¦‚æœæ²¡æœ‰ç›´æ¥è¾¹ï¼Œåˆ™è·ç¦»ä¸º INFã€‚ è°ƒç”¨ floydWarshall å‡½æ•°ï¼šä¼ å…¥å›¾çš„é‚»æ¥çŸ©é˜µè¿›è¡Œå¤„ç†ã€‚ æ›´æ–°è·ç¦»çŸ©é˜µï¼šé€šè¿‡ä¸‰é‡å¾ªç¯è¿­ä»£æ›´æ–°è·ç¦»çŸ©é˜µä¸­çš„å€¼ã€‚ è¾“å‡ºç»“æœï¼šæ‰“å°æœ€ç»ˆçš„æœ€çŸ­è·¯å¾„çŸ©é˜µã€‚ æ€»ç»“ Floyd-Warshall ç®—æ³•æ˜¯ä¸€ç§ç®€å•ä½†åŠŸèƒ½å¼ºå¤§çš„ç®—æ³•ï¼Œå¯ä»¥æœ‰æ•ˆåœ°è§£å†³æ‰€æœ‰é¡¶ç‚¹å¯¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„é—®é¢˜ã€‚é€šè¿‡æœ¬æ–‡çš„ä»‹ç»å’Œä»£ç ç¤ºä¾‹ï¼Œå¸Œæœ›è¯»è€…èƒ½å¤Ÿæ›´å¥½åœ°ç†è§£å¹¶åº”ç”¨è¿™ä¸€ç®—æ³•ã€‚"},{"title":"æ›¿æ¢ VS Code çš„æ°´å°","path":"/wiki/Others/Softwares/VSCode/æ›¿æ¢ VS Code çš„æ°´å°.html","content":"æ°´å°ä¸‹è½½ä¼ é€é—¨ï¼šhttps://github.com/Aikoyori/ProgrammingVTuberLogos å®‰è£… å®‰è£…ä»¥ä¸‹æ‰©å±•: Custom CSS and JS Loader Fix VSCode Checksums Next åœ¨ä½ çš„è®¾ç½® JSON æ–‡ä»¶ä¸­æ·»åŠ ä»¥ä¸‹å†…å®¹(é€šè¿‡å‘½ä»¤ Open User Settings (JSON) æ‰“å¼€ settings.json):123&quot;vscode_custom_css.imports&quot;: [ &quot;https://raw.githubusercontent.com/Aikoyori/ProgrammingVTuberLogos/main/ReplaceGuide/VSCode/style.css&quot;] è¿è¡Œä»¥ä¸‹å‘½ä»¤: Enable Custom CSS and JS Fix Checksums: Apply é‡å¯ Visual Studio Code å¸è½½ ä»ä½ çš„è®¾ç½® JSON æ–‡ä»¶(settings.json)ä¸­ç§»é™¤ vscode_custom_css.imports éƒ¨åˆ† è¿è¡Œä»¥ä¸‹å‘½ä»¤: Disable Custom CSS and JS Fix Checksums: Restore å¸è½½ Custom CSS and JS Loader å’Œ Fix VSCode Checksums Next æ‰©å±• é‡å¯ Visual Studio Code"},{"title":"è¿è¡Œè·¯å¾„è®¾ç½®","path":"/wiki/Others/Softwares/VSCode/è¿è¡Œè·¯å¾„è®¾ç½®.html","content":"é—®é¢˜æè¿° åœ¨è¿è¡Œæˆ–è°ƒè¯•Pythonä»£ç çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šé‡è§ä¸‹é¢è¿™ç§æƒ…å†µï¼Œé¡¹ç›®ç»“æ„å¦‚ä¸‹æ‰€ç¤ºï¼š 123456/path/to/your/projectâ”œâ”€â”€ main.pyâ”œâ”€â”€ aâ”‚ â””â”€â”€ some_script.pyâ””â”€â”€ b â””â”€â”€ some_module.py æ­¤æ—¶æˆ‘ä»¬æƒ³è¿è¡Œaæ–‡ä»¶å¤¹ä¸­çš„some_script.pyæ–‡ä»¶ï¼Œä½†ä»–å…¶ä¸­åŒ…å«äº†ä¸€è¡Œå¼•å…¥ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 1from b.some_module import * ç›´æ¥ä½¿ç”¨ä¼ ç»Ÿpython ./a/some_script.pyè¿è¡Œä»£ç ä¼šæŠ¥é”™ã€‚ è§£å†³æ–¹æ¡ˆ è®¾ç½®PYTHONPATHå‚æ•°ï¼Œå…¶ä½œç”¨æ˜¯å‘Šè¯‰è„šæœ¬ä»å“ªä¸ªä½ç½®æŸ¥æ‰¾æ¨¡å—. å½“ä½ è¿è¡Œä¸€ä¸ª Python ç¨‹åºå¹¶ä½¿ç”¨ import è¯­å¥å¯¼å…¥æ¨¡å—æ—¶ï¼ŒPython ä¼šæŒ‰é¡ºåºåœ¨ä»¥ä¸‹å‡ ä¸ªä½ç½®æŸ¥æ‰¾æ¨¡å—ï¼š å½“å‰è„šæœ¬æ‰€åœ¨ç›®å½•ã€‚ æ ‡å‡†åº“ç›®å½•ã€‚ PYTHONPATH ç¯å¢ƒå˜é‡ä¸­æŒ‡å®šçš„ç›®å½•ã€‚ å®‰è£…çš„ç¬¬ä¸‰æ–¹åŒ…æ‰€åœ¨çš„ç›®å½•ï¼ˆä¾‹å¦‚ï¼Œé€šè¿‡ pip å®‰è£…çš„åŒ…ï¼‰ã€‚ è¿è¡Œ åœ¨å‘½ä»¤è¡Œä¸­è®¾ç½®PYTHONPATH,ç„¶åè¿è¡Œaæ–‡ä»¶å¤¹ä¸­çš„ä»£ç ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ è¦è¿è¡Œaæ–‡ä»¶å¤¹ä¸­çš„some_script.pyï¼Œå¯ä»¥è¿™æ ·åšï¼š 1PYTHONPATH=$(pwd) python a/some_script.py å¦‚æœå‘½ä»¤è¡Œæ­£å¥½å¤„åœ¨å½“å‰é¡¹ç›®æ–‡ä»¶å¤¹ä¸‹ï¼Œç›´æ¥å†™æˆå¦‚ä¸‹å½¢å¼,å³å¯ç¡®ä¿ç›¸å…³åŒ…èƒ½å¤Ÿè¢«æ­£ç¡®å¯¼å…¥ã€‚ 1PYTHONPATH=./ python a/some_script.py è°ƒè¯• åœ¨vscodeå·¦ä¾§åˆå§‹åŒ–ä¸€ä¸ªè°ƒè¯•launch.jsonæ–‡ä»¶åï¼Œæ·»åŠ envå‚æ•°ï¼ŒæŒ‰ç…§å¦‚ä¸‹è®¾ç½®å³å¯ï¼š 12345678910111213141516171819&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Python Debugger: Current File&quot;, &quot;type&quot;: &quot;debugpy&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;file&#125;&quot;, &quot;console&quot;: &quot;integratedTerminal&quot;, // &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;env&quot;: &#123; &quot;PYTHONPATH&quot;: &quot;$&#123;workspaceFolder&#125;&quot; &#125; &#125; ]&#125; æ³¨æ„å…¶ä¸­çš„cwdå‚æ•°ä½œç”¨æ˜¯è®¾ç½®å½“å‰å·¥ä½œç›®å½•ä¸ºå·¥ä½œåŒºæ ¹ç›®å½•ï¼Œç¡®ä¿ä»£ç ä¸­æ‰€æœ‰ç›¸å¯¹è·¯å¾„éƒ½æ˜¯ç›¸å¯¹äºé¡¹ç›®æ ¹ç›®å½•ã€‚ä¸è¦æ··æ·†ã€‚"}]